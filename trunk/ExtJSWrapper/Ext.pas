unit Ext;

// Generated by ExtToPascal v.0.9.9, at 13/03/2013 18:28:07
// from "\extpascal\ext-4.1.1a\src

interface

uses
  StrUtils, ExtPascal, ExtPascalUtils;

const
  SourcePath = '/src';

type
  TExtAbstractManager = class;
  TExtAbstractPlugin = class;
  TExtAction = class;
  TExtAjaxSingleton = class;
  TExtAppApplication = class;
  TExtAppController = class;
  TExtButton = class;
  TExtButtonCycle = class;
  TExtButtonSplit = class;
  TExtChart = class;
  TExtChartAxis = class;
  TExtChartAxisCategory = class;
  TExtChartAxisGauge = class;
  TExtChartAxisNumeric = class;
  TExtChartAxisTime = class;
  TExtChartCallout = class;
  TExtChartHighlight = class;
  TExtChartLabel = class;
  TExtChartLegend = class;
  TExtChartLegendItem = class;
  TExtChartMask = class;
  TExtChartNavigation = class;
  TExtChartSeries = class;
  TExtChartSeriesArea = class;
  TExtChartSeriesBar = class;
  TExtChartSeriesCartesian = class;
  TExtChartSeriesColumn = class;
  TExtChartSeriesGauge = class;
  TExtChartSeriesLine = class;
  TExtChartSeriesPie = class;
  TExtChartSeriesRadar = class;
  TExtChartSeriesScatter = class;
  TExtChartTheme = class;
  TExtChartTip = class;
  TExtComponent = class;
  TExtComponentLoader = class;
  TExtComponentManagerSingleton = class;
  TExtComponentQuery = class;
  TExtContainer = class;
  TExtContainerButtonGroup = class;
  TExtContainerDockingContainer = class;
  TExtContainerViewport = class;
  TExtDataAbstractStore = class;
  TExtDataArrayStore = class;
  TExtDataAssociation = class;
  TExtDataAssociationBelongsTo = class;
  TExtDataAssociationHasMany = class;
  TExtDataAssociationHasOne = class;
  TExtDataBatch = class;
  TExtDataConnection = class;
  TExtDataDirectStore = class;
  TExtDataErrors = class;
  TExtDataField = class;
  TExtDataIdGenerator = class;
  TExtDataJsonPSingleton = class;
  TExtDataJsonPStore = class;
  TExtDataJsonStore = class;
  TExtDataModel = class;
  TExtDataNodeInterface = class;
  TExtDataOperation = class;
  TExtDataProxy = class;
  TExtDataProxyAjax = class;
  TExtDataProxyDirect = class;
  TExtDataProxyJsonP = class;
  TExtDataProxyLocalStorage = class;
  TExtDataProxyMemory = class;
  TExtDataProxyRest = class;
  TExtDataProxySessionStorage = class;
  TExtDataReader = class;
  TExtDataReaderArray = class;
  TExtDataReaderJson = class;
  TExtDataReaderXml = class;
  TExtDataRequest = class;
  TExtDataResultSet = class;
  TExtDataSequentialIdGenerator = class;
  TExtDataSortTypesSingleton = class;
  TExtDataStore = class;
  TExtDataStoreManager = class;
  TExtDataTree = class;
  TExtDataTreeStore = class;
  TExtDataTypesSingleton = class;
  TExtDataUuidGenerator = class;
  TExtDataValidations = class;
  TExtDataWriter = class;
  TExtDataWriterJson = class;
  TExtDataWriterXml = class;
  TExtDataXmlStore = class;
  TExtDdDD = class;
  TExtDdDDProxy = class;
  TExtDdDDTarget = class;
  TExtDdDragDrop = class;
  TExtDdDragDropManager = class;
  TExtDdDragSource = class;
  TExtDdDragTracker = class;
  TExtDdDragZone = class;
  TExtDdDropTarget = class;
  TExtDdDropZone = class;
  TExtDdRegistry = class;
  TExtDdScrollManager = class;
  TExtDdStatusProxy = class;
  TExtDiagLayoutContext = class;
  TExtDiagLayoutContextItem = class;
  TExtDirectEvent = class;
  TExtDirectExceptionEvent = class;
  TExtDirectManagerSingleton = class;
  TExtDirectPollingProvider = class;
  TExtDirectRemotingEvent = class;
  TExtDirectRemotingProvider = class;
  TExtDirectTransaction = class;
  TExtDomCompositeElement = class;
  TExtDomCompositeElementLite = class;
  TExtDomElement = class;
  TExtDomHelperSingleton = class;
  TExtDrawColor = class;
  TExtDrawComponent = class;
  TExtDrawCompositeSprite = class;
  TExtDrawEngineImageExporter = class;
  TExtDrawEngineSvg = class;
  TExtDrawEngineSvgExporterSingleton = class;
  TExtDrawEngineVml = class;
  TExtDrawSprite = class;
  TExtDrawSurface = class;
  TExtDrawText = class;
  TExtEditor = class;
  TExtElementLoader = class;
  TExtEventObjectImplSingleton = class;
  TExtFlashComponent = class;
  TExtFocusManager = class;
  TExtFoo = class;
  TExtFormAction = class;
  TExtFormActionDirectLoad = class;
  TExtFormActionDirectSubmit = class;
  TExtFormActionLoad = class;
  TExtFormActionStandardSubmit = class;
  TExtFormActionSubmit = class;
  TExtFormBasic = class;
  TExtFormCheckboxGroup = class;
  TExtFormField = class;
  TExtFormFieldAncestor = class;
  TExtFormFieldBase = class;
  TExtFormFieldCheckbox = class;
  TExtFormFieldComboBox = class;
  TExtFormFieldContainer = class;
  TExtFormFieldDate = class;
  TExtFormFieldDisplay = class;
  TExtFormFieldFile = class;
  TExtFormFieldHidden = class;
  TExtFormFieldHtmlEditor = class;
  TExtFormFieldNumber = class;
  TExtFormFieldPicker = class;
  TExtFormFieldRadio = class;
  TExtFormFieldSet = class;
  TExtFormFieldSpinner = class;
  TExtFormFieldText = class;
  TExtFormFieldTextArea = class;
  TExtFormFieldTime = class;
  TExtFormFieldTrigger = class;
  TExtFormFieldVTypesSingleton = class;
  TExtFormLabel = class;
  TExtFormLabelable = class;
  TExtFormPanel = class;
  TExtFormRadioGroup = class;
  TExtFxAnim = class;
  TExtFxAnimator = class;
  TExtFxTargetComponent = class;
  TExtFxTargetCompositeElement = class;
  TExtFxTargetCompositeElementCSS = class;
  TExtFxTargetCompositeSprite = class;
  TExtFxTargetElement = class;
  TExtFxTargetElementCSS = class;
  TExtFxTargetSprite = class;
  TExtGridColumn = class;
  TExtGridColumnAction = class;
  TExtGridColumnBoolean = class;
  TExtGridColumnDate = class;
  TExtGridColumnNumber = class;
  TExtGridColumnTemplate = class;
  TExtGridFeatureAbstractSummary = class;
  TExtGridFeatureChunking = class;
  TExtGridFeatureGrouping = class;
  TExtGridFeatureGroupingSummary = class;
  TExtGridFeatureRowBody = class;
  TExtGridFeatureSummary = class;
  TExtGridHeaderContainer = class;
  TExtGridPagingScroller = class;
  TExtGridPanel = class;
  TExtGridPluginCellEditing = class;
  TExtGridPluginDragDrop = class;
  TExtGridPluginEditing = class;
  TExtGridPluginHeaderResizer = class;
  TExtGridPluginRowEditing = class;
  TExtGridProperty = class;
  TExtGridPropertyGrid = class;
  TExtGridPropertyHeaderContainer = class;
  TExtGridPropertyStore = class;
  TExtGridRowNumberer = class;
  TExtGridScroller = class;
  TExtGridView = class;
  TExtImg = class;
  TExtLayer = class;
  TExtLayout = class;
  TExtLayoutClassList = class;
  TExtLayoutContainer = class;
  TExtLayoutContainerAbsolute = class;
  TExtLayoutContainerAccordion = class;
  TExtLayoutContainerAnchor = class;
  TExtLayoutContainerAuto = class;
  TExtLayoutContainerBorder = class;
  TExtLayoutContainerBox = class;
  TExtLayoutContainerCard = class;
  TExtLayoutContainerCheckboxGroup = class;
  TExtLayoutContainerColumn = class;
  TExtLayoutContainerFit = class;
  TExtLayoutContainerForm = class;
  TExtLayoutContainerHBox = class;
  TExtLayoutContainerTable = class;
  TExtLayoutContainerVBox = class;
  TExtLoadMask = class;
  TExtMenu = class;
  TExtMenuCheckItem = class;
  TExtMenuColorPicker = class;
  TExtMenuDatePicker = class;
  TExtMenuItem = class;
  TExtMenuManagerSingleton = class;
  TExtMenuSeparator = class;
  TExtModelManagerSingleton = class;
  TExtPanel = class;
  TExtPanelHeader = class;
  TExtPanelTable = class;
  TExtPanelTool = class;
  TExtPickerColor = class;
  TExtPickerDate = class;
  TExtPickerTime = class;
  TExtPluginManager = class;
  TExtProgressBar = class;
  TExtResizer = class;
  TExtResizerHandle = class;
  TExtResizerSplitter = class;
  TExtSelectionCellModel = class;
  TExtSelectionCheckboxModel = class;
  TExtSelectionModel = class;
  TExtSelectionRowModel = class;
  TExtShadow = class;
  TExtSliderMulti = class;
  TExtSliderSingle = class;
  TExtSliderTip = class;
  TExtStateCookieProvider = class;
  TExtStateLocalStorageProvider = class;
  TExtStateManagerSingleton = class;
  TExtStateProvider = class;
  TExtStateStateful = class;
  TExtTab = class;
  TExtTabBar = class;
  TExtTabPanel = class;
  TExtTemplate = class;
  TExtTip = class;
  TExtTipQuickTip = class;
  TExtTipQuickTipManagerSingleton = class;
  TExtTipToolTip = class;
  TExtToolbar = class;
  TExtToolbarFill = class;
  TExtToolbarItem = class;
  TExtToolbarPaging = class;
  TExtToolbarSeparator = class;
  TExtToolbarSpacer = class;
  TExtToolbarTextItem = class;
  TExtTreePanel = class;
  TExtTreePluginTreeViewDragDrop = class;
  TExtTreeView = class;
  TExtUtilAnimate = class;
  TExtUtilBindable = class;
  TExtUtilClickRepeater = class;
  TExtUtilComponentDragger = class;
  TExtUtilCookies = class;
  TExtUtilCSSSingleton = class;
  TExtUtilFilter = class;
  TExtUtilFloating = class;
  TExtUtilGrouper = class;
  TExtUtilHashMap = class;
  TExtUtilHistory = class;
  TExtUtilInflector = class;
  TExtUtilKeyMap = class;
  TExtUtilKeyNav = class;
  TExtUtilMemento = class;
  TExtUtilMixedCollection = class;
  TExtUtilObservable = class;
  TExtUtilPoint = class;
  TExtUtilProtoElement = class;
  TExtUtilRegion = class;
  TExtUtilSortable = class;
  TExtUtilSorter = class;
  TExtUtilTaskRunner = class;
  TExtUtilTextMetrics = class;
  TExtView = class;
  TExtViewBoundList = class;
  TExtViewBoundListKeyNav = class;
  TExtViewTable = class;
  TExtViewTableChunker = class;
  TExtWindow = class;
  TExtWindowMessageBox = class;
  TExtXTemplate = class;
  TExtZIndexManager = class;
  TMotherSingleton = class;
  TMyAppCoolPanelSingleton = class;
  TMyCoolClass = class;
  TPerson = class;
  TExtClass = class(TExtObject);
  TExtDataRecord = class(TExtObject);
  TExtDirectProvider = class(TExtObject);
  TExtElement = class(TExtObject);
  TExtError = class(TExtObject);
  TExtEventObject = class(TExtObject);
  TExtFxTarget = class(TExtObject);
  TExtResizerResizeTracker = class(TExtObject);
  TExtSliderThumb = class(TExtObject);
  TExtUtilOffset = class(TExtObject);

  TExtUtilObservable = class(TExtFunction)
  private
    FListeners : TExtObject;
    FIsObservable : Boolean;
    FHasListeners : TExtObject;
    procedure SetFListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFHasListeners(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil; OptionsScope : TExtObject = nil; OptionsDelay : Integer = 0; OptionsSingle : Boolean = false; OptionsBuffer : Integer = 0; OptionsTarget : TExtUtilObservable = nil; OptionsElement : String = '') : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil; OptionsScope : TExtObject = nil; OptionsDelay : Integer = 0; OptionsSingle : Boolean = false; OptionsBuffer : Integer = 0; OptionsTarget : TExtUtilObservable = nil; OptionsElement : String = '') : TExtFunction; overload;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function HasListener(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TExtObjectList; Prefix : String = '') : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TExtObjectList) : TExtFunction; overload;
    destructor Destroy; override;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
  end;

  TExtFormAction = class(TExtUtilObservable)
  private
    FForm : TExtFormBasic;
    FUrl : String;
    FReset : Boolean;
    FMethod : String;
    FParams : TExtObject;
    FParamsString : String;
    FHeaders : TExtObject;
    FTimeout : Integer;
    FSuccess : TExtFunction;
    FFailure : TExtFunction;
    FScope : TExtObject;
    FWaitMsg : String;
    FWaitTitle : String;
    FSubmitEmptyText : Boolean;
    FTypeJS : String;
    FFailureType : String;
    FResponse : TExtObject;
    FResultJS : TExtObject;
    procedure SetFForm(Value : TExtFormBasic);
    procedure SetFUrl(Value : String);
    procedure SetFReset(Value : Boolean);
    procedure SetFMethod(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFParamsString(Value : String);
    procedure SetFHeaders(Value : TExtObject);
    procedure SetFTimeout(Value : Integer);
    procedure SetFSuccess(Value : TExtFunction);
    procedure SetFFailure(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFWaitMsg(Value : String);
    procedure SetFWaitTitle(Value : String);
    procedure SetFSubmitEmptyText(Value : Boolean);
    procedure SetFTypeJS(Value : String);
    procedure SetFFailureType(Value : String);
    procedure SetFResponse(Value : TExtObject);
    procedure SetFResultJS(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    destructor Destroy; override;
    property Form : TExtFormBasic read FForm write SetFForm;
    property Url : String read FUrl write SetFUrl;
    property Reset : Boolean read FReset write SetFReset;
    property Method : String read FMethod write SetFMethod;
    property Params : TExtObject read FParams write SetFParams;
    property ParamsString : String read FParamsString write SetFParamsString;
    property Headers : TExtObject read FHeaders write SetFHeaders;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Success : TExtFunction read FSuccess write SetFSuccess;
    property Failure : TExtFunction read FFailure write SetFFailure;
    property Scope : TExtObject read FScope write SetFScope;
    property WaitMsg : String read FWaitMsg write SetFWaitMsg;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
    property SubmitEmptyText : Boolean read FSubmitEmptyText write SetFSubmitEmptyText;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property FailureType : String read FFailureType write SetFFailureType;
    property Response : TExtObject read FResponse write SetFResponse;
    property ResultJS : TExtObject read FResultJS write SetFResultJS;
  end;

  TExtFormBasic = class(TExtUtilObservable)
  private
    FMethod : String;
    FReader : TExtDataReader;
    FErrorReader : TExtDataReader;
    FUrl : String;
    FBaseParams : TExtObject;
    FTimeout : Integer;
    FApi : TExtObject;
    FParamOrder : String;
    FParamOrderTExtObjectList : TExtObjectList;
    FParamsAsHash : Boolean;
    FWaitTitle : String;
    FTrackResetOnLoad : Boolean;
    FStandardSubmit : Boolean;
    FWaitMsgTarget : String;
    FWaitMsgTargetTHTMLElement : THTMLElement;
    FWaitMsgTargetTExtElement : TExtElement;
    procedure SetFMethod(Value : String);
    procedure SetFReader(Value : TExtDataReader);
    procedure SetFErrorReader(Value : TExtDataReader);
    procedure SetFUrl(Value : String);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFTimeout(Value : Integer);
    procedure SetFApi(Value : TExtObject);
    procedure SetFParamOrder(Value : String);
    procedure SetFParamOrderTExtObjectList(Value : TExtObjectList);
    procedure SetFParamsAsHash(Value : Boolean);
    procedure SetFWaitTitle(Value : String);
    procedure SetFTrackResetOnLoad(Value : Boolean);
    procedure SetFStandardSubmit(Value : Boolean);
    procedure SetFWaitMsgTarget(Value : String);
    procedure SetFWaitMsgTargetTHTMLElement(Value : THTMLElement);
    procedure SetFWaitMsgTargetTExtElement(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetFields : TExtFunction;
    function HasInvalidField : TExtFunction;
    function IsValid : TExtFunction;
    function CheckValidity : TExtFunction;
    function IsDirty : TExtFunction;
    function CheckDirty : TExtFunction;
    function HasUpload : TExtFunction;
    function DoAction(Action : String; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : String = ''; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; overload;
    function DoAction(Action : TExtFormAction; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : String = ''; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; overload;
    function DoAction(Action : TExtFormAction; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : TExtObject = nil; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; overload;
    function DoAction(Action : String; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : TExtObject = nil; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; overload;
    function Submit(Options : TExtObject) : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function UpdateRecord(RecordJS : TExtDataModel = nil) : TExtFunction;
    function LoadRecord(RecordJS : TExtDataModel) : TExtFunction;
    function GetRecord : TExtFunction;
    function FindField(Id : String) : TExtFunction;
    function MarkInvalid(Errors : TExtObject) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtObjectList) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtDataErrors) : TExtFunction; overload;
    function SetValues(Values : TExtObject) : TExtFunction; overload;
    function SetValues(Values : TExtObjectList) : TExtFunction; overload;
    function GetValues(AsString : Boolean = false; DirtyOnly : Boolean = false; IncludeEmptyText : Boolean = false; UseDataValues : Boolean = false) : TExtFunction;
    function GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction;
    function ClearInvalid : TExtFunction;
    function Reset : TExtFunction;
    function ApplyToFields(Obj : TExtObject) : TExtFunction;
    function ApplyIfToFields(Obj : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Method : String read FMethod write SetFMethod;
    property Reader : TExtDataReader read FReader write SetFReader;
    property ErrorReader : TExtDataReader read FErrorReader write SetFErrorReader;
    property Url : String read FUrl write SetFUrl;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Api : TExtObject read FApi write SetFApi;
    property ParamOrder : String read FParamOrder write SetFParamOrder;
    property ParamOrderTExtObjectList : TExtObjectList read FParamOrderTExtObjectList write SetFParamOrderTExtObjectList;
    property ParamsAsHash : Boolean read FParamsAsHash write SetFParamsAsHash;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
    property TrackResetOnLoad : Boolean read FTrackResetOnLoad write SetFTrackResetOnLoad;
    property StandardSubmit : Boolean read FStandardSubmit write SetFStandardSubmit;
    property WaitMsgTarget : String read FWaitMsgTarget write SetFWaitMsgTarget;
    property WaitMsgTargetTHTMLElement : THTMLElement read FWaitMsgTargetTHTMLElement write SetFWaitMsgTargetTHTMLElement;
    property WaitMsgTargetTExtElement : TExtElement read FWaitMsgTargetTExtElement write SetFWaitMsgTargetTExtElement;
  end;

  // Procedural types for events TExtFormFieldAncestor
  TExtFormFieldAncestorOnFieldvaliditychange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; IsValid : String) of object;
  TExtFormFieldAncestorOnFielderrorchange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; Error : String) of object;

  TExtFormFieldAncestor = class(TExtUtilObservable)
  private
    FFieldDefaults : TExtObject;
    FOnFieldvaliditychange : TExtFormFieldAncestorOnFieldvaliditychange;
    FOnFielderrorchange : TExtFormFieldAncestorOnFielderrorchange;
    procedure SetFFieldDefaults(Value : TExtObject);
    procedure SetFOnFieldvaliditychange(Value : TExtFormFieldAncestorOnFieldvaliditychange);
    procedure SetFOnFielderrorchange(Value : TExtFormFieldAncestorOnFielderrorchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FieldDefaults : TExtObject read FFieldDefaults write SetFFieldDefaults;
    property OnFieldvaliditychange : TExtFormFieldAncestorOnFieldvaliditychange read FOnFieldvaliditychange write SetFOnFieldvaliditychange;
    property OnFielderrorchange : TExtFormFieldAncestorOnFielderrorchange read FOnFielderrorchange write SetFOnFielderrorchange;
  end;

  TExtFormField = class(TExtUtilObservable)
  private
    FValue : TExtObject;
    FName : String;
    FDisabled : Boolean;
    FSubmitValue : Boolean;
    FValidateOnChange : Boolean;
    FOriginalValue : TExtObject;
    procedure SetFValue(Value : TExtObject);
    procedure SetFName(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFValidateOnChange(Value : Boolean);
    procedure SetFOriginalValue(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetName : TExtFunction;
    function GetValue : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction;
    function GetSubmitData : TExtFunction;
    function GetModelData : TExtFunction;
    function Reset : TExtFunction;
    function ResetOriginalValue : TExtFunction;
    function CheckChange : TExtFunction;
    function IsDirty : TExtFunction;
    function CheckDirty : TExtFunction;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function IsValid : TExtFunction;
    function Validate : TExtFunction;
    function BatchChanges(Fn : TExtObject) : TExtFunction;
    function IsFileUpload : TExtFunction;
    function ExtractFileInput : TExtFunction;
    destructor Destroy; override;
    property Value : TExtObject read FValue write SetFValue;
    property Name : String read FName write SetFName;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property ValidateOnChange : Boolean read FValidateOnChange write SetFValidateOnChange;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
  end;

  TExtFoo = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Handle(Err : TExtError) : TExtFunction;
    constructor Create(Config : String); overload;
    constructor Create(Config : TExtObject); overload;
    function ToString : TExtFunction;
  end;

  TExtDrawSurface = class(TExtUtilObservable)
  private
    FHeight : Integer;
    FWidth : Integer;
    FItems : TExtObjectList;
    procedure SetFHeight(Value : Integer);
    procedure SetFWidth(Value : Integer);
    procedure SetFItems(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetSize(W : Integer; H : Integer) : TExtFunction;
    function Remove(Sprite : TExtDrawSprite; DestroySprite : Boolean) : TExtFunction;
    function RemoveAll(DestroySprites : Boolean) : TExtFunction;
    function GetGroup(Id : String) : TExtFunction;
    destructor Destroy; override;
    property Height : Integer read FHeight write SetFHeight;
    property Width : Integer read FWidth write SetFWidth;
    property Items : TExtObjectList read FItems write SetFItems;
  end;

  TExtDrawSprite = class(TExtUtilObservable)
  private
    FTypeJS : String;
    FWidth : Integer;
    FHeight : Integer;
    FRadius : Integer;
    FRadiusX : Integer;
    FRadiusY : Integer;
    FX : Integer;
    FY : Integer;
    FPath : String;
    FOpacity : Integer;
    FFill : String;
    FStroke : String;
    FStrokeWidth : Integer;
    FFont : String;
    FText : String;
    FSrc : String;
    FGroup : String;
    FGroupTExtObjectList : TExtObjectList;
    FDraggable : Boolean;
    FIsSprite : Boolean;
    FDd : TExtDdDragSource;
    procedure SetFTypeJS(Value : String);
    procedure SetFWidth(Value : Integer);
    procedure SetFHeight(Value : Integer);
    procedure SetFRadius(Value : Integer);
    procedure SetFRadiusX(Value : Integer);
    procedure SetFRadiusY(Value : Integer);
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
    procedure SetFPath(Value : String);
    procedure SetFOpacity(Value : Integer);
    procedure SetFFill(Value : String);
    procedure SetFStroke(Value : String);
    procedure SetFStrokeWidth(Value : Integer);
    procedure SetFFont(Value : String);
    procedure SetFText(Value : String);
    procedure SetFSrc(Value : String);
    procedure SetFGroup(Value : String);
    procedure SetFGroupTExtObjectList(Value : TExtObjectList);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFIsSprite(Value : Boolean);
    procedure SetFDd(Value : TExtDdDragSource);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction;
    function GetBBox : TExtFunction;
    function Hide(Redraw : Boolean) : TExtFunction;
    function Show(Redraw : Boolean) : TExtFunction;
    function Remove : TExtFunction;
    function Redraw : TExtFunction;
    function SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; overload;
    function SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; overload;
    function AddCls(ClassName : String) : TExtFunction; overload;
    function AddCls(ClassName : TExtObjectList) : TExtFunction; overload;
    function RemoveCls(ClassName : String) : TExtFunction; overload;
    function RemoveCls(ClassName : TExtObjectList) : TExtFunction; overload;
    destructor Destroy; override;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property Width : Integer read FWidth write SetFWidth;
    property Height : Integer read FHeight write SetFHeight;
    property Radius : Integer read FRadius write SetFRadius;
    property RadiusX : Integer read FRadiusX write SetFRadiusX;
    property RadiusY : Integer read FRadiusY write SetFRadiusY;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
    property Path : String read FPath write SetFPath;
    property Opacity : Integer read FOpacity write SetFOpacity;
    property Fill : String read FFill write SetFFill;
    property Stroke : String read FStroke write SetFStroke;
    property StrokeWidth : Integer read FStrokeWidth write SetFStrokeWidth;
    property Font : String read FFont write SetFFont;
    property Text : String read FText write SetFText;
    property Src : String read FSrc write SetFSrc;
    property Group : String read FGroup write SetFGroup;
    property GroupTExtObjectList : TExtObjectList read FGroupTExtObjectList write SetFGroupTExtObjectList;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property IsSprite : Boolean read FIsSprite write SetFIsSprite;
    property Dd : TExtDdDragSource read FDd write SetFDd;
  end;

  // Procedural types for events TExtElementLoader
  TExtElementLoaderOnBeforeload = procedure(This : TExtElementLoader; Options : TExtObject) of object;
  TExtElementLoaderOnException = procedure(This : TExtElementLoader; Response : TExtObject; Options : TExtObject) of object;
  TExtElementLoaderOnLoad = procedure(This : TExtElementLoader; Response : TExtObject; Options : TExtObject) of object;

  TExtElementLoader = class(TExtUtilObservable)
  private
    FUrl : String;
    FParams : TExtObject;
    FBaseParams : TExtObject;
    FAutoLoad : Boolean;
    FAutoLoadTExtObject : TExtObject;
    FTarget : THTMLElement;
    FTargetTExtElement : TExtElement;
    FTargetString : String;
    FLoadMask : Boolean;
    FLoadMaskString : String;
    FAjaxOptions : TExtObject;
    FScripts : Boolean;
    FSuccess : TExtFunction;
    FFailure : TExtFunction;
    FCallback : TExtFunction;
    FScope : TExtObject;
    FRenderer : TExtFunction;
    FIsLoader : Boolean;
    FOnBeforeload : TExtElementLoaderOnBeforeload;
    FOnException : TExtElementLoaderOnException;
    FOnLoad : TExtElementLoaderOnLoad;
    procedure SetFUrl(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFAutoLoad(Value : Boolean);
    procedure SetFAutoLoadTExtObject(Value : TExtObject);
    procedure SetFTarget(Value : THTMLElement);
    procedure SetFTargetTExtElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFLoadMask(Value : Boolean);
    procedure SetFLoadMaskString(Value : String);
    procedure SetFAjaxOptions(Value : TExtObject);
    procedure SetFScripts(Value : Boolean);
    procedure SetFSuccess(Value : TExtFunction);
    procedure SetFFailure(Value : TExtFunction);
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFIsLoader(Value : Boolean);
    procedure SetFOnBeforeload(Value : TExtElementLoaderOnBeforeload);
    procedure SetFOnException(Value : TExtElementLoaderOnException);
    procedure SetFOnLoad(Value : TExtElementLoaderOnLoad);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetTarget(Target : String) : TExtFunction; overload;
    function SetTarget(Target : THTMLElement) : TExtFunction; overload;
    function SetTarget(Target : TExtElement) : TExtFunction; overload;
    function GetTarget : TExtFunction;
    function Abort : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function StartAutoRefresh(Interval : Integer; Options : TExtObject = nil) : TExtFunction;
    function StopAutoRefresh : TExtFunction;
    function IsAutoRefreshing : TExtFunction;
    destructor Destroy; override;
    property Url : String read FUrl write SetFUrl;
    property Params : TExtObject read FParams write SetFParams;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property AutoLoad : Boolean read FAutoLoad write SetFAutoLoad;
    property AutoLoadTExtObject : TExtObject read FAutoLoadTExtObject write SetFAutoLoadTExtObject;
    property Target : THTMLElement read FTarget write SetFTarget;
    property TargetTExtElement : TExtElement read FTargetTExtElement write SetFTargetTExtElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property LoadMask : Boolean read FLoadMask write SetFLoadMask;
    property LoadMaskString : String read FLoadMaskString write SetFLoadMaskString;
    property AjaxOptions : TExtObject read FAjaxOptions write SetFAjaxOptions;
    property Scripts : Boolean read FScripts write SetFScripts;
    property Success : TExtFunction read FSuccess write SetFSuccess;
    property Failure : TExtFunction read FFailure write SetFFailure;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property Scope : TExtObject read FScope write SetFScope;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property IsLoader : Boolean read FIsLoader write SetFIsLoader;
    property OnBeforeload : TExtElementLoaderOnBeforeload read FOnBeforeload write SetFOnBeforeload;
    property OnException : TExtElementLoaderOnException read FOnException write SetFOnException;
    property OnLoad : TExtElementLoaderOnLoad read FOnLoad write SetFOnLoad;
  end;

  // Procedural types for events TExtFocusManager
  TExtFocusManagerOnBeforecomponentfocus = procedure(Fm : TExtFocusManager; Cmp : TExtComponent; PreviousCmp : TExtComponent) of object;
  TExtFocusManagerOnComponentfocus = procedure(Fm : TExtFocusManager; Cmp : TExtComponent; PreviousCmp : TExtComponent) of object;
  TExtFocusManagerOnDisable = procedure(Fm : TExtFocusManager) of object;
  TExtFocusManagerOnEnable = procedure(Fm : TExtFocusManager) of object;

  TExtFocusManager = class(TExtUtilObservable)
  private
    FEnabled : Boolean;
    FFocusedCmp : TExtComponent;
    FWhitelist : TExtObjectList;
    FOnBeforecomponentfocus : TExtFocusManagerOnBeforecomponentfocus;
    FOnComponentfocus : TExtFocusManagerOnComponentfocus;
    FOnDisable : TExtFocusManagerOnDisable;
    FOnEnable : TExtFocusManagerOnEnable;
    procedure SetFEnabled(Value : Boolean);
    procedure SetFFocusedCmp(Value : TExtComponent);
    procedure SetFWhitelist(Value : TExtObjectList);
    procedure SetFOnBeforecomponentfocus(Value : TExtFocusManagerOnBeforecomponentfocus);
    procedure SetFOnComponentfocus(Value : TExtFocusManagerOnComponentfocus);
    procedure SetFOnDisable(Value : TExtFocusManagerOnDisable);
    procedure SetFOnEnable(Value : TExtFocusManagerOnEnable);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AddXTypeToWhitelist(Xtype : String) : TExtFunction; overload;
    function AddXTypeToWhitelist(Xtype : TExtObjectList) : TExtFunction; overload;
    function Disable : TExtFunction;
    function Enable(Options : Boolean; FocusFrame : Boolean = false) : TExtFunction; overload;
    function Enable(Options : TExtObject; FocusFrame : Boolean = false) : TExtFunction; overload;
    function RemoveXTypeFromWhitelist(Xtype : String) : TExtFunction; overload;
    function RemoveXTypeFromWhitelist(Xtype : TExtObjectList) : TExtFunction; overload;
    destructor Destroy; override;
    property Enabled : Boolean read FEnabled write SetFEnabled;
    property FocusedCmp : TExtComponent read FFocusedCmp write SetFFocusedCmp;
    property Whitelist : TExtObjectList read FWhitelist write SetFWhitelist;
    property OnBeforecomponentfocus : TExtFocusManagerOnBeforecomponentfocus read FOnBeforecomponentfocus write SetFOnBeforecomponentfocus;
    property OnComponentfocus : TExtFocusManagerOnComponentfocus read FOnComponentfocus write SetFOnComponentfocus;
    property OnDisable : TExtFocusManagerOnDisable read FOnDisable write SetFOnDisable;
    property OnEnable : TExtFocusManagerOnEnable read FOnEnable write SetFOnEnable;
  end;

  TExtEventObjectImplSingleton = class(TExtUtilObservable)
  private
    FCtrlKey : Boolean;
    FAltKey : Boolean;
    FShiftKey : Boolean;
    procedure SetFCtrlKey(Value : Boolean);
    procedure SetFAltKey(Value : Boolean);
    procedure SetFShiftKey(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function StopEvent : TExtFunction;
    function PreventDefault : TExtFunction;
    function StopPropagation : TExtFunction;
    function GetCharCode : TExtFunction;
    function GetKey : TExtFunction;
    function GetPageX : TExtFunction;
    function GetPageY : TExtFunction;
    function GetX : TExtFunction;
    function GetY : TExtFunction;
    function GetXY : TExtFunction;
    function GetTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetRelatedTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetRelatedTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function Within(El : String; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    function Within(El : THTMLElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    function Within(El : TExtElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    function IsNavKeyPress : TExtFunction;
    function IsSpecialKey : TExtFunction;
    function GetPoint : TExtFunction;
    function HasModifier : TExtFunction;
    property CtrlKey : Boolean read FCtrlKey write SetFCtrlKey;
    property AltKey : Boolean read FAltKey write SetFAltKey;
    property ShiftKey : Boolean read FShiftKey write SetFShiftKey;
  end;

  // Procedural types for events TExtFxAnimator
  TExtFxAnimatorOnBeforeanimate = procedure(This : TExtFxAnimator) of object;
  TExtFxAnimatorOnKeyframe = procedure(This : TExtFxAnimator; Keyframe : Integer) of object;
  TExtFxAnimatorOnAfteranimate = procedure(This : TExtFxAnimator; StartTime : TDateTime) of object;

  TExtFxAnimator = class(TExtUtilObservable)
  private
    FDuration : Integer; // 250
    FDelay : Integer; // 0
    FDynamic : Boolean;
    FEasing : String;
    FIterations : Integer; // 1
    FTarget : TExtFxTarget;
    FKeyframes : TExtObject;
    FOnBeforeanimate : TExtFxAnimatorOnBeforeanimate;
    FOnKeyframe : TExtFxAnimatorOnKeyframe;
    FOnAfteranimate : TExtFxAnimatorOnAfteranimate;
    procedure SetFDuration(Value : Integer);
    procedure SetFDelay(Value : Integer);
    procedure SetFDynamic(Value : Boolean);
    procedure SetFEasing(Value : String);
    procedure SetFIterations(Value : Integer);
    procedure SetFTarget(Value : TExtFxTarget);
    procedure SetFKeyframes(Value : TExtObject);
    procedure SetFOnBeforeanimate(Value : TExtFxAnimatorOnBeforeanimate);
    procedure SetFOnKeyframe(Value : TExtFxAnimatorOnKeyframe);
    procedure SetFOnAfteranimate(Value : TExtFxAnimatorOnAfteranimate);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function EndJS : TExtFunction;
    destructor Destroy; override;
    property Duration : Integer read FDuration write SetFDuration;
    property Delay : Integer read FDelay write SetFDelay;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property Easing : String read FEasing write SetFEasing;
    property Iterations : Integer read FIterations write SetFIterations;
    property Target : TExtFxTarget read FTarget write SetFTarget;
    property Keyframes : TExtObject read FKeyframes write SetFKeyframes;
    property OnBeforeanimate : TExtFxAnimatorOnBeforeanimate read FOnBeforeanimate write SetFOnBeforeanimate;
    property OnKeyframe : TExtFxAnimatorOnKeyframe read FOnKeyframe write SetFOnKeyframe;
    property OnAfteranimate : TExtFxAnimatorOnAfteranimate read FOnAfteranimate write SetFOnAfteranimate;
  end;

  // Procedural types for events TExtFxAnim
  TExtFxAnimOnBeforeanimate = procedure(This : TExtFxAnim) of object;
  TExtFxAnimOnAfteranimate = procedure(This : TExtFxAnim; StartTime : TDateTime) of object;
  TExtFxAnimOnLastframe = procedure(This : TExtFxAnim; StartTime : TDateTime) of object;

  TExtFxAnim = class(TExtUtilObservable)
  private
    FCallback : TExtFunction;
    FScope : TExtFunction;
    FDuration : Integer;
    FDelay : Integer;
    FDynamic : Boolean;
    FEasing : String;
    FKeyframes : TExtObject;
    FReverse : Boolean;
    FIterations : Integer;
    FAlternate : Boolean;
    FTarget : String;
    FTargetTExtObject : TExtObject;
    FFrom : TExtObject;
    FToJS : TExtObject;
    FOnBeforeanimate : TExtFxAnimOnBeforeanimate;
    FOnAfteranimate : TExtFxAnimOnAfteranimate;
    FOnLastframe : TExtFxAnimOnLastframe;
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFScope(Value : TExtFunction);
    procedure SetFDuration(Value : Integer);
    procedure SetFDelay(Value : Integer);
    procedure SetFDynamic(Value : Boolean);
    procedure SetFEasing(Value : String);
    procedure SetFKeyframes(Value : TExtObject);
    procedure SetFReverse(Value : Boolean);
    procedure SetFIterations(Value : Integer);
    procedure SetFAlternate(Value : Boolean);
    procedure SetFTarget(Value : String);
    procedure SetFTargetTExtObject(Value : TExtObject);
    procedure SetFFrom(Value : TExtObject);
    procedure SetFToJS(Value : TExtObject);
    procedure SetFOnBeforeanimate(Value : TExtFxAnimOnBeforeanimate);
    procedure SetFOnAfteranimate(Value : TExtFxAnimOnAfteranimate);
    procedure SetFOnLastframe(Value : TExtFxAnimOnLastframe);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function EndJS : TExtFunction;
    destructor Destroy; override;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property Scope : TExtFunction read FScope write SetFScope;
    property Duration : Integer read FDuration write SetFDuration;
    property Delay : Integer read FDelay write SetFDelay;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property Easing : String read FEasing write SetFEasing;
    property Keyframes : TExtObject read FKeyframes write SetFKeyframes;
    property Reverse : Boolean read FReverse write SetFReverse;
    property Iterations : Integer read FIterations write SetFIterations;
    property Alternate : Boolean read FAlternate write SetFAlternate;
    property Target : String read FTarget write SetFTarget;
    property TargetTExtObject : TExtObject read FTargetTExtObject write SetFTargetTExtObject;
    property From : TExtObject read FFrom write SetFFrom;
    property ToJS : TExtObject read FToJS write SetFToJS;
    property OnBeforeanimate : TExtFxAnimOnBeforeanimate read FOnBeforeanimate write SetFOnBeforeanimate;
    property OnAfteranimate : TExtFxAnimOnAfteranimate read FOnAfteranimate write SetFOnAfteranimate;
    property OnLastframe : TExtFxAnimOnLastframe read FOnLastframe write SetFOnLastframe;
  end;

  TExtFxTargetComponent = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetSprite = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetElement = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TMotherSingleton = class(TExtUtilObservable)
  private
    FUsesJS : TExtObjectList;
    procedure SetFUsesJS(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    destructor Destroy; override;
    property UsesJS : TExtObjectList read FUsesJS write SetFUsesJS;
  end;

  TMyCoolClass = class(TExtUtilObservable)
  private
    FSelf : TExtClass;
    procedure SetFSelf(Value : TExtClass);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetInitialConfig(Name : String = '') : TExtFunction;
    destructor Destroy; override;
    property Self : TExtClass read FSelf write SetFSelf;
  end;

  TExtZIndexManager = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Register(Comp : TExtComponent) : TExtFunction;
    function Unregister(Comp : TExtComponent) : TExtFunction;
    function Get(Id : String) : TExtFunction; overload;
    function Get(Id : TExtObject) : TExtFunction; overload;
    function BringToFront(Comp : String) : TExtFunction; overload;
    function BringToFront(Comp : TExtObject) : TExtFunction; overload;
    function SendToBack(Comp : String) : TExtFunction; overload;
    function SendToBack(Comp : TExtObject) : TExtFunction; overload;
    function HideAll : TExtFunction;
    function GetActive : TExtFunction;
    function GetBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
  end;

  // Procedural types for events TExtFormLabelable
  TExtFormLabelableOnErrorchange = procedure(This : TExtFormLabelable; Error : String) of object;

  TExtFormLabelable = class(TExtUtilObservable)
  private
    FLabelableRenderTpl : String;
    FLabelableRenderTplTExtObjectList : TExtObjectList;
    FLabelableRenderTplTExtXTemplate : TExtXTemplate;
    FActiveErrorsTpl : String;
    FActiveErrorsTplTExtObjectList : TExtObjectList;
    FActiveErrorsTplTExtXTemplate : TExtXTemplate;
    FFormItemCls : String;
    FLabelCls : String;
    FLabelClsExtra : String;
    FErrorMsgCls : String;
    FBaseBodyCls : String;
    FFieldBodyCls : String;
    FClearCls : String;
    FInvalidCls : String;
    FFieldLabel : String;
    FLabelAlign : String;
    FLabelWidth : Integer;
    FLabelPad : Integer;
    FLabelSeparator : String;
    FLabelStyle : String;
    FHideLabel : Boolean;
    FHideEmptyLabel : Boolean;
    FPreventMark : Boolean;
    FAutoFitErrors : Boolean;
    FMsgTarget : String;
    FActiveError : String;
    FBeforeBodyEl : String;
    FBeforeBodyElTExtObjectList : TExtObjectList;
    FBeforeBodyElTExtXTemplate : TExtXTemplate;
    FAfterBodyEl : String;
    FAfterBodyElTExtObjectList : TExtObjectList;
    FAfterBodyElTExtXTemplate : TExtXTemplate;
    FBeforeLabelTpl : String;
    FBeforeLabelTplTExtObjectList : TExtObjectList;
    FBeforeLabelTplTExtXTemplate : TExtXTemplate;
    FAfterLabelTpl : String;
    FAfterLabelTplTExtObjectList : TExtObjectList;
    FAfterLabelTplTExtXTemplate : TExtXTemplate;
    FBeforeSubTpl : String;
    FBeforeSubTplTExtObjectList : TExtObjectList;
    FBeforeSubTplTExtXTemplate : TExtXTemplate;
    FAfterSubTpl : String;
    FAfterSubTplTExtObjectList : TExtObjectList;
    FAfterSubTplTExtXTemplate : TExtXTemplate;
    FBeforeLabelTextTpl : String;
    FBeforeLabelTextTplTExtObjectList : TExtObjectList;
    FBeforeLabelTextTplTExtXTemplate : TExtXTemplate;
    FAfterLabelTextTpl : String;
    FAfterLabelTextTplTExtObjectList : TExtObjectList;
    FAfterLabelTextTplTExtXTemplate : TExtXTemplate;
    FLabelAttrTpl : String;
    FLabelAttrTplTExtObjectList : TExtObjectList;
    FLabelAttrTplTExtXTemplate : TExtXTemplate;
    FOnErrorchange : TExtFormLabelableOnErrorchange;
    procedure SetFLabelableRenderTpl(Value : String);
    procedure SetFLabelableRenderTplTExtObjectList(Value : TExtObjectList);
    procedure SetFLabelableRenderTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFActiveErrorsTpl(Value : String);
    procedure SetFActiveErrorsTplTExtObjectList(Value : TExtObjectList);
    procedure SetFActiveErrorsTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFFormItemCls(Value : String);
    procedure SetFLabelCls(Value : String);
    procedure SetFLabelClsExtra(Value : String);
    procedure SetFErrorMsgCls(Value : String);
    procedure SetFBaseBodyCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFClearCls(Value : String);
    procedure SetFInvalidCls(Value : String);
    procedure SetFFieldLabel(Value : String);
    procedure SetFLabelAlign(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFLabelPad(Value : Integer);
    procedure SetFLabelSeparator(Value : String);
    procedure SetFLabelStyle(Value : String);
    procedure SetFHideLabel(Value : Boolean);
    procedure SetFHideEmptyLabel(Value : Boolean);
    procedure SetFPreventMark(Value : Boolean);
    procedure SetFAutoFitErrors(Value : Boolean);
    procedure SetFMsgTarget(Value : String);
    procedure SetFActiveError(Value : String);
    procedure SetFBeforeBodyEl(Value : String);
    procedure SetFBeforeBodyElTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeBodyElTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterBodyEl(Value : String);
    procedure SetFAfterBodyElTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterBodyElTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTpl(Value : String);
    procedure SetFBeforeLabelTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeLabelTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTpl(Value : String);
    procedure SetFAfterLabelTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterLabelTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBeforeSubTpl(Value : String);
    procedure SetFBeforeSubTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeSubTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterSubTpl(Value : String);
    procedure SetFAfterSubTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterSubTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTextTpl(Value : String);
    procedure SetFBeforeLabelTextTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeLabelTextTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTextTpl(Value : String);
    procedure SetFAfterLabelTextTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterLabelTextTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFLabelAttrTpl(Value : String);
    procedure SetFLabelAttrTplTExtObjectList(Value : TExtObjectList);
    procedure SetFLabelAttrTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFOnErrorchange(Value : TExtFormLabelableOnErrorchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function TrimLabelSeparator : TExtFunction;
    function SetFieldLabel(LabelJS : String) : TExtFunction;
    function HasVisibleLabel : TExtFunction;
    function GetInputId : TExtFunction;
    function GetActiveError : TExtFunction;
    function HasActiveError : TExtFunction;
    function SetActiveError(Msg : String) : TExtFunction;
    function GetActiveErrors : TExtFunction;
    function SetActiveErrors(Errors : TExtObjectList) : TExtFunction;
    function UnsetActiveError : TExtFunction;
    function SetFieldDefaults(Defaults : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property LabelableRenderTpl : String read FLabelableRenderTpl write SetFLabelableRenderTpl;
    property LabelableRenderTplTExtObjectList : TExtObjectList read FLabelableRenderTplTExtObjectList write SetFLabelableRenderTplTExtObjectList;
    property LabelableRenderTplTExtXTemplate : TExtXTemplate read FLabelableRenderTplTExtXTemplate write SetFLabelableRenderTplTExtXTemplate;
    property ActiveErrorsTpl : String read FActiveErrorsTpl write SetFActiveErrorsTpl;
    property ActiveErrorsTplTExtObjectList : TExtObjectList read FActiveErrorsTplTExtObjectList write SetFActiveErrorsTplTExtObjectList;
    property ActiveErrorsTplTExtXTemplate : TExtXTemplate read FActiveErrorsTplTExtXTemplate write SetFActiveErrorsTplTExtXTemplate;
    property FormItemCls : String read FFormItemCls write SetFFormItemCls;
    property LabelCls : String read FLabelCls write SetFLabelCls;
    property LabelClsExtra : String read FLabelClsExtra write SetFLabelClsExtra;
    property ErrorMsgCls : String read FErrorMsgCls write SetFErrorMsgCls;
    property BaseBodyCls : String read FBaseBodyCls write SetFBaseBodyCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property ClearCls : String read FClearCls write SetFClearCls;
    property InvalidCls : String read FInvalidCls write SetFInvalidCls;
    property FieldLabel : String read FFieldLabel write SetFFieldLabel;
    property LabelAlign : String read FLabelAlign write SetFLabelAlign;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property LabelPad : Integer read FLabelPad write SetFLabelPad;
    property LabelSeparator : String read FLabelSeparator write SetFLabelSeparator;
    property LabelStyle : String read FLabelStyle write SetFLabelStyle;
    property HideLabel : Boolean read FHideLabel write SetFHideLabel;
    property HideEmptyLabel : Boolean read FHideEmptyLabel write SetFHideEmptyLabel;
    property PreventMark : Boolean read FPreventMark write SetFPreventMark;
    property AutoFitErrors : Boolean read FAutoFitErrors write SetFAutoFitErrors;
    property MsgTarget : String read FMsgTarget write SetFMsgTarget;
    property ActiveError : String read FActiveError write SetFActiveError;
    property BeforeBodyEl : String read FBeforeBodyEl write SetFBeforeBodyEl;
    property BeforeBodyElTExtObjectList : TExtObjectList read FBeforeBodyElTExtObjectList write SetFBeforeBodyElTExtObjectList;
    property BeforeBodyElTExtXTemplate : TExtXTemplate read FBeforeBodyElTExtXTemplate write SetFBeforeBodyElTExtXTemplate;
    property AfterBodyEl : String read FAfterBodyEl write SetFAfterBodyEl;
    property AfterBodyElTExtObjectList : TExtObjectList read FAfterBodyElTExtObjectList write SetFAfterBodyElTExtObjectList;
    property AfterBodyElTExtXTemplate : TExtXTemplate read FAfterBodyElTExtXTemplate write SetFAfterBodyElTExtXTemplate;
    property BeforeLabelTpl : String read FBeforeLabelTpl write SetFBeforeLabelTpl;
    property BeforeLabelTplTExtObjectList : TExtObjectList read FBeforeLabelTplTExtObjectList write SetFBeforeLabelTplTExtObjectList;
    property BeforeLabelTplTExtXTemplate : TExtXTemplate read FBeforeLabelTplTExtXTemplate write SetFBeforeLabelTplTExtXTemplate;
    property AfterLabelTpl : String read FAfterLabelTpl write SetFAfterLabelTpl;
    property AfterLabelTplTExtObjectList : TExtObjectList read FAfterLabelTplTExtObjectList write SetFAfterLabelTplTExtObjectList;
    property AfterLabelTplTExtXTemplate : TExtXTemplate read FAfterLabelTplTExtXTemplate write SetFAfterLabelTplTExtXTemplate;
    property BeforeSubTpl : String read FBeforeSubTpl write SetFBeforeSubTpl;
    property BeforeSubTplTExtObjectList : TExtObjectList read FBeforeSubTplTExtObjectList write SetFBeforeSubTplTExtObjectList;
    property BeforeSubTplTExtXTemplate : TExtXTemplate read FBeforeSubTplTExtXTemplate write SetFBeforeSubTplTExtXTemplate;
    property AfterSubTpl : String read FAfterSubTpl write SetFAfterSubTpl;
    property AfterSubTplTExtObjectList : TExtObjectList read FAfterSubTplTExtObjectList write SetFAfterSubTplTExtObjectList;
    property AfterSubTplTExtXTemplate : TExtXTemplate read FAfterSubTplTExtXTemplate write SetFAfterSubTplTExtXTemplate;
    property BeforeLabelTextTpl : String read FBeforeLabelTextTpl write SetFBeforeLabelTextTpl;
    property BeforeLabelTextTplTExtObjectList : TExtObjectList read FBeforeLabelTextTplTExtObjectList write SetFBeforeLabelTextTplTExtObjectList;
    property BeforeLabelTextTplTExtXTemplate : TExtXTemplate read FBeforeLabelTextTplTExtXTemplate write SetFBeforeLabelTextTplTExtXTemplate;
    property AfterLabelTextTpl : String read FAfterLabelTextTpl write SetFAfterLabelTextTpl;
    property AfterLabelTextTplTExtObjectList : TExtObjectList read FAfterLabelTextTplTExtObjectList write SetFAfterLabelTextTplTExtObjectList;
    property AfterLabelTextTplTExtXTemplate : TExtXTemplate read FAfterLabelTextTplTExtXTemplate write SetFAfterLabelTextTplTExtXTemplate;
    property LabelAttrTpl : String read FLabelAttrTpl write SetFLabelAttrTpl;
    property LabelAttrTplTExtObjectList : TExtObjectList read FLabelAttrTplTExtObjectList write SetFLabelAttrTplTExtObjectList;
    property LabelAttrTplTExtXTemplate : TExtXTemplate read FLabelAttrTplTExtXTemplate write SetFLabelAttrTplTExtXTemplate;
    property OnErrorchange : TExtFormLabelableOnErrorchange read FOnErrorchange write SetFOnErrorchange;
  end;

  TExtFormFieldVTypesSingleton = class(TExtUtilObservable)
  private
    FEmailText : String; // 'This field should be an e-mail address in the format'
    FEmailMask : TRegExp;
    FUrlText : String; // 'This field should be a URL in the format'
    FAlphaText : String; // 'This field should only contain letters and _'
    FAlphanumText : String; // 'This field should only contain letters, numbers and _'
    procedure SetFEmailText(Value : String);
    procedure SetFEmailMask(Value : TRegExp);
    procedure SetFUrlText(Value : String);
    procedure SetFAlphaText(Value : String);
    procedure SetFAlphanumText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property EmailText : String read FEmailText write SetFEmailText;
    property EmailMask : TRegExp read FEmailMask write SetFEmailMask;
    property UrlText : String read FUrlText write SetFUrlText;
    property AlphaText : String read FAlphaText write SetFAlphaText;
    property AlphanumText : String read FAlphanumText write SetFAlphanumText;
  end;

  TExtDdScrollManager = class(TExtUtilObservable)
  private
    FDdGroup : String;
    procedure SetFDdGroup(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function RefreshCache : TExtFunction;
    property DdGroup : String read FDdGroup write SetFDdGroup;
  end;

  TExtDdRegistry = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Register(Element : String; Data : TExtObject; DataHandles : TExtObjectList; DataIsHandle : Boolean) : TExtFunction; overload;
    function Register(Element : THTMLElement; Data : TExtObject; DataHandles : TExtObjectList; DataIsHandle : Boolean) : TExtFunction; overload;
    function Unregister(Element : String) : TExtFunction; overload;
    function Unregister(Element : THTMLElement) : TExtFunction; overload;
    function GetHandle(Id : String) : TExtFunction; overload;
    function GetHandle(Id : THTMLElement) : TExtFunction; overload;
    function GetHandleFromEvent(E : TEvent) : TExtFunction;
    function GetTarget(Id : String) : TExtFunction; overload;
    function GetTarget(Id : THTMLElement) : TExtFunction; overload;
    function GetTargetFromEvent(E : TEvent) : TExtFunction;
  end;

  TExtDiagLayoutContext = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDirectEvent = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function GetData : TExtFunction;
  end;

  TExtDiagLayoutContextItem = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDdDragDrop = class(TExtUtilObservable)
  private
    FIgnoreSelf : Boolean; // true
    FId : String;
    FConfig : TExtObject;
    FInvalidHandleTypes : TExtObject;
    FInvalidHandleClasses : TExtObjectList;
    FGroups : TExtObject;
    FMoveOnly : Boolean;
    FIsTarget : Boolean;
    FPadding : TArrayOfInteger;
    FMaintainOffset : Boolean;
    FXTicks : TArrayOfInteger;
    FYTicks : TArrayOfInteger;
    FPrimaryButtonOnly : Boolean;
    FAvailable : Boolean;
    FHasOuterHandles : Boolean;
    FDefaultPadding : TExtObject;
    procedure SetFIgnoreSelf(Value : Boolean);
    procedure SetFId(Value : String);
    procedure SetFConfig(Value : TExtObject);
    procedure SetFInvalidHandleTypes(Value : TExtObject);
    procedure SetFInvalidHandleClasses(Value : TExtObjectList);
    procedure SetFGroups(Value : TExtObject);
    procedure SetFMoveOnly(Value : Boolean);
    procedure SetFIsTarget(Value : Boolean);
    procedure SetFPadding(Value : TArrayOfInteger);
    procedure SetFMaintainOffset(Value : Boolean);
    procedure SetFXTicks(Value : TArrayOfInteger);
    procedure SetFYTicks(Value : TArrayOfInteger);
    procedure SetFPrimaryButtonOnly(Value : Boolean);
    procedure SetFAvailable(Value : Boolean);
    procedure SetFHasOuterHandles(Value : Boolean);
    procedure SetFDefaultPadding(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ConstrainTo(ConstrainTo : String; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : THTMLElement; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : THTMLElement; Pad : Integer; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : TExtElement; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : TExtElement; Pad : Integer; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : String; Pad : Integer; InContent : Boolean = false) : TExtFunction; overload;
    function GetEl : TExtFunction;
    function GetDragEl : TExtFunction;
    function Init(Id : String; SGroup : String; Config : TExtObject) : TExtFunction;
    function InitTarget(Id : String; SGroup : String; Config : TExtObject) : TExtFunction;
    function ApplyConfig : TExtFunction;
    function SetPadding(ITop : Integer; IRight : Integer; IBot : Integer; ILeft : Integer) : TExtFunction;
    function SetInitPosition(DiffX : Integer; DiffY : Integer) : TExtFunction;
    function AddToGroup(SGroup : String) : TExtFunction;
    function RemoveFromGroup(SGroup : String) : TExtFunction;
    function SetDragElId(Id : String) : TExtFunction;
    function SetHandleElId(Id : String) : TExtFunction;
    function SetOuterHandleElId(Id : String) : TExtFunction;
    function Unreg : TExtFunction;
    function IsLocked : TExtFunction;
    function AddInvalidHandleType(TagName : String) : TExtFunction;
    function AddInvalidHandleId(Id : String) : TExtFunction;
    function AddInvalidHandleClass(CssClass : String) : TExtFunction;
    function RemoveInvalidHandleType(TagName : String) : TExtFunction;
    function RemoveInvalidHandleId(Id : String) : TExtFunction;
    function RemoveInvalidHandleClass(CssClass : String) : TExtFunction;
    function IsValidHandleChild(Node : THTMLElement) : TExtFunction;
    function SetXConstraint(ILeft : Integer; IRight : Integer; ITickSize : Integer = 0) : TExtFunction;
    function ClearConstraints : TExtFunction;
    function ClearTicks : TExtFunction;
    function SetYConstraint(IUp : Integer; IDown : Integer; ITickSize : Integer = 0) : TExtFunction;
    function ResetConstraints(MaintainOffset : Boolean) : TExtFunction;
    function ToString : TExtFunction;
    destructor Destroy; override;
    property IgnoreSelf : Boolean read FIgnoreSelf write SetFIgnoreSelf;
    property Id : String read FId write SetFId;
    property Config : TExtObject read FConfig write SetFConfig;
    property InvalidHandleTypes : TExtObject read FInvalidHandleTypes write SetFInvalidHandleTypes;
    property InvalidHandleClasses : TExtObjectList read FInvalidHandleClasses write SetFInvalidHandleClasses;
    property Groups : TExtObject read FGroups write SetFGroups;
    property MoveOnly : Boolean read FMoveOnly write SetFMoveOnly;
    property IsTarget : Boolean read FIsTarget write SetFIsTarget;
    property Padding : TArrayOfInteger read FPadding write SetFPadding;
    property MaintainOffset : Boolean read FMaintainOffset write SetFMaintainOffset;
    property XTicks : TArrayOfInteger read FXTicks write SetFXTicks;
    property YTicks : TArrayOfInteger read FYTicks write SetFYTicks;
    property PrimaryButtonOnly : Boolean read FPrimaryButtonOnly write SetFPrimaryButtonOnly;
    property Available : Boolean read FAvailable write SetFAvailable;
    property HasOuterHandles : Boolean read FHasOuterHandles write SetFHasOuterHandles;
    property DefaultPadding : TExtObject read FDefaultPadding write SetFDefaultPadding;
  end;

  TExtDataValidations = class(TExtUtilObservable)
  private
    FPresenceMessage : String;
    FLengthMessage : String;
    FFormatMessage : String;
    FInclusionMessage : String;
    FExclusionMessage : String;
    FEmailMessage : String;
    FEmailRe : TRegExp;
    procedure SetFPresenceMessage(Value : String);
    procedure SetFLengthMessage(Value : String);
    procedure SetFFormatMessage(Value : String);
    procedure SetFInclusionMessage(Value : String);
    procedure SetFExclusionMessage(Value : String);
    procedure SetFEmailMessage(Value : String);
    procedure SetFEmailRe(Value : TRegExp);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Presence(Config : TExtObject; Value : TExtObject) : TExtFunction;
    function Length(Config : TExtObject; Value : String) : TExtFunction;
    function Email(Config : TExtObject; Email : String) : TExtFunction;
    function Format(Config : TExtObject; Value : String) : TExtFunction;
    function Inclusion(Config : TExtObject; Value : String) : TExtFunction;
    function Exclusion(Config : TExtObject; Value : String) : TExtFunction;
    property PresenceMessage : String read FPresenceMessage write SetFPresenceMessage;
    property LengthMessage : String read FLengthMessage write SetFLengthMessage;
    property FormatMessage : String read FFormatMessage write SetFFormatMessage;
    property InclusionMessage : String read FInclusionMessage write SetFInclusionMessage;
    property ExclusionMessage : String read FExclusionMessage write SetFExclusionMessage;
    property EmailMessage : String read FEmailMessage write SetFEmailMessage;
    property EmailRe : TRegExp read FEmailRe write SetFEmailRe;
  end;

  TExtDdDragDropManager = class(TExtUtilObservable)
  private
    FPreventDefault : Boolean;
    FStopPropagation : Boolean;
    FMode : Integer;
    FNotifyOccluded : Boolean;
    FLocationCache : TExtObject;
    FUseCache : Boolean;
    FClickPixelThresh : Integer;
    FClickTimeThresh : Integer;
    FElementCache : TExtObject;
    F_timeoutCount : Integer;
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopPropagation(Value : Boolean);
    procedure SetFMode(Value : Integer);
    procedure SetFNotifyOccluded(Value : Boolean);
    procedure SetFLocationCache(Value : TExtObject);
    procedure SetFUseCache(Value : Boolean);
    procedure SetFClickPixelThresh(Value : Integer);
    procedure SetFClickTimeThresh(Value : Integer);
    procedure SetFElementCache(Value : TExtObject);
    procedure SetF_timeoutCount(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    class function POINT : Integer;
    class function INTERSECT : Integer;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function HandleWasClicked(Node : THTMLElement) : TExtFunction;
    destructor Destroy; override;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopPropagation : Boolean read FStopPropagation write SetFStopPropagation;
    property Mode : Integer read FMode write SetFMode;
    property NotifyOccluded : Boolean read FNotifyOccluded write SetFNotifyOccluded;
    property LocationCache : TExtObject read FLocationCache write SetFLocationCache;
    property UseCache : Boolean read FUseCache write SetFUseCache;
    property ClickPixelThresh : Integer read FClickPixelThresh write SetFClickPixelThresh;
    property ClickTimeThresh : Integer read FClickTimeThresh write SetFClickTimeThresh;
    property ElementCache : TExtObject read FElementCache write SetFElementCache;
    property _timeoutCount : Integer read F_timeoutCount write SetF_timeoutCount;
  end;

  TPerson = class(TExtUtilObservable)
  private
    FStatics : TExtObject;
    FInheritableStatics : TExtObject;
    FConfig : TExtObject;
    FMixins : TExtObjectList;
    FMixinsTExtObject : TExtObject;
    procedure SetFStatics(Value : TExtObject);
    procedure SetFInheritableStatics(Value : TExtObject);
    procedure SetFConfig(Value : TExtObject);
    procedure SetFMixins(Value : TExtObjectList);
    procedure SetFMixinsTExtObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Statics : TExtObject read FStatics write SetFStatics;
    property InheritableStatics : TExtObject read FInheritableStatics write SetFInheritableStatics;
    property Config : TExtObject read FConfig write SetFConfig;
    property Mixins : TExtObjectList read FMixins write SetFMixins;
    property MixinsTExtObject : TExtObject read FMixinsTExtObject write SetFMixinsTExtObject;
  end;

  // Procedural types for events TExtDdDragTracker
  TExtDdDragTrackerOnMouseover = procedure(This : TExtDdDragTracker; E : TExtObject; Target : THTMLElement) of object;
  TExtDdDragTrackerOnMouseout = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMousedown = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMouseup = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMousemove = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnBeforestart = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDragstart = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDragend = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDrag = procedure(This : TExtDdDragTracker; E : TExtObject) of object;

  TExtDdDragTracker = class(TExtUtilObservable)
  private
    FTrackOver : Boolean;
    FOverCls : String;
    FConstrainTo : TExtUtilRegion;
    FConstrainToTExtElement : TExtElement;
    FTolerance : Integer;
    FAutoStart : Boolean;
    FAutoStartInteger : Integer;
    FDelegate : String;
    FPreventDefault : Boolean;
    FStopEvent : Boolean;
    FOnMouseover : TExtDdDragTrackerOnMouseover;
    FOnMouseout : TExtDdDragTrackerOnMouseout;
    FOnMousedown : TExtDdDragTrackerOnMousedown;
    FOnMouseup : TExtDdDragTrackerOnMouseup;
    FOnMousemove : TExtDdDragTrackerOnMousemove;
    FOnBeforestart : TExtDdDragTrackerOnBeforestart;
    FOnDragstart : TExtDdDragTrackerOnDragstart;
    FOnDragend : TExtDdDragTrackerOnDragend;
    FOnDrag : TExtDdDragTrackerOnDrag;
    procedure SetFTrackOver(Value : Boolean);
    procedure SetFOverCls(Value : String);
    procedure SetFConstrainTo(Value : TExtUtilRegion);
    procedure SetFConstrainToTExtElement(Value : TExtElement);
    procedure SetFTolerance(Value : Integer);
    procedure SetFAutoStart(Value : Boolean);
    procedure SetFAutoStartInteger(Value : Integer);
    procedure SetFDelegate(Value : String);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopEvent(Value : Boolean);
    procedure SetFOnMouseover(Value : TExtDdDragTrackerOnMouseover);
    procedure SetFOnMouseout(Value : TExtDdDragTrackerOnMouseout);
    procedure SetFOnMousedown(Value : TExtDdDragTrackerOnMousedown);
    procedure SetFOnMouseup(Value : TExtDdDragTrackerOnMouseup);
    procedure SetFOnMousemove(Value : TExtDdDragTrackerOnMousemove);
    procedure SetFOnBeforestart(Value : TExtDdDragTrackerOnBeforestart);
    procedure SetFOnDragstart(Value : TExtDdDragTrackerOnDragstart);
    procedure SetFOnDragend(Value : TExtDdDragTrackerOnDragend);
    procedure SetFOnDrag(Value : TExtDdDragTrackerOnDrag);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function InitEl(El : TExtElement) : TExtFunction; overload;
    function InitEl(El : THTMLElement) : TExtFunction; overload;
    function GetDragTarget : TExtFunction;
    function GetOffset(Optional : String) : TExtFunction;
    destructor Destroy; override;
    property TrackOver : Boolean read FTrackOver write SetFTrackOver;
    property OverCls : String read FOverCls write SetFOverCls;
    property ConstrainTo : TExtUtilRegion read FConstrainTo write SetFConstrainTo;
    property ConstrainToTExtElement : TExtElement read FConstrainToTExtElement write SetFConstrainToTExtElement;
    property Tolerance : Integer read FTolerance write SetFTolerance;
    property AutoStart : Boolean read FAutoStart write SetFAutoStart;
    property AutoStartInteger : Integer read FAutoStartInteger write SetFAutoStartInteger;
    property Delegate : String read FDelegate write SetFDelegate;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopEvent : Boolean read FStopEvent write SetFStopEvent;
    property OnMouseover : TExtDdDragTrackerOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseout : TExtDdDragTrackerOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMousedown : TExtDdDragTrackerOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseup : TExtDdDragTrackerOnMouseup read FOnMouseup write SetFOnMouseup;
    property OnMousemove : TExtDdDragTrackerOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnBeforestart : TExtDdDragTrackerOnBeforestart read FOnBeforestart write SetFOnBeforestart;
    property OnDragstart : TExtDdDragTrackerOnDragstart read FOnDragstart write SetFOnDragstart;
    property OnDragend : TExtDdDragTrackerOnDragend read FOnDragend write SetFOnDragend;
    property OnDrag : TExtDdDragTrackerOnDrag read FOnDrag write SetFOnDrag;
  end;

  TExtDomHelperSingleton = class(TExtUtilObservable)
  private
    FUseDom : Boolean;
    procedure SetFUseDom(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateDom(O : TExtObject) : TExtFunction; overload;
    function CreateDom(O : String) : TExtFunction; overload;
    function CreateHtml : TExtFunction;
    function Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function CreateTemplate(O : TExtObject) : TExtFunction;
    property UseDom : Boolean read FUseDom write SetFUseDom;
  end;

  // Procedural types for events TExtDomElement
  TExtDomElementOnClick = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnContextmenu = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDblclick = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMousedown = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseup = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseover = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMousemove = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseout = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseenter = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseleave = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeypress = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeydown = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeyup = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnLoad = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnUnload = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnAbort = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnError = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnResize = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnScroll = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnSelect = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnChange = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnSubmit = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnReset = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnFocus = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnBlur = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMFocusIn = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMFocusOut = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMActivate = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMSubtreeModified = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeInserted = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeRemoved = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeRemovedFromDocument = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeInsertedIntoDocument = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMAttrModified = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMCharacterDataModified = procedure(E : TExtEventObject; T : THTMLElement) of object;

  TExtDomElement = class(TExtUtilObservable)
  private
    FAutoBoxAdjust : Boolean;
    FOnClick : TExtDomElementOnClick;
    FOnContextmenu : TExtDomElementOnContextmenu;
    FOnDblclick : TExtDomElementOnDblclick;
    FOnMousedown : TExtDomElementOnMousedown;
    FOnMouseup : TExtDomElementOnMouseup;
    FOnMouseover : TExtDomElementOnMouseover;
    FOnMousemove : TExtDomElementOnMousemove;
    FOnMouseout : TExtDomElementOnMouseout;
    FOnMouseenter : TExtDomElementOnMouseenter;
    FOnMouseleave : TExtDomElementOnMouseleave;
    FOnKeypress : TExtDomElementOnKeypress;
    FOnKeydown : TExtDomElementOnKeydown;
    FOnKeyup : TExtDomElementOnKeyup;
    FOnLoad : TExtDomElementOnLoad;
    FOnUnload : TExtDomElementOnUnload;
    FOnAbort : TExtDomElementOnAbort;
    FOnError : TExtDomElementOnError;
    FOnResize : TExtDomElementOnResize;
    FOnScroll : TExtDomElementOnScroll;
    FOnSelect : TExtDomElementOnSelect;
    FOnChange : TExtDomElementOnChange;
    FOnSubmit : TExtDomElementOnSubmit;
    FOnReset : TExtDomElementOnReset;
    FOnFocus : TExtDomElementOnFocus;
    FOnBlur : TExtDomElementOnBlur;
    FOnDOMFocusIn : TExtDomElementOnDOMFocusIn;
    FOnDOMFocusOut : TExtDomElementOnDOMFocusOut;
    FOnDOMActivate : TExtDomElementOnDOMActivate;
    FOnDOMSubtreeModified : TExtDomElementOnDOMSubtreeModified;
    FOnDOMNodeInserted : TExtDomElementOnDOMNodeInserted;
    FOnDOMNodeRemoved : TExtDomElementOnDOMNodeRemoved;
    FOnDOMNodeRemovedFromDocument : TExtDomElementOnDOMNodeRemovedFromDocument;
    FOnDOMNodeInsertedIntoDocument : TExtDomElementOnDOMNodeInsertedIntoDocument;
    FOnDOMAttrModified : TExtDomElementOnDOMAttrModified;
    FOnDOMCharacterDataModified : TExtDomElementOnDOMCharacterDataModified;
    procedure SetFAutoBoxAdjust(Value : Boolean);
    procedure SetFOnClick(Value : TExtDomElementOnClick);
    procedure SetFOnContextmenu(Value : TExtDomElementOnContextmenu);
    procedure SetFOnDblclick(Value : TExtDomElementOnDblclick);
    procedure SetFOnMousedown(Value : TExtDomElementOnMousedown);
    procedure SetFOnMouseup(Value : TExtDomElementOnMouseup);
    procedure SetFOnMouseover(Value : TExtDomElementOnMouseover);
    procedure SetFOnMousemove(Value : TExtDomElementOnMousemove);
    procedure SetFOnMouseout(Value : TExtDomElementOnMouseout);
    procedure SetFOnMouseenter(Value : TExtDomElementOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtDomElementOnMouseleave);
    procedure SetFOnKeypress(Value : TExtDomElementOnKeypress);
    procedure SetFOnKeydown(Value : TExtDomElementOnKeydown);
    procedure SetFOnKeyup(Value : TExtDomElementOnKeyup);
    procedure SetFOnLoad(Value : TExtDomElementOnLoad);
    procedure SetFOnUnload(Value : TExtDomElementOnUnload);
    procedure SetFOnAbort(Value : TExtDomElementOnAbort);
    procedure SetFOnError(Value : TExtDomElementOnError);
    procedure SetFOnResize(Value : TExtDomElementOnResize);
    procedure SetFOnScroll(Value : TExtDomElementOnScroll);
    procedure SetFOnSelect(Value : TExtDomElementOnSelect);
    procedure SetFOnChange(Value : TExtDomElementOnChange);
    procedure SetFOnSubmit(Value : TExtDomElementOnSubmit);
    procedure SetFOnReset(Value : TExtDomElementOnReset);
    procedure SetFOnFocus(Value : TExtDomElementOnFocus);
    procedure SetFOnBlur(Value : TExtDomElementOnBlur);
    procedure SetFOnDOMFocusIn(Value : TExtDomElementOnDOMFocusIn);
    procedure SetFOnDOMFocusOut(Value : TExtDomElementOnDOMFocusOut);
    procedure SetFOnDOMActivate(Value : TExtDomElementOnDOMActivate);
    procedure SetFOnDOMSubtreeModified(Value : TExtDomElementOnDOMSubtreeModified);
    procedure SetFOnDOMNodeInserted(Value : TExtDomElementOnDOMNodeInserted);
    procedure SetFOnDOMNodeRemoved(Value : TExtDomElementOnDOMNodeRemoved);
    procedure SetFOnDOMNodeRemovedFromDocument(Value : TExtDomElementOnDOMNodeRemovedFromDocument);
    procedure SetFOnDOMNodeInsertedIntoDocument(Value : TExtDomElementOnDOMNodeInsertedIntoDocument);
    procedure SetFOnDOMAttrModified(Value : TExtDomElementOnDOMAttrModified);
    procedure SetFOnDOMCharacterDataModified(Value : TExtDomElementOnDOMCharacterDataModified);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function On(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction;
    function Un(EventName : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function RemoveAllListeners : TExtFunction;
    function PurgeAllListeners : TExtFunction;
    function MonitorMouseLeave(Delay : Integer; Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function SwallowEvent(EventName : String; PreventDefault : Boolean = false) : TExtFunction; overload;
    function SwallowEvent(EventName : TExtObjectList; PreventDefault : Boolean = false) : TExtFunction; overload;
    function RelayEvent(EventName : String; Observable : TExtObject) : TExtFunction;
    function Clean(ForceReclean : Boolean = false) : TExtFunction;
    function Load : TExtFunction;
    function GetLoader : TExtFunction;
    function Update(Html : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction;
    function CreateProxy(Config : String; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : TExtObject; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : TExtObject; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : String; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; overload;
    function NeedsTabIndex : TExtFunction;
    property AutoBoxAdjust : Boolean read FAutoBoxAdjust write SetFAutoBoxAdjust;
    property OnClick : TExtDomElementOnClick read FOnClick write SetFOnClick;
    property OnContextmenu : TExtDomElementOnContextmenu read FOnContextmenu write SetFOnContextmenu;
    property OnDblclick : TExtDomElementOnDblclick read FOnDblclick write SetFOnDblclick;
    property OnMousedown : TExtDomElementOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseup : TExtDomElementOnMouseup read FOnMouseup write SetFOnMouseup;
    property OnMouseover : TExtDomElementOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMousemove : TExtDomElementOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseout : TExtDomElementOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseenter : TExtDomElementOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtDomElementOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnKeypress : TExtDomElementOnKeypress read FOnKeypress write SetFOnKeypress;
    property OnKeydown : TExtDomElementOnKeydown read FOnKeydown write SetFOnKeydown;
    property OnKeyup : TExtDomElementOnKeyup read FOnKeyup write SetFOnKeyup;
    property OnLoad : TExtDomElementOnLoad read FOnLoad write SetFOnLoad;
    property OnUnload : TExtDomElementOnUnload read FOnUnload write SetFOnUnload;
    property OnAbort : TExtDomElementOnAbort read FOnAbort write SetFOnAbort;
    property OnError : TExtDomElementOnError read FOnError write SetFOnError;
    property OnResize : TExtDomElementOnResize read FOnResize write SetFOnResize;
    property OnScroll : TExtDomElementOnScroll read FOnScroll write SetFOnScroll;
    property OnSelect : TExtDomElementOnSelect read FOnSelect write SetFOnSelect;
    property OnChange : TExtDomElementOnChange read FOnChange write SetFOnChange;
    property OnSubmit : TExtDomElementOnSubmit read FOnSubmit write SetFOnSubmit;
    property OnReset : TExtDomElementOnReset read FOnReset write SetFOnReset;
    property OnFocus : TExtDomElementOnFocus read FOnFocus write SetFOnFocus;
    property OnBlur : TExtDomElementOnBlur read FOnBlur write SetFOnBlur;
    property OnDOMFocusIn : TExtDomElementOnDOMFocusIn read FOnDOMFocusIn write SetFOnDOMFocusIn;
    property OnDOMFocusOut : TExtDomElementOnDOMFocusOut read FOnDOMFocusOut write SetFOnDOMFocusOut;
    property OnDOMActivate : TExtDomElementOnDOMActivate read FOnDOMActivate write SetFOnDOMActivate;
    property OnDOMSubtreeModified : TExtDomElementOnDOMSubtreeModified read FOnDOMSubtreeModified write SetFOnDOMSubtreeModified;
    property OnDOMNodeInserted : TExtDomElementOnDOMNodeInserted read FOnDOMNodeInserted write SetFOnDOMNodeInserted;
    property OnDOMNodeRemoved : TExtDomElementOnDOMNodeRemoved read FOnDOMNodeRemoved write SetFOnDOMNodeRemoved;
    property OnDOMNodeRemovedFromDocument : TExtDomElementOnDOMNodeRemovedFromDocument read FOnDOMNodeRemovedFromDocument write SetFOnDOMNodeRemovedFromDocument;
    property OnDOMNodeInsertedIntoDocument : TExtDomElementOnDOMNodeInsertedIntoDocument read FOnDOMNodeInsertedIntoDocument write SetFOnDOMNodeInsertedIntoDocument;
    property OnDOMAttrModified : TExtDomElementOnDOMAttrModified read FOnDOMAttrModified write SetFOnDOMAttrModified;
    property OnDOMCharacterDataModified : TExtDomElementOnDOMCharacterDataModified read FOnDOMCharacterDataModified write SetFOnDOMCharacterDataModified;
  end;

  TExtDrawColor = class(TExtUtilObservable)
  private
    FLightnessFactor : Integer; // 0
    procedure SetFLightnessFactor(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Red : Integer; Green : Integer; Blue : Integer); overload;
    function GetRed : TExtFunction;
    function GetGreen : TExtFunction;
    function GetBlue : TExtFunction;
    function GetRGB : TExtFunction;
    function GetHSL : TExtFunction;
    function GetLighter(Factor : Integer) : TExtFunction;
    function GetDarker(Factor : Integer) : TExtFunction;
    function ToString : TExtFunction;
    function ToHex(Color : String) : TExtFunction; overload;
    function ToHex(Color : TExtObjectList) : TExtFunction; overload;
    function FromString(Str : String) : TExtFunction;
    function GetGrayscale : TExtFunction;
    function FromHSL(H : Integer; S : Integer; L : Integer) : TExtFunction;
    property LightnessFactor : Integer read FLightnessFactor write SetFLightnessFactor;
  end;

  TExtDrawEngineSvgExporterSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction;
  end;

  TExtDrawEngineImageExporter = class(TExtUtilObservable)
  private
    FDefaultUrl : String;
    FSupportedTypes : TExtObjectList;
    FWidthParam : String;
    FHeightParam : String;
    FTypeParam : String;
    FSvgParam : String;
    procedure SetFDefaultUrl(Value : String);
    procedure SetFSupportedTypes(Value : TExtObjectList);
    procedure SetFWidthParam(Value : String);
    procedure SetFHeightParam(Value : String);
    procedure SetFTypeParam(Value : String);
    procedure SetFSvgParam(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Generate(Surface : TExtDrawSurface; Config : TExtObject = nil; ConfigWidth : Integer = 0; ConfigHeight : Integer = 0; ConfigUrl : String = ''; ConfigType : String = ''; ConfigWidthParam : String = ''; ConfigHeightParam : String = ''; ConfigTypeParam : String = ''; ConfigSvgParam : String = '') : TExtFunction;
    destructor Destroy; override;
    property DefaultUrl : String read FDefaultUrl write SetFDefaultUrl;
    property SupportedTypes : TExtObjectList read FSupportedTypes write SetFSupportedTypes;
    property WidthParam : String read FWidthParam write SetFWidthParam;
    property HeightParam : String read FHeightParam write SetFHeightParam;
    property TypeParam : String read FTypeParam write SetFTypeParam;
    property SvgParam : String read FSvgParam write SetFSvgParam;
  end;

  // Procedural types for events TExtDirectPollingProvider
  TExtDirectPollingProviderOnBeforepoll = procedure(This : TExtDirectPollingProvider) of object;
  TExtDirectPollingProviderOnPoll = procedure(This : TExtDirectPollingProvider) of object;

  TExtDirectPollingProvider = class(TExtUtilObservable)
  private
    FInterval : Integer; // 3
    FBaseParams : TExtObject;
    FUrl : String;
    FUrlTExtFunction : TExtFunction;
    FOnBeforepoll : TExtDirectPollingProviderOnBeforepoll;
    FOnPoll : TExtDirectPollingProviderOnPoll;
    procedure SetFInterval(Value : Integer);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFUrl(Value : String);
    procedure SetFUrlTExtFunction(Value : TExtFunction);
    procedure SetFOnBeforepoll(Value : TExtDirectPollingProviderOnBeforepoll);
    procedure SetFOnPoll(Value : TExtDirectPollingProviderOnPoll);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Connect : TExtFunction;
    function Disconnect : TExtFunction;
    destructor Destroy; override;
    property Interval : Integer read FInterval write SetFInterval;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property Url : String read FUrl write SetFUrl;
    property UrlTExtFunction : TExtFunction read FUrlTExtFunction write SetFUrlTExtFunction;
    property OnBeforepoll : TExtDirectPollingProviderOnBeforepoll read FOnBeforepoll write SetFOnBeforepoll;
    property OnPoll : TExtDirectPollingProviderOnPoll read FOnPoll write SetFOnPoll;
  end;

  // Procedural types for events TExtDirectManagerSingleton
  TExtDirectManagerSingletonOnEvent = procedure(E : TExtDirectEvent; Provider : TExtDirectProvider) of object;
  TExtDirectManagerSingletonOnException = procedure(E : TExtDirectEvent) of object;

  TExtDirectManagerSingleton = class(TExtUtilObservable)
  private
    FOnEvent : TExtDirectManagerSingletonOnEvent;
    FOnException : TExtDirectManagerSingletonOnException;
    procedure SetFOnEvent(Value : TExtDirectManagerSingletonOnEvent);
    procedure SetFOnException(Value : TExtDirectManagerSingletonOnException);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddProvider(Provider : TExtDirectProvider) : TExtFunction; overload;
    function AddProvider(Provider : TExtObjectList) : TExtFunction; overload;
    function GetProvider(Id : String) : TExtFunction; overload;
    function GetProvider(Id : TExtDirectProvider) : TExtFunction; overload;
    function RemoveProvider(Provider : String) : TExtFunction; overload;
    function RemoveProvider(Provider : TExtDirectProvider) : TExtFunction; overload;
    property OnEvent : TExtDirectManagerSingletonOnEvent read FOnEvent write SetFOnEvent;
    property OnException : TExtDirectManagerSingletonOnException read FOnException write SetFOnException;
  end;

  // Procedural types for events TExtDirectRemotingProvider
  TExtDirectRemotingProviderOnBeforecall = procedure(Provider : TExtDirectRemotingProvider; Transaction : TExtDirectTransaction; Meta : TExtObject) of object;
  TExtDirectRemotingProviderOnCall = procedure(Provider : TExtDirectRemotingProvider; Transaction : TExtDirectTransaction; Meta : TExtObject) of object;

  TExtDirectRemotingProvider = class(TExtUtilObservable)
  private
    FActions : TExtObject;
    FNamespace : String;
    FNamespaceTExtObject : TExtObject;
    FUrl : String;
    FEnableUrlEncode : String; // 'data'
    FEnableBuffer : Integer;
    FEnableBufferBoolean : Boolean;
    FMaxRetries : Integer;
    FTimeout : Integer;
    FOnBeforecall : TExtDirectRemotingProviderOnBeforecall;
    FOnCall : TExtDirectRemotingProviderOnCall;
    procedure SetFActions(Value : TExtObject);
    procedure SetFNamespace(Value : String);
    procedure SetFNamespaceTExtObject(Value : TExtObject);
    procedure SetFUrl(Value : String);
    procedure SetFEnableUrlEncode(Value : String);
    procedure SetFEnableBuffer(Value : Integer);
    procedure SetFEnableBufferBoolean(Value : Boolean);
    procedure SetFMaxRetries(Value : Integer);
    procedure SetFTimeout(Value : Integer);
    procedure SetFOnBeforecall(Value : TExtDirectRemotingProviderOnBeforecall);
    procedure SetFOnCall(Value : TExtDirectRemotingProviderOnCall);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Actions : TExtObject read FActions write SetFActions;
    property Namespace : String read FNamespace write SetFNamespace;
    property NamespaceTExtObject : TExtObject read FNamespaceTExtObject write SetFNamespaceTExtObject;
    property Url : String read FUrl write SetFUrl;
    property EnableUrlEncode : String read FEnableUrlEncode write SetFEnableUrlEncode;
    property EnableBuffer : Integer read FEnableBuffer write SetFEnableBuffer;
    property EnableBufferBoolean : Boolean read FEnableBufferBoolean write SetFEnableBufferBoolean;
    property MaxRetries : Integer read FMaxRetries write SetFMaxRetries;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property OnBeforecall : TExtDirectRemotingProviderOnBeforecall read FOnBeforecall write SetFOnBeforecall;
    property OnCall : TExtDirectRemotingProviderOnCall read FOnCall write SetFOnCall;
  end;

  TExtDomCompositeElementLite = class(TExtUtilObservable)
  private
    FElements : TExtObjectList;
    FIsComposite : Boolean;
    procedure SetFElements(Value : TExtObjectList);
    procedure SetFIsComposite(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetCount : TExtFunction;
    function Add(Els : TExtObjectList) : TExtFunction; overload;
    function Add(Els : TExtDomCompositeElement) : TExtFunction; overload;
    function Item(Index : Integer) : TExtFunction;
    function Each(Fn : TExtFunction; FnEl : TExtDomElement; FnC : TExtDomCompositeElement; FnIndex : Integer; Scope : TExtObject = nil) : TExtFunction;
    function Fill(Els : TExtObjectList) : TExtFunction; overload;
    function Fill(Els : TExtDomCompositeElement) : TExtFunction; overload;
    function Filter(Selector : String; SelectorEl : TExtDomElement; SelectorIndex : Integer) : TExtFunction; overload;
    function Filter(Selector : TExtFunction; SelectorEl : TExtDomElement; SelectorIndex : Integer) : TExtFunction; overload;
    function IndexOf(El : String) : TExtFunction; overload;
    function IndexOf(El : THTMLElement) : TExtFunction; overload;
    function IndexOf(El : TExtElement) : TExtFunction; overload;
    function IndexOf(El : Integer) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function Clear : TExtFunction;
    function First : TExtFunction;
    function Last : TExtFunction;
    function Contains(El : String) : TExtFunction; overload;
    function Contains(El : THTMLElement) : TExtFunction; overload;
    function Contains(El : TExtElement) : TExtFunction; overload;
    function Contains(El : Integer) : TExtFunction; overload;
    function RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; overload;
    destructor Destroy; override;
    property Elements : TExtObjectList read FElements write SetFElements;
    property IsComposite : Boolean read FIsComposite write SetFIsComposite;
  end;

  TExtDirectTransaction = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
  end;

  TExtGridFeatureAbstractSummary = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ToggleSummaryRow(Visible : Boolean) : TExtFunction;
    function GetColumnValue(Column : TExtGridColumn; Data : TExtObject) : TExtFunction;
  end;

  // Procedural types for events TExtUtilHashMap
  TExtUtilHashMapOnAdd = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject) of object;
  TExtUtilHashMapOnClear = procedure(This : TExtUtilHashMap) of object;
  TExtUtilHashMapOnRemove = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject) of object;
  TExtUtilHashMapOnReplace = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject; Old : TExtObject) of object;

  TExtUtilHashMap = class(TExtUtilObservable)
  private
    FKeyFn : TExtFunction;
    FOnAdd : TExtUtilHashMapOnAdd;
    FOnClear : TExtUtilHashMapOnClear;
    FOnRemove : TExtUtilHashMapOnRemove;
    FOnReplace : TExtUtilHashMapOnReplace;
    procedure SetFKeyFn(Value : TExtFunction);
    procedure SetFOnAdd(Value : TExtUtilHashMapOnAdd);
    procedure SetFOnClear(Value : TExtUtilHashMapOnClear);
    procedure SetFOnRemove(Value : TExtUtilHashMapOnRemove);
    procedure SetFOnReplace(Value : TExtUtilHashMapOnReplace);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCount : TExtFunction;
    function GetKey(O : TExtObject) : TExtFunction;
    function Add(Key : String; O : TExtObject = nil) : TExtFunction; overload;
    function Add(Key : TExtObject; O : TExtObject = nil) : TExtFunction; overload;
    function Replace(Key : String; Value : TExtObject) : TExtFunction;
    function Remove(O : TExtObject) : TExtFunction;
    function RemoveAtKey(Key : String) : TExtFunction;
    function Get(Key : String) : TExtFunction;
    function Clear : TExtFunction;
    function ContainsKey(Key : String) : TExtFunction;
    function Contains(Value : TExtObject) : TExtFunction;
    function GetKeys : TExtFunction;
    function GetValues : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Clone : TExtFunction;
    property KeyFn : TExtFunction read FKeyFn write SetFKeyFn;
    property OnAdd : TExtUtilHashMapOnAdd read FOnAdd write SetFOnAdd;
    property OnClear : TExtUtilHashMapOnClear read FOnClear write SetFOnClear;
    property OnRemove : TExtUtilHashMapOnRemove read FOnRemove write SetFOnRemove;
    property OnReplace : TExtUtilHashMapOnReplace read FOnReplace write SetFOnReplace;
  end;

  TExtUtilFloating = class(TExtUtilObservable)
  private
    FFocusOnToFront : Boolean;
    FShadow : String;
    FShadowBoolean : Boolean;
    FShadowOffset : String;
    FShadowOffsetBoolean : Boolean;
    procedure SetFFocusOnToFront(Value : Boolean);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFShadowOffset(Value : String);
    procedure SetFShadowOffsetBoolean(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function DoConstrain(ConstrainTo : String = '') : TExtFunction; overload;
    function DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; overload;
    function AlignTo(Element : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function AlignTo(Element : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function ToFront(PreventFocus : Boolean = false) : TExtFunction;
    function SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction;
    function ToBack : TExtFunction;
    function Center : TExtFunction;
    property FocusOnToFront : Boolean read FFocusOnToFront write SetFFocusOnToFront;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property ShadowOffset : String read FShadowOffset write SetFShadowOffset;
    property ShadowOffsetBoolean : Boolean read FShadowOffsetBoolean write SetFShadowOffsetBoolean;
  end;

  // Procedural types for events TExtUtilHistory
  TExtUtilHistoryOnReady = procedure(The : TExtUtilHistory) of object;
  TExtUtilHistoryOnChange = procedure(Token : String) of object;

  TExtUtilHistory = class(TExtUtilObservable)
  private
    FOnReady : TExtUtilHistoryOnReady;
    FOnChange : TExtUtilHistoryOnChange;
    procedure SetFOnReady(Value : TExtUtilHistoryOnReady);
    procedure SetFOnChange(Value : TExtUtilHistoryOnChange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Forward : TExtFunction;
    function GetToken : TExtFunction;
    property OnReady : TExtUtilHistoryOnReady read FOnReady write SetFOnReady;
    property OnChange : TExtUtilHistoryOnChange read FOnChange write SetFOnChange;
  end;

  TExtUtilKeyMap = class(TExtUtilObservable)
  private
    FTarget : TExtComponent;
    FTargetTExtElement : TExtElement;
    FTargetTHTMLElement : THTMLElement;
    FTargetString : String;
    FBinding : TExtObject;
    FBindingTExtObjectList : TExtObjectList;
    FProcessEventScope : TExtObject;
    FIgnoreInputFields : Boolean;
    FEventName : String;
    FProcessEvent : TExtFunction;
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetTExtElement(Value : TExtElement);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
    procedure SetFTargetString(Value : String);
    procedure SetFBinding(Value : TExtObject);
    procedure SetFBindingTExtObjectList(Value : TExtObjectList);
    procedure SetFProcessEventScope(Value : TExtObject);
    procedure SetFIgnoreInputFields(Value : Boolean);
    procedure SetFEventName(Value : String);
    procedure SetFProcessEvent(Value : TExtFunction);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function On(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function On(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function On(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function IsEnabled : TExtFunction;
    function Enable : TExtFunction;
    function Disable : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetTExtElement : TExtElement read FTargetTExtElement write SetFTargetTExtElement;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property Binding : TExtObject read FBinding write SetFBinding;
    property BindingTExtObjectList : TExtObjectList read FBindingTExtObjectList write SetFBindingTExtObjectList;
    property ProcessEventScope : TExtObject read FProcessEventScope write SetFProcessEventScope;
    property IgnoreInputFields : Boolean read FIgnoreInputFields write SetFIgnoreInputFields;
    property EventName : String read FEventName write SetFEventName;
    property ProcessEvent : TExtFunction read FProcessEvent write SetFProcessEvent;
  end;

  TExtUtilInflector = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Singular(Matcher : TRegExp; Replacer : String) : TExtFunction;
    function Plural(Matcher : TRegExp; Replacer : String) : TExtFunction;
    function ClearSingulars : TExtFunction;
    function ClearPlurals : TExtFunction;
    function IsTransnumeral(Word : String) : TExtFunction;
    function Pluralize(Word : String) : TExtFunction;
    function Singularize(Word : String) : TExtFunction;
    function Classify(Word : String) : TExtFunction;
    function Ordinalize(Number : Integer) : TExtFunction;
  end;

  TExtUtilClickRepeater = class(TExtUtilObservable)
  private
    FEl : String;
    FElTHTMLElement : THTMLElement;
    FElTExtElement : TExtElement;
    FPressedCls : String;
    FAccelerate : Boolean;
    FInterval : Integer;
    FDelay : Integer;
    FPreventDefault : Boolean;
    FStopDefault : Boolean;
    procedure SetFEl(Value : String);
    procedure SetFElTHTMLElement(Value : THTMLElement);
    procedure SetFElTExtElement(Value : TExtElement);
    procedure SetFPressedCls(Value : String);
    procedure SetFAccelerate(Value : Boolean);
    procedure SetFInterval(Value : Integer);
    procedure SetFDelay(Value : Integer);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopDefault(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Enable : TExtFunction;
    function Disable : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property El : String read FEl write SetFEl;
    property ElTHTMLElement : THTMLElement read FElTHTMLElement write SetFElTHTMLElement;
    property ElTExtElement : TExtElement read FElTExtElement write SetFElTExtElement;
    property PressedCls : String read FPressedCls write SetFPressedCls;
    property Accelerate : Boolean read FAccelerate write SetFAccelerate;
    property Interval : Integer read FInterval write SetFInterval;
    property Delay : Integer read FDelay write SetFDelay;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopDefault : Boolean read FStopDefault write SetFStopDefault;
  end;

  TExtUtilBindable = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : TExtDataAbstractStore = nil; Initial : Boolean = false) : TExtFunction; overload;
    function BindStore(Store : String; Initial : Boolean = false) : TExtFunction; overload;
    function GetStore : TExtFunction;
  end;

  TExtUtilCookies = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetJS(Name : String; Value : TExtObject; Expires : TExtObject = nil; Path : String = ''; Domain : String = ''; Secure : Boolean = false) : TExtFunction;
    function Get(Name : String) : TExtFunction;
    function Clear(Name : String; Path : String = '') : TExtFunction;
  end;

  TExtUtilFilter = class(TExtUtilObservable)
  private
    FPropertyJS : String;
    FFilterFn : TExtFunction;
    FAnyMatch : Boolean;
    FExactMatch : Boolean;
    FCaseSensitive : Boolean;
    FRoot : String;
    procedure SetFPropertyJS(Value : String);
    procedure SetFFilterFn(Value : TExtFunction);
    procedure SetFAnyMatch(Value : Boolean);
    procedure SetFExactMatch(Value : Boolean);
    procedure SetFCaseSensitive(Value : Boolean);
    procedure SetFRoot(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    property PropertyJS : String read FPropertyJS write SetFPropertyJS;
    property FilterFn : TExtFunction read FFilterFn write SetFFilterFn;
    property AnyMatch : Boolean read FAnyMatch write SetFAnyMatch;
    property ExactMatch : Boolean read FExactMatch write SetFExactMatch;
    property CaseSensitive : Boolean read FCaseSensitive write SetFCaseSensitive;
    property Root : String read FRoot write SetFRoot;
  end;

  TExtUtilCSSSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateStyleSheet(CssText : String; Id : String) : TExtFunction;
    function RemoveStyleSheet(Id : String) : TExtFunction;
    function SwapStyleSheet(Id : String; Url : String) : TExtFunction;
    function RefreshCache : TExtFunction;
    function GetRules(RefreshCache : Boolean) : TExtFunction;
    function GetRule(Selector : String; RefreshCache : Boolean) : TExtFunction; overload;
    function GetRule(Selector : TExtObjectList; RefreshCache : Boolean) : TExtFunction; overload;
    function UpdateRule(Selector : String; PropertyJS : String; Value : String) : TExtFunction; overload;
    function UpdateRule(Selector : TExtObjectList; PropertyJS : String; Value : String) : TExtFunction; overload;
  end;

  TExtUtilSorter = class(TExtUtilObservable)
  private
    FPropertyJS : String;
    FSorterFn : TExtFunction;
    FRoot : String;
    FTransform : TExtFunction;
    FDirection : String;
    procedure SetFPropertyJS(Value : String);
    procedure SetFSorterFn(Value : TExtFunction);
    procedure SetFRoot(Value : String);
    procedure SetFTransform(Value : TExtFunction);
    procedure SetFDirection(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetDirection(Direction : String) : TExtFunction;
    function Toggle : TExtFunction;
    function UpdateSortFunction(Fn : TExtFunction = nil) : TExtFunction;
    property PropertyJS : String read FPropertyJS write SetFPropertyJS;
    property SorterFn : TExtFunction read FSorterFn write SetFSorterFn;
    property Root : String read FRoot write SetFRoot;
    property Transform : TExtFunction read FTransform write SetFTransform;
    property Direction : String read FDirection write SetFDirection;
  end;

  TExtUtilSortable = class(TExtUtilObservable)
  private
    FIsSortable : Boolean;
    FDefaultSortDirection : String;
    FSortRoot : String;
    FSorters : TExtObjectList;
    procedure SetFIsSortable(Value : Boolean);
    procedure SetFDefaultSortDirection(Value : String);
    procedure SetFSortRoot(Value : String);
    procedure SetFSorters(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; overload;
    function Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; overload;
    function GenerateComparator : TExtFunction;
    destructor Destroy; override;
    property IsSortable : Boolean read FIsSortable write SetFIsSortable;
    property DefaultSortDirection : String read FDefaultSortDirection write SetFDefaultSortDirection;
    property SortRoot : String read FSortRoot write SetFSortRoot;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
  end;

  TExtUtilTaskRunner = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Stop(Task : TExtObject) : TExtFunction;
    function StopAll : TExtFunction;
  end;

  // Procedural types for events TExtView
  TExtViewOnBeforeitemmousedown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseup = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseenter = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseleave = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemdblclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemcontextmenu = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemkeydown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmousedown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseup = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseenter = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseleave = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemdblclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemcontextmenu = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemkeydown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermousedown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseup = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseover = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseout = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainerclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainerdblclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainercontextmenu = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainerkeydown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseup = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseover = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseout = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainerclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainerdblclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainercontextmenu = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainerkeydown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnHighlightitem = procedure(View : TExtView; Node : TExtElement) of object;
  TExtViewOnUnhighlightitem = procedure(View : TExtView; Node : TExtElement) of object;

  TExtView = class(TExtUtilObservable)
  private
    FOnBeforeitemmousedown : TExtViewOnBeforeitemmousedown;
    FOnBeforeitemmouseup : TExtViewOnBeforeitemmouseup;
    FOnBeforeitemmouseenter : TExtViewOnBeforeitemmouseenter;
    FOnBeforeitemmouseleave : TExtViewOnBeforeitemmouseleave;
    FOnBeforeitemclick : TExtViewOnBeforeitemclick;
    FOnBeforeitemdblclick : TExtViewOnBeforeitemdblclick;
    FOnBeforeitemcontextmenu : TExtViewOnBeforeitemcontextmenu;
    FOnBeforeitemkeydown : TExtViewOnBeforeitemkeydown;
    FOnItemmousedown : TExtViewOnItemmousedown;
    FOnItemmouseup : TExtViewOnItemmouseup;
    FOnItemmouseenter : TExtViewOnItemmouseenter;
    FOnItemmouseleave : TExtViewOnItemmouseleave;
    FOnItemclick : TExtViewOnItemclick;
    FOnItemdblclick : TExtViewOnItemdblclick;
    FOnItemcontextmenu : TExtViewOnItemcontextmenu;
    FOnItemkeydown : TExtViewOnItemkeydown;
    FOnBeforecontainermousedown : TExtViewOnBeforecontainermousedown;
    FOnBeforecontainermouseup : TExtViewOnBeforecontainermouseup;
    FOnBeforecontainermouseover : TExtViewOnBeforecontainermouseover;
    FOnBeforecontainermouseout : TExtViewOnBeforecontainermouseout;
    FOnBeforecontainerclick : TExtViewOnBeforecontainerclick;
    FOnBeforecontainerdblclick : TExtViewOnBeforecontainerdblclick;
    FOnBeforecontainercontextmenu : TExtViewOnBeforecontainercontextmenu;
    FOnBeforecontainerkeydown : TExtViewOnBeforecontainerkeydown;
    FOnContainermouseup : TExtViewOnContainermouseup;
    FOnContainermouseover : TExtViewOnContainermouseover;
    FOnContainermouseout : TExtViewOnContainermouseout;
    FOnContainerclick : TExtViewOnContainerclick;
    FOnContainerdblclick : TExtViewOnContainerdblclick;
    FOnContainercontextmenu : TExtViewOnContainercontextmenu;
    FOnContainerkeydown : TExtViewOnContainerkeydown;
    FOnHighlightitem : TExtViewOnHighlightitem;
    FOnUnhighlightitem : TExtViewOnUnhighlightitem;
    procedure SetFOnBeforeitemmousedown(Value : TExtViewOnBeforeitemmousedown);
    procedure SetFOnBeforeitemmouseup(Value : TExtViewOnBeforeitemmouseup);
    procedure SetFOnBeforeitemmouseenter(Value : TExtViewOnBeforeitemmouseenter);
    procedure SetFOnBeforeitemmouseleave(Value : TExtViewOnBeforeitemmouseleave);
    procedure SetFOnBeforeitemclick(Value : TExtViewOnBeforeitemclick);
    procedure SetFOnBeforeitemdblclick(Value : TExtViewOnBeforeitemdblclick);
    procedure SetFOnBeforeitemcontextmenu(Value : TExtViewOnBeforeitemcontextmenu);
    procedure SetFOnBeforeitemkeydown(Value : TExtViewOnBeforeitemkeydown);
    procedure SetFOnItemmousedown(Value : TExtViewOnItemmousedown);
    procedure SetFOnItemmouseup(Value : TExtViewOnItemmouseup);
    procedure SetFOnItemmouseenter(Value : TExtViewOnItemmouseenter);
    procedure SetFOnItemmouseleave(Value : TExtViewOnItemmouseleave);
    procedure SetFOnItemclick(Value : TExtViewOnItemclick);
    procedure SetFOnItemdblclick(Value : TExtViewOnItemdblclick);
    procedure SetFOnItemcontextmenu(Value : TExtViewOnItemcontextmenu);
    procedure SetFOnItemkeydown(Value : TExtViewOnItemkeydown);
    procedure SetFOnBeforecontainermousedown(Value : TExtViewOnBeforecontainermousedown);
    procedure SetFOnBeforecontainermouseup(Value : TExtViewOnBeforecontainermouseup);
    procedure SetFOnBeforecontainermouseover(Value : TExtViewOnBeforecontainermouseover);
    procedure SetFOnBeforecontainermouseout(Value : TExtViewOnBeforecontainermouseout);
    procedure SetFOnBeforecontainerclick(Value : TExtViewOnBeforecontainerclick);
    procedure SetFOnBeforecontainerdblclick(Value : TExtViewOnBeforecontainerdblclick);
    procedure SetFOnBeforecontainercontextmenu(Value : TExtViewOnBeforecontainercontextmenu);
    procedure SetFOnBeforecontainerkeydown(Value : TExtViewOnBeforecontainerkeydown);
    procedure SetFOnContainermouseup(Value : TExtViewOnContainermouseup);
    procedure SetFOnContainermouseover(Value : TExtViewOnContainermouseover);
    procedure SetFOnContainermouseout(Value : TExtViewOnContainermouseout);
    procedure SetFOnContainerclick(Value : TExtViewOnContainerclick);
    procedure SetFOnContainerdblclick(Value : TExtViewOnContainerdblclick);
    procedure SetFOnContainercontextmenu(Value : TExtViewOnContainercontextmenu);
    procedure SetFOnContainerkeydown(Value : TExtViewOnContainerkeydown);
    procedure SetFOnHighlightitem(Value : TExtViewOnHighlightitem);
    procedure SetFOnUnhighlightitem(Value : TExtViewOnUnhighlightitem);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function HighlightItem(Item : THTMLElement) : TExtFunction;
    function ClearHighlight : TExtFunction;
    property OnBeforeitemmousedown : TExtViewOnBeforeitemmousedown read FOnBeforeitemmousedown write SetFOnBeforeitemmousedown;
    property OnBeforeitemmouseup : TExtViewOnBeforeitemmouseup read FOnBeforeitemmouseup write SetFOnBeforeitemmouseup;
    property OnBeforeitemmouseenter : TExtViewOnBeforeitemmouseenter read FOnBeforeitemmouseenter write SetFOnBeforeitemmouseenter;
    property OnBeforeitemmouseleave : TExtViewOnBeforeitemmouseleave read FOnBeforeitemmouseleave write SetFOnBeforeitemmouseleave;
    property OnBeforeitemclick : TExtViewOnBeforeitemclick read FOnBeforeitemclick write SetFOnBeforeitemclick;
    property OnBeforeitemdblclick : TExtViewOnBeforeitemdblclick read FOnBeforeitemdblclick write SetFOnBeforeitemdblclick;
    property OnBeforeitemcontextmenu : TExtViewOnBeforeitemcontextmenu read FOnBeforeitemcontextmenu write SetFOnBeforeitemcontextmenu;
    property OnBeforeitemkeydown : TExtViewOnBeforeitemkeydown read FOnBeforeitemkeydown write SetFOnBeforeitemkeydown;
    property OnItemmousedown : TExtViewOnItemmousedown read FOnItemmousedown write SetFOnItemmousedown;
    property OnItemmouseup : TExtViewOnItemmouseup read FOnItemmouseup write SetFOnItemmouseup;
    property OnItemmouseenter : TExtViewOnItemmouseenter read FOnItemmouseenter write SetFOnItemmouseenter;
    property OnItemmouseleave : TExtViewOnItemmouseleave read FOnItemmouseleave write SetFOnItemmouseleave;
    property OnItemclick : TExtViewOnItemclick read FOnItemclick write SetFOnItemclick;
    property OnItemdblclick : TExtViewOnItemdblclick read FOnItemdblclick write SetFOnItemdblclick;
    property OnItemcontextmenu : TExtViewOnItemcontextmenu read FOnItemcontextmenu write SetFOnItemcontextmenu;
    property OnItemkeydown : TExtViewOnItemkeydown read FOnItemkeydown write SetFOnItemkeydown;
    property OnBeforecontainermousedown : TExtViewOnBeforecontainermousedown read FOnBeforecontainermousedown write SetFOnBeforecontainermousedown;
    property OnBeforecontainermouseup : TExtViewOnBeforecontainermouseup read FOnBeforecontainermouseup write SetFOnBeforecontainermouseup;
    property OnBeforecontainermouseover : TExtViewOnBeforecontainermouseover read FOnBeforecontainermouseover write SetFOnBeforecontainermouseover;
    property OnBeforecontainermouseout : TExtViewOnBeforecontainermouseout read FOnBeforecontainermouseout write SetFOnBeforecontainermouseout;
    property OnBeforecontainerclick : TExtViewOnBeforecontainerclick read FOnBeforecontainerclick write SetFOnBeforecontainerclick;
    property OnBeforecontainerdblclick : TExtViewOnBeforecontainerdblclick read FOnBeforecontainerdblclick write SetFOnBeforecontainerdblclick;
    property OnBeforecontainercontextmenu : TExtViewOnBeforecontainercontextmenu read FOnBeforecontainercontextmenu write SetFOnBeforecontainercontextmenu;
    property OnBeforecontainerkeydown : TExtViewOnBeforecontainerkeydown read FOnBeforecontainerkeydown write SetFOnBeforecontainerkeydown;
    property OnContainermouseup : TExtViewOnContainermouseup read FOnContainermouseup write SetFOnContainermouseup;
    property OnContainermouseover : TExtViewOnContainermouseover read FOnContainermouseover write SetFOnContainermouseover;
    property OnContainermouseout : TExtViewOnContainermouseout read FOnContainermouseout write SetFOnContainermouseout;
    property OnContainerclick : TExtViewOnContainerclick read FOnContainerclick write SetFOnContainerclick;
    property OnContainerdblclick : TExtViewOnContainerdblclick read FOnContainerdblclick write SetFOnContainerdblclick;
    property OnContainercontextmenu : TExtViewOnContainercontextmenu read FOnContainercontextmenu write SetFOnContainercontextmenu;
    property OnContainerkeydown : TExtViewOnContainerkeydown read FOnContainerkeydown write SetFOnContainerkeydown;
    property OnHighlightitem : TExtViewOnHighlightitem read FOnHighlightitem write SetFOnHighlightitem;
    property OnUnhighlightitem : TExtViewOnUnhighlightitem read FOnUnhighlightitem write SetFOnUnhighlightitem;
  end;

  TExtUtilTextMetrics = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Measure(El : String; Text : String; FixedWidth : Integer = 0) : TExtFunction; overload;
    function Measure(El : THTMLElement; Text : String; FixedWidth : Integer = 0) : TExtFunction; overload;
    constructor Create(BindTo : String; FixedWidth : Integer = 0); overload;
    constructor Create(BindTo : THTMLElement; FixedWidth : Integer = 0); overload;
    constructor Create(BindTo : TExtElement; FixedWidth : Integer = 0); overload;
    function GetSize(Text : String) : TExtFunction;
    function Bind(El : String) : TExtFunction; overload;
    function Bind(El : THTMLElement) : TExtFunction; overload;
    function Bind(El : TExtElement) : TExtFunction; overload;
    function SetFixedWidth(Width : Integer) : TExtFunction;
    function GetWidth(Text : String) : TExtFunction;
    function GetHeight(Text : String) : TExtFunction;
    function GetTextWidth(Text : String; Min : Integer = 0; Max : Integer = 0) : TExtFunction;
  end;

  TExtUtilMemento = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilKeyNav = class(TExtUtilObservable)
  private
    FDisabled : Boolean;
    FDefaultEventAction : String;
    FForceKeyDown : Boolean;
    FTarget : TExtComponent;
    FTargetTExtElement : TExtElement;
    FTargetTHTMLElement : THTMLElement;
    FTargetString : String;
    FEventName : String;
    FProcessEvent : TExtFunction;
    FProcessEventScope : TExtObject;
    FIgnoreInputFields : Boolean;
    procedure SetFDisabled(Value : Boolean);
    procedure SetFDefaultEventAction(Value : String);
    procedure SetFForceKeyDown(Value : Boolean);
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetTExtElement(Value : TExtElement);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
    procedure SetFTargetString(Value : String);
    procedure SetFEventName(Value : String);
    procedure SetFProcessEvent(Value : TExtFunction);
    procedure SetFProcessEventScope(Value : TExtObject);
    procedure SetFIgnoreInputFields(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Enable : TExtFunction;
    function Disable : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property DefaultEventAction : String read FDefaultEventAction write SetFDefaultEventAction;
    property ForceKeyDown : Boolean read FForceKeyDown write SetFForceKeyDown;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetTExtElement : TExtElement read FTargetTExtElement write SetFTargetTExtElement;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property EventName : String read FEventName write SetFEventName;
    property ProcessEvent : TExtFunction read FProcessEvent write SetFProcessEvent;
    property ProcessEventScope : TExtObject read FProcessEventScope write SetFProcessEventScope;
    property IgnoreInputFields : Boolean read FIgnoreInputFields write SetFIgnoreInputFields;
  end;

  TExtUtilMixedCollection = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(AllowFunctions : Boolean; KeyFn : TExtFunction);
    function SortBy(SorterFn : TExtFunction) : TExtFunction;
    function FindInsertionIndex(NewItem : TExtObject; SorterFn : TExtFunction = nil) : TExtFunction;
    function Reorder(Mapping : TExtObject) : TExtFunction;
    function SortByKey(Direction : String = ''; Fn : TExtFunction = nil) : TExtFunction;
  end;

  TExtUtilRegion = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetRegion(El : String) : TExtFunction; overload;
    function GetRegion(El : THTMLElement) : TExtFunction; overload;
    function GetRegion(El : TExtElement) : TExtFunction; overload;
    function From(O : TExtObject) : TExtFunction;
    constructor Create(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer);
    function Contains(Region : TExtUtilRegion) : TExtFunction;
    function Intersect(Region : TExtUtilRegion) : TExtFunction;
    function Union(Region : TExtUtilRegion) : TExtFunction;
    function ConstrainTo(TargetRegion : TExtUtilRegion) : TExtFunction;
    function Adjust(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer) : TExtFunction;
    function GetOutOfBoundOffset(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction;
    function GetOutOfBoundOffsetX(P : Integer) : TExtFunction;
    function GetOutOfBoundOffsetY(P : Integer) : TExtFunction;
    function IsOutOfBound(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction; overload;
    function IsOutOfBound(Axis : String; P : Integer) : TExtFunction; overload;
    function IsOutOfBoundX(P : Integer) : TExtFunction;
    function IsOutOfBoundY(P : Integer) : TExtFunction;
    function Copy : TExtFunction;
    function CopyFrom(P : TExtUtilRegion) : TExtFunction;
    function TranslateBy(X : TExtUtilOffset; Y : Integer) : TExtFunction; overload;
    function TranslateBy(X : TExtObject; Y : Integer) : TExtFunction; overload;
    function Round : TExtFunction;
    function Equals(Region : TExtUtilRegion) : TExtFunction;
  end;

  TExtUtilProtoElement = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayout = class(TExtUtilObservable)
  private
    FIsLayout : Boolean;
    FDone : Boolean;
    FName : String;
    FAuto : Boolean;
    FCalculated : Boolean;
    FConfigured : Boolean;
    FConstrainedMax : Boolean;
    FConstrainedMin : Boolean;
    FFixed : Boolean;
    FNatural : Boolean;
    FShrinkWrap : Boolean;
    FCalculatedFromConfigured : Boolean;
    FCalculatedFromNatural : Boolean;
    FCalculatedFromShrinkWrap : Boolean;
    FNames : TExtObject;
    FPairsByHeightOrdinal : TExtObjectList;
    procedure SetFIsLayout(Value : Boolean);
    procedure SetFDone(Value : Boolean);
    procedure SetFName(Value : String);
    procedure SetFAuto(Value : Boolean);
    procedure SetFCalculated(Value : Boolean);
    procedure SetFConfigured(Value : Boolean);
    procedure SetFConstrainedMax(Value : Boolean);
    procedure SetFConstrainedMin(Value : Boolean);
    procedure SetFFixed(Value : Boolean);
    procedure SetFNatural(Value : Boolean);
    procedure SetFShrinkWrap(Value : Boolean);
    procedure SetFCalculatedFromConfigured(Value : Boolean);
    procedure SetFCalculatedFromNatural(Value : Boolean);
    procedure SetFCalculatedFromShrinkWrap(Value : Boolean);
    procedure SetFNames(Value : TExtObject);
    procedure SetFPairsByHeightOrdinal(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property IsLayout : Boolean read FIsLayout write SetFIsLayout;
    property Done : Boolean read FDone write SetFDone;
    property Name : String read FName write SetFName;
    property Auto : Boolean read FAuto write SetFAuto;
    property Calculated : Boolean read FCalculated write SetFCalculated;
    property Configured : Boolean read FConfigured write SetFConfigured;
    property ConstrainedMax : Boolean read FConstrainedMax write SetFConstrainedMax;
    property ConstrainedMin : Boolean read FConstrainedMin write SetFConstrainedMin;
    property Fixed : Boolean read FFixed write SetFFixed;
    property Natural : Boolean read FNatural write SetFNatural;
    property ShrinkWrap : Boolean read FShrinkWrap write SetFShrinkWrap;
    property CalculatedFromConfigured : Boolean read FCalculatedFromConfigured write SetFCalculatedFromConfigured;
    property CalculatedFromNatural : Boolean read FCalculatedFromNatural write SetFCalculatedFromNatural;
    property CalculatedFromShrinkWrap : Boolean read FCalculatedFromShrinkWrap write SetFCalculatedFromShrinkWrap;
    property Names : TExtObject read FNames write SetFNames;
    property PairsByHeightOrdinal : TExtObjectList read FPairsByHeightOrdinal write SetFPairsByHeightOrdinal;
  end;

  TExtLayer = class(TExtUtilObservable)
  private
    FShim : Boolean;
    FShadow : String;
    FShadowBoolean : Boolean;
    FDh : TExtObject;
    FConstrain : Boolean;
    FCls : String;
    FZindex : Integer;
    FShadowOffset : Integer;
    FUseDisplay : Boolean;
    FVisibilityCls : String;
    FHideMode : String;
    procedure SetFShim(Value : Boolean);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFDh(Value : TExtObject);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFCls(Value : String);
    procedure SetFZindex(Value : Integer);
    procedure SetFShadowOffset(Value : Integer);
    procedure SetFUseDisplay(Value : Boolean);
    procedure SetFVisibilityCls(Value : String);
    procedure SetFHideMode(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil; ExistingEl : String = ''); overload;
    constructor Create(Config : TExtObject; ExistingEl : THTMLElement); overload;
    function SetZIndex(Zindex : Integer) : TExtFunction;
    destructor Destroy; override;
    property Shim : Boolean read FShim write SetFShim;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property Dh : TExtObject read FDh write SetFDh;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Cls : String read FCls write SetFCls;
    property Zindex : Integer read FZindex write SetFZindex;
    property ShadowOffset : Integer read FShadowOffset write SetFShadowOffset;
    property UseDisplay : Boolean read FUseDisplay write SetFUseDisplay;
    property VisibilityCls : String read FVisibilityCls write SetFVisibilityCls;
    property HideMode : String read FHideMode write SetFHideMode;
  end;

  TExtLayoutClassList = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtMenuManagerSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function HideAll : TExtFunction;
    function Get(Menu : String) : TExtFunction; overload;
    function Get(Menu : TExtObject) : TExtFunction; overload;
  end;

  TExtViewTableChunker = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridFeatureGrouping = class(TExtUtilObservable)
  private
    FGroupHeaderTpl : String;
    FGroupHeaderTplTExtObjectList : TExtObjectList;
    FGroupHeaderTplTExtTemplate : TExtTemplate;
    FDepthToIndent : Integer;
    FGroupByText : String;
    FShowGroupsText : String;
    FHideGroupedHeader : Boolean;
    FStartCollapsed : Boolean;
    FEnableGroupingMenu : Boolean;
    FEnableNoGroups : Boolean;
    FCollapsible : Boolean;
    procedure SetFGroupHeaderTpl(Value : String);
    procedure SetFGroupHeaderTplTExtObjectList(Value : TExtObjectList);
    procedure SetFGroupHeaderTplTExtTemplate(Value : TExtTemplate);
    procedure SetFDepthToIndent(Value : Integer);
    procedure SetFGroupByText(Value : String);
    procedure SetFShowGroupsText(Value : String);
    procedure SetFHideGroupedHeader(Value : Boolean);
    procedure SetFStartCollapsed(Value : Boolean);
    procedure SetFEnableGroupingMenu(Value : Boolean);
    procedure SetFEnableNoGroups(Value : Boolean);
    procedure SetFCollapsible(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function IsExpanded(GroupName : String) : TExtFunction;
    function Expand(GroupName : String; Focus : Boolean) : TExtFunction; overload;
    function Expand(GroupName : TExtElement; Focus : Boolean) : TExtFunction; overload;
    function ExpandAll : TExtFunction;
    function Collapse(GroupName : String; Focus : Boolean) : TExtFunction; overload;
    function Collapse(GroupName : TExtElement; Focus : Boolean) : TExtFunction; overload;
    function CollapseAll : TExtFunction;
    destructor Destroy; override;
    property GroupHeaderTpl : String read FGroupHeaderTpl write SetFGroupHeaderTpl;
    property GroupHeaderTplTExtObjectList : TExtObjectList read FGroupHeaderTplTExtObjectList write SetFGroupHeaderTplTExtObjectList;
    property GroupHeaderTplTExtTemplate : TExtTemplate read FGroupHeaderTplTExtTemplate write SetFGroupHeaderTplTExtTemplate;
    property DepthToIndent : Integer read FDepthToIndent write SetFDepthToIndent;
    property GroupByText : String read FGroupByText write SetFGroupByText;
    property ShowGroupsText : String read FShowGroupsText write SetFShowGroupsText;
    property HideGroupedHeader : Boolean read FHideGroupedHeader write SetFHideGroupedHeader;
    property StartCollapsed : Boolean read FStartCollapsed write SetFStartCollapsed;
    property EnableGroupingMenu : Boolean read FEnableGroupingMenu write SetFEnableGroupingMenu;
    property EnableNoGroups : Boolean read FEnableNoGroups write SetFEnableNoGroups;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
  end;

  TExtGridFeatureChunking = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridFeatureRowBody = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetAdditionalData(Data : TExtObject; Idx : Integer; RecordJS : TExtDataModel; Orig : TExtObject) : TExtFunction;
  end;

  TExtGridScroller = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPagingScroller = class(TExtUtilObservable)
  private
    FPosition : Integer;
    procedure SetFPosition(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Position : Integer read FPosition write SetFPosition;
  end;

  // Procedural types for events TExtStateStateful
  TExtStateStatefulOnBeforestaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnStaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnBeforestatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnStatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;

  TExtStateStateful = class(TExtUtilObservable)
  private
    FStateful : Boolean;
    FStateId : String;
    FStateEvents : TExtObjectList;
    FSaveDelay : Integer;
    FOnBeforestaterestore : TExtStateStatefulOnBeforestaterestore;
    FOnStaterestore : TExtStateStatefulOnStaterestore;
    FOnBeforestatesave : TExtStateStatefulOnBeforestatesave;
    FOnStatesave : TExtStateStatefulOnStatesave;
    procedure SetFStateful(Value : Boolean);
    procedure SetFStateId(Value : String);
    procedure SetFStateEvents(Value : TExtObjectList);
    procedure SetFSaveDelay(Value : Integer);
    procedure SetFOnBeforestaterestore(Value : TExtStateStatefulOnBeforestaterestore);
    procedure SetFOnStaterestore(Value : TExtStateStatefulOnStaterestore);
    procedure SetFOnBeforestatesave(Value : TExtStateStatefulOnBeforestatesave);
    procedure SetFOnStatesave(Value : TExtStateStatefulOnStatesave);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SaveState : TExtFunction;
    function GetState : TExtFunction;
    function ApplyState(State : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Stateful : Boolean read FStateful write SetFStateful;
    property StateId : String read FStateId write SetFStateId;
    property StateEvents : TExtObjectList read FStateEvents write SetFStateEvents;
    property SaveDelay : Integer read FSaveDelay write SetFSaveDelay;
    property OnBeforestaterestore : TExtStateStatefulOnBeforestaterestore read FOnBeforestaterestore write SetFOnBeforestaterestore;
    property OnStaterestore : TExtStateStatefulOnStaterestore read FOnStaterestore write SetFOnStaterestore;
    property OnBeforestatesave : TExtStateStatefulOnBeforestatesave read FOnBeforestatesave write SetFOnBeforestatesave;
    property OnStatesave : TExtStateStatefulOnStatesave read FOnStatesave write SetFOnStatesave;
  end;

  TExtStateProvider = class(TExtUtilObservable)
  private
    FPrefix : String; // 'ext-'
    procedure SetFPrefix(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Get(Name : String; DefaultValue : TExtObject) : TExtFunction;
    function Clear(Name : String) : TExtFunction;
    function SetJS(Name : String; Value : TExtObject) : TExtFunction;
    function DecodeValue(Value : String) : TExtFunction;
    function EncodeValue(Value : TExtObject) : TExtFunction;
    property Prefix : String read FPrefix write SetFPrefix;
  end;

  TExtTemplate = class(TExtUtilObservable)
  private
    FCompiled : Boolean;
    FDisableFormats : Boolean;
    procedure SetFCompiled(Value : Boolean);
    procedure SetFDisableFormats(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Apply(Values : TExtObject) : TExtFunction; overload;
    function Apply(Values : TExtObjectList) : TExtFunction; overload;
    function ApplyOut(Values : TExtObject; OutJS : TExtObjectList) : TExtFunction; overload;
    function ApplyOut(Values : TExtObjectList; OutJS : TExtObjectList) : TExtFunction; overload;
    function Compile : TExtFunction;
    function InsertFirst(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    property Compiled : Boolean read FCompiled write SetFCompiled;
    property DisableFormats : Boolean read FDisableFormats write SetFDisableFormats;
  end;

  TExtUtilAnimate = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Animate(Config : TExtObject) : TExtFunction;
    function SyncFx : TExtFunction;
    function SequenceFx : TExtFunction;
  end;

  TExtTipQuickTipManagerSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Enable : TExtFunction;
    function Disable : TExtFunction;
    function IsEnabled : TExtFunction;
    function GetQuickTip : TExtFunction;
    function Register(Config : TExtObject) : TExtFunction;
    function Unregister(El : String) : TExtFunction; overload;
    function Unregister(El : THTMLElement) : TExtFunction; overload;
    function Unregister(El : TExtElement) : TExtFunction; overload;
    function Tips : TExtFunction;
  end;

  TExtResizer = class(TExtUtilObservable)
  private
    FDynamic : Boolean;
    FHandles : String; // 's e se'
    FHeight : Integer;
    FWidth : Integer;
    FHeightIncrement : Integer;
    FWidthIncrement : Integer;
    FMinHeight : Integer;
    FMinWidth : Integer;
    FMaxHeight : Integer;
    FMaxWidth : Integer;
    FPinned : Boolean;
    FPreserveRatio : Boolean;
    FTransparent : Boolean;
    FConstrainTo : TExtElement;
    FConstrainToTExtUtilRegion : TExtUtilRegion;
    FTarget : TExtElement;
    FTargetTExtComponent : TExtComponent;
    FEl : TExtElement;
    FOriginalTarget : TExtElement;
    FOriginalTargetTExtComponent : TExtComponent;
    FResizeTracker : TExtResizerResizeTracker;
    procedure SetFDynamic(Value : Boolean);
    procedure SetFHandles(Value : String);
    procedure SetFHeight(Value : Integer);
    procedure SetFWidth(Value : Integer);
    procedure SetFHeightIncrement(Value : Integer);
    procedure SetFWidthIncrement(Value : Integer);
    procedure SetFMinHeight(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFMaxHeight(Value : Integer);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFPinned(Value : Boolean);
    procedure SetFPreserveRatio(Value : Boolean);
    procedure SetFTransparent(Value : Boolean);
    procedure SetFConstrainTo(Value : TExtElement);
    procedure SetFConstrainToTExtUtilRegion(Value : TExtUtilRegion);
    procedure SetFTarget(Value : TExtElement);
    procedure SetFTargetTExtComponent(Value : TExtComponent);
    procedure SetFEl(Value : TExtElement);
    procedure SetFOriginalTarget(Value : TExtElement);
    procedure SetFOriginalTargetTExtComponent(Value : TExtComponent);
    procedure SetFResizeTracker(Value : TExtResizerResizeTracker);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ResizeTo(Width : Integer; Height : Integer) : TExtFunction;
    function GetEl : TExtFunction;
    function GetTarget : TExtFunction;
    destructor Destroy; override;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property Handles : String read FHandles write SetFHandles;
    property Height : Integer read FHeight write SetFHeight;
    property Width : Integer read FWidth write SetFWidth;
    property HeightIncrement : Integer read FHeightIncrement write SetFHeightIncrement;
    property WidthIncrement : Integer read FWidthIncrement write SetFWidthIncrement;
    property MinHeight : Integer read FMinHeight write SetFMinHeight;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property MaxHeight : Integer read FMaxHeight write SetFMaxHeight;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property Pinned : Boolean read FPinned write SetFPinned;
    property PreserveRatio : Boolean read FPreserveRatio write SetFPreserveRatio;
    property Transparent : Boolean read FTransparent write SetFTransparent;
    property ConstrainTo : TExtElement read FConstrainTo write SetFConstrainTo;
    property ConstrainToTExtUtilRegion : TExtUtilRegion read FConstrainToTExtUtilRegion write SetFConstrainToTExtUtilRegion;
    property Target : TExtElement read FTarget write SetFTarget;
    property TargetTExtComponent : TExtComponent read FTargetTExtComponent write SetFTargetTExtComponent;
    property El : TExtElement read FEl write SetFEl;
    property OriginalTarget : TExtElement read FOriginalTarget write SetFOriginalTarget;
    property OriginalTargetTExtComponent : TExtComponent read FOriginalTargetTExtComponent write SetFOriginalTargetTExtComponent;
    property ResizeTracker : TExtResizerResizeTracker read FResizeTracker write SetFResizeTracker;
  end;

  TExtPanel = class(TExtUtilObservable)
  private
    FCollapsedCls : String;
    FAnimCollapse : Boolean;
    FMinButtonWidth : Integer;
    FCollapsed : Boolean;
    FCollapseFirst : Boolean;
    FHideCollapseTool : Boolean;
    FTitleCollapse : Boolean;
    FCollapseMode : String;
    FPlaceholder : TExtComponent;
    FPlaceholderTExtObject : TExtObject;
    FFloatable : Boolean;
    FOverlapHeader : Boolean;
    FCollapsible : Boolean;
    FCollapseDirection : String;
    FClosable : Boolean;
    FCloseAction : String;
    FDockedItems : TExtObject;
    FDockedItemsTExtObjectList : TExtObjectList;
    FPlaceholderCollapseHideMode : Integer;
    FPreventHeader : Boolean;
    FHeader : Boolean;
    FHeaderTExtObject : TExtObject;
    FHeaderPosition : String;
    FFrame : Boolean;
    FFrameHeader : Boolean;
    FTools : TExtObjectList;
    FToolsTExtObjectList : TExtObjectList;
    FTitle : String;
    FTitleAlign : String;
    FManageHeight : Boolean;
    FIconCls : String;
    FIcon : String;
    FButtonAlign : String;
    FTbar : TExtObject;
    FTbarTExtObjectList : TExtObjectList;
    FBbar : TExtObject;
    FBbarTExtObjectList : TExtObjectList;
    FButtons : TExtObject;
    FButtonsTExtObjectList : TExtObjectList;
    FFbar : TExtObject;
    FFbarTExtObjectList : TExtObjectList;
    FLbar : TExtObject;
    FLbarTExtObjectList : TExtObjectList;
    FRbar : TExtObject;
    FRbarTExtObjectList : TExtObjectList;
    FDd : TExtDdDragSource;
    procedure SetFCollapsedCls(Value : String);
    procedure SetFAnimCollapse(Value : Boolean);
    procedure SetFMinButtonWidth(Value : Integer);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFCollapseFirst(Value : Boolean);
    procedure SetFHideCollapseTool(Value : Boolean);
    procedure SetFTitleCollapse(Value : Boolean);
    procedure SetFCollapseMode(Value : String);
    procedure SetFPlaceholder(Value : TExtComponent);
    procedure SetFPlaceholderTExtObject(Value : TExtObject);
    procedure SetFFloatable(Value : Boolean);
    procedure SetFOverlapHeader(Value : Boolean);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFCollapseDirection(Value : String);
    procedure SetFClosable(Value : Boolean);
    procedure SetFCloseAction(Value : String);
    procedure SetFDockedItems(Value : TExtObject);
    procedure SetFDockedItemsTExtObjectList(Value : TExtObjectList);
    procedure SetFPlaceholderCollapseHideMode(Value : Integer);
    procedure SetFPreventHeader(Value : Boolean);
    procedure SetFHeader(Value : Boolean);
    procedure SetFHeaderTExtObject(Value : TExtObject);
    procedure SetFHeaderPosition(Value : String);
    procedure SetFFrame(Value : Boolean);
    procedure SetFFrameHeader(Value : Boolean);
    procedure SetFTools(Value : TExtObjectList);
    procedure SetFToolsTExtObjectList(Value : TExtObjectList);
    procedure SetFTitle(Value : String);
    procedure SetFTitleAlign(Value : String);
    procedure SetFManageHeight(Value : Boolean);
    procedure SetFIconCls(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFButtonAlign(Value : String);
    procedure SetFTbar(Value : TExtObject);
    procedure SetFTbarTExtObjectList(Value : TExtObjectList);
    procedure SetFBbar(Value : TExtObject);
    procedure SetFBbarTExtObjectList(Value : TExtObjectList);
    procedure SetFButtons(Value : TExtObject);
    procedure SetFButtonsTExtObjectList(Value : TExtObjectList);
    procedure SetFFbar(Value : TExtObject);
    procedure SetFFbarTExtObjectList(Value : TExtObjectList);
    procedure SetFLbar(Value : TExtObject);
    procedure SetFLbarTExtObjectList(Value : TExtObjectList);
    procedure SetFRbar(Value : TExtObject);
    procedure SetFRbarTExtObjectList(Value : TExtObjectList);
    procedure SetFDd(Value : TExtDdDragSource);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property CollapsedCls : String read FCollapsedCls write SetFCollapsedCls;
    property AnimCollapse : Boolean read FAnimCollapse write SetFAnimCollapse;
    property MinButtonWidth : Integer read FMinButtonWidth write SetFMinButtonWidth;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property CollapseFirst : Boolean read FCollapseFirst write SetFCollapseFirst;
    property HideCollapseTool : Boolean read FHideCollapseTool write SetFHideCollapseTool;
    property TitleCollapse : Boolean read FTitleCollapse write SetFTitleCollapse;
    property CollapseMode : String read FCollapseMode write SetFCollapseMode;
    property Placeholder : TExtComponent read FPlaceholder write SetFPlaceholder;
    property PlaceholderTExtObject : TExtObject read FPlaceholderTExtObject write SetFPlaceholderTExtObject;
    property Floatable : Boolean read FFloatable write SetFFloatable;
    property OverlapHeader : Boolean read FOverlapHeader write SetFOverlapHeader;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property CollapseDirection : String read FCollapseDirection write SetFCollapseDirection;
    property Closable : Boolean read FClosable write SetFClosable;
    property CloseAction : String read FCloseAction write SetFCloseAction;
    property DockedItems : TExtObject read FDockedItems write SetFDockedItems;
    property DockedItemsTExtObjectList : TExtObjectList read FDockedItemsTExtObjectList write SetFDockedItemsTExtObjectList;
    property PlaceholderCollapseHideMode : Integer read FPlaceholderCollapseHideMode write SetFPlaceholderCollapseHideMode;
    property PreventHeader : Boolean read FPreventHeader write SetFPreventHeader;
    property Header : Boolean read FHeader write SetFHeader;
    property HeaderTExtObject : TExtObject read FHeaderTExtObject write SetFHeaderTExtObject;
    property HeaderPosition : String read FHeaderPosition write SetFHeaderPosition;
    property Frame : Boolean read FFrame write SetFFrame;
    property FrameHeader : Boolean read FFrameHeader write SetFFrameHeader;
    property Tools : TExtObjectList read FTools write SetFTools;
    property ToolsTExtObjectList : TExtObjectList read FToolsTExtObjectList write SetFToolsTExtObjectList;
    property Title : String read FTitle write SetFTitle;
    property TitleAlign : String read FTitleAlign write SetFTitleAlign;
    property ManageHeight : Boolean read FManageHeight write SetFManageHeight;
    property IconCls : String read FIconCls write SetFIconCls;
    property Icon : String read FIcon write SetFIcon;
    property ButtonAlign : String read FButtonAlign write SetFButtonAlign;
    property Tbar : TExtObject read FTbar write SetFTbar;
    property TbarTExtObjectList : TExtObjectList read FTbarTExtObjectList write SetFTbarTExtObjectList;
    property Bbar : TExtObject read FBbar write SetFBbar;
    property BbarTExtObjectList : TExtObjectList read FBbarTExtObjectList write SetFBbarTExtObjectList;
    property Buttons : TExtObject read FButtons write SetFButtons;
    property ButtonsTExtObjectList : TExtObjectList read FButtonsTExtObjectList write SetFButtonsTExtObjectList;
    property Fbar : TExtObject read FFbar write SetFFbar;
    property FbarTExtObjectList : TExtObjectList read FFbarTExtObjectList write SetFFbarTExtObjectList;
    property Lbar : TExtObject read FLbar write SetFLbar;
    property LbarTExtObjectList : TExtObjectList read FLbarTExtObjectList write SetFLbarTExtObjectList;
    property Rbar : TExtObject read FRbar write SetFRbar;
    property RbarTExtObjectList : TExtObjectList read FRbarTExtObjectList write SetFRbarTExtObjectList;
    property Dd : TExtDdDragSource read FDd write SetFDd;
  end;

  TExtSelectionModel = class(TExtUtilObservable)
  private
    FMode : String;
    FAllowDeselect : Boolean;
    FPruneRemoved : Boolean;
    procedure SetFMode(Value : String);
    procedure SetFAllowDeselect(Value : Boolean);
    procedure SetFPruneRemoved(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SelectAll(SuppressEvent : Boolean) : TExtFunction;
    function DeselectAll(SuppressEvent : Boolean) : TExtFunction;
    function SelectRange(StartRow : TExtDataModel; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : Integer; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : Integer; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : TExtDataModel; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; overload;
    function Select(Records : TExtObjectList; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function Select(Records : Integer; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function Deselect(Records : TExtObjectList; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function Deselect(Records : Integer; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function SetLastFocused(RecordJS : TExtDataModel) : TExtFunction;
    function IsFocused(RecordJS : TExtDataModel) : TExtFunction;
    function GetLastSelected : TExtFunction;
    function GetSelection : TExtFunction;
    function GetSelectionMode : TExtFunction;
    function SetSelectionMode(SelMode : String) : TExtFunction;
    function IsLocked : TExtFunction;
    function SetLocked(Locked : Boolean) : TExtFunction;
    function IsSelected(RecordJS : TExtDataModel) : TExtFunction; overload;
    function IsSelected(RecordJS : Integer) : TExtFunction; overload;
    function HasSelection : TExtFunction;
    function GetCount : TExtFunction;
    property Mode : String read FMode write SetFMode;
    property AllowDeselect : Boolean read FAllowDeselect write SetFAllowDeselect;
    property PruneRemoved : Boolean read FPruneRemoved write SetFPruneRemoved;
  end;

  TExtStateManagerSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetProvider(StateProvider : TExtStateProvider) : TExtFunction;
    function Get(Name : String; DefaultValue : TExtObject) : TExtFunction;
    function SetJS(Name : String; Value : TExtObject) : TExtFunction;
    function Clear(Name : String) : TExtFunction;
    function GetProvider : TExtFunction;
  end;

  TExtShadow = class(TExtUtilObservable)
  private
    FMode : String;
    FOffset : Integer;
    procedure SetFMode(Value : String);
    procedure SetFOffset(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Show(TargetEl : String) : TExtFunction; overload;
    function Show(TargetEl : THTMLElement) : TExtFunction; overload;
    function Show(TargetEl : TExtElement) : TExtFunction; overload;
    function IsVisible : TExtFunction;
    function Realign(Left : Integer; Top : Integer; Width : Integer; Height : Integer) : TExtFunction;
    function Hide : TExtFunction;
    function SetZIndex(Zindex : Integer) : TExtFunction;
    function SetOpacity(Opacity : Integer) : TExtFunction;
    property Mode : String read FMode write SetFMode;
    property Offset : Integer read FOffset write SetFOffset;
  end;

  // Procedural types for events TExtDataProxy
  TExtDataProxyOnMetachange = procedure(This : TExtDataProxy; Meta : TExtObject) of object;

  TExtDataProxy = class(TExtUtilObservable)
  private
    FBatchOrder : String; // 'create,update,destroy'
    FBatchActions : Boolean; // true
    FModel : String;
    FModelTExtDataModel : TExtDataModel;
    FReader : TExtObject;
    FReaderString : String;
    FReaderTExtDataReader : TExtDataReader;
    FWriter : TExtObject;
    FWriterString : String;
    FWriterTExtDataWriter : TExtDataWriter;
    FIsProxy : Boolean;
    FOnMetachange : TExtDataProxyOnMetachange;
    procedure SetFBatchOrder(Value : String);
    procedure SetFBatchActions(Value : Boolean);
    procedure SetFModel(Value : String);
    procedure SetFModelTExtDataModel(Value : TExtDataModel);
    procedure SetFReader(Value : TExtObject);
    procedure SetFReaderString(Value : String);
    procedure SetFReaderTExtDataReader(Value : TExtDataReader);
    procedure SetFWriter(Value : TExtObject);
    procedure SetFWriterString(Value : String);
    procedure SetFWriterTExtDataWriter(Value : TExtDataWriter);
    procedure SetFIsProxy(Value : Boolean);
    procedure SetFOnMetachange(Value : TExtDataProxyOnMetachange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetModel(Model : String; SetOnStore : Boolean) : TExtFunction; overload;
    function SetModel(Model : TExtDataModel; SetOnStore : Boolean) : TExtFunction; overload;
    function GetModel : TExtFunction;
    function SetReader(Reader : String) : TExtFunction; overload;
    function SetReader(Reader : TExtObject) : TExtFunction; overload;
    function SetReader(Reader : TExtDataReader) : TExtFunction; overload;
    function GetReader : TExtFunction;
    function SetWriter(Writer : String) : TExtFunction; overload;
    function SetWriter(Writer : TExtObject) : TExtFunction; overload;
    function SetWriter(Writer : TExtDataWriter) : TExtFunction; overload;
    function GetWriter : TExtFunction;
    destructor Destroy; override;
    property BatchOrder : String read FBatchOrder write SetFBatchOrder;
    property BatchActions : Boolean read FBatchActions write SetFBatchActions;
    property Model : String read FModel write SetFModel;
    property ModelTExtDataModel : TExtDataModel read FModelTExtDataModel write SetFModelTExtDataModel;
    property Reader : TExtObject read FReader write SetFReader;
    property ReaderString : String read FReaderString write SetFReaderString;
    property ReaderTExtDataReader : TExtDataReader read FReaderTExtDataReader write SetFReaderTExtDataReader;
    property Writer : TExtObject read FWriter write SetFWriter;
    property WriterString : String read FWriterString write SetFWriterString;
    property WriterTExtDataWriter : TExtDataWriter read FWriterTExtDataWriter write SetFWriterTExtDataWriter;
    property IsProxy : Boolean read FIsProxy write SetFIsProxy;
    property OnMetachange : TExtDataProxyOnMetachange read FOnMetachange write SetFOnMetachange;
  end;

  TExtDataProxyAjax = class(TExtUtilObservable)
  private
    FHeaders : TExtObject;
    procedure SetFHeaders(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetMethod(Request : TExtDataRequest) : TExtFunction;
    destructor Destroy; override;
    property Headers : TExtObject read FHeaders write SetFHeaders;
  end;

  TExtDataProxyDirect = class(TExtUtilObservable)
  private
    FParamOrder : String;
    FParamOrderTExtObjectList : TExtObjectList;
    FParamsAsHash : Boolean;
    FDirectFn : TExtFunction;
    FDirectFnString : String;
    FApi : TExtObject;
    FExtraParams : TExtObject;
    procedure SetFParamOrder(Value : String);
    procedure SetFParamOrderTExtObjectList(Value : TExtObjectList);
    procedure SetFParamsAsHash(Value : Boolean);
    procedure SetFDirectFn(Value : TExtFunction);
    procedure SetFDirectFnString(Value : String);
    procedure SetFApi(Value : TExtObject);
    procedure SetFExtraParams(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property ParamOrder : String read FParamOrder write SetFParamOrder;
    property ParamOrderTExtObjectList : TExtObjectList read FParamOrderTExtObjectList write SetFParamOrderTExtObjectList;
    property ParamsAsHash : Boolean read FParamsAsHash write SetFParamsAsHash;
    property DirectFn : TExtFunction read FDirectFn write SetFDirectFn;
    property DirectFnString : String read FDirectFnString write SetFDirectFnString;
    property Api : TExtObject read FApi write SetFApi;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
  end;

  // Procedural types for events TExtDataNodeInterface
  TExtDataNodeInterfaceOnAppend = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnRemove = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; IsMove : Boolean) of object;
  TExtDataNodeInterfaceOnMove = procedure(This : TExtDataNodeInterface; OldParent : TExtDataNodeInterface; NewParent : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnInsert = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforeappend = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforeremove = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; IsMove : Boolean) of object;
  TExtDataNodeInterfaceOnBeforemove = procedure(This : TExtDataNodeInterface; OldParent : TExtDataNodeInterface; NewParent : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnBeforeinsert = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnExpand = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnCollapse = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforeexpand = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforecollapse = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnSort = procedure(This : TExtDataNodeInterface; ChildNodes : TExtObjectList) of object;

  TExtDataNodeInterface = class(TExtUtilObservable)
  private
    FParentId : String;
    FIndex : Integer;
    FDepth : Integer;
    FExpanded : Boolean;
    FExpandable : Boolean;
    FChecked : Boolean;
    FLeaf : Boolean;
    FCls : String;
    FIconCls : String;
    FIcon : String;
    FRoot : Boolean;
    FIsLast : Boolean;
    FIsFirst : Boolean;
    FAllowDrop : Boolean;
    FAllowDrag : Boolean;
    FLoaded : Boolean;
    FLoading : Boolean;
    FHref : String;
    FHrefTarget : String;
    FQtip : String;
    FQtitle : String;
    FText : String;
    FChildren : TExtObjectList;
    FIsNode : Boolean;
    FOnAppend : TExtDataNodeInterfaceOnAppend;
    FOnRemove : TExtDataNodeInterfaceOnRemove;
    FOnMove : TExtDataNodeInterfaceOnMove;
    FOnInsert : TExtDataNodeInterfaceOnInsert;
    FOnBeforeappend : TExtDataNodeInterfaceOnBeforeappend;
    FOnBeforeremove : TExtDataNodeInterfaceOnBeforeremove;
    FOnBeforemove : TExtDataNodeInterfaceOnBeforemove;
    FOnBeforeinsert : TExtDataNodeInterfaceOnBeforeinsert;
    FOnExpand : TExtDataNodeInterfaceOnExpand;
    FOnCollapse : TExtDataNodeInterfaceOnCollapse;
    FOnBeforeexpand : TExtDataNodeInterfaceOnBeforeexpand;
    FOnBeforecollapse : TExtDataNodeInterfaceOnBeforecollapse;
    FOnSort : TExtDataNodeInterfaceOnSort;
    procedure SetFParentId(Value : String);
    procedure SetFIndex(Value : Integer);
    procedure SetFDepth(Value : Integer);
    procedure SetFExpanded(Value : Boolean);
    procedure SetFExpandable(Value : Boolean);
    procedure SetFChecked(Value : Boolean);
    procedure SetFLeaf(Value : Boolean);
    procedure SetFCls(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFRoot(Value : Boolean);
    procedure SetFIsLast(Value : Boolean);
    procedure SetFIsFirst(Value : Boolean);
    procedure SetFAllowDrop(Value : Boolean);
    procedure SetFAllowDrag(Value : Boolean);
    procedure SetFLoaded(Value : Boolean);
    procedure SetFLoading(Value : Boolean);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFQtip(Value : String);
    procedure SetFQtitle(Value : String);
    procedure SetFText(Value : String);
    procedure SetFChildren(Value : TExtObjectList);
    procedure SetFIsNode(Value : Boolean);
    procedure SetFOnAppend(Value : TExtDataNodeInterfaceOnAppend);
    procedure SetFOnRemove(Value : TExtDataNodeInterfaceOnRemove);
    procedure SetFOnMove(Value : TExtDataNodeInterfaceOnMove);
    procedure SetFOnInsert(Value : TExtDataNodeInterfaceOnInsert);
    procedure SetFOnBeforeappend(Value : TExtDataNodeInterfaceOnBeforeappend);
    procedure SetFOnBeforeremove(Value : TExtDataNodeInterfaceOnBeforeremove);
    procedure SetFOnBeforemove(Value : TExtDataNodeInterfaceOnBeforemove);
    procedure SetFOnBeforeinsert(Value : TExtDataNodeInterfaceOnBeforeinsert);
    procedure SetFOnExpand(Value : TExtDataNodeInterfaceOnExpand);
    procedure SetFOnCollapse(Value : TExtDataNodeInterfaceOnCollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataNodeInterfaceOnBeforeexpand);
    procedure SetFOnBeforecollapse(Value : TExtDataNodeInterfaceOnBeforecollapse);
    procedure SetFOnSort(Value : TExtDataNodeInterfaceOnSort);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function CreateNode : TExtFunction;
    function IsLeaf : TExtFunction;
    function UpdateInfo : TExtFunction;
    function IsLast_ : TExtFunction;
    function IsFirst_ : TExtFunction;
    function HasChildNodes : TExtFunction;
    function IsExpandable : TExtFunction;
    function AppendChild(Node : TExtDataNodeInterface) : TExtFunction; overload;
    function AppendChild(Node : TExtObjectList) : TExtFunction; overload;
    function RemoveChild(Node : TExtDataNodeInterface; DestroyJS : Boolean = false) : TExtFunction;
    function Copy(Id : String = ''; Deep : Boolean = false) : TExtFunction;
    function InsertBefore(Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) : TExtFunction;
    function InsertChild(Index : Integer; Node : TExtDataNodeInterface) : TExtFunction;
    function Remove(DestroyJS : Boolean = false) : TExtFunction;
    function RemoveAll(DestroyJS : Boolean = false) : TExtFunction;
    function GetChildAt(Index : Integer) : TExtFunction;
    function ReplaceChild(NewChild : TExtDataNodeInterface; OldChild : TExtDataNodeInterface) : TExtFunction;
    function IndexOf(Node : TExtDataNodeInterface) : TExtFunction;
    function IndexOfId(Id : String) : TExtFunction;
    function GetPath(Field : String = ''; Separator : String = '') : TExtFunction;
    function GetDepth : TExtFunction;
    function Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function CascadeBy(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function EachChild(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function FindChild(Attribute : String; Value : TExtObject; Deep : Boolean = false) : TExtFunction;
    function FindChildBy(Fn : TExtFunction; Scope : TExtObject = nil; Deep : Boolean = false) : TExtFunction;
    function Contains(Node : TExtDataNodeInterface) : TExtFunction;
    function IsAncestor(Node : TExtDataNodeInterface) : TExtFunction;
    function Sort(Fn : TExtFunction; Recursive : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    function IsExpanded : TExtFunction;
    function IsLoaded : TExtFunction;
    function IsLoading : TExtFunction;
    function IsRoot : TExtFunction;
    function IsVisible : TExtFunction;
    function Expand(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandChildren(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Collapse(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function CollapseChildren(Recursive : TExtFunction = nil; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property ParentId : String read FParentId write SetFParentId;
    property Index : Integer read FIndex write SetFIndex;
    property Depth : Integer read FDepth write SetFDepth;
    property Expanded : Boolean read FExpanded write SetFExpanded;
    property Expandable : Boolean read FExpandable write SetFExpandable;
    property Checked : Boolean read FChecked write SetFChecked;
    property Leaf : Boolean read FLeaf write SetFLeaf;
    property Cls : String read FCls write SetFCls;
    property IconCls : String read FIconCls write SetFIconCls;
    property Icon : String read FIcon write SetFIcon;
    property Root : Boolean read FRoot write SetFRoot;
    property IsLast : Boolean read FIsLast write SetFIsLast;
    property IsFirst : Boolean read FIsFirst write SetFIsFirst;
    property AllowDrop : Boolean read FAllowDrop write SetFAllowDrop;
    property AllowDrag : Boolean read FAllowDrag write SetFAllowDrag;
    property Loaded : Boolean read FLoaded write SetFLoaded;
    property Loading : Boolean read FLoading write SetFLoading;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property Qtip : String read FQtip write SetFQtip;
    property Qtitle : String read FQtitle write SetFQtitle;
    property Text : String read FText write SetFText;
    property Children : TExtObjectList read FChildren write SetFChildren;
    property IsNode : Boolean read FIsNode write SetFIsNode;
    property OnAppend : TExtDataNodeInterfaceOnAppend read FOnAppend write SetFOnAppend;
    property OnRemove : TExtDataNodeInterfaceOnRemove read FOnRemove write SetFOnRemove;
    property OnMove : TExtDataNodeInterfaceOnMove read FOnMove write SetFOnMove;
    property OnInsert : TExtDataNodeInterfaceOnInsert read FOnInsert write SetFOnInsert;
    property OnBeforeappend : TExtDataNodeInterfaceOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforeremove : TExtDataNodeInterfaceOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnBeforemove : TExtDataNodeInterfaceOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeinsert : TExtDataNodeInterfaceOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnExpand : TExtDataNodeInterfaceOnExpand read FOnExpand write SetFOnExpand;
    property OnCollapse : TExtDataNodeInterfaceOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnBeforeexpand : TExtDataNodeInterfaceOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforecollapse : TExtDataNodeInterfaceOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnSort : TExtDataNodeInterfaceOnSort read FOnSort write SetFOnSort;
  end;

  TExtDataOperation = class(TExtUtilObservable)
  private
    FSynchronous : Boolean;
    FAction : String;
    FFilters : TExtObjectList;
    FSorters : TExtObjectList;
    FGroupers : TExtObjectList;
    FStart : Integer;
    FLimit : Integer;
    FBatch : TExtDataBatch;
    FParams : TExtObject;
    FCallback : TExtFunction;
    FScope : TExtObject;
    FActionCommitRecordsRe : TRegExp;
    FActionSkipSyncRe : TRegExp;
    procedure SetFSynchronous(Value : Boolean);
    procedure SetFAction(Value : String);
    procedure SetFFilters(Value : TExtObjectList);
    procedure SetFSorters(Value : TExtObjectList);
    procedure SetFGroupers(Value : TExtObjectList);
    procedure SetFStart(Value : Integer);
    procedure SetFLimit(Value : Integer);
    procedure SetFBatch(Value : TExtDataBatch);
    procedure SetFParams(Value : TExtObject);
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFActionCommitRecordsRe(Value : TRegExp);
    procedure SetFActionSkipSyncRe(Value : TRegExp);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    function SetStarted : TExtFunction;
    function SetCompleted : TExtFunction;
    function SetSuccessful : TExtFunction;
    function SetException(Error : String = '') : TExtFunction; overload;
    function SetException(Error : TExtObject) : TExtFunction; overload;
    function HasException : TExtFunction;
    function GetError : TExtFunction;
    function GetRecords : TExtFunction;
    function GetResultSet : TExtFunction;
    function IsStarted : TExtFunction;
    function IsRunning : TExtFunction;
    function IsComplete : TExtFunction;
    function WasSuccessful : TExtFunction;
    function AllowWrite : TExtFunction;
    destructor Destroy; override;
    property Synchronous : Boolean read FSynchronous write SetFSynchronous;
    property Action : String read FAction write SetFAction;
    property Filters : TExtObjectList read FFilters write SetFFilters;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
    property Groupers : TExtObjectList read FGroupers write SetFGroupers;
    property Start : Integer read FStart write SetFStart;
    property Limit : Integer read FLimit write SetFLimit;
    property Batch : TExtDataBatch read FBatch write SetFBatch;
    property Params : TExtObject read FParams write SetFParams;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property Scope : TExtObject read FScope write SetFScope;
    property ActionCommitRecordsRe : TRegExp read FActionCommitRecordsRe write SetFActionCommitRecordsRe;
    property ActionSkipSyncRe : TRegExp read FActionSkipSyncRe write SetFActionSkipSyncRe;
  end;

  // Procedural types for events TExtChartSeries
  TExtChartSeriesOnTitlechange = procedure(Title : String; Index : Integer) of object;

  TExtChartSeries = class(TExtUtilObservable)
  private
    FHighlight : Boolean;
    FHighlightTExtObject : TExtObject;
    FTips : TExtObject;
    FTypeJS : String;
    FTitle : String;
    FShowInLegend : Boolean;
    FRenderer : TExtFunction;
    FShadowAttributes : TExtObjectList;
    FListeners : TExtObject;
    FOnTitlechange : TExtChartSeriesOnTitlechange;
    procedure SetFHighlight(Value : Boolean);
    procedure SetFHighlightTExtObject(Value : TExtObject);
    procedure SetFTips(Value : TExtObject);
    procedure SetFTypeJS(Value : String);
    procedure SetFTitle(Value : String);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFShadowAttributes(Value : TExtObjectList);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnTitlechange(Value : TExtChartSeriesOnTitlechange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function EachRecord(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function GetRecordCount : TExtFunction;
    function IsExcluded : TExtFunction;
    function GetItemForPoint(X : Integer; Y : Integer) : TExtFunction;
    function HideAll : TExtFunction;
    function ShowAll : TExtFunction;
    function GetLegendColor : TExtFunction;
    function SetTitle(Index : Integer; Title : String) : TExtFunction;
    destructor Destroy; override;
    property Highlight : Boolean read FHighlight write SetFHighlight;
    property HighlightTExtObject : TExtObject read FHighlightTExtObject write SetFHighlightTExtObject;
    property Tips : TExtObject read FTips write SetFTips;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property Title : String read FTitle write SetFTitle;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property ShadowAttributes : TExtObjectList read FShadowAttributes write SetFShadowAttributes;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnTitlechange : TExtChartSeriesOnTitlechange read FOnTitlechange write SetFOnTitlechange;
  end;

  TExtDataProxySessionStorage = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartNavigation = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetZoom : TExtFunction;
    function RestoreZoom : TExtFunction;
  end;

  TExtChartMask = class(TExtUtilObservable)
  private
    FMask : Boolean;
    FMaskString : String;
    procedure SetFMask(Value : Boolean);
    procedure SetFMaskString(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    property Mask : Boolean read FMask write SetFMask;
    property MaskString : String read FMaskString write SetFMaskString;
  end;

  TExtDataProxyJsonP = class(TExtUtilObservable)
  private
    FCallbackKey : String;
    FRecordParam : String; // 'records'
    procedure SetFCallbackKey(Value : String);
    procedure SetFRecordParam(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function BuildUrl(Request : TExtDataRequest) : TExtFunction;
    function Abort : TExtFunction;
    function EncodeRecords(Records : TExtObjectList) : TExtFunction;
    property CallbackKey : String read FCallbackKey write SetFCallbackKey;
    property RecordParam : String read FRecordParam write SetFRecordParam;
  end;

  TExtDataProxyLocalStorage = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataProxyMemory = class(TExtUtilObservable)
  private
    FData : TExtObject;
    procedure SetFData(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Update(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Read(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Data : TExtObject read FData write SetFData;
  end;

  TExtDataAssociation = class(TExtUtilObservable)
  private
    FOwnerModel : String;
    FAssociatedModel : String;
    FModel : String;
    FPrimaryKey : String;
    FReader : TExtDataReader;
    FAssociationKey : String;
    FOwnerName : String;
    FAssociatedName : String;
    procedure SetFOwnerModel(Value : String);
    procedure SetFAssociatedModel(Value : String);
    procedure SetFModel(Value : String);
    procedure SetFPrimaryKey(Value : String);
    procedure SetFReader(Value : TExtDataReader);
    procedure SetFAssociationKey(Value : String);
    procedure SetFOwnerName(Value : String);
    procedure SetFAssociatedName(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetReader : TExtFunction;
    destructor Destroy; override;
    property OwnerModel : String read FOwnerModel write SetFOwnerModel;
    property AssociatedModel : String read FAssociatedModel write SetFAssociatedModel;
    property Model : String read FModel write SetFModel;
    property PrimaryKey : String read FPrimaryKey write SetFPrimaryKey;
    property Reader : TExtDataReader read FReader write SetFReader;
    property AssociationKey : String read FAssociationKey write SetFAssociationKey;
    property OwnerName : String read FOwnerName write SetFOwnerName;
    property AssociatedName : String read FAssociatedName write SetFAssociatedName;
  end;

  TExtDataBatch = class(TExtUtilObservable)
  private
    FAutoStart : Boolean;
    FPauseOnException : Boolean;
    FCurrent : Integer;
    FTotal : Integer;
    FIsRunning : Boolean;
    FIsComplete : Boolean;
    FHasException : Boolean;
    FOperations : TExtObjectList;
    procedure SetFAutoStart(Value : Boolean);
    procedure SetFPauseOnException(Value : Boolean);
    procedure SetFCurrent(Value : Integer);
    procedure SetFTotal(Value : Integer);
    procedure SetFIsRunning(Value : Boolean);
    procedure SetFIsComplete(Value : Boolean);
    procedure SetFHasException(Value : Boolean);
    procedure SetFOperations(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Add(Operation : TExtObject) : TExtFunction;
    function Start : TExtFunction;
    function Retry : TExtFunction;
    function Pause : TExtFunction;
    function RunOperation(Index : Integer) : TExtFunction;
    destructor Destroy; override;
    property AutoStart : Boolean read FAutoStart write SetFAutoStart;
    property PauseOnException : Boolean read FPauseOnException write SetFPauseOnException;
    property Current : Integer read FCurrent write SetFCurrent;
    property Total : Integer read FTotal write SetFTotal;
    property IsRunning : Boolean read FIsRunning write SetFIsRunning;
    property IsComplete : Boolean read FIsComplete write SetFIsComplete;
    property HasException : Boolean read FHasException write SetFHasException;
    property Operations : TExtObjectList read FOperations write SetFOperations;
  end;

  TExtComponent = class(TExtUtilObservable)
  private
    FResizable : Boolean;
    FResizableTExtObject : TExtObject;
    FResizeHandles : String;
    FAutoScroll : Boolean;
    FOverflowX : String;
    FOverflowY : String;
    FFloating : Boolean;
    FToFrontOnShow : Boolean;
    FDraggable : Boolean;
    FDraggableTExtObject : TExtObject;
    FFormBind : Boolean;
    FColumnWidth : Integer;
    FColumnWidthString : String;
    FRegion : String;
    procedure SetFResizable(Value : Boolean);
    procedure SetFResizableTExtObject(Value : TExtObject);
    procedure SetFResizeHandles(Value : String);
    procedure SetFAutoScroll(Value : Boolean);
    procedure SetFOverflowX(Value : String);
    procedure SetFOverflowY(Value : String);
    procedure SetFFloating(Value : Boolean);
    procedure SetFToFrontOnShow(Value : Boolean);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFDraggableTExtObject(Value : TExtObject);
    procedure SetFFormBind(Value : Boolean);
    procedure SetFColumnWidth(Value : Integer);
    procedure SetFColumnWidthString(Value : String);
    procedure SetFRegion(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtElement); overload;
    constructor Create(Config : String); overload;
    constructor Create(Config : TExtObject); overload;
    function SetAutoScroll(Scroll : Boolean) : TExtFunction;
    function SetOverflowXY(OverflowX : String; OverflowY : String) : TExtFunction;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetLoading(Load : Boolean; TargetEl : Boolean = false) : TExtFunction; overload;
    function SetLoading(Load : TExtObject; TargetEl : Boolean = false) : TExtFunction; overload;
    function SetLoading(Load : String; TargetEl : Boolean = false) : TExtFunction; overload;
    function ShowAt(X : Integer; Y : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function ShowAt(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPagePosition(X : Integer; Y : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetPagePosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function GetBox(Local : Boolean = false) : TExtFunction;
    function UpdateBox(Box : TExtObject) : TExtFunction;
    function GetPosition(Local : Boolean = false) : TExtFunction;
    function Show(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Show(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Hide(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Hide(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Hide(AnimateTarget : TExtComponent; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Focus(SelectText : Boolean = false; Delay : Boolean = false) : TExtFunction; overload;
    function Focus(SelectText : Boolean; Delay : Integer) : TExtFunction; overload;
    function CloneConfig(Overrides : TExtObject) : TExtFunction;
    function GetXType : TExtFunction;
    function FindParentBy(Fn : TExtFunction) : TExtFunction;
    function FindParentByType(Xtype : String) : TExtFunction; overload;
    function FindParentByType(Xtype : TExtClass) : TExtFunction; overload;
    function Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    destructor Destroy; override;
    property Resizable : Boolean read FResizable write SetFResizable;
    property ResizableTExtObject : TExtObject read FResizableTExtObject write SetFResizableTExtObject;
    property ResizeHandles : String read FResizeHandles write SetFResizeHandles;
    property AutoScroll : Boolean read FAutoScroll write SetFAutoScroll;
    property OverflowX : String read FOverflowX write SetFOverflowX;
    property OverflowY : String read FOverflowY write SetFOverflowY;
    property Floating : Boolean read FFloating write SetFFloating;
    property ToFrontOnShow : Boolean read FToFrontOnShow write SetFToFrontOnShow;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property DraggableTExtObject : TExtObject read FDraggableTExtObject write SetFDraggableTExtObject;
    property FormBind : Boolean read FFormBind write SetFFormBind;
    property ColumnWidth : Integer read FColumnWidth write SetFColumnWidth;
    property ColumnWidthString : String read FColumnWidthString write SetFColumnWidthString;
    property Region : String read FRegion write SetFRegion;
  end;

  TExtContainerDockingContainer = class(TExtUtilObservable)
  private
    FDefaultDockWeights : TExtObject;
    procedure SetFDefaultDockWeights(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; overload;
    function AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; overload;
    function GetDockedComponent(Comp : String) : TExtFunction; overload;
    function GetDockedComponent(Comp : Integer) : TExtFunction; overload;
    function GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction;
    function InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; overload;
    function InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; overload;
    function RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property DefaultDockWeights : TExtObject read FDefaultDockWeights write SetFDefaultDockWeights;
  end;

  TExtContainer = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetChildByElement(El : TExtElement; Deep : Boolean) : TExtFunction; overload;
    function GetChildByElement(El : THTMLElement; Deep : Boolean) : TExtFunction; overload;
    function GetChildByElement(El : String; Deep : Boolean) : TExtFunction; overload;
  end;

  TExtComponentQuery = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Query(Selector : String; Root : TExtContainer) : TExtFunction;
    function IsJS(Component : TExtComponent; Selector : String) : TExtFunction;
  end;

  TExtDataIdGenerator = class(TExtUtilObservable)
  private
    FId : String;
    procedure SetFId(Value : String);
  public
    function JSClassName : string; override;
    class function All : TExtObject;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Id : String read FId write SetFId;
  end;

  TExtDataJsonPSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort(Request : TExtObject = nil) : TExtFunction; overload;
    function Abort(Request : String) : TExtFunction; overload;
  end;

  TExtDataModel = class(TExtUtilObservable)
  private
    FIdgen : String;
    FIdgenTExtObject : TExtObject;
    FPersistenceProperty : String; // 'data'
    FIdProperty : String; // 'id'
    FClientIdProperty : String;
    FDefaultProxyType : String; // 'ajax'
    FFields : TExtObjectList;
    FFieldsTExtObjectList : TExtObjectList;
    FValidations : TExtObjectList;
    FAssociations : TExtObjectList;
    FHasMany : String;
    FHasManyTExtObject : TExtObject;
    FHasManyTExtObjectList : TExtObjectList;
    FBelongsTo : String;
    FBelongsToTExtObject : TExtObject;
    FBelongsToTExtObjectList : TExtObjectList;
    FProxy : String;
    FProxyTExtObject : TExtObject;
    FProxyTExtDataProxy : TExtDataProxy;
    FInternalId : Integer;
    FInternalIdString : String;
    FRaw : TExtObject;
    FModified : TExtObject;
    FStores : TExtObjectList;
    FStore : TExtDataStore;
    procedure SetFIdgen(Value : String);
    procedure SetFIdgenTExtObject(Value : TExtObject);
    procedure SetFPersistenceProperty(Value : String);
    procedure SetFIdProperty(Value : String);
    procedure SetFClientIdProperty(Value : String);
    procedure SetFDefaultProxyType(Value : String);
    procedure SetFFields(Value : TExtObjectList);
    procedure SetFFieldsTExtObjectList(Value : TExtObjectList);
    procedure SetFValidations(Value : TExtObjectList);
    procedure SetFAssociations(Value : TExtObjectList);
    procedure SetFHasMany(Value : String);
    procedure SetFHasManyTExtObject(Value : TExtObject);
    procedure SetFHasManyTExtObjectList(Value : TExtObjectList);
    procedure SetFBelongsTo(Value : String);
    procedure SetFBelongsToTExtObject(Value : TExtObject);
    procedure SetFBelongsToTExtObjectList(Value : TExtObjectList);
    procedure SetFProxy(Value : String);
    procedure SetFProxyTExtObject(Value : TExtObject);
    procedure SetFProxyTExtDataProxy(Value : TExtDataProxy);
    procedure SetFInternalId(Value : Integer);
    procedure SetFInternalIdString(Value : String);
    procedure SetFRaw(Value : TExtObject);
    procedure SetFModified(Value : TExtObject);
    procedure SetFStores(Value : TExtObjectList);
    procedure SetFStore(Value : TExtDataStore);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Unjoin(Store : TExtDataStore) : TExtFunction;
    function GetData(IncludeAssociated : Boolean) : TExtFunction;
    function GetAssociatedData : TExtFunction;
    destructor Destroy; override;
    property Idgen : String read FIdgen write SetFIdgen;
    property IdgenTExtObject : TExtObject read FIdgenTExtObject write SetFIdgenTExtObject;
    property PersistenceProperty : String read FPersistenceProperty write SetFPersistenceProperty;
    property IdProperty : String read FIdProperty write SetFIdProperty;
    property ClientIdProperty : String read FClientIdProperty write SetFClientIdProperty;
    property DefaultProxyType : String read FDefaultProxyType write SetFDefaultProxyType;
    property Fields : TExtObjectList read FFields write SetFFields;
    property FieldsTExtObjectList : TExtObjectList read FFieldsTExtObjectList write SetFFieldsTExtObjectList;
    property Validations : TExtObjectList read FValidations write SetFValidations;
    property Associations : TExtObjectList read FAssociations write SetFAssociations;
    property HasMany : String read FHasMany write SetFHasMany;
    property HasManyTExtObject : TExtObject read FHasManyTExtObject write SetFHasManyTExtObject;
    property HasManyTExtObjectList : TExtObjectList read FHasManyTExtObjectList write SetFHasManyTExtObjectList;
    property BelongsTo : String read FBelongsTo write SetFBelongsTo;
    property BelongsToTExtObject : TExtObject read FBelongsToTExtObject write SetFBelongsToTExtObject;
    property BelongsToTExtObjectList : TExtObjectList read FBelongsToTExtObjectList write SetFBelongsToTExtObjectList;
    property Proxy : String read FProxy write SetFProxy;
    property ProxyTExtObject : TExtObject read FProxyTExtObject write SetFProxyTExtObject;
    property ProxyTExtDataProxy : TExtDataProxy read FProxyTExtDataProxy write SetFProxyTExtDataProxy;
    property InternalId : Integer read FInternalId write SetFInternalId;
    property InternalIdString : String read FInternalIdString write SetFInternalIdString;
    property Raw : TExtObject read FRaw write SetFRaw;
    property Modified : TExtObject read FModified write SetFModified;
    property Stores : TExtObjectList read FStores write SetFStores;
    property Store : TExtDataStore read FStore write SetFStore;
  end;

  TExtChartTip = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartTheme = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtDataConnection
  TExtDataConnectionOnBeforerequest = procedure(Conn : TExtDataConnection; Options : TExtObject) of object;
  TExtDataConnectionOnRequestcomplete = procedure(Conn : TExtDataConnection; Response : TExtObject; Options : TExtObject) of object;
  TExtDataConnectionOnRequestexception = procedure(Conn : TExtDataConnection; Response : TExtObject; Options : TExtObject) of object;

  TExtDataConnection = class(TExtUtilObservable)
  private
    FDisableCaching : Boolean;
    FWithCredentials : Boolean;
    FCors : Boolean;
    FDisableCachingParam : String;
    FTimeout : Integer;
    FExtraParams : TExtObject;
    FAutoAbort : Boolean;
    FMethod : String;
    FDefaultHeaders : TExtObject;
    FOnBeforerequest : TExtDataConnectionOnBeforerequest;
    FOnRequestcomplete : TExtDataConnectionOnRequestcomplete;
    FOnRequestexception : TExtDataConnectionOnRequestexception;
    procedure SetFDisableCaching(Value : Boolean);
    procedure SetFWithCredentials(Value : Boolean);
    procedure SetFCors(Value : Boolean);
    procedure SetFDisableCachingParam(Value : String);
    procedure SetFTimeout(Value : Integer);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFAutoAbort(Value : Boolean);
    procedure SetFMethod(Value : String);
    procedure SetFDefaultHeaders(Value : TExtObject);
    procedure SetFOnBeforerequest(Value : TExtDataConnectionOnBeforerequest);
    procedure SetFOnRequestcomplete(Value : TExtDataConnectionOnRequestcomplete);
    procedure SetFOnRequestexception(Value : TExtDataConnectionOnRequestexception);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; overload;
    function Upload(Form : String; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    function Upload(Form : THTMLElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    function Upload(Form : TExtElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    function SetOptions(Options : TExtObject; Scope : TExtObject) : TExtFunction;
    function IsLoading(Request : TExtObject = nil) : TExtFunction;
    function Abort(Request : TExtObject = nil) : TExtFunction;
    function AbortAll : TExtFunction;
    function ParseStatus(Status : Integer) : TExtFunction;
    destructor Destroy; override;
    property DisableCaching : Boolean read FDisableCaching write SetFDisableCaching;
    property WithCredentials : Boolean read FWithCredentials write SetFWithCredentials;
    property Cors : Boolean read FCors write SetFCors;
    property DisableCachingParam : String read FDisableCachingParam write SetFDisableCachingParam;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property AutoAbort : Boolean read FAutoAbort write SetFAutoAbort;
    property Method : String read FMethod write SetFMethod;
    property DefaultHeaders : TExtObject read FDefaultHeaders write SetFDefaultHeaders;
    property OnBeforerequest : TExtDataConnectionOnBeforerequest read FOnBeforerequest write SetFOnBeforerequest;
    property OnRequestcomplete : TExtDataConnectionOnRequestcomplete read FOnRequestcomplete write SetFOnRequestcomplete;
    property OnRequestexception : TExtDataConnectionOnRequestexception read FOnRequestexception write SetFOnRequestexception;
  end;

  TExtChartLegend = class(TExtUtilObservable)
  private
    FVisible : Boolean;
    FUpdate : Boolean;
    FPosition : String;
    FX : Integer;
    FY : Integer;
    FLabelColor : String;
    FLabelFont : String;
    FBoxStroke : String;
    FBoxStrokeWidth : String;
    FBoxFill : String;
    FItemSpacing : Integer;
    FPadding : Integer;
    FBoxZIndex : Integer; // 100
    procedure SetFVisible(Value : Boolean);
    procedure SetFUpdate(Value : Boolean);
    procedure SetFPosition(Value : String);
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
    procedure SetFLabelColor(Value : String);
    procedure SetFLabelFont(Value : String);
    procedure SetFBoxStroke(Value : String);
    procedure SetFBoxStrokeWidth(Value : String);
    procedure SetFBoxFill(Value : String);
    procedure SetFItemSpacing(Value : Integer);
    procedure SetFPadding(Value : Integer);
    procedure SetFBoxZIndex(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject); overload;
    function Toggle(Whether : Boolean) : TExtFunction;
    property Visible : Boolean read FVisible write SetFVisible;
    property Update : Boolean read FUpdate write SetFUpdate;
    property Position : String read FPosition write SetFPosition;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
    property LabelColor : String read FLabelColor write SetFLabelColor;
    property LabelFont : String read FLabelFont write SetFLabelFont;
    property BoxStroke : String read FBoxStroke write SetFBoxStroke;
    property BoxStrokeWidth : String read FBoxStrokeWidth write SetFBoxStrokeWidth;
    property BoxFill : String read FBoxFill write SetFBoxFill;
    property ItemSpacing : Integer read FItemSpacing write SetFItemSpacing;
    property Padding : Integer read FPadding write SetFPadding;
    property BoxZIndex : Integer read FBoxZIndex write SetFBoxZIndex;
  end;

  TExtAppController = class(TExtUtilObservable)
  private
    FViews : TExtObjectList;
    FStores : TExtObjectList;
    FRefs : TExtObjectList;
    procedure SetFViews(Value : TExtObjectList);
    procedure SetFStores(Value : TExtObjectList);
    procedure SetFRefs(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    function AddRef(Ref : TExtObject) : TExtFunction;
    function HasRef : TExtFunction;
    function Control(Selectors : String; Listeners : TExtObject) : TExtFunction; overload;
    function Control(Selectors : TExtObject; Listeners : TExtObject) : TExtFunction; overload;
    function GetController(Name : String) : TExtFunction;
    function GetStore(Name : String) : TExtFunction;
    function GetModel(Name : String) : TExtFunction;
    function GetView(Name : String) : TExtFunction;
    destructor Destroy; override;
    property Views : TExtObjectList read FViews write SetFViews;
    property Stores : TExtObjectList read FStores write SetFStores;
    property Refs : TExtObjectList read FRefs write SetFRefs;
  end;

  // Procedural types for events TExtDataTree
  TExtDataTreeOnAppend = procedure of object;
  TExtDataTreeOnRemove = procedure of object;
  TExtDataTreeOnMove = procedure of object;
  TExtDataTreeOnInsert = procedure of object;
  TExtDataTreeOnBeforeappend = procedure of object;
  TExtDataTreeOnBeforeremove = procedure of object;
  TExtDataTreeOnBeforemove = procedure of object;
  TExtDataTreeOnBeforeinsert = procedure of object;
  TExtDataTreeOnExpand = procedure of object;
  TExtDataTreeOnCollapse = procedure of object;
  TExtDataTreeOnBeforeexpand = procedure of object;
  TExtDataTreeOnBeforecollapse = procedure of object;
  TExtDataTreeOnSort = procedure of object;
  TExtDataTreeOnRootchange = procedure(Root : TExtDataModel) of object;

  TExtDataTree = class(TExtUtilObservable)
  private
    FOnAppend : TExtDataTreeOnAppend;
    FOnRemove : TExtDataTreeOnRemove;
    FOnMove : TExtDataTreeOnMove;
    FOnInsert : TExtDataTreeOnInsert;
    FOnBeforeappend : TExtDataTreeOnBeforeappend;
    FOnBeforeremove : TExtDataTreeOnBeforeremove;
    FOnBeforemove : TExtDataTreeOnBeforemove;
    FOnBeforeinsert : TExtDataTreeOnBeforeinsert;
    FOnExpand : TExtDataTreeOnExpand;
    FOnCollapse : TExtDataTreeOnCollapse;
    FOnBeforeexpand : TExtDataTreeOnBeforeexpand;
    FOnBeforecollapse : TExtDataTreeOnBeforecollapse;
    FOnSort : TExtDataTreeOnSort;
    FOnRootchange : TExtDataTreeOnRootchange;
    procedure SetFOnAppend(Value : TExtDataTreeOnAppend);
    procedure SetFOnRemove(Value : TExtDataTreeOnRemove);
    procedure SetFOnMove(Value : TExtDataTreeOnMove);
    procedure SetFOnInsert(Value : TExtDataTreeOnInsert);
    procedure SetFOnBeforeappend(Value : TExtDataTreeOnBeforeappend);
    procedure SetFOnBeforeremove(Value : TExtDataTreeOnBeforeremove);
    procedure SetFOnBeforemove(Value : TExtDataTreeOnBeforemove);
    procedure SetFOnBeforeinsert(Value : TExtDataTreeOnBeforeinsert);
    procedure SetFOnExpand(Value : TExtDataTreeOnExpand);
    procedure SetFOnCollapse(Value : TExtDataTreeOnCollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataTreeOnBeforeexpand);
    procedure SetFOnBeforecollapse(Value : TExtDataTreeOnBeforecollapse);
    procedure SetFOnSort(Value : TExtDataTreeOnSort);
    procedure SetFOnRootchange(Value : TExtDataTreeOnRootchange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetNodeById(Id : String) : TExtFunction;
    property OnAppend : TExtDataTreeOnAppend read FOnAppend write SetFOnAppend;
    property OnRemove : TExtDataTreeOnRemove read FOnRemove write SetFOnRemove;
    property OnMove : TExtDataTreeOnMove read FOnMove write SetFOnMove;
    property OnInsert : TExtDataTreeOnInsert read FOnInsert write SetFOnInsert;
    property OnBeforeappend : TExtDataTreeOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforeremove : TExtDataTreeOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnBeforemove : TExtDataTreeOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeinsert : TExtDataTreeOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnExpand : TExtDataTreeOnExpand read FOnExpand write SetFOnExpand;
    property OnCollapse : TExtDataTreeOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnBeforeexpand : TExtDataTreeOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforecollapse : TExtDataTreeOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnSort : TExtDataTreeOnSort read FOnSort write SetFOnSort;
    property OnRootchange : TExtDataTreeOnRootchange read FOnRootchange write SetFOnRootchange;
  end;

  TExtDataTypesSingleton = class(TExtUtilObservable)
  private
    FStripRe : TRegExp;
    procedure SetFStripRe(Value : TRegExp);
  public
    function JSClassName : string; override;
    class function AUTO : TExtObject;
    class function STRINGJS : TExtObject;
    class function INT : TExtObject;
    class function FLOAT : TExtObject;
    class function BOOL : TExtObject;
    class function DATE : TExtObject;
    class function BOOLEAN : TExtObject;
    class function INTEGER : TExtObject;
    class function NUMBER : TExtObject;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property StripRe : TRegExp read FStripRe write SetFStripRe;
  end;

  TExtDataSortTypesSingleton = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function None(S : TExtObject) : TExtFunction;
    function AsUCText(S : TExtObject) : TExtFunction;
    function AsUCString(S : TExtObject) : TExtFunction;
    function AsDate(S : TExtObject) : TExtFunction;
    function AsFloat(S : TExtObject) : TExtFunction;
    function AsInt(S : TExtObject) : TExtFunction;
  end;

  TExtChartAxis = class(TExtUtilObservable)
  private
    FGrid : Boolean;
    FGridTExtObject : TExtObject;
    FMajorTickSteps : Integer;
    FMinorTickSteps : Integer;
    FTitle : String;
    FDashSize : Integer;
    FPosition : String;
    FLength : Integer;
    FWidth : Integer;
    FAdjustEnd : Boolean;
    procedure SetFGrid(Value : Boolean);
    procedure SetFGridTExtObject(Value : TExtObject);
    procedure SetFMajorTickSteps(Value : Integer);
    procedure SetFMinorTickSteps(Value : Integer);
    procedure SetFTitle(Value : String);
    procedure SetFDashSize(Value : Integer);
    procedure SetFPosition(Value : String);
    procedure SetFLength(Value : Integer);
    procedure SetFWidth(Value : Integer);
    procedure SetFAdjustEnd(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Grid : Boolean read FGrid write SetFGrid;
    property GridTExtObject : TExtObject read FGridTExtObject write SetFGridTExtObject;
    property MajorTickSteps : Integer read FMajorTickSteps write SetFMajorTickSteps;
    property MinorTickSteps : Integer read FMinorTickSteps write SetFMinorTickSteps;
    property Title : String read FTitle write SetFTitle;
    property DashSize : Integer read FDashSize write SetFDashSize;
    property Position : String read FPosition write SetFPosition;
    property Length : Integer read FLength write SetFLength;
    property Width : Integer read FWidth write SetFWidth;
    property AdjustEnd : Boolean read FAdjustEnd write SetFAdjustEnd;
  end;

  TExtAbstractManager = class(TExtUtilObservable)
  private
    FAll : TExtUtilHashMap;
    procedure SetFAll(Value : TExtUtilHashMap);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Get(Id : String) : TExtFunction;
    function Register(Item : TExtObject) : TExtFunction;
    function Unregister(Item : TExtObject) : TExtFunction;
    function RegisterType(TypeJS : String; Cls : TExtFunction) : TExtFunction;
    function IsRegistered(TypeJS : String) : TExtFunction;
    function OnAvailable(Id : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Each(Fn : TExtFunction; FnKey : String; FnValue : Integer; FnLength : Integer; FnReturn : Boolean; Scope : TExtObject) : TExtFunction;
    function GetCount : TExtFunction;
    destructor Destroy; override;
    property All : TExtUtilHashMap read FAll write SetFAll;
  end;

  TExtChartAxisGauge = class(TExtUtilObservable)
  private
    FMinimum : Integer;
    FMaximum : Integer;
    FSteps : Integer;
    FMargin : Integer;
    FTitle : String;
    procedure SetFMinimum(Value : Integer);
    procedure SetFMaximum(Value : Integer);
    procedure SetFSteps(Value : Integer);
    procedure SetFMargin(Value : Integer);
    procedure SetFTitle(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetTitle(Title : String) : TExtFunction;
    property Minimum : Integer read FMinimum write SetFMinimum;
    property Maximum : Integer read FMaximum write SetFMaximum;
    property Steps : Integer read FSteps write SetFSteps;
    property Margin : Integer read FMargin write SetFMargin;
    property Title : String read FTitle write SetFTitle;
  end;

  TExtAction = class(TExtUtilObservable)
  private
    FText : String;
    FIconCls : String;
    FDisabled : Boolean;
    FHidden : Boolean;
    FHandler : TExtFunction;
    FItemId : String;
    FScope : TExtObject;
    FIsAction : Boolean;
    procedure SetFText(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFHidden(Value : Boolean);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFItemId(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFIsAction(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetText(Text : String) : TExtFunction;
    function GetText : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function GetIconCls : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    function Enable : TExtFunction;
    function Disable : TExtFunction;
    function IsDisabled : TExtFunction;
    function SetHidden(Hidden : Boolean) : TExtFunction;
    function Show : TExtFunction;
    function Hide : TExtFunction;
    function IsHidden : TExtFunction;
    function SetHandler(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Execute(Args : TExtObjectList) : TExtFunction;
    destructor Destroy; override;
    property Text : String read FText write SetFText;
    property IconCls : String read FIconCls write SetFIconCls;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property Hidden : Boolean read FHidden write SetFHidden;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property ItemId : String read FItemId write SetFItemId;
    property Scope : TExtObject read FScope write SetFScope;
    property IsAction : Boolean read FIsAction write SetFIsAction;
  end;

  TExtChartLabel = class(TExtUtilObservable)
  private
    FLabelJS : TExtObject;
    procedure SetFLabelJS(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property LabelJS : TExtObject read FLabelJS write SetFLabelJS;
  end;

  TExtChartHighlight = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function HighlightItem(Item : TExtObject) : TExtFunction;
    function UnHighlightItem : TExtFunction;
  end;

  TExtChartCallout = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataResultSet = class(TExtUtilObservable)
  private
    FLoaded : Boolean;
    FCount : Integer;
    FTotal : Integer;
    FSuccess : Boolean;
    FRecords : TExtObjectList;
    FTotalRecords : Integer;
    procedure SetFLoaded(Value : Boolean);
    procedure SetFCount(Value : Integer);
    procedure SetFTotal(Value : Integer);
    procedure SetFSuccess(Value : Boolean);
    procedure SetFRecords(Value : TExtObjectList);
    procedure SetFTotalRecords(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Loaded : Boolean read FLoaded write SetFLoaded;
    property Count : Integer read FCount write SetFCount;
    property Total : Integer read FTotal write SetFTotal;
    property Success : Boolean read FSuccess write SetFSuccess;
    property Records : TExtObjectList read FRecords write SetFRecords;
    property TotalRecords : Integer read FTotalRecords write SetFTotalRecords;
  end;

  TExtDataRequest = class(TExtUtilObservable)
  private
    FAction : String;
    FParams : TExtObject;
    FMethod : String;
    FUrl : String;
    procedure SetFAction(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFMethod(Value : String);
    procedure SetFUrl(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    destructor Destroy; override;
    property Action : String read FAction write SetFAction;
    property Params : TExtObject read FParams write SetFParams;
    property Method : String read FMethod write SetFMethod;
    property Url : String read FUrl write SetFUrl;
  end;

  TExtAbstractPlugin = class(TExtUtilObservable)
  private
    FPluginId : String;
    procedure SetFPluginId(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Disable : TExtFunction;
    property PluginId : String read FPluginId write SetFPluginId;
  end;

  TExtAjaxSingleton = class(TExtDataConnection)
  private
    FDisableCaching : Boolean; // true
    FUrl : String;
    FExtraParams : TExtObject;
    FDefaultHeaders : TExtObject;
    FMethod : String;
    FTimeout : Integer; // 30000
    FAutoAbort : Boolean;
    procedure SetFDisableCaching(Value : Boolean);
    procedure SetFUrl(Value : String);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFDefaultHeaders(Value : TExtObject);
    procedure SetFMethod(Value : String);
    procedure SetFTimeout(Value : Integer);
    procedure SetFAutoAbort(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    destructor Destroy; override;
    property DisableCaching : Boolean read FDisableCaching write SetFDisableCaching;
    property Url : String read FUrl write SetFUrl;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property DefaultHeaders : TExtObject read FDefaultHeaders write SetFDefaultHeaders;
    property Method : String read FMethod write SetFMethod;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property AutoAbort : Boolean read FAutoAbort write SetFAutoAbort;
  end;

  TExtLayoutContainer = class(TExtLayout)
  private
    FItemCls : String;
    FManageOverflow : Integer;
    FReserveScrollbar : Boolean;
    procedure SetFItemCls(Value : String);
    procedure SetFManageOverflow(Value : Integer);
    procedure SetFReserveScrollbar(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetLayoutItems : TExtFunction;
    function GetRenderTarget : TExtFunction;
    function GetElementTarget : TExtFunction;
    property ItemCls : String read FItemCls write SetFItemCls;
    property ManageOverflow : Integer read FManageOverflow write SetFManageOverflow;
    property ReserveScrollbar : Boolean read FReserveScrollbar write SetFReserveScrollbar;
  end;

  TExtComponentLoader = class(TExtElementLoader)
  private
    FTarget : TExtComponent;
    FTargetString : String;
    FLoadMask : Boolean;
    FLoadMaskTExtObject : TExtObject;
    FScripts : Boolean;
    FRenderer : String;
    FRendererTExtFunction : TExtFunction;
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetString(Value : String);
    procedure SetFLoadMask(Value : Boolean);
    procedure SetFLoadMaskTExtObject(Value : TExtObject);
    procedure SetFScripts(Value : Boolean);
    procedure SetFRenderer(Value : String);
    procedure SetFRendererTExtFunction(Value : TExtFunction);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetTarget(Target : String) : TExtFunction; overload;
    function SetTarget(Target : TExtComponent) : TExtFunction; overload;
    destructor Destroy; override;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetString : String read FTargetString write SetFTargetString;
    property LoadMask : Boolean read FLoadMask write SetFLoadMask;
    property LoadMaskTExtObject : TExtObject read FLoadMaskTExtObject write SetFLoadMaskTExtObject;
    property Scripts : Boolean read FScripts write SetFScripts;
    property Renderer : String read FRenderer write SetFRenderer;
    property RendererTExtFunction : TExtFunction read FRendererTExtFunction write SetFRendererTExtFunction;
  end;

  TExtModelManagerSingleton = class(TExtAbstractManager)
  private
    FAssociationStack : TExtObjectList;
    procedure SetFAssociationStack(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetModel(Id : String) : TExtFunction; overload;
    function GetModel(Id : TExtObject) : TExtFunction; overload;
    constructor Create(Data : TExtObject; Name : String; Id : Integer = 0);
    destructor Destroy; override;
    property AssociationStack : TExtObjectList read FAssociationStack write SetFAssociationStack;
  end;

  TExtChartSeriesRadar = class(TExtChartSeries)
  private
    FStyle : TExtObject;
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  // Procedural types for events TExtPanelHeader
  TExtPanelHeaderOnClick = procedure(This : TExtPanelHeader; E : TExtEventObject) of object;
  TExtPanelHeaderOnDblclick = procedure(This : TExtPanelHeader; E : TExtEventObject) of object;

  TExtPanelHeader = class(TExtContainer)
  private
    FTitleAlign : String;
    FTitle : String;
    FIconCls : String;
    FIcon : String;
    FOnClick : TExtPanelHeaderOnClick;
    FOnDblclick : TExtPanelHeaderOnDblclick;
    procedure SetFTitleAlign(Value : String);
    procedure SetFTitle(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFOnClick(Value : TExtPanelHeaderOnClick);
    procedure SetFOnDblclick(Value : TExtPanelHeaderOnDblclick);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetTitle(Title : String) : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function SetIcon(Icon : String) : TExtFunction;
    function AddTool(Tool : TExtObject) : TExtFunction;
    property TitleAlign : String read FTitleAlign write SetFTitleAlign;
    property Title : String read FTitle write SetFTitle;
    property IconCls : String read FIconCls write SetFIconCls;
    property Icon : String read FIcon write SetFIcon;
    property OnClick : TExtPanelHeaderOnClick read FOnClick write SetFOnClick;
    property OnDblclick : TExtPanelHeaderOnDblclick read FOnDblclick write SetFOnDblclick;
  end;

  // Procedural types for events TExtMenuItem
  TExtMenuItemOnActivate = procedure(Item : TExtMenuItem) of object;
  TExtMenuItemOnClick = procedure(Item : TExtMenuItem; E : TExtEventObject) of object;
  TExtMenuItemOnDeactivate = procedure(Item : TExtMenuItem) of object;

  TExtMenuItem = class(TExtComponent)
  private
    FActiveCls : String;
    FCanActivate : Boolean;
    FClickHideDelay : Integer;
    FDestroyMenu : Boolean;
    FDisabledCls : String;
    FHref : String;
    FHrefTarget : String;
    FHideOnClick : Boolean;
    FIcon : String;
    FIconCls : String;
    FMenu : TExtMenu;
    FMenuTExtObject : TExtObject;
    FMenuAlign : String;
    FMenuExpandDelay : Integer;
    FMenuHideDelay : Integer;
    FPlain : Boolean;
    FTooltip : String;
    FTooltipTExtObject : TExtObject;
    FTooltipType : String;
    FText : String;
    FHandler : TExtFunction;
    FOnActivate : TExtMenuItemOnActivate;
    FOnClick : TExtMenuItemOnClick;
    FOnDeactivate : TExtMenuItemOnDeactivate;
    procedure SetFActiveCls(Value : String);
    procedure SetFCanActivate(Value : Boolean);
    procedure SetFClickHideDelay(Value : Integer);
    procedure SetFDestroyMenu(Value : Boolean);
    procedure SetFDisabledCls(Value : String);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFMenuTExtObject(Value : TExtObject);
    procedure SetFMenuAlign(Value : String);
    procedure SetFMenuExpandDelay(Value : Integer);
    procedure SetFMenuHideDelay(Value : Integer);
    procedure SetFPlain(Value : Boolean);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipTExtObject(Value : TExtObject);
    procedure SetFTooltipType(Value : String);
    procedure SetFText(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFOnActivate(Value : TExtMenuItemOnActivate);
    procedure SetFOnClick(Value : TExtMenuItemOnClick);
    procedure SetFOnDeactivate(Value : TExtMenuItemOnDeactivate);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetMenu(Menu : TExtMenu; DestroyMenu : Boolean = false) : TExtFunction; overload;
    function SetMenu(Menu : TExtObject; DestroyMenu : Boolean = false) : TExtFunction; overload;
    function SetHandler(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function SetIcon(Icon : String) : TExtFunction;
    function SetIconCls(IconCls : String) : TExtFunction;
    function SetText(Text : String) : TExtFunction;
    function SetTooltip(Tooltip : String) : TExtFunction; overload;
    function SetTooltip(Tooltip : TExtObject) : TExtFunction; overload;
    destructor Destroy; override;
    property ActiveCls : String read FActiveCls write SetFActiveCls;
    property CanActivate : Boolean read FCanActivate write SetFCanActivate;
    property ClickHideDelay : Integer read FClickHideDelay write SetFClickHideDelay;
    property DestroyMenu : Boolean read FDestroyMenu write SetFDestroyMenu;
    property DisabledCls : String read FDisabledCls write SetFDisabledCls;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property MenuTExtObject : TExtObject read FMenuTExtObject write SetFMenuTExtObject;
    property MenuAlign : String read FMenuAlign write SetFMenuAlign;
    property MenuExpandDelay : Integer read FMenuExpandDelay write SetFMenuExpandDelay;
    property MenuHideDelay : Integer read FMenuHideDelay write SetFMenuHideDelay;
    property Plain : Boolean read FPlain write SetFPlain;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipTExtObject : TExtObject read FTooltipTExtObject write SetFTooltipTExtObject;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property Text : String read FText write SetFText;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property OnActivate : TExtMenuItemOnActivate read FOnActivate write SetFOnActivate;
    property OnClick : TExtMenuItemOnClick read FOnClick write SetFOnClick;
    property OnDeactivate : TExtMenuItemOnDeactivate read FOnDeactivate write SetFOnDeactivate;
  end;

  TExtAppApplication = class(TExtAppController)
  private
    FName : String;
    FControllers : TExtObjectList;
    FScope : TExtObject;
    FEnableQuickTips : Boolean;
    FAppFolder : String;
    FAutoCreateViewport : Boolean;
    FPaths : TExtObject;
    procedure SetFName(Value : String);
    procedure SetFControllers(Value : TExtObjectList);
    procedure SetFScope(Value : TExtObject);
    procedure SetFEnableQuickTips(Value : Boolean);
    procedure SetFAppFolder(Value : String);
    procedure SetFAutoCreateViewport(Value : Boolean);
    procedure SetFPaths(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    destructor Destroy; override;
    property Name : String read FName write SetFName;
    property Controllers : TExtObjectList read FControllers write SetFControllers;
    property Scope : TExtObject read FScope write SetFScope;
    property EnableQuickTips : Boolean read FEnableQuickTips write SetFEnableQuickTips;
    property AppFolder : String read FAppFolder write SetFAppFolder;
    property AutoCreateViewport : Boolean read FAutoCreateViewport write SetFAutoCreateViewport;
    property Paths : TExtObject read FPaths write SetFPaths;
  end;

  TExtLoadMask = class(TExtComponent)
  private
    FStore : TExtDataStore;
    FMsg : String;
    FMsgCls : String;
    FMaskCls : String;
    FUseMsg : Boolean;
    FUseTargetEl : Boolean;
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFMsg(Value : String);
    procedure SetFMsgCls(Value : String);
    procedure SetFMaskCls(Value : String);
    procedure SetFUseMsg(Value : Boolean);
    procedure SetFUseTargetEl(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Comp : TExtComponent; Config : TExtObject = nil); overload;
    function BindStore(Store : TExtDataStore) : TExtFunction;
    destructor Destroy; override;
    property Store : TExtDataStore read FStore write SetFStore;
    property Msg : String read FMsg write SetFMsg;
    property MsgCls : String read FMsgCls write SetFMsgCls;
    property MaskCls : String read FMaskCls write SetFMaskCls;
    property UseMsg : Boolean read FUseMsg write SetFUseMsg;
    property UseTargetEl : Boolean read FUseTargetEl write SetFUseTargetEl;
  end;

  // Procedural types for events TExtMenu
  TExtMenuOnClick = procedure(Menu : TExtMenu; Item : TExtComponent; E : TExtEventObject) of object;
  TExtMenuOnMouseenter = procedure(Menu : TExtMenu; E : TExtEventObject) of object;
  TExtMenuOnMouseleave = procedure(Menu : TExtMenu; E : TExtEventObject) of object;
  TExtMenuOnMouseover = procedure(Menu : TExtMenu; Item : TExtComponent; E : TExtEventObject) of object;

  TExtMenu = class(TExtPanel)
  private
    FEnableKeyNav : Boolean;
    FAllowOtherMenus : Boolean;
    FDefaultAlign : String;
    FFloating : Boolean;
    FHidden : Boolean; // true
    FIgnoreParentClicks : Boolean;
    FLayout : String;
    FLayoutTExtObject : TExtObject;
    FShowSeparator : Boolean;
    FMinWidth : Integer;
    FPlain : Boolean;
    FOnClick : TExtMenuOnClick;
    FOnMouseenter : TExtMenuOnMouseenter;
    FOnMouseleave : TExtMenuOnMouseleave;
    FOnMouseover : TExtMenuOnMouseover;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFAllowOtherMenus(Value : Boolean);
    procedure SetFDefaultAlign(Value : String);
    procedure SetFFloating(Value : Boolean);
    procedure SetFHidden(Value : Boolean);
    procedure SetFIgnoreParentClicks(Value : Boolean);
    procedure SetFLayout(Value : String);
    procedure SetFLayoutTExtObject(Value : TExtObject);
    procedure SetFShowSeparator(Value : Boolean);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFPlain(Value : Boolean);
    procedure SetFOnClick(Value : TExtMenuOnClick);
    procedure SetFOnMouseenter(Value : TExtMenuOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtMenuOnMouseleave);
    procedure SetFOnMouseover(Value : TExtMenuOnMouseover);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function CanActivateItem : TExtFunction;
    function DeactivateActiveItem : TExtFunction;
    function ShowBy(Component : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function ShowBy(Component : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    destructor Destroy; override;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property AllowOtherMenus : Boolean read FAllowOtherMenus write SetFAllowOtherMenus;
    property DefaultAlign : String read FDefaultAlign write SetFDefaultAlign;
    property Floating : Boolean read FFloating write SetFFloating;
    property Hidden : Boolean read FHidden write SetFHidden;
    property IgnoreParentClicks : Boolean read FIgnoreParentClicks write SetFIgnoreParentClicks;
    property Layout : String read FLayout write SetFLayout;
    property LayoutTExtObject : TExtObject read FLayoutTExtObject write SetFLayoutTExtObject;
    property ShowSeparator : Boolean read FShowSeparator write SetFShowSeparator;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property Plain : Boolean read FPlain write SetFPlain;
    property OnClick : TExtMenuOnClick read FOnClick write SetFOnClick;
    property OnMouseenter : TExtMenuOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtMenuOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnMouseover : TExtMenuOnMouseover read FOnMouseover write SetFOnMouseover;
  end;

  TExtViewBoundListKeyNav = class(TExtUtilKeyNav)
  private
    FBoundList : TExtViewBoundList;
    procedure SetFBoundList(Value : TExtViewBoundList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function HighlightAt(Index : Integer) : TExtFunction;
    function SelectHighlighted : TExtFunction;
    destructor Destroy; override;
    property BoundList : TExtViewBoundList read FBoundList write SetFBoundList;
  end;

  TExtGridFeatureSummary = class(TExtGridFeatureAbstractSummary)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridHeaderContainer
  TExtGridHeaderContainerOnColumnresize = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; Width : Integer) of object;
  TExtGridHeaderContainerOnHeaderclick = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; E : TExtEventObject; T : THTMLElement) of object;
  TExtGridHeaderContainerOnHeadertriggerclick = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; E : TExtEventObject; T : THTMLElement) of object;
  TExtGridHeaderContainerOnColumnmove = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; FromIdx : Integer; ToIdx : Integer) of object;
  TExtGridHeaderContainerOnColumnhide = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn) of object;
  TExtGridHeaderContainerOnColumnshow = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn) of object;
  TExtGridHeaderContainerOnSortchange = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; Direction : String) of object;
  TExtGridHeaderContainerOnMenucreate = procedure(Ct : TExtGridHeaderContainer; Menu : TExtMenu) of object;

  TExtGridHeaderContainer = class(TExtContainer)
  private
    FWeight : Integer;
    FDefaultWidth : Integer;
    FSealed : Boolean;
    FSortable : Boolean;
    FOnColumnresize : TExtGridHeaderContainerOnColumnresize;
    FOnHeaderclick : TExtGridHeaderContainerOnHeaderclick;
    FOnHeadertriggerclick : TExtGridHeaderContainerOnHeadertriggerclick;
    FOnColumnmove : TExtGridHeaderContainerOnColumnmove;
    FOnColumnhide : TExtGridHeaderContainerOnColumnhide;
    FOnColumnshow : TExtGridHeaderContainerOnColumnshow;
    FOnSortchange : TExtGridHeaderContainerOnSortchange;
    FOnMenucreate : TExtGridHeaderContainerOnMenucreate;
    procedure SetFWeight(Value : Integer);
    procedure SetFDefaultWidth(Value : Integer);
    procedure SetFSealed(Value : Boolean);
    procedure SetFSortable(Value : Boolean);
    procedure SetFOnColumnresize(Value : TExtGridHeaderContainerOnColumnresize);
    procedure SetFOnHeaderclick(Value : TExtGridHeaderContainerOnHeaderclick);
    procedure SetFOnHeadertriggerclick(Value : TExtGridHeaderContainerOnHeadertriggerclick);
    procedure SetFOnColumnmove(Value : TExtGridHeaderContainerOnColumnmove);
    procedure SetFOnColumnhide(Value : TExtGridHeaderContainerOnColumnhide);
    procedure SetFOnColumnshow(Value : TExtGridHeaderContainerOnColumnshow);
    procedure SetFOnSortchange(Value : TExtGridHeaderContainerOnSortchange);
    procedure SetFOnMenucreate(Value : TExtGridHeaderContainerOnMenucreate);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetMenuItems : TExtFunction;
    function GetColumnMenu : TExtFunction;
    function GetColumnCount : TExtFunction;
    function GetFullWidth : TExtFunction;
    function GetVisibleGridColumns(RefreshCache : Boolean) : TExtFunction;
    function GetGridColumns(RefreshCache : Boolean) : TExtFunction;
    function GetHeaderIndex(Header : TExtGridColumn) : TExtFunction;
    function GetHeaderAtIndex(The : Integer) : TExtFunction;
    function GetVisibleHeaderClosestToIndex(Index : Integer) : TExtFunction;
    function PrepareData : TExtFunction;
    property Weight : Integer read FWeight write SetFWeight;
    property DefaultWidth : Integer read FDefaultWidth write SetFDefaultWidth;
    property Sealed : Boolean read FSealed write SetFSealed;
    property Sortable : Boolean read FSortable write SetFSortable;
    property OnColumnresize : TExtGridHeaderContainerOnColumnresize read FOnColumnresize write SetFOnColumnresize;
    property OnHeaderclick : TExtGridHeaderContainerOnHeaderclick read FOnHeaderclick write SetFOnHeaderclick;
    property OnHeadertriggerclick : TExtGridHeaderContainerOnHeadertriggerclick read FOnHeadertriggerclick write SetFOnHeadertriggerclick;
    property OnColumnmove : TExtGridHeaderContainerOnColumnmove read FOnColumnmove write SetFOnColumnmove;
    property OnColumnhide : TExtGridHeaderContainerOnColumnhide read FOnColumnhide write SetFOnColumnhide;
    property OnColumnshow : TExtGridHeaderContainerOnColumnshow read FOnColumnshow write SetFOnColumnshow;
    property OnSortchange : TExtGridHeaderContainerOnSortchange read FOnSortchange write SetFOnSortchange;
    property OnMenucreate : TExtGridHeaderContainerOnMenucreate read FOnMenucreate write SetFOnMenucreate;
  end;

  TExtGridFeatureGroupingSummary = class(TExtGridFeatureGrouping)
  private
    FRemoteRoot : String;
    procedure SetFRemoteRoot(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property RemoteRoot : String read FRemoteRoot write SetFRemoteRoot;
  end;

  TExtContainerViewport = class(TExtContainer)
  private
    FIsViewport : Boolean;
    procedure SetFIsViewport(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsViewport : Boolean read FIsViewport write SetFIsViewport;
  end;

  TExtViewTable = class(TExtView)
  private
    FFirstCls : String;
    FLastCls : String;
    FStripeRows : Boolean;
    FMarkDirty : Boolean;
    FEnableTextSelection : Boolean;
    procedure SetFFirstCls(Value : String);
    procedure SetFLastCls(Value : String);
    procedure SetFStripeRows(Value : Boolean);
    procedure SetFMarkDirty(Value : Boolean);
    procedure SetFEnableTextSelection(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetFeature(Id : String) : TExtFunction;
    function GetTableChunker : TExtFunction;
    function AddRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : String; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : Integer; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : String; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : Integer; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; overload;
    function FocusRow(RowIdx : THTMLElement) : TExtFunction; overload;
    function FocusRow(RowIdx : String) : TExtFunction; overload;
    function FocusRow(RowIdx : Integer) : TExtFunction; overload;
    function FocusRow(RowIdx : TExtDataModel) : TExtFunction; overload;
    function Refresh : TExtFunction;
    property FirstCls : String read FFirstCls write SetFFirstCls;
    property LastCls : String read FLastCls write SetFLastCls;
    property StripeRows : Boolean read FStripeRows write SetFStripeRows;
    property MarkDirty : Boolean read FMarkDirty write SetFMarkDirty;
    property EnableTextSelection : Boolean read FEnableTextSelection write SetFEnableTextSelection;
  end;

  TExtContainerButtonGroup = class(TExtPanel)
  private
    FColumns : Integer;
    FBaseCls : String;
    FLayout : TExtObject;
    FFrame : Boolean;
    procedure SetFColumns(Value : Integer);
    procedure SetFBaseCls(Value : String);
    procedure SetFLayout(Value : TExtObject);
    procedure SetFFrame(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Columns : Integer read FColumns write SetFColumns;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Layout : TExtObject read FLayout write SetFLayout;
    property Frame : Boolean read FFrame write SetFFrame;
  end;

  TExtGridProperty = class(TExtDataModel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtComponentManagerSingleton = class(TExtAbstractManager)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; DefaultType : String = '');
  end;

  TExtImg = class(TExtComponent)
  private
    FSrc : String;
    FAlt : String;
    FImgCls : String;
    procedure SetFSrc(Value : String);
    procedure SetFAlt(Value : String);
    procedure SetFImgCls(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetSrc(Src : String) : TExtFunction;
    property Src : String read FSrc write SetFSrc;
    property Alt : String read FAlt write SetFAlt;
    property ImgCls : String read FImgCls write SetFImgCls;
  end;

  TExtGridPluginHeaderResizer = class(TExtAbstractPlugin)
  private
    FDynamic : Boolean;
    procedure SetFDynamic(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Dynamic : Boolean read FDynamic write SetFDynamic;
  end;

  TExtViewBoundList = class(TExtView)
  private
    FPageSize : Integer;
    FDisplayField : String;
    FTpl : String;
    FTplTExtXTemplate : TExtXTemplate;
    procedure SetFPageSize(Value : Integer);
    procedure SetFDisplayField(Value : String);
    procedure SetFTpl(Value : String);
    procedure SetFTplTExtXTemplate(Value : TExtXTemplate);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetInnerTpl(DisplayField : String) : TExtFunction;
    destructor Destroy; override;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property Tpl : String read FTpl write SetFTpl;
    property TplTExtXTemplate : TExtXTemplate read FTplTExtXTemplate write SetFTplTExtXTemplate;
  end;

  TExtGridPluginDragDrop = class(TExtAbstractPlugin)
  private
    FDdGroup : String;
    FDragGroup : String;
    FDropGroup : String;
    FEnableDrop : Boolean;
    FEnableDrag : Boolean;
    procedure SetFDdGroup(Value : String);
    procedure SetFDragGroup(Value : String);
    procedure SetFDropGroup(Value : String);
    procedure SetFEnableDrop(Value : Boolean);
    procedure SetFEnableDrag(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DragGroup : String read FDragGroup write SetFDragGroup;
    property DropGroup : String read FDropGroup write SetFDropGroup;
    property EnableDrop : Boolean read FEnableDrop write SetFEnableDrop;
    property EnableDrag : Boolean read FEnableDrag write SetFEnableDrag;
  end;

  // Procedural types for events TExtGridPluginEditing
  TExtGridPluginEditingOnBeforeedit = procedure(Editor : TExtGridPluginEditing; E : TExtObject) of object;
  TExtGridPluginEditingOnEdit = procedure(Editor : TExtGridPluginEditing; E : TExtObject) of object;
  TExtGridPluginEditingOnValidateedit = procedure(Editor : TExtGridPluginEditing; E : TExtObject) of object;
  TExtGridPluginEditingOnCanceledit = procedure(Editor : TExtGridPluginEditing; E : TExtObject) of object;

  TExtGridPluginEditing = class(TExtAbstractPlugin)
  private
    FClicksToEdit : Integer;
    FTriggerEvent : String;
    FOnBeforeedit : TExtGridPluginEditingOnBeforeedit;
    FOnEdit : TExtGridPluginEditingOnEdit;
    FOnValidateedit : TExtGridPluginEditingOnValidateedit;
    FOnCanceledit : TExtGridPluginEditingOnCanceledit;
    procedure SetFClicksToEdit(Value : Integer);
    procedure SetFTriggerEvent(Value : String);
    procedure SetFOnBeforeedit(Value : TExtGridPluginEditingOnBeforeedit);
    procedure SetFOnEdit(Value : TExtGridPluginEditingOnEdit);
    procedure SetFOnValidateedit(Value : TExtGridPluginEditingOnValidateedit);
    procedure SetFOnCanceledit(Value : TExtGridPluginEditingOnCanceledit);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; overload;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; overload;
    function CancelEdit : TExtFunction;
    function CompleteEdit : TExtFunction;
    property ClicksToEdit : Integer read FClicksToEdit write SetFClicksToEdit;
    property TriggerEvent : String read FTriggerEvent write SetFTriggerEvent;
    property OnBeforeedit : TExtGridPluginEditingOnBeforeedit read FOnBeforeedit write SetFOnBeforeedit;
    property OnEdit : TExtGridPluginEditingOnEdit read FOnEdit write SetFOnEdit;
    property OnValidateedit : TExtGridPluginEditingOnValidateedit read FOnValidateedit write SetFOnValidateedit;
    property OnCanceledit : TExtGridPluginEditingOnCanceledit read FOnCanceledit write SetFOnCanceledit;
  end;

  TExtTip = class(TExtPanel)
  private
    FClosable : Boolean;
    FWidth : Integer;
    FMinWidth : Integer;
    FMaxWidth : Integer;
    FShadow : Boolean;
    FShadowString : String;
    FDefaultAlign : String;
    FConstrainPosition : Boolean;
    FCloseAction : String;
    procedure SetFClosable(Value : Boolean);
    procedure SetFWidth(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFShadow(Value : Boolean);
    procedure SetFShadowString(Value : String);
    procedure SetFDefaultAlign(Value : String);
    procedure SetFConstrainPosition(Value : Boolean);
    procedure SetFCloseAction(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ShowAt(Xy : TArrayOfInteger) : TExtFunction;
    function ShowBy(El : String; Position : String = '') : TExtFunction; overload;
    function ShowBy(El : THTMLElement; Position : String = '') : TExtFunction; overload;
    function ShowBy(El : TExtElement; Position : String = '') : TExtFunction; overload;
    property Closable : Boolean read FClosable write SetFClosable;
    property Width : Integer read FWidth write SetFWidth;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property Shadow : Boolean read FShadow write SetFShadow;
    property ShadowString : String read FShadowString write SetFShadowString;
    property DefaultAlign : String read FDefaultAlign write SetFDefaultAlign;
    property ConstrainPosition : Boolean read FConstrainPosition write SetFConstrainPosition;
    property CloseAction : String read FCloseAction write SetFCloseAction;
  end;

  TExtChartAxisCategory = class(TExtChartAxis)
  private
    FCategoryNames : String;
    procedure SetFCategoryNames(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property CategoryNames : String read FCategoryNames write SetFCategoryNames;
  end;

  // Procedural types for events TExtToolbar
  TExtToolbarOnOverflowchange = procedure(C : TExtObject; LastOverflow : Boolean) of object;

  TExtToolbar = class(TExtContainer)
  private
    FVertical : Boolean;
    FLayout : String;
    FLayoutTExtObject : TExtObject;
    FEnableOverflow : Boolean;
    FMenuTriggerCls : String;
    FOnOverflowchange : TExtToolbarOnOverflowchange;
    procedure SetFVertical(Value : Boolean);
    procedure SetFLayout(Value : String);
    procedure SetFLayoutTExtObject(Value : TExtObject);
    procedure SetFEnableOverflow(Value : Boolean);
    procedure SetFMenuTriggerCls(Value : String);
    procedure SetFOnOverflowchange(Value : TExtToolbarOnOverflowchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function PrivateLookupComponent(Args : TExtObjectList) : TExtFunction;
    destructor Destroy; override;
    property Vertical : Boolean read FVertical write SetFVertical;
    property Layout : String read FLayout write SetFLayout;
    property LayoutTExtObject : TExtObject read FLayoutTExtObject write SetFLayoutTExtObject;
    property EnableOverflow : Boolean read FEnableOverflow write SetFEnableOverflow;
    property MenuTriggerCls : String read FMenuTriggerCls write SetFMenuTriggerCls;
    property OnOverflowchange : TExtToolbarOnOverflowchange read FOnOverflowchange write SetFOnOverflowchange;
  end;

  TExtUtilPoint = class(TExtUtilRegion)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function FromEvent(E : TEvent) : TExtFunction;
    constructor Create(X : Integer; Y : Integer);
    function ToString : TExtFunction;
    function Equals(The : TExtUtilPoint) : TExtFunction; overload;
    function Equals(The : TExtObject) : TExtFunction; overload;
    function IsWithin(P : TExtUtilPoint; Threshold : TExtObject) : TExtFunction; overload;
    function IsWithin(P : TExtObject; Threshold : TExtObject) : TExtFunction; overload;
    function IsWithin(P : TExtObject; Threshold : Integer) : TExtFunction; overload;
    function IsWithin(P : TExtUtilPoint; Threshold : Integer) : TExtFunction; overload;
    function RoundedEquals(P : TExtUtilPoint) : TExtFunction; overload;
    function RoundedEquals(P : TExtObject) : TExtFunction; overload;
  end;

  TExtStateLocalStorageProvider = class(TExtStateProvider)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartSeriesCartesian = class(TExtChartSeries)
  private
    FAxis : String;
    FAxisTExtObjectList : TExtObjectList;
    procedure SetFAxis(Value : String);
    procedure SetFAxisTExtObjectList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetMinMaxXValues : TExtFunction;
    function GetMinMaxYValues : TExtFunction;
    destructor Destroy; override;
    property Axis : String read FAxis write SetFAxis;
    property AxisTExtObjectList : TExtObjectList read FAxisTExtObjectList write SetFAxisTExtObjectList;
  end;

  TExtTabPanel = class(TExtPanel)
  private
    FTabPosition : String;
    FActiveItem : String;
    FActiveItemInteger : Integer;
    FActiveTab : String;
    FActiveTabInteger : Integer;
    FActiveTabTExtComponent : TExtComponent;
    FTabBar : TExtObject;
    FLayout : TExtObject;
    FRemovePanelHeader : Boolean;
    FPlain : Boolean;
    FItemCls : String;
    FMinTabWidth : Integer;
    FMaxTabWidth : Integer;
    FDeferredRender : Boolean;
    FTabBar_ : TExtTabBar;
    procedure SetFTabPosition(Value : String);
    procedure SetFActiveItem(Value : String);
    procedure SetFActiveItemInteger(Value : Integer);
    procedure SetFActiveTab(Value : String);
    procedure SetFActiveTabInteger(Value : Integer);
    procedure SetFActiveTabTExtComponent(Value : TExtComponent);
    procedure SetFTabBar(Value : TExtObject);
    procedure SetFLayout(Value : TExtObject);
    procedure SetFRemovePanelHeader(Value : Boolean);
    procedure SetFPlain(Value : Boolean);
    procedure SetFItemCls(Value : String);
    procedure SetFMinTabWidth(Value : Integer);
    procedure SetFMaxTabWidth(Value : Integer);
    procedure SetFDeferredRender(Value : Boolean);
    procedure SetFTabBar_(Value : TExtTabBar);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetActiveTab(Card : String) : TExtFunction; overload;
    function SetActiveTab(Card : Integer) : TExtFunction; overload;
    function SetActiveTab(Card : TExtComponent) : TExtFunction; overload;
    function GetActiveTab : TExtFunction;
    function GetTabBar : TExtFunction;
    destructor Destroy; override;
    property TabPosition : String read FTabPosition write SetFTabPosition;
    property ActiveItem : String read FActiveItem write SetFActiveItem;
    property ActiveItemInteger : Integer read FActiveItemInteger write SetFActiveItemInteger;
    property ActiveTab : String read FActiveTab write SetFActiveTab;
    property ActiveTabInteger : Integer read FActiveTabInteger write SetFActiveTabInteger;
    property ActiveTabTExtComponent : TExtComponent read FActiveTabTExtComponent write SetFActiveTabTExtComponent;
    property TabBar : TExtObject read FTabBar write SetFTabBar;
    property Layout : TExtObject read FLayout write SetFLayout;
    property RemovePanelHeader : Boolean read FRemovePanelHeader write SetFRemovePanelHeader;
    property Plain : Boolean read FPlain write SetFPlain;
    property ItemCls : String read FItemCls write SetFItemCls;
    property MinTabWidth : Integer read FMinTabWidth write SetFMinTabWidth;
    property MaxTabWidth : Integer read FMaxTabWidth write SetFMaxTabWidth;
    property DeferredRender : Boolean read FDeferredRender write SetFDeferredRender;
    property TabBar_ : TExtTabBar read FTabBar_ write SetFTabBar_;
  end;

  TExtToolbarSpacer = class(TExtComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtTreePluginTreeViewDragDrop = class(TExtAbstractPlugin)
  private
    FAllowParentInserts : Boolean;
    FAllowContainerDrops : Boolean;
    FAppendOnly : Boolean;
    FDdGroup : String;
    FDragGroup : String;
    FDropGroup : String;
    FExpandDelay : String;
    FEnableDrop : Boolean;
    FEnableDrag : Boolean;
    FNodeHighlightColor : String;
    FNodeHighlightOnDrop : Boolean;
    FNodeHighlightOnRepair : Boolean;
    procedure SetFAllowParentInserts(Value : Boolean);
    procedure SetFAllowContainerDrops(Value : Boolean);
    procedure SetFAppendOnly(Value : Boolean);
    procedure SetFDdGroup(Value : String);
    procedure SetFDragGroup(Value : String);
    procedure SetFDropGroup(Value : String);
    procedure SetFExpandDelay(Value : String);
    procedure SetFEnableDrop(Value : Boolean);
    procedure SetFEnableDrag(Value : Boolean);
    procedure SetFNodeHighlightColor(Value : String);
    procedure SetFNodeHighlightOnDrop(Value : Boolean);
    procedure SetFNodeHighlightOnRepair(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AllowParentInserts : Boolean read FAllowParentInserts write SetFAllowParentInserts;
    property AllowContainerDrops : Boolean read FAllowContainerDrops write SetFAllowContainerDrops;
    property AppendOnly : Boolean read FAppendOnly write SetFAppendOnly;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DragGroup : String read FDragGroup write SetFDragGroup;
    property DropGroup : String read FDropGroup write SetFDropGroup;
    property ExpandDelay : String read FExpandDelay write SetFExpandDelay;
    property EnableDrop : Boolean read FEnableDrop write SetFEnableDrop;
    property EnableDrag : Boolean read FEnableDrag write SetFEnableDrag;
    property NodeHighlightColor : String read FNodeHighlightColor write SetFNodeHighlightColor;
    property NodeHighlightOnDrop : Boolean read FNodeHighlightOnDrop write SetFNodeHighlightOnDrop;
    property NodeHighlightOnRepair : Boolean read FNodeHighlightOnRepair write SetFNodeHighlightOnRepair;
  end;

  TExtUtilComponentDragger = class(TExtDdDragTracker)
  private
    FConstrain : Boolean;
    FDelegate : String;
    FDelegateTExtElement : TExtElement;
    FConstrainDelegate : Boolean;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFDelegate(Value : String);
    procedure SetFDelegateTExtElement(Value : TExtElement);
    procedure SetFConstrainDelegate(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Comp : TExtObject; Config : TExtObject = nil); overload;
    destructor Destroy; override;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Delegate : String read FDelegate write SetFDelegate;
    property DelegateTExtElement : TExtElement read FDelegateTExtElement write SetFDelegateTExtElement;
    property ConstrainDelegate : Boolean read FConstrainDelegate write SetFConstrainDelegate;
  end;

  TExtToolbarItem = class(TExtComponent)
  private
    FOverflowText : String;
    procedure SetFOverflowText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property OverflowText : String read FOverflowText write SetFOverflowText;
  end;

  TExtChartAxisNumeric = class(TExtChartAxis)
  private
    FConstrain : Boolean;
    FDecimals : Integer;
    FPosition : String;
    FAdjustMinimumByMajorUnit : Boolean;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFDecimals(Value : Integer);
    procedure SetFPosition(Value : String);
    procedure SetFAdjustMinimumByMajorUnit(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Decimals : Integer read FDecimals write SetFDecimals;
    property Position : String read FPosition write SetFPosition;
    property AdjustMinimumByMajorUnit : Boolean read FAdjustMinimumByMajorUnit write SetFAdjustMinimumByMajorUnit;
  end;

  TExtToolbarFill = class(TExtComponent)
  private
    FIsFill : Boolean;
    procedure SetFIsFill(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsFill : Boolean read FIsFill write SetFIsFill;
  end;

  TExtUtilGrouper = class(TExtUtilSorter)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetGroupString(Instance : TExtDataModel) : TExtFunction;
  end;

  TExtPluginManager = class(TExtAbstractManager)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; DefaultType : TExtFunction = nil);
    function FindByType(TypeJS : String; DefaultsOnly : Boolean) : TExtFunction;
  end;

  // Procedural types for events TExtProgressBar
  TExtProgressBarOnUpdate = procedure(This : TExtProgressBar; Value : Integer; Text : String) of object;

  TExtProgressBar = class(TExtComponent)
  private
    FValue : Integer;
    FTextEl : String;
    FTextElTHTMLElement : THTMLElement;
    FTextElTExtElement : TExtElement;
    FId : String;
    FBaseCls : String;
    FAnimate : Boolean;
    FText : String;
    FOnUpdate : TExtProgressBarOnUpdate;
    procedure SetFValue(Value : Integer);
    procedure SetFTextEl(Value : String);
    procedure SetFTextElTHTMLElement(Value : THTMLElement);
    procedure SetFTextElTExtElement(Value : TExtElement);
    procedure SetFId(Value : String);
    procedure SetFBaseCls(Value : String);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFText(Value : String);
    procedure SetFOnUpdate(Value : TExtProgressBarOnUpdate);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function UpdateProgress(Value : Integer = 0; Text : String = ''; Animate : Boolean = false) : TExtFunction;
    function UpdateText(Text : String = '') : TExtFunction;
    function Wait(Config : TExtObject = nil; ConfigDuration : Integer = 0; ConfigInterval : Integer = 0; ConfigAnimate : Boolean = false; ConfigIncrement : Integer = 0; ConfigText : String = ''; ConfigFn : TExtFunction = nil; ConfigScope : TExtObject = nil) : TExtFunction;
    function IsWaiting : TExtFunction;
    function Reset(Hide : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property Value : Integer read FValue write SetFValue;
    property TextEl : String read FTextEl write SetFTextEl;
    property TextElTHTMLElement : THTMLElement read FTextElTHTMLElement write SetFTextElTHTMLElement;
    property TextElTExtElement : TExtElement read FTextElTExtElement write SetFTextElTExtElement;
    property Id : String read FId write SetFId;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property Text : String read FText write SetFText;
    property OnUpdate : TExtProgressBarOnUpdate read FOnUpdate write SetFOnUpdate;
  end;

  TExtChartSeriesPie = class(TExtChartSeries)
  private
    FHighlightDuration : Integer;
    FAngleField : String;
    FField : String;
    FXField : String;
    FLengthField : String;
    FDonut : Boolean;
    FDonutInteger : Integer;
    FShowInLegend : Boolean;
    FColorSet : TExtObjectList;
    FStyle : TExtObject;
    procedure SetFHighlightDuration(Value : Integer);
    procedure SetFAngleField(Value : String);
    procedure SetFField(Value : String);
    procedure SetFXField(Value : String);
    procedure SetFLengthField(Value : String);
    procedure SetFDonut(Value : Boolean);
    procedure SetFDonutInteger(Value : Integer);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFColorSet(Value : TExtObjectList);
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function HighlightItem(Info : TExtObject) : TExtFunction;
    function UnHighlightItem(Info : TExtObject) : TExtFunction;
    function GetLegendColor(Info : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property HighlightDuration : Integer read FHighlightDuration write SetFHighlightDuration;
    property AngleField : String read FAngleField write SetFAngleField;
    property Field : String read FField write SetFField;
    property XField : String read FXField write SetFXField;
    property LengthField : String read FLengthField write SetFLengthField;
    property Donut : Boolean read FDonut write SetFDonut;
    property DonutInteger : Integer read FDonutInteger write SetFDonutInteger;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property ColorSet : TExtObjectList read FColorSet write SetFColorSet;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  // Procedural types for events TExtPickerDate
  TExtPickerDateOnSelect = procedure(This : TExtPickerDate; Date : TDateTime) of object;

  TExtPickerDate = class(TExtComponent)
  private
    FTodayText : String;
    FAriaTitle : String;
    FAriaTitleDateFormat : String;
    FHandler : TExtFunction;
    FScope : TExtObject;
    FTodayTip : String;
    FMinText : String;
    FMaxText : String;
    FFormat : String;
    FDisabledDaysText : String;
    FDisabledDatesText : String;
    FMonthNames : TExtObjectList;
    FDayNames : TExtObjectList;
    FNextText : String;
    FPrevText : String;
    FMonthYearText : String;
    FMonthYearFormat : String;
    FStartDay : Integer; // 0
    FShowToday : Boolean;
    FMinDate : TDateTime;
    FMaxDate : TDateTime;
    FDisabledDays : TArrayOfInteger;
    FDisabledDatesRE : TRegExp;
    FDisabledDates : TExtObjectList;
    FDisableAnim : Boolean;
    FBaseCls : String;
    FSelectedCls : String;
    FDisabledCellCls : String;
    FLongDayFormat : String;
    FKeyNavConfig : TExtObject;
    FFocusOnShow : Boolean;
    FOnSelect : TExtPickerDateOnSelect;
    procedure SetFTodayText(Value : String);
    procedure SetFAriaTitle(Value : String);
    procedure SetFAriaTitleDateFormat(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFTodayTip(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFDisabledDaysText(Value : String);
    procedure SetFDisabledDatesText(Value : String);
    procedure SetFMonthNames(Value : TExtObjectList);
    procedure SetFDayNames(Value : TExtObjectList);
    procedure SetFNextText(Value : String);
    procedure SetFPrevText(Value : String);
    procedure SetFMonthYearText(Value : String);
    procedure SetFMonthYearFormat(Value : String);
    procedure SetFStartDay(Value : Integer);
    procedure SetFShowToday(Value : Boolean);
    procedure SetFMinDate(Value : TDateTime);
    procedure SetFMaxDate(Value : TDateTime);
    procedure SetFDisabledDays(Value : TArrayOfInteger);
    procedure SetFDisabledDatesRE(Value : TRegExp);
    procedure SetFDisabledDates(Value : TExtObjectList);
    procedure SetFDisableAnim(Value : Boolean);
    procedure SetFBaseCls(Value : String);
    procedure SetFSelectedCls(Value : String);
    procedure SetFDisabledCellCls(Value : String);
    procedure SetFLongDayFormat(Value : String);
    procedure SetFKeyNavConfig(Value : TExtObject);
    procedure SetFFocusOnShow(Value : Boolean);
    procedure SetFOnSelect(Value : TExtPickerDateOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetDisabledDates(DisabledDates : TExtObjectList) : TExtFunction; overload;
    function SetDisabledDates(DisabledDates : TRegExp) : TExtFunction; overload;
    function SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction;
    function SetMinDate(Value : TDateTime) : TExtFunction;
    function SetMaxDate(Value : TDateTime) : TExtFunction;
    function SetValue(Value : TDateTime) : TExtFunction;
    function GetValue : TExtFunction;
    function GetDayInitial : TExtFunction;
    function HideMonthPicker(Animate : Boolean = false) : TExtFunction;
    function ShowMonthPicker(Animate : Boolean = false) : TExtFunction;
    function ShowPrevMonth(E : TExtObject) : TExtFunction;
    function ShowNextMonth(E : TExtObject) : TExtFunction;
    function ShowPrevYear : TExtFunction;
    function ShowNextYear : TExtFunction;
    function SelectToday : TExtFunction;
    destructor Destroy; override;
    property TodayText : String read FTodayText write SetFTodayText;
    property AriaTitle : String read FAriaTitle write SetFAriaTitle;
    property AriaTitleDateFormat : String read FAriaTitleDateFormat write SetFAriaTitleDateFormat;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property TodayTip : String read FTodayTip write SetFTodayTip;
    property MinText : String read FMinText write SetFMinText;
    property MaxText : String read FMaxText write SetFMaxText;
    property Format : String read FFormat write SetFFormat;
    property DisabledDaysText : String read FDisabledDaysText write SetFDisabledDaysText;
    property DisabledDatesText : String read FDisabledDatesText write SetFDisabledDatesText;
    property MonthNames : TExtObjectList read FMonthNames write SetFMonthNames;
    property DayNames : TExtObjectList read FDayNames write SetFDayNames;
    property NextText : String read FNextText write SetFNextText;
    property PrevText : String read FPrevText write SetFPrevText;
    property MonthYearText : String read FMonthYearText write SetFMonthYearText;
    property MonthYearFormat : String read FMonthYearFormat write SetFMonthYearFormat;
    property StartDay : Integer read FStartDay write SetFStartDay;
    property ShowToday : Boolean read FShowToday write SetFShowToday;
    property MinDate : TDateTime read FMinDate write SetFMinDate;
    property MaxDate : TDateTime read FMaxDate write SetFMaxDate;
    property DisabledDays : TArrayOfInteger read FDisabledDays write SetFDisabledDays;
    property DisabledDatesRE : TRegExp read FDisabledDatesRE write SetFDisabledDatesRE;
    property DisabledDates : TExtObjectList read FDisabledDates write SetFDisabledDates;
    property DisableAnim : Boolean read FDisableAnim write SetFDisableAnim;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property SelectedCls : String read FSelectedCls write SetFSelectedCls;
    property DisabledCellCls : String read FDisabledCellCls write SetFDisabledCellCls;
    property LongDayFormat : String read FLongDayFormat write SetFLongDayFormat;
    property KeyNavConfig : TExtObject read FKeyNavConfig write SetFKeyNavConfig;
    property FocusOnShow : Boolean read FFocusOnShow write SetFFocusOnShow;
    property OnSelect : TExtPickerDateOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtPanelTable
  TExtPanelTableOnViewready = procedure(This : TExtPanelTable) of object;
  TExtPanelTableOnBeforeitemmousedown = procedure of object;
  TExtPanelTableOnBeforeitemmouseup = procedure of object;
  TExtPanelTableOnBeforeitemmouseenter = procedure of object;
  TExtPanelTableOnBeforeitemmouseleave = procedure of object;
  TExtPanelTableOnBeforeitemclick = procedure of object;
  TExtPanelTableOnBeforeitemdblclick = procedure of object;
  TExtPanelTableOnBeforeitemcontextmenu = procedure of object;
  TExtPanelTableOnItemmousedown = procedure of object;
  TExtPanelTableOnItemmouseup = procedure of object;
  TExtPanelTableOnItemmouseenter = procedure of object;
  TExtPanelTableOnItemmouseleave = procedure of object;
  TExtPanelTableOnItemclick = procedure of object;
  TExtPanelTableOnItemdblclick = procedure of object;
  TExtPanelTableOnItemcontextmenu = procedure of object;
  TExtPanelTableOnBeforecontainermousedown = procedure of object;
  TExtPanelTableOnBeforecontainermouseup = procedure of object;
  TExtPanelTableOnBeforecontainermouseover = procedure of object;
  TExtPanelTableOnBeforecontainermouseout = procedure of object;
  TExtPanelTableOnBeforecontainerclick = procedure of object;
  TExtPanelTableOnBeforecontainerdblclick = procedure of object;
  TExtPanelTableOnBeforecontainercontextmenu = procedure of object;
  TExtPanelTableOnContainermouseup = procedure of object;
  TExtPanelTableOnContainermouseover = procedure of object;
  TExtPanelTableOnContainermouseout = procedure of object;
  TExtPanelTableOnContainerclick = procedure of object;
  TExtPanelTableOnContainerdblclick = procedure of object;
  TExtPanelTableOnContainercontextmenu = procedure of object;
  TExtPanelTableOnSelectionchange = procedure of object;
  TExtPanelTableOnBeforeselect = procedure of object;
  TExtPanelTableOnSelect = procedure of object;
  TExtPanelTableOnBeforedeselect = procedure of object;
  TExtPanelTableOnDeselect = procedure of object;
  TExtPanelTableOnColumnresize = procedure of object;
  TExtPanelTableOnColumnmove = procedure of object;
  TExtPanelTableOnColumnhide = procedure of object;
  TExtPanelTableOnColumnshow = procedure of object;
  TExtPanelTableOnSortchange = procedure of object;
  TExtPanelTableOnCellclick = procedure(This : TExtPanelTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtPanelTableOnCelldblclick = procedure(This : TExtPanelTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;

  TExtPanelTable = class(TExtPanel)
  private
    FViewType : String;
    FViewConfig : TExtObject;
    FView : TExtViewTable;
    FSelType : String; // 'rowmodel'
    FSelModel : TExtSelectionModel;
    FSelModelTExtObject : TExtObject;
    FMultiSelect : Boolean;
    FSimpleSelect : Boolean;
    FStore : TExtDataStore;
    FScroll : String;
    FScrollBoolean : Boolean;
    FColumns : TExtObjectList;
    FColumnsTExtObject : TExtObject;
    FForceFit : Boolean;
    FFeatures : TExtObjectList;
    FHideHeaders : Boolean;
    FDeferRowRender : Boolean; // true
    FVerticalScroller : TExtObject;
    FSortableColumns : Boolean;
    FEnableLocking : Boolean;
    FEnableColumnMove : Boolean;
    FSealedColumns : Boolean;
    FEnableColumnResize : Boolean;
    FEnableColumnHide : Boolean;
    FColumnLines : Boolean;
    FRowLines : Boolean;
    FDisableSelection : Boolean;
    FEmptyText : String;
    FAllowDeselect : Boolean;
    FOptimizedColumnMove : Boolean;
    FOnViewready : TExtPanelTableOnViewready;
    FOnBeforeitemmousedown : TExtPanelTableOnBeforeitemmousedown;
    FOnBeforeitemmouseup : TExtPanelTableOnBeforeitemmouseup;
    FOnBeforeitemmouseenter : TExtPanelTableOnBeforeitemmouseenter;
    FOnBeforeitemmouseleave : TExtPanelTableOnBeforeitemmouseleave;
    FOnBeforeitemclick : TExtPanelTableOnBeforeitemclick;
    FOnBeforeitemdblclick : TExtPanelTableOnBeforeitemdblclick;
    FOnBeforeitemcontextmenu : TExtPanelTableOnBeforeitemcontextmenu;
    FOnItemmousedown : TExtPanelTableOnItemmousedown;
    FOnItemmouseup : TExtPanelTableOnItemmouseup;
    FOnItemmouseenter : TExtPanelTableOnItemmouseenter;
    FOnItemmouseleave : TExtPanelTableOnItemmouseleave;
    FOnItemclick : TExtPanelTableOnItemclick;
    FOnItemdblclick : TExtPanelTableOnItemdblclick;
    FOnItemcontextmenu : TExtPanelTableOnItemcontextmenu;
    FOnBeforecontainermousedown : TExtPanelTableOnBeforecontainermousedown;
    FOnBeforecontainermouseup : TExtPanelTableOnBeforecontainermouseup;
    FOnBeforecontainermouseover : TExtPanelTableOnBeforecontainermouseover;
    FOnBeforecontainermouseout : TExtPanelTableOnBeforecontainermouseout;
    FOnBeforecontainerclick : TExtPanelTableOnBeforecontainerclick;
    FOnBeforecontainerdblclick : TExtPanelTableOnBeforecontainerdblclick;
    FOnBeforecontainercontextmenu : TExtPanelTableOnBeforecontainercontextmenu;
    FOnContainermouseup : TExtPanelTableOnContainermouseup;
    FOnContainermouseover : TExtPanelTableOnContainermouseover;
    FOnContainermouseout : TExtPanelTableOnContainermouseout;
    FOnContainerclick : TExtPanelTableOnContainerclick;
    FOnContainerdblclick : TExtPanelTableOnContainerdblclick;
    FOnContainercontextmenu : TExtPanelTableOnContainercontextmenu;
    FOnSelectionchange : TExtPanelTableOnSelectionchange;
    FOnBeforeselect : TExtPanelTableOnBeforeselect;
    FOnSelect : TExtPanelTableOnSelect;
    FOnBeforedeselect : TExtPanelTableOnBeforedeselect;
    FOnDeselect : TExtPanelTableOnDeselect;
    FOnColumnresize : TExtPanelTableOnColumnresize;
    FOnColumnmove : TExtPanelTableOnColumnmove;
    FOnColumnhide : TExtPanelTableOnColumnhide;
    FOnColumnshow : TExtPanelTableOnColumnshow;
    FOnSortchange : TExtPanelTableOnSortchange;
    FOnCellclick : TExtPanelTableOnCellclick;
    FOnCelldblclick : TExtPanelTableOnCelldblclick;
    procedure SetFViewType(Value : String);
    procedure SetFViewConfig(Value : TExtObject);
    procedure SetFView(Value : TExtViewTable);
    procedure SetFSelType(Value : String);
    procedure SetFSelModel(Value : TExtSelectionModel);
    procedure SetFSelModelTExtObject(Value : TExtObject);
    procedure SetFMultiSelect(Value : Boolean);
    procedure SetFSimpleSelect(Value : Boolean);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFScroll(Value : String);
    procedure SetFScrollBoolean(Value : Boolean);
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFColumnsTExtObject(Value : TExtObject);
    procedure SetFForceFit(Value : Boolean);
    procedure SetFFeatures(Value : TExtObjectList);
    procedure SetFHideHeaders(Value : Boolean);
    procedure SetFDeferRowRender(Value : Boolean);
    procedure SetFVerticalScroller(Value : TExtObject);
    procedure SetFSortableColumns(Value : Boolean);
    procedure SetFEnableLocking(Value : Boolean);
    procedure SetFEnableColumnMove(Value : Boolean);
    procedure SetFSealedColumns(Value : Boolean);
    procedure SetFEnableColumnResize(Value : Boolean);
    procedure SetFEnableColumnHide(Value : Boolean);
    procedure SetFColumnLines(Value : Boolean);
    procedure SetFRowLines(Value : Boolean);
    procedure SetFDisableSelection(Value : Boolean);
    procedure SetFEmptyText(Value : String);
    procedure SetFAllowDeselect(Value : Boolean);
    procedure SetFOptimizedColumnMove(Value : Boolean);
    procedure SetFOnViewready(Value : TExtPanelTableOnViewready);
    procedure SetFOnBeforeitemmousedown(Value : TExtPanelTableOnBeforeitemmousedown);
    procedure SetFOnBeforeitemmouseup(Value : TExtPanelTableOnBeforeitemmouseup);
    procedure SetFOnBeforeitemmouseenter(Value : TExtPanelTableOnBeforeitemmouseenter);
    procedure SetFOnBeforeitemmouseleave(Value : TExtPanelTableOnBeforeitemmouseleave);
    procedure SetFOnBeforeitemclick(Value : TExtPanelTableOnBeforeitemclick);
    procedure SetFOnBeforeitemdblclick(Value : TExtPanelTableOnBeforeitemdblclick);
    procedure SetFOnBeforeitemcontextmenu(Value : TExtPanelTableOnBeforeitemcontextmenu);
    procedure SetFOnItemmousedown(Value : TExtPanelTableOnItemmousedown);
    procedure SetFOnItemmouseup(Value : TExtPanelTableOnItemmouseup);
    procedure SetFOnItemmouseenter(Value : TExtPanelTableOnItemmouseenter);
    procedure SetFOnItemmouseleave(Value : TExtPanelTableOnItemmouseleave);
    procedure SetFOnItemclick(Value : TExtPanelTableOnItemclick);
    procedure SetFOnItemdblclick(Value : TExtPanelTableOnItemdblclick);
    procedure SetFOnItemcontextmenu(Value : TExtPanelTableOnItemcontextmenu);
    procedure SetFOnBeforecontainermousedown(Value : TExtPanelTableOnBeforecontainermousedown);
    procedure SetFOnBeforecontainermouseup(Value : TExtPanelTableOnBeforecontainermouseup);
    procedure SetFOnBeforecontainermouseover(Value : TExtPanelTableOnBeforecontainermouseover);
    procedure SetFOnBeforecontainermouseout(Value : TExtPanelTableOnBeforecontainermouseout);
    procedure SetFOnBeforecontainerclick(Value : TExtPanelTableOnBeforecontainerclick);
    procedure SetFOnBeforecontainerdblclick(Value : TExtPanelTableOnBeforecontainerdblclick);
    procedure SetFOnBeforecontainercontextmenu(Value : TExtPanelTableOnBeforecontainercontextmenu);
    procedure SetFOnContainermouseup(Value : TExtPanelTableOnContainermouseup);
    procedure SetFOnContainermouseover(Value : TExtPanelTableOnContainermouseover);
    procedure SetFOnContainermouseout(Value : TExtPanelTableOnContainermouseout);
    procedure SetFOnContainerclick(Value : TExtPanelTableOnContainerclick);
    procedure SetFOnContainerdblclick(Value : TExtPanelTableOnContainerdblclick);
    procedure SetFOnContainercontextmenu(Value : TExtPanelTableOnContainercontextmenu);
    procedure SetFOnSelectionchange(Value : TExtPanelTableOnSelectionchange);
    procedure SetFOnBeforeselect(Value : TExtPanelTableOnBeforeselect);
    procedure SetFOnSelect(Value : TExtPanelTableOnSelect);
    procedure SetFOnBeforedeselect(Value : TExtPanelTableOnBeforedeselect);
    procedure SetFOnDeselect(Value : TExtPanelTableOnDeselect);
    procedure SetFOnColumnresize(Value : TExtPanelTableOnColumnresize);
    procedure SetFOnColumnmove(Value : TExtPanelTableOnColumnmove);
    procedure SetFOnColumnhide(Value : TExtPanelTableOnColumnhide);
    procedure SetFOnColumnshow(Value : TExtPanelTableOnColumnshow);
    procedure SetFOnSortchange(Value : TExtPanelTableOnSortchange);
    procedure SetFOnCellclick(Value : TExtPanelTableOnCellclick);
    procedure SetFOnCelldblclick(Value : TExtPanelTableOnCelldblclick);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetSelectionModel : TExtFunction;
    destructor Destroy; override;
    property ViewType : String read FViewType write SetFViewType;
    property ViewConfig : TExtObject read FViewConfig write SetFViewConfig;
    property View : TExtViewTable read FView write SetFView;
    property SelType : String read FSelType write SetFSelType;
    property SelModel : TExtSelectionModel read FSelModel write SetFSelModel;
    property SelModelTExtObject : TExtObject read FSelModelTExtObject write SetFSelModelTExtObject;
    property MultiSelect : Boolean read FMultiSelect write SetFMultiSelect;
    property SimpleSelect : Boolean read FSimpleSelect write SetFSimpleSelect;
    property Store : TExtDataStore read FStore write SetFStore;
    property Scroll : String read FScroll write SetFScroll;
    property ScrollBoolean : Boolean read FScrollBoolean write SetFScrollBoolean;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property ColumnsTExtObject : TExtObject read FColumnsTExtObject write SetFColumnsTExtObject;
    property ForceFit : Boolean read FForceFit write SetFForceFit;
    property Features : TExtObjectList read FFeatures write SetFFeatures;
    property HideHeaders : Boolean read FHideHeaders write SetFHideHeaders;
    property DeferRowRender : Boolean read FDeferRowRender write SetFDeferRowRender;
    property VerticalScroller : TExtObject read FVerticalScroller write SetFVerticalScroller;
    property SortableColumns : Boolean read FSortableColumns write SetFSortableColumns;
    property EnableLocking : Boolean read FEnableLocking write SetFEnableLocking;
    property EnableColumnMove : Boolean read FEnableColumnMove write SetFEnableColumnMove;
    property SealedColumns : Boolean read FSealedColumns write SetFSealedColumns;
    property EnableColumnResize : Boolean read FEnableColumnResize write SetFEnableColumnResize;
    property EnableColumnHide : Boolean read FEnableColumnHide write SetFEnableColumnHide;
    property ColumnLines : Boolean read FColumnLines write SetFColumnLines;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property DisableSelection : Boolean read FDisableSelection write SetFDisableSelection;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property AllowDeselect : Boolean read FAllowDeselect write SetFAllowDeselect;
    property OptimizedColumnMove : Boolean read FOptimizedColumnMove write SetFOptimizedColumnMove;
    property OnViewready : TExtPanelTableOnViewready read FOnViewready write SetFOnViewready;
    property OnBeforeitemmousedown : TExtPanelTableOnBeforeitemmousedown read FOnBeforeitemmousedown write SetFOnBeforeitemmousedown;
    property OnBeforeitemmouseup : TExtPanelTableOnBeforeitemmouseup read FOnBeforeitemmouseup write SetFOnBeforeitemmouseup;
    property OnBeforeitemmouseenter : TExtPanelTableOnBeforeitemmouseenter read FOnBeforeitemmouseenter write SetFOnBeforeitemmouseenter;
    property OnBeforeitemmouseleave : TExtPanelTableOnBeforeitemmouseleave read FOnBeforeitemmouseleave write SetFOnBeforeitemmouseleave;
    property OnBeforeitemclick : TExtPanelTableOnBeforeitemclick read FOnBeforeitemclick write SetFOnBeforeitemclick;
    property OnBeforeitemdblclick : TExtPanelTableOnBeforeitemdblclick read FOnBeforeitemdblclick write SetFOnBeforeitemdblclick;
    property OnBeforeitemcontextmenu : TExtPanelTableOnBeforeitemcontextmenu read FOnBeforeitemcontextmenu write SetFOnBeforeitemcontextmenu;
    property OnItemmousedown : TExtPanelTableOnItemmousedown read FOnItemmousedown write SetFOnItemmousedown;
    property OnItemmouseup : TExtPanelTableOnItemmouseup read FOnItemmouseup write SetFOnItemmouseup;
    property OnItemmouseenter : TExtPanelTableOnItemmouseenter read FOnItemmouseenter write SetFOnItemmouseenter;
    property OnItemmouseleave : TExtPanelTableOnItemmouseleave read FOnItemmouseleave write SetFOnItemmouseleave;
    property OnItemclick : TExtPanelTableOnItemclick read FOnItemclick write SetFOnItemclick;
    property OnItemdblclick : TExtPanelTableOnItemdblclick read FOnItemdblclick write SetFOnItemdblclick;
    property OnItemcontextmenu : TExtPanelTableOnItemcontextmenu read FOnItemcontextmenu write SetFOnItemcontextmenu;
    property OnBeforecontainermousedown : TExtPanelTableOnBeforecontainermousedown read FOnBeforecontainermousedown write SetFOnBeforecontainermousedown;
    property OnBeforecontainermouseup : TExtPanelTableOnBeforecontainermouseup read FOnBeforecontainermouseup write SetFOnBeforecontainermouseup;
    property OnBeforecontainermouseover : TExtPanelTableOnBeforecontainermouseover read FOnBeforecontainermouseover write SetFOnBeforecontainermouseover;
    property OnBeforecontainermouseout : TExtPanelTableOnBeforecontainermouseout read FOnBeforecontainermouseout write SetFOnBeforecontainermouseout;
    property OnBeforecontainerclick : TExtPanelTableOnBeforecontainerclick read FOnBeforecontainerclick write SetFOnBeforecontainerclick;
    property OnBeforecontainerdblclick : TExtPanelTableOnBeforecontainerdblclick read FOnBeforecontainerdblclick write SetFOnBeforecontainerdblclick;
    property OnBeforecontainercontextmenu : TExtPanelTableOnBeforecontainercontextmenu read FOnBeforecontainercontextmenu write SetFOnBeforecontainercontextmenu;
    property OnContainermouseup : TExtPanelTableOnContainermouseup read FOnContainermouseup write SetFOnContainermouseup;
    property OnContainermouseover : TExtPanelTableOnContainermouseover read FOnContainermouseover write SetFOnContainermouseover;
    property OnContainermouseout : TExtPanelTableOnContainermouseout read FOnContainermouseout write SetFOnContainermouseout;
    property OnContainerclick : TExtPanelTableOnContainerclick read FOnContainerclick write SetFOnContainerclick;
    property OnContainerdblclick : TExtPanelTableOnContainerdblclick read FOnContainerdblclick write SetFOnContainerdblclick;
    property OnContainercontextmenu : TExtPanelTableOnContainercontextmenu read FOnContainercontextmenu write SetFOnContainercontextmenu;
    property OnSelectionchange : TExtPanelTableOnSelectionchange read FOnSelectionchange write SetFOnSelectionchange;
    property OnBeforeselect : TExtPanelTableOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnSelect : TExtPanelTableOnSelect read FOnSelect write SetFOnSelect;
    property OnBeforedeselect : TExtPanelTableOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnDeselect : TExtPanelTableOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnColumnresize : TExtPanelTableOnColumnresize read FOnColumnresize write SetFOnColumnresize;
    property OnColumnmove : TExtPanelTableOnColumnmove read FOnColumnmove write SetFOnColumnmove;
    property OnColumnhide : TExtPanelTableOnColumnhide read FOnColumnhide write SetFOnColumnhide;
    property OnColumnshow : TExtPanelTableOnColumnshow read FOnColumnshow write SetFOnColumnshow;
    property OnSortchange : TExtPanelTableOnSortchange read FOnSortchange write SetFOnSortchange;
    property OnCellclick : TExtPanelTableOnCellclick read FOnCellclick write SetFOnCellclick;
    property OnCelldblclick : TExtPanelTableOnCelldblclick read FOnCelldblclick write SetFOnCelldblclick;
  end;

  // Procedural types for events TExtPanelTool
  TExtPanelToolOnClick = procedure(This : TExtPanelTool; E : TExtEventObject) of object;

  TExtPanelTool = class(TExtComponent)
  private
    FHandler : TExtFunction;
    FScope : TExtObject;
    FTypeJS : String;
    FTooltip : String;
    FTooltipTExtObject : TExtObject;
    FTooltipType : String;
    FStopEvent : Boolean;
    FOnClick : TExtPanelToolOnClick;
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFTypeJS(Value : String);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipTExtObject(Value : TExtObject);
    procedure SetFTooltipType(Value : String);
    procedure SetFStopEvent(Value : Boolean);
    procedure SetFOnClick(Value : TExtPanelToolOnClick);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetType(TypeJS : String) : TExtFunction;
    destructor Destroy; override;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipTExtObject : TExtObject read FTooltipTExtObject write SetFTooltipTExtObject;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property StopEvent : Boolean read FStopEvent write SetFStopEvent;
    property OnClick : TExtPanelToolOnClick read FOnClick write SetFOnClick;
  end;

  // Procedural types for events TExtPickerColor
  TExtPickerColorOnSelect = procedure(This : TExtPickerColor; Color : String) of object;

  TExtPickerColor = class(TExtComponent)
  private
    FComponentCls : String;
    FSelectedCls : String;
    FValue : String;
    FClickEvent : String;
    FAllowReselect : Boolean;
    FHandler : TExtFunction;
    FScope : TExtObject;
    FOnSelect : TExtPickerColorOnSelect;
    procedure SetFComponentCls(Value : String);
    procedure SetFSelectedCls(Value : String);
    procedure SetFValue(Value : String);
    procedure SetFClickEvent(Value : String);
    procedure SetFAllowReselect(Value : Boolean);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFOnSelect(Value : TExtPickerColorOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Select(Color : String; SuppressEvent : Boolean = false) : TExtFunction;
    function GetValue : TExtFunction;
    destructor Destroy; override;
    property ComponentCls : String read FComponentCls write SetFComponentCls;
    property SelectedCls : String read FSelectedCls write SetFSelectedCls;
    property Value : String read FValue write SetFValue;
    property ClickEvent : String read FClickEvent write SetFClickEvent;
    property AllowReselect : Boolean read FAllowReselect write SetFAllowReselect;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property OnSelect : TExtPickerColorOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtSelectionRowModel
  TExtSelectionRowModelOnBeforedeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnBeforeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnDeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnSelect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;

  TExtSelectionRowModel = class(TExtSelectionModel)
  private
    FEnableKeyNav : Boolean;
    FIgnoreRightMouseSelection : Boolean;
    FOnBeforedeselect : TExtSelectionRowModelOnBeforedeselect;
    FOnBeforeselect : TExtSelectionRowModelOnBeforeselect;
    FOnDeselect : TExtSelectionRowModelOnDeselect;
    FOnSelect : TExtSelectionRowModelOnSelect;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFIgnoreRightMouseSelection(Value : Boolean);
    procedure SetFOnBeforedeselect(Value : TExtSelectionRowModelOnBeforedeselect);
    procedure SetFOnBeforeselect(Value : TExtSelectionRowModelOnBeforeselect);
    procedure SetFOnDeselect(Value : TExtSelectionRowModelOnDeselect);
    procedure SetFOnSelect(Value : TExtSelectionRowModelOnSelect);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCurrentPosition : TExtFunction;
    function SelectNext(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    function SelectPrevious(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property IgnoreRightMouseSelection : Boolean read FIgnoreRightMouseSelection write SetFIgnoreRightMouseSelection;
    property OnBeforedeselect : TExtSelectionRowModelOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforeselect : TExtSelectionRowModelOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnDeselect : TExtSelectionRowModelOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnSelect : TExtSelectionRowModelOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtChartSeriesGauge = class(TExtChartSeries)
  private
    FHighlightDuration : Integer;
    FAngleField : String;
    FNeedle : Boolean;
    FDonut : Boolean;
    FDonutInteger : Integer;
    FShowInLegend : Boolean;
    FStyle : TExtObject;
    procedure SetFHighlightDuration(Value : Integer);
    procedure SetFAngleField(Value : String);
    procedure SetFNeedle(Value : Boolean);
    procedure SetFDonut(Value : Boolean);
    procedure SetFDonutInteger(Value : Integer);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function GetLegendColor(Info : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property HighlightDuration : Integer read FHighlightDuration write SetFHighlightDuration;
    property AngleField : String read FAngleField write SetFAngleField;
    property Needle : Boolean read FNeedle write SetFNeedle;
    property Donut : Boolean read FDonut write SetFDonut;
    property DonutInteger : Integer read FDonutInteger write SetFDonutInteger;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtStateCookieProvider = class(TExtStateProvider)
  private
    FPath : String; // '/'
    FExpires : TDateTime;
    FDomain : String; // 'www'
    FSecure : Boolean;
    procedure SetFPath(Value : String);
    procedure SetFExpires(Value : TDateTime);
    procedure SetFDomain(Value : String);
    procedure SetFSecure(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create; overload;
    constructor Create(Config : TExtObject = nil); overload;
    property Path : String read FPath write SetFPath;
    property Expires : TDateTime read FExpires write SetFExpires;
    property Domain : String read FDomain write SetFDomain;
    property Secure : Boolean read FSecure write SetFSecure;
  end;

  // Procedural types for events TExtSelectionCellModel
  TExtSelectionCellModelOnDeselect = procedure(This : TExtSelectionCellModel; RecordJS : TExtDataModel; Row : Integer; Column : Integer) of object;
  TExtSelectionCellModelOnSelect = procedure(This : TExtSelectionCellModel; RecordJS : TExtDataModel; Row : Integer; Column : Integer) of object;

  TExtSelectionCellModel = class(TExtSelectionModel)
  private
    FEnableKeyNav : Boolean;
    FPreventWrap : Boolean;
    FOnDeselect : TExtSelectionCellModelOnDeselect;
    FOnSelect : TExtSelectionCellModelOnSelect;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFPreventWrap(Value : Boolean);
    procedure SetFOnDeselect(Value : TExtSelectionCellModelOnDeselect);
    procedure SetFOnSelect(Value : TExtSelectionCellModelOnSelect);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCurrentPosition : TExtFunction;
    function SetCurrentPosition(Position : TExtObject) : TExtFunction;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property PreventWrap : Boolean read FPreventWrap write SetFPreventWrap;
    property OnDeselect : TExtSelectionCellModelOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnSelect : TExtSelectionCellModelOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtResizerHandle = class(TExtComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtButton
  TExtButtonOnClick = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnToggle = procedure(This : TExtButton; Pressed : Boolean) of object;
  TExtButtonOnMouseover = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnMouseout = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnMenushow = procedure(This : TExtButton; Menu : TExtMenu) of object;
  TExtButtonOnMenuhide = procedure(This : TExtButton; Menu : TExtMenu) of object;
  TExtButtonOnMenutriggerover = procedure(This : TExtButton; Menu : TExtMenu; E : TExtDirectEvent) of object;
  TExtButtonOnMenutriggerout = procedure(This : TExtButton; Menu : TExtMenu; E : TExtDirectEvent) of object;

  TExtButton = class(TExtComponent)
  private
    FText : String;
    FIcon : String;
    FHandler : TExtFunction;
    FMinWidth : Integer;
    FTooltip : String;
    FTooltipTExtObject : TExtObject;
    FHidden : Boolean;
    FDisabled : Boolean;
    FPressed : Boolean;
    FToggleGroup : String;
    FRepeatJS : Boolean;
    FRepeatJSTExtObject : TExtObject;
    FTabIndex : Integer;
    FAllowDepress : Boolean;
    FEnableToggle : Boolean;
    FToggleHandler : TExtFunction;
    FMenu : TExtMenu;
    FMenuString : String;
    FMenuTExtObject : TExtObject;
    FMenuAlign : String;
    FTextAlign : String;
    FOverflowText : String;
    FIconCls : String;
    FTypeJS : String;
    FClickEvent : String;
    FPreventDefault : Boolean;
    FHandleMouseEvents : Boolean;
    FTooltipType : String;
    FBaseCls : String;
    FPressedCls : String;
    FOverCls : String;
    FFocusCls : String;
    FMenuActiveCls : String;
    FHref : String;
    FHrefTarget : String;
    FBaseParams : TExtObject;
    FParams : TExtObject;
    FScale : String;
    FScope : TExtObject;
    FIconAlign : String;
    FArrowAlign : String;
    FArrowCls : String;
    FCls : String;
    FMenu_ : TExtMenu;
    FOnClick : TExtButtonOnClick;
    FOnToggle : TExtButtonOnToggle;
    FOnMouseover : TExtButtonOnMouseover;
    FOnMouseout : TExtButtonOnMouseout;
    FOnMenushow : TExtButtonOnMenushow;
    FOnMenuhide : TExtButtonOnMenuhide;
    FOnMenutriggerover : TExtButtonOnMenutriggerover;
    FOnMenutriggerout : TExtButtonOnMenutriggerout;
    procedure SetFText(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipTExtObject(Value : TExtObject);
    procedure SetFHidden(Value : Boolean);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFPressed(Value : Boolean);
    procedure SetFToggleGroup(Value : String);
    procedure SetFRepeatJS(Value : Boolean);
    procedure SetFRepeatJSTExtObject(Value : TExtObject);
    procedure SetFTabIndex(Value : Integer);
    procedure SetFAllowDepress(Value : Boolean);
    procedure SetFEnableToggle(Value : Boolean);
    procedure SetFToggleHandler(Value : TExtFunction);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFMenuString(Value : String);
    procedure SetFMenuTExtObject(Value : TExtObject);
    procedure SetFMenuAlign(Value : String);
    procedure SetFTextAlign(Value : String);
    procedure SetFOverflowText(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFClickEvent(Value : String);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFHandleMouseEvents(Value : Boolean);
    procedure SetFTooltipType(Value : String);
    procedure SetFBaseCls(Value : String);
    procedure SetFPressedCls(Value : String);
    procedure SetFOverCls(Value : String);
    procedure SetFFocusCls(Value : String);
    procedure SetFMenuActiveCls(Value : String);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFParams(Value : TExtObject);
    procedure SetFScale(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFIconAlign(Value : String);
    procedure SetFArrowAlign(Value : String);
    procedure SetFArrowCls(Value : String);
    procedure SetFCls(Value : String);
    procedure SetFMenu_(Value : TExtMenu);
    procedure SetFOnClick(Value : TExtButtonOnClick);
    procedure SetFOnToggle(Value : TExtButtonOnToggle);
    procedure SetFOnMouseover(Value : TExtButtonOnMouseover);
    procedure SetFOnMouseout(Value : TExtButtonOnMouseout);
    procedure SetFOnMenushow(Value : TExtButtonOnMenushow);
    procedure SetFOnMenuhide(Value : TExtButtonOnMenuhide);
    procedure SetFOnMenutriggerover(Value : TExtButtonOnMenutriggerover);
    procedure SetFOnMenutriggerout(Value : TExtButtonOnMenutriggerout);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTemplateArgs : TExtFunction;
    function SetParams(Params : TExtObject) : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function SetTooltip(Tooltip : String) : TExtFunction; overload;
    function SetTooltip(Tooltip : TExtObject) : TExtFunction; overload;
    function SetTextAlign(Align : String) : TExtFunction;
    function SetHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function SetText(Text : String) : TExtFunction;
    function SetIcon(Icon : String) : TExtFunction;
    function GetText : TExtFunction;
    function Toggle(State : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    function ShowMenu : TExtFunction;
    function HideMenu : TExtFunction;
    function HasVisibleMenu : TExtFunction;
    function SetScale(Scale : String) : TExtFunction;
    destructor Destroy; override;
    property Text : String read FText write SetFText;
    property Icon : String read FIcon write SetFIcon;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipTExtObject : TExtObject read FTooltipTExtObject write SetFTooltipTExtObject;
    property Hidden : Boolean read FHidden write SetFHidden;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property Pressed : Boolean read FPressed write SetFPressed;
    property ToggleGroup : String read FToggleGroup write SetFToggleGroup;
    property RepeatJS : Boolean read FRepeatJS write SetFRepeatJS;
    property RepeatJSTExtObject : TExtObject read FRepeatJSTExtObject write SetFRepeatJSTExtObject;
    property TabIndex : Integer read FTabIndex write SetFTabIndex;
    property AllowDepress : Boolean read FAllowDepress write SetFAllowDepress;
    property EnableToggle : Boolean read FEnableToggle write SetFEnableToggle;
    property ToggleHandler : TExtFunction read FToggleHandler write SetFToggleHandler;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property MenuString : String read FMenuString write SetFMenuString;
    property MenuTExtObject : TExtObject read FMenuTExtObject write SetFMenuTExtObject;
    property MenuAlign : String read FMenuAlign write SetFMenuAlign;
    property TextAlign : String read FTextAlign write SetFTextAlign;
    property OverflowText : String read FOverflowText write SetFOverflowText;
    property IconCls : String read FIconCls write SetFIconCls;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property ClickEvent : String read FClickEvent write SetFClickEvent;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property HandleMouseEvents : Boolean read FHandleMouseEvents write SetFHandleMouseEvents;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property PressedCls : String read FPressedCls write SetFPressedCls;
    property OverCls : String read FOverCls write SetFOverCls;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property MenuActiveCls : String read FMenuActiveCls write SetFMenuActiveCls;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property Params : TExtObject read FParams write SetFParams;
    property Scale : String read FScale write SetFScale;
    property Scope : TExtObject read FScope write SetFScope;
    property IconAlign : String read FIconAlign write SetFIconAlign;
    property ArrowAlign : String read FArrowAlign write SetFArrowAlign;
    property ArrowCls : String read FArrowCls write SetFArrowCls;
    property Cls : String read FCls write SetFCls;
    property Menu_ : TExtMenu read FMenu_ write SetFMenu_;
    property OnClick : TExtButtonOnClick read FOnClick write SetFOnClick;
    property OnToggle : TExtButtonOnToggle read FOnToggle write SetFOnToggle;
    property OnMouseover : TExtButtonOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseout : TExtButtonOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMenushow : TExtButtonOnMenushow read FOnMenushow write SetFOnMenushow;
    property OnMenuhide : TExtButtonOnMenuhide read FOnMenuhide write SetFOnMenuhide;
    property OnMenutriggerover : TExtButtonOnMenutriggerover read FOnMenutriggerover write SetFOnMenutriggerover;
    property OnMenutriggerout : TExtButtonOnMenutriggerout read FOnMenutriggerout write SetFOnMenutriggerout;
  end;

  TExtResizerSplitter = class(TExtComponent)
  private
    FCollapsible : Boolean;
    FPerformCollapse : Boolean;
    FCollapseOnDblClick : Boolean;
    FDefaultSplitMin : Integer;
    FDefaultSplitMax : Integer;
    FCollapsedCls : String;
    FCollapseTarget : String;
    FCollapseTargetTExtPanel : TExtPanel;
    FOrientation : String;
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFPerformCollapse(Value : Boolean);
    procedure SetFCollapseOnDblClick(Value : Boolean);
    procedure SetFDefaultSplitMin(Value : Integer);
    procedure SetFDefaultSplitMax(Value : Integer);
    procedure SetFCollapsedCls(Value : String);
    procedure SetFCollapseTarget(Value : String);
    procedure SetFCollapseTargetTExtPanel(Value : TExtPanel);
    procedure SetFOrientation(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property PerformCollapse : Boolean read FPerformCollapse write SetFPerformCollapse;
    property CollapseOnDblClick : Boolean read FCollapseOnDblClick write SetFCollapseOnDblClick;
    property DefaultSplitMin : Integer read FDefaultSplitMin write SetFDefaultSplitMin;
    property DefaultSplitMax : Integer read FDefaultSplitMax write SetFDefaultSplitMax;
    property CollapsedCls : String read FCollapsedCls write SetFCollapsedCls;
    property CollapseTarget : String read FCollapseTarget write SetFCollapseTarget;
    property CollapseTargetTExtPanel : TExtPanel read FCollapseTargetTExtPanel write SetFCollapseTargetTExtPanel;
    property Orientation : String read FOrientation write SetFOrientation;
  end;

  TExtFormActionLoad = class(TExtFormAction)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormActionSubmit = class(TExtFormAction)
  private
    FClientValidation : Boolean;
    procedure SetFClientValidation(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ClientValidation : Boolean read FClientValidation write SetFClientValidation;
  end;

  TExtDataField = class(TExtDataModel)
  private
    FSerialize : TExtFunction;
    FDateFormat : String;
    FUseNull : Boolean;
    FDefaultValue : TExtObject;
    FMapping : String;
    FMappingInteger : Integer;
    FSortType : TExtFunction;
    FSortDir : String; // 'ASC'
    FPersist : Boolean; // true
    procedure SetFSerialize(Value : TExtFunction);
    procedure SetFDateFormat(Value : String);
    procedure SetFUseNull(Value : Boolean);
    procedure SetFDefaultValue(Value : TExtObject);
    procedure SetFMapping(Value : String);
    procedure SetFMappingInteger(Value : Integer);
    procedure SetFSortType(Value : TExtFunction);
    procedure SetFSortDir(Value : String);
    procedure SetFPersist(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Serialize : TExtFunction read FSerialize write SetFSerialize;
    property DateFormat : String read FDateFormat write SetFDateFormat;
    property UseNull : Boolean read FUseNull write SetFUseNull;
    property DefaultValue : TExtObject read FDefaultValue write SetFDefaultValue;
    property Mapping : String read FMapping write SetFMapping;
    property MappingInteger : Integer read FMappingInteger write SetFMappingInteger;
    property SortType : TExtFunction read FSortType write SetFSortType;
    property SortDir : String read FSortDir write SetFSortDir;
    property Persist : Boolean read FPersist write SetFPersist;
  end;

  TExtDrawEngineVml = class(TExtDrawSurface)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtEditor
  TExtEditorOnBeforestartedit = procedure(This : TExtEditor; BoundEl : TExtElement; Value : TExtObject) of object;
  TExtEditorOnStartedit = procedure(This : TExtEditor; BoundEl : TExtElement; Value : TExtObject) of object;
  TExtEditorOnBeforecomplete = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnComplete = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnCanceledit = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnSpecialkey = procedure(This : TExtEditor; Field : TExtFormField; Event : TExtEventObject) of object;

  TExtEditor = class(TExtContainer)
  private
    FField : TExtFormField;
    FAllowBlur : Boolean;
    FAutoSize : Boolean;
    FAutoSizeTExtObject : TExtObject;
    FRevertInvalid : Boolean;
    FIgnoreNoChange : Boolean;
    FHideEl : Boolean;
    FValue : TExtObject;
    FAlignment : String;
    FOffsets : TArrayOfInteger;
    FShadow : Boolean;
    FShadowString : String;
    FConstrain : Boolean;
    FSwallowKeys : Boolean;
    FCompleteOnEnter : Boolean;
    FCancelOnEsc : Boolean;
    FUpdateEl : Boolean;
    FParentEl : String;
    FParentElTHTMLElement : THTMLElement;
    FParentElTExtElement : TExtElement;
    FOnBeforestartedit : TExtEditorOnBeforestartedit;
    FOnStartedit : TExtEditorOnStartedit;
    FOnBeforecomplete : TExtEditorOnBeforecomplete;
    FOnComplete : TExtEditorOnComplete;
    FOnCanceledit : TExtEditorOnCanceledit;
    FOnSpecialkey : TExtEditorOnSpecialkey;
    procedure SetFField(Value : TExtFormField);
    procedure SetFAllowBlur(Value : Boolean);
    procedure SetFAutoSize(Value : Boolean);
    procedure SetFAutoSizeTExtObject(Value : TExtObject);
    procedure SetFRevertInvalid(Value : Boolean);
    procedure SetFIgnoreNoChange(Value : Boolean);
    procedure SetFHideEl(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFAlignment(Value : String);
    procedure SetFOffsets(Value : TArrayOfInteger);
    procedure SetFShadow(Value : Boolean);
    procedure SetFShadowString(Value : String);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFSwallowKeys(Value : Boolean);
    procedure SetFCompleteOnEnter(Value : Boolean);
    procedure SetFCancelOnEsc(Value : Boolean);
    procedure SetFUpdateEl(Value : Boolean);
    procedure SetFParentEl(Value : String);
    procedure SetFParentElTHTMLElement(Value : THTMLElement);
    procedure SetFParentElTExtElement(Value : TExtElement);
    procedure SetFOnBeforestartedit(Value : TExtEditorOnBeforestartedit);
    procedure SetFOnStartedit(Value : TExtEditorOnStartedit);
    procedure SetFOnBeforecomplete(Value : TExtEditorOnBeforecomplete);
    procedure SetFOnComplete(Value : TExtEditorOnComplete);
    procedure SetFOnCanceledit(Value : TExtEditorOnCanceledit);
    procedure SetFOnSpecialkey(Value : TExtEditorOnSpecialkey);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function StartEdit(El : String; Value : String = '') : TExtFunction; overload;
    function StartEdit(El : THTMLElement; Value : String = '') : TExtFunction; overload;
    function StartEdit(El : TExtElement; Value : String = '') : TExtFunction; overload;
    function Realign(AutoSize : Boolean = false) : TExtFunction;
    function CompleteEdit(RemainVisible : Boolean = false) : TExtFunction;
    function CancelEdit(RemainVisible : Boolean = false) : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function GetValue : TExtFunction;
    destructor Destroy; override;
    property Field : TExtFormField read FField write SetFField;
    property AllowBlur : Boolean read FAllowBlur write SetFAllowBlur;
    property AutoSize : Boolean read FAutoSize write SetFAutoSize;
    property AutoSizeTExtObject : TExtObject read FAutoSizeTExtObject write SetFAutoSizeTExtObject;
    property RevertInvalid : Boolean read FRevertInvalid write SetFRevertInvalid;
    property IgnoreNoChange : Boolean read FIgnoreNoChange write SetFIgnoreNoChange;
    property HideEl : Boolean read FHideEl write SetFHideEl;
    property Value : TExtObject read FValue write SetFValue;
    property Alignment : String read FAlignment write SetFAlignment;
    property Offsets : TArrayOfInteger read FOffsets write SetFOffsets;
    property Shadow : Boolean read FShadow write SetFShadow;
    property ShadowString : String read FShadowString write SetFShadowString;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property SwallowKeys : Boolean read FSwallowKeys write SetFSwallowKeys;
    property CompleteOnEnter : Boolean read FCompleteOnEnter write SetFCompleteOnEnter;
    property CancelOnEsc : Boolean read FCancelOnEsc write SetFCancelOnEsc;
    property UpdateEl : Boolean read FUpdateEl write SetFUpdateEl;
    property ParentEl : String read FParentEl write SetFParentEl;
    property ParentElTHTMLElement : THTMLElement read FParentElTHTMLElement write SetFParentElTHTMLElement;
    property ParentElTExtElement : TExtElement read FParentElTExtElement write SetFParentElTExtElement;
    property OnBeforestartedit : TExtEditorOnBeforestartedit read FOnBeforestartedit write SetFOnBeforestartedit;
    property OnStartedit : TExtEditorOnStartedit read FOnStartedit write SetFOnStartedit;
    property OnBeforecomplete : TExtEditorOnBeforecomplete read FOnBeforecomplete write SetFOnBeforecomplete;
    property OnComplete : TExtEditorOnComplete read FOnComplete write SetFOnComplete;
    property OnCanceledit : TExtEditorOnCanceledit read FOnCanceledit write SetFOnCanceledit;
    property OnSpecialkey : TExtEditorOnSpecialkey read FOnSpecialkey write SetFOnSpecialkey;
  end;

  TExtFlashComponent = class(TExtComponent)
  private
    FFlashVersion : String;
    FBackgroundColor : String;
    FWmode : String;
    FFlashVars : TExtObject;
    FFlashParams : TExtObject;
    FFlashAttributes : TExtObject;
    FUrl : String;
    FSwfWidth : String; // '100%'
    FSwfWidthInteger : Integer;
    FSwfHeight : String; // '100%'
    FSwfHeightInteger : Integer;
    FExpressInstall : Boolean;
    FSwf : TExtElement;
    procedure SetFFlashVersion(Value : String);
    procedure SetFBackgroundColor(Value : String);
    procedure SetFWmode(Value : String);
    procedure SetFFlashVars(Value : TExtObject);
    procedure SetFFlashParams(Value : TExtObject);
    procedure SetFFlashAttributes(Value : TExtObject);
    procedure SetFUrl(Value : String);
    procedure SetFSwfWidth(Value : String);
    procedure SetFSwfWidthInteger(Value : Integer);
    procedure SetFSwfHeight(Value : String);
    procedure SetFSwfHeightInteger(Value : Integer);
    procedure SetFExpressInstall(Value : Boolean);
    procedure SetFSwf(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FlashVersion : String read FFlashVersion write SetFFlashVersion;
    property BackgroundColor : String read FBackgroundColor write SetFBackgroundColor;
    property Wmode : String read FWmode write SetFWmode;
    property FlashVars : TExtObject read FFlashVars write SetFFlashVars;
    property FlashParams : TExtObject read FFlashParams write SetFFlashParams;
    property FlashAttributes : TExtObject read FFlashAttributes write SetFFlashAttributes;
    property Url : String read FUrl write SetFUrl;
    property SwfWidth : String read FSwfWidth write SetFSwfWidth;
    property SwfWidthInteger : Integer read FSwfWidthInteger write SetFSwfWidthInteger;
    property SwfHeight : String read FSwfHeight write SetFSwfHeight;
    property SwfHeightInteger : Integer read FSwfHeightInteger write SetFSwfHeightInteger;
    property ExpressInstall : Boolean read FExpressInstall write SetFExpressInstall;
    property Swf : TExtElement read FSwf write SetFSwf;
  end;

  TExtFormFieldBase = class(TExtComponent)
  private
    FInputAttrTpl : String;
    FInputAttrTplTExtObjectList : TExtObjectList;
    FInputAttrTplTExtXTemplate : TExtXTemplate;
    FName : String;
    FInputType : String;
    FTabIndex : Integer;
    FInvalidText : String;
    FFieldCls : String;
    FFieldStyle : String;
    FFocusCls : String;
    FDirtyCls : String;
    FCheckChangeEvents : TExtObjectList;
    FCheckChangeBuffer : Integer; // 50
    FReadOnly : Boolean;
    FReadOnlyCls : String;
    FInputId : String;
    FValidateOnBlur : Boolean;
    FInputEl : TExtElement;
    procedure SetFInputAttrTpl(Value : String);
    procedure SetFInputAttrTplTExtObjectList(Value : TExtObjectList);
    procedure SetFInputAttrTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFName(Value : String);
    procedure SetFInputType(Value : String);
    procedure SetFTabIndex(Value : Integer);
    procedure SetFInvalidText(Value : String);
    procedure SetFFieldCls(Value : String);
    procedure SetFFieldStyle(Value : String);
    procedure SetFFocusCls(Value : String);
    procedure SetFDirtyCls(Value : String);
    procedure SetFCheckChangeEvents(Value : TExtObjectList);
    procedure SetFCheckChangeBuffer(Value : Integer);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFReadOnlyCls(Value : String);
    procedure SetFInputId(Value : String);
    procedure SetFValidateOnBlur(Value : Boolean);
    procedure SetFInputEl(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetSubTplMarkup : TExtFunction;
    function SetFieldStyle(Style : String) : TExtFunction; overload;
    function SetFieldStyle(Style : TExtObject) : TExtFunction; overload;
    function SetFieldStyle(Style : TExtFunction) : TExtFunction; overload;
    function GetSubmitValue : TExtFunction;
    function GetRawValue : TExtFunction;
    function SetRawValue(Value : TExtObject) : TExtFunction;
    function ValueToRaw(Value : TExtObject) : TExtFunction;
    function RawToValue(RawValue : TExtObject) : TExtFunction;
    function ProcessRawValue(Value : TExtObject) : TExtFunction;
    function GetValue : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function SetReadOnly(ReadOnly : Boolean) : TExtFunction;
    function IsValid : TExtFunction;
    function ValidateValue(Value : TExtObject) : TExtFunction;
    function MarkInvalid(Errors : String) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtObjectList) : TExtFunction; overload;
    function ClearInvalid : TExtFunction;
    destructor Destroy; override;
    property InputAttrTpl : String read FInputAttrTpl write SetFInputAttrTpl;
    property InputAttrTplTExtObjectList : TExtObjectList read FInputAttrTplTExtObjectList write SetFInputAttrTplTExtObjectList;
    property InputAttrTplTExtXTemplate : TExtXTemplate read FInputAttrTplTExtXTemplate write SetFInputAttrTplTExtXTemplate;
    property Name : String read FName write SetFName;
    property InputType : String read FInputType write SetFInputType;
    property TabIndex : Integer read FTabIndex write SetFTabIndex;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property FieldStyle : String read FFieldStyle write SetFFieldStyle;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property DirtyCls : String read FDirtyCls write SetFDirtyCls;
    property CheckChangeEvents : TExtObjectList read FCheckChangeEvents write SetFCheckChangeEvents;
    property CheckChangeBuffer : Integer read FCheckChangeBuffer write SetFCheckChangeBuffer;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property ReadOnlyCls : String read FReadOnlyCls write SetFReadOnlyCls;
    property InputId : String read FInputId write SetFInputId;
    property ValidateOnBlur : Boolean read FValidateOnBlur write SetFValidateOnBlur;
    property InputEl : TExtElement read FInputEl write SetFInputEl;
  end;

  TExtFormFieldHtmlEditor = class(TExtComponent)
  private
    FBeforeTextAreaTpl : String;
    FBeforeTextAreaTplTExtObjectList : TExtObjectList;
    FBeforeTextAreaTplTExtXTemplate : TExtXTemplate;
    FAfterTextAreaTpl : String;
    FAfterTextAreaTplTExtObjectList : TExtObjectList;
    FAfterTextAreaTplTExtXTemplate : TExtXTemplate;
    FBeforeIFrameTpl : String;
    FBeforeIFrameTplTExtObjectList : TExtObjectList;
    FBeforeIFrameTplTExtXTemplate : TExtXTemplate;
    FAfterIFrameTpl : String;
    FAfterIFrameTplTExtObjectList : TExtObjectList;
    FAfterIFrameTplTExtXTemplate : TExtXTemplate;
    FIframeAttrTpl : String;
    FIframeAttrTplTExtObjectList : TExtObjectList;
    FIframeAttrTplTExtXTemplate : TExtXTemplate;
    FEnableFormat : Boolean;
    FEnableFontSize : Boolean;
    FEnableColors : Boolean;
    FEnableAlignments : Boolean;
    FEnableLists : Boolean;
    FEnableSourceEdit : Boolean;
    FEnableLinks : Boolean;
    FEnableFont : Boolean;
    FCreateLinkText : String;
    FDefaultLinkValue : String;
    FFontFamilies : TExtObjectList;
    FDefaultValue : String;
    FFieldCls : String;
    procedure SetFBeforeTextAreaTpl(Value : String);
    procedure SetFBeforeTextAreaTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeTextAreaTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterTextAreaTpl(Value : String);
    procedure SetFAfterTextAreaTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterTextAreaTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBeforeIFrameTpl(Value : String);
    procedure SetFBeforeIFrameTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeIFrameTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterIFrameTpl(Value : String);
    procedure SetFAfterIFrameTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterIFrameTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFIframeAttrTpl(Value : String);
    procedure SetFIframeAttrTplTExtObjectList(Value : TExtObjectList);
    procedure SetFIframeAttrTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFEnableFormat(Value : Boolean);
    procedure SetFEnableFontSize(Value : Boolean);
    procedure SetFEnableColors(Value : Boolean);
    procedure SetFEnableAlignments(Value : Boolean);
    procedure SetFEnableLists(Value : Boolean);
    procedure SetFEnableSourceEdit(Value : Boolean);
    procedure SetFEnableLinks(Value : Boolean);
    procedure SetFEnableFont(Value : Boolean);
    procedure SetFCreateLinkText(Value : String);
    procedure SetFDefaultLinkValue(Value : String);
    procedure SetFFontFamilies(Value : TExtObjectList);
    procedure SetFDefaultValue(Value : String);
    procedure SetFFieldCls(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property BeforeTextAreaTpl : String read FBeforeTextAreaTpl write SetFBeforeTextAreaTpl;
    property BeforeTextAreaTplTExtObjectList : TExtObjectList read FBeforeTextAreaTplTExtObjectList write SetFBeforeTextAreaTplTExtObjectList;
    property BeforeTextAreaTplTExtXTemplate : TExtXTemplate read FBeforeTextAreaTplTExtXTemplate write SetFBeforeTextAreaTplTExtXTemplate;
    property AfterTextAreaTpl : String read FAfterTextAreaTpl write SetFAfterTextAreaTpl;
    property AfterTextAreaTplTExtObjectList : TExtObjectList read FAfterTextAreaTplTExtObjectList write SetFAfterTextAreaTplTExtObjectList;
    property AfterTextAreaTplTExtXTemplate : TExtXTemplate read FAfterTextAreaTplTExtXTemplate write SetFAfterTextAreaTplTExtXTemplate;
    property BeforeIFrameTpl : String read FBeforeIFrameTpl write SetFBeforeIFrameTpl;
    property BeforeIFrameTplTExtObjectList : TExtObjectList read FBeforeIFrameTplTExtObjectList write SetFBeforeIFrameTplTExtObjectList;
    property BeforeIFrameTplTExtXTemplate : TExtXTemplate read FBeforeIFrameTplTExtXTemplate write SetFBeforeIFrameTplTExtXTemplate;
    property AfterIFrameTpl : String read FAfterIFrameTpl write SetFAfterIFrameTpl;
    property AfterIFrameTplTExtObjectList : TExtObjectList read FAfterIFrameTplTExtObjectList write SetFAfterIFrameTplTExtObjectList;
    property AfterIFrameTplTExtXTemplate : TExtXTemplate read FAfterIFrameTplTExtXTemplate write SetFAfterIFrameTplTExtXTemplate;
    property IframeAttrTpl : String read FIframeAttrTpl write SetFIframeAttrTpl;
    property IframeAttrTplTExtObjectList : TExtObjectList read FIframeAttrTplTExtObjectList write SetFIframeAttrTplTExtObjectList;
    property IframeAttrTplTExtXTemplate : TExtXTemplate read FIframeAttrTplTExtXTemplate write SetFIframeAttrTplTExtXTemplate;
    property EnableFormat : Boolean read FEnableFormat write SetFEnableFormat;
    property EnableFontSize : Boolean read FEnableFontSize write SetFEnableFontSize;
    property EnableColors : Boolean read FEnableColors write SetFEnableColors;
    property EnableAlignments : Boolean read FEnableAlignments write SetFEnableAlignments;
    property EnableLists : Boolean read FEnableLists write SetFEnableLists;
    property EnableSourceEdit : Boolean read FEnableSourceEdit write SetFEnableSourceEdit;
    property EnableLinks : Boolean read FEnableLinks write SetFEnableLinks;
    property EnableFont : Boolean read FEnableFont write SetFEnableFont;
    property CreateLinkText : String read FCreateLinkText write SetFCreateLinkText;
    property DefaultLinkValue : String read FDefaultLinkValue write SetFDefaultLinkValue;
    property FontFamilies : TExtObjectList read FFontFamilies write SetFFontFamilies;
    property DefaultValue : String read FDefaultValue write SetFDefaultValue;
    property FieldCls : String read FFieldCls write SetFFieldCls;
  end;

  TExtXTemplate = class(TExtTemplate)
  private
    FCompiled : Boolean;
    FDefinitions : String;
    FDefinitionsTExtObjectList : TExtObjectList;
    procedure SetFCompiled(Value : Boolean);
    procedure SetFDefinitions(Value : String);
    procedure SetFDefinitionsTExtObjectList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Compile : TExtFunction;
    destructor Destroy; override;
    property Compiled : Boolean read FCompiled write SetFCompiled;
    property Definitions : String read FDefinitions write SetFDefinitions;
    property DefinitionsTExtObjectList : TExtObjectList read FDefinitionsTExtObjectList write SetFDefinitionsTExtObjectList;
  end;

  TExtFormFieldSet = class(TExtContainer)
  private
    FTitle : String;
    FCheckboxToggle : Boolean;
    FCheckboxName : String;
    FCollapsible : Boolean;
    FCollapsed : Boolean;
    FToggleOnTitleClick : Boolean;
    FBaseCls : String;
    FLayout : String;
    FCheckboxCmp : TExtFormFieldCheckbox;
    FToggleCmp : TExtPanelTool;
    procedure SetFTitle(Value : String);
    procedure SetFCheckboxToggle(Value : Boolean);
    procedure SetFCheckboxName(Value : String);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFToggleOnTitleClick(Value : Boolean);
    procedure SetFBaseCls(Value : String);
    procedure SetFLayout(Value : String);
    procedure SetFCheckboxCmp(Value : TExtFormFieldCheckbox);
    procedure SetFToggleCmp(Value : TExtPanelTool);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetTitle(Title : String) : TExtFunction;
    function Expand : TExtFunction;
    function Collapse : TExtFunction;
    function Toggle : TExtFunction;
    destructor Destroy; override;
    property Title : String read FTitle write SetFTitle;
    property CheckboxToggle : Boolean read FCheckboxToggle write SetFCheckboxToggle;
    property CheckboxName : String read FCheckboxName write SetFCheckboxName;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property ToggleOnTitleClick : Boolean read FToggleOnTitleClick write SetFToggleOnTitleClick;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Layout : String read FLayout write SetFLayout;
    property CheckboxCmp : TExtFormFieldCheckbox read FCheckboxCmp write SetFCheckboxCmp;
    property ToggleCmp : TExtPanelTool read FToggleCmp write SetFToggleCmp;
  end;

  TExtDataErrors = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function IsValid : TExtFunction;
    function GetByField(FieldName : String) : TExtFunction;
  end;

  TExtFormFieldContainer = class(TExtContainer)
  private
    FCombineLabels : Boolean;
    FLabelConnector : String; // ','
    FCombineErrors : Boolean;
    procedure SetFCombineLabels(Value : Boolean);
    procedure SetFLabelConnector(Value : String);
    procedure SetFCombineErrors(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetCombinedErrors(InvalidFields : TExtObjectList) : TExtFunction;
    property CombineLabels : Boolean read FCombineLabels write SetFCombineLabels;
    property LabelConnector : String read FLabelConnector write SetFLabelConnector;
    property CombineErrors : Boolean read FCombineErrors write SetFCombineErrors;
  end;

  TMyAppCoolPanelSingleton = class(TExtPanel)
  private
    FSingleton : Boolean;
    FAlternateClassName : String;
    FAlternateClassNameTExtObjectList : TExtObjectList;
    procedure SetFSingleton(Value : Boolean);
    procedure SetFAlternateClassName(Value : String);
    procedure SetFAlternateClassNameTExtObjectList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    destructor Destroy; override;
    property Singleton : Boolean read FSingleton write SetFSingleton;
    property AlternateClassName : String read FAlternateClassName write SetFAlternateClassName;
    property AlternateClassNameTExtObjectList : TExtObjectList read FAlternateClassNameTExtObjectList write SetFAlternateClassNameTExtObjectList;
  end;

  TExtDrawEngineSvg = class(TExtDrawSurface)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetRegion : TExtFunction;
    function ApplyZIndex(Sprite : TExtDrawSprite) : TExtFunction;
    function HasCls(Sprite : TExtDrawSprite; ClassName : String) : TExtFunction;
  end;

  TExtDdDDTarget = class(TExtDdDragDrop)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Id : String; SGroup : String; Config : TExtObject);
  end;

  TExtDataStoreManager = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Register(Stores : TExtDataStore) : TExtFunction;
    function Unregister(Stores : String) : TExtFunction; overload;
    function Unregister(Stores : TExtObjectList) : TExtFunction; overload;
    function Lookup(Store : String) : TExtFunction; overload;
    function Lookup(Store : TExtObject) : TExtFunction; overload;
  end;

  TExtDdStatusProxy = class(TExtComponent)
  private
    FDropAllowed : String;
    FDropNotAllowed : String;
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetStatus(CssClass : String) : TExtFunction;
    function Reset(ClearGhost : Boolean) : TExtFunction;
    function Update(Html : String) : TExtFunction; overload;
    function Update(Html : THTMLElement) : TExtFunction; overload;
    function GetGhost : TExtFunction;
    function Hide(Clear : Boolean) : TExtFunction;
    function Stop : TExtFunction;
    function Sync : TExtFunction;
    function Repair(Xy : TArrayOfInteger; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
  end;

  TExtDataUuidGenerator = class(TExtDataIdGenerator)
  private
    FVersion : Integer;
    procedure SetFVersion(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Version : Integer read FVersion write SetFVersion;
  end;

  TExtDataWriter = class(TExtDataModel)
  private
    FIsWriter : Boolean;
    procedure SetFIsWriter(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function Write(Request : TExtDataRequest) : TExtFunction;
    function GetRecordData(RecordJS : TExtDataModel; Operation : TExtDataOperation = nil) : TExtFunction;
    property IsWriter : Boolean read FIsWriter write SetFIsWriter;
  end;

  TExtDdDD = class(TExtDdDragDrop)
  private
    FScroll : Boolean;
    procedure SetFScroll(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AutoOffset(IPageX : Integer; IPageY : Integer) : TExtFunction;
    function SetDelta(IDeltaX : Integer; IDeltaY : Integer) : TExtFunction;
    function SetDragElPos(IPageX : Integer; IPageY : Integer) : TExtFunction;
    function AlignElWithMouse(El : THTMLElement; IPageX : Integer; IPageY : Integer) : TExtFunction;
    function CachePosition(IPageX : Integer = 0; IPageY : Integer = 0) : TExtFunction;
    function ApplyConfig : TExtFunction;
    function B4MouseDown : TExtFunction;
    function B4Drag : TExtFunction;
    property Scroll : Boolean read FScroll write SetFScroll;
  end;

  TExtDataSequentialIdGenerator = class(TExtDataIdGenerator)
  private
    FPrefix : String;
    FSeed : Integer;
    procedure SetFPrefix(Value : String);
    procedure SetFSeed(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Prefix : String read FPrefix write SetFPrefix;
    property Seed : Integer read FSeed write SetFSeed;
  end;

  TExtDataProxyRest = class(TExtDataProxyAjax)
  private
    FAppendId : Boolean; // true
    FFormat : String;
    FBatchActions : Boolean;
    FActionMethods : TExtObject;
    procedure SetFAppendId(Value : Boolean);
    procedure SetFFormat(Value : String);
    procedure SetFBatchActions(Value : Boolean);
    procedure SetFActionMethods(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property AppendId : Boolean read FAppendId write SetFAppendId;
    property Format : String read FFormat write SetFFormat;
    property BatchActions : Boolean read FBatchActions write SetFBatchActions;
    property ActionMethods : TExtObject read FActionMethods write SetFActionMethods;
  end;

  TExtDrawComponent = class(TExtComponent)
  private
    FEnginePriority : TExtObjectList;
    FViewBox : Boolean;
    FAutoSize : Boolean;
    FGradients : TExtObjectList;
    FItems : TExtObjectList;
    FSurface : TExtDrawSurface;
    procedure SetFEnginePriority(Value : TExtObjectList);
    procedure SetFViewBox(Value : Boolean);
    procedure SetFAutoSize(Value : Boolean);
    procedure SetFGradients(Value : TExtObjectList);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFSurface(Value : TExtDrawSurface);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property EnginePriority : TExtObjectList read FEnginePriority write SetFEnginePriority;
    property ViewBox : Boolean read FViewBox write SetFViewBox;
    property AutoSize : Boolean read FAutoSize write SetFAutoSize;
    property Gradients : TExtObjectList read FGradients write SetFGradients;
    property Items : TExtObjectList read FItems write SetFItems;
    property Surface : TExtDrawSurface read FSurface write SetFSurface;
  end;

  TExtDrawCompositeSprite = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetBBox : TExtFunction;
    function SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction;
    function Hide(Redraw : Boolean) : TExtFunction;
    function Show(Redraw : Boolean) : TExtFunction;
    function Redraw : TExtFunction;
    function SetStyle(Style : String) : TExtFunction;
    function AddCls(Cls : String) : TExtFunction;
    function RemoveCls(Cls : String) : TExtFunction;
  end;

  TExtDirectRemotingEvent = class(TExtDirectEvent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetTransaction : TExtFunction;
  end;

  TExtDataReader = class(TExtDataModel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDomCompositeElement = class(TExtDomCompositeElementLite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtWindow = class(TExtPanel)
  private
    FX : Integer;
    FY : Integer;
    FModal : Boolean;
    FAnimateTarget : String;
    FAnimateTargetTExtElement : TExtElement;
    FDefaultFocus : String;
    FDefaultFocusInteger : Integer;
    FDefaultFocusTExtComponent : TExtComponent;
    FOnEsc : TExtFunction;
    FCollapsed : Boolean;
    FMaximized : Boolean;
    FBaseCls : String;
    FResizable : Boolean;
    FResizableTExtObject : TExtObject;
    FDraggable : Boolean;
    FConstrain : Boolean;
    FConstrainHeader : Boolean;
    FConstrainTo : TExtUtilRegion;
    FConstrainToTExtElement : TExtElement;
    FPlain : Boolean;
    FMinimizable : Boolean;
    FMaximizable : Boolean;
    FExpandOnShow : Boolean;
    FClosable : Boolean;
    FHidden : Boolean;
    FIsWindow : Boolean;
    FDd : TExtUtilComponentDragger;
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
    procedure SetFModal(Value : Boolean);
    procedure SetFAnimateTarget(Value : String);
    procedure SetFAnimateTargetTExtElement(Value : TExtElement);
    procedure SetFDefaultFocus(Value : String);
    procedure SetFDefaultFocusInteger(Value : Integer);
    procedure SetFDefaultFocusTExtComponent(Value : TExtComponent);
    procedure SetFOnEsc(Value : TExtFunction);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFMaximized(Value : Boolean);
    procedure SetFBaseCls(Value : String);
    procedure SetFResizable(Value : Boolean);
    procedure SetFResizableTExtObject(Value : TExtObject);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFConstrainHeader(Value : Boolean);
    procedure SetFConstrainTo(Value : TExtUtilRegion);
    procedure SetFConstrainToTExtElement(Value : TExtElement);
    procedure SetFPlain(Value : Boolean);
    procedure SetFMinimizable(Value : Boolean);
    procedure SetFMaximizable(Value : Boolean);
    procedure SetFExpandOnShow(Value : Boolean);
    procedure SetFClosable(Value : Boolean);
    procedure SetFHidden(Value : Boolean);
    procedure SetFIsWindow(Value : Boolean);
    procedure SetFDd(Value : TExtUtilComponentDragger);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetDefaultFocus : TExtFunction;
    function Minimize : TExtFunction;
    function Maximize : TExtFunction;
    function Restore : TExtFunction;
    function ToggleMaximize : TExtFunction;
    destructor Destroy; override;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
    property Modal : Boolean read FModal write SetFModal;
    property AnimateTarget : String read FAnimateTarget write SetFAnimateTarget;
    property AnimateTargetTExtElement : TExtElement read FAnimateTargetTExtElement write SetFAnimateTargetTExtElement;
    property DefaultFocus : String read FDefaultFocus write SetFDefaultFocus;
    property DefaultFocusInteger : Integer read FDefaultFocusInteger write SetFDefaultFocusInteger;
    property DefaultFocusTExtComponent : TExtComponent read FDefaultFocusTExtComponent write SetFDefaultFocusTExtComponent;
    property OnEsc : TExtFunction read FOnEsc write SetFOnEsc;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property Maximized : Boolean read FMaximized write SetFMaximized;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Resizable : Boolean read FResizable write SetFResizable;
    property ResizableTExtObject : TExtObject read FResizableTExtObject write SetFResizableTExtObject;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property ConstrainHeader : Boolean read FConstrainHeader write SetFConstrainHeader;
    property ConstrainTo : TExtUtilRegion read FConstrainTo write SetFConstrainTo;
    property ConstrainToTExtElement : TExtElement read FConstrainToTExtElement write SetFConstrainToTExtElement;
    property Plain : Boolean read FPlain write SetFPlain;
    property Minimizable : Boolean read FMinimizable write SetFMinimizable;
    property Maximizable : Boolean read FMaximizable write SetFMaximizable;
    property ExpandOnShow : Boolean read FExpandOnShow write SetFExpandOnShow;
    property Closable : Boolean read FClosable write SetFClosable;
    property Hidden : Boolean read FHidden write SetFHidden;
    property IsWindow : Boolean read FIsWindow write SetFIsWindow;
    property Dd : TExtUtilComponentDragger read FDd write SetFDd;
  end;

  TExtFxTargetCompositeElement = class(TExtFxTargetElement)
  private
    FIsComposite : Boolean;
    procedure SetFIsComposite(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsComposite : Boolean read FIsComposite write SetFIsComposite;
  end;

  TExtDataAssociationHasOne = class(TExtDataAssociation)
  private
    FForeignKey : String; // '_id'
    FGetterName : String; // 'get'
    FSetterName : String; // 'set'
    FTypeJS : String;
    procedure SetFForeignKey(Value : String);
    procedure SetFGetterName(Value : String);
    procedure SetFSetterName(Value : String);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property GetterName : String read FGetterName write SetFGetterName;
    property SetterName : String read FSetterName write SetFSetterName;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtDataAssociationBelongsTo = class(TExtDataAssociation)
  private
    FForeignKey : String; // '_id'
    FGetterName : String; // 'get'
    FSetterName : String; // 'set'
    FTypeJS : String;
    procedure SetFForeignKey(Value : String);
    procedure SetFGetterName(Value : String);
    procedure SetFSetterName(Value : String);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property GetterName : String read FGetterName write SetFGetterName;
    property SetterName : String read FSetterName write SetFSetterName;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtFxTargetCompositeSprite = class(TExtFxTargetSprite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataAbstractStore = class(TExtDataModel)
  private
    FFilters : TExtObjectList;
    procedure SetFFilters(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetProxy(Proxy : String) : TExtFunction; overload;
    function SetProxy(Proxy : TExtObject) : TExtFunction; overload;
    function SetProxy(Proxy : TExtDataProxy) : TExtFunction; overload;
    function GetProxy : TExtFunction;
    function GetNewRecords : TExtFunction;
    function GetUpdatedRecords : TExtFunction;
    function GetModifiedRecords : TExtFunction;
    function GetRemovedRecords : TExtFunction;
    function Sync(Options : TExtObject = nil; OptionsBatch : TExtDataBatch = nil; OptionsCallback : TExtFunction = nil; OptionsCallbackBatch : TExtDataBatch = nil; OptionsCallbackOptions : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessBatch : TExtDataBatch = nil; OptionsSuccessOptions : TExtObject = nil; OptionsFailure : TExtFunction = nil; OptionsFailureBatch : TExtDataBatch = nil; OptionsFailureOptions : TExtObject = nil; OptionsScope : TExtObject = nil) : TExtFunction; overload;
    function Sync(Options : TExtObject; OptionsBatch : TExtObject; OptionsCallback : TExtFunction = nil; OptionsCallbackBatch : TExtDataBatch = nil; OptionsCallbackOptions : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessBatch : TExtDataBatch = nil; OptionsSuccessOptions : TExtObject = nil; OptionsFailure : TExtFunction = nil; OptionsFailureBatch : TExtDataBatch = nil; OptionsFailureOptions : TExtObject = nil; OptionsScope : TExtObject = nil) : TExtFunction; overload;
    function Save : TExtFunction;
    function Load(Options : TExtObject = nil) : TExtFunction;
    function Reload(Options : TExtObject) : TExtFunction;
    function SuspendAutoSync : TExtFunction;
    function ResumeAutoSync : TExtFunction;
    destructor Destroy; override;
    property Filters : TExtObjectList read FFilters write SetFFilters;
  end;

  TExtFormLabel = class(TExtComponent)
  private
    FText : String;
    FForId : String;
    FHtml : String;
    procedure SetFText(Value : String);
    procedure SetFForId(Value : String);
    procedure SetFHtml(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetText(Text : String; Encode : Boolean = false) : TExtFunction;
    property Text : String read FText write SetFText;
    property ForId : String read FForId write SetFForId;
    property Html : String read FHtml write SetFHtml;
  end;

  TExtDataAssociationHasMany = class(TExtDataAssociation)
  private
    FForeignKey : String; // '_id'
    FName : String;
    FStoreConfig : TExtObject;
    FFilterProperty : String;
    FTypeJS : String;
    procedure SetFForeignKey(Value : String);
    procedure SetFName(Value : String);
    procedure SetFStoreConfig(Value : TExtObject);
    procedure SetFFilterProperty(Value : String);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property Name : String read FName write SetFName;
    property StoreConfig : TExtObject read FStoreConfig write SetFStoreConfig;
    property FilterProperty : String read FFilterProperty write SetFFilterProperty;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtFxTargetElementCSS = class(TExtFxTargetElement)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormPanel
  TExtFormPanelOnBeforeaction = procedure of object;
  TExtFormPanelOnActionfailed = procedure of object;
  TExtFormPanelOnActioncomplete = procedure of object;
  TExtFormPanelOnValiditychange = procedure of object;
  TExtFormPanelOnDirtychange = procedure of object;

  TExtFormPanel = class(TExtPanel)
  private
    FPollForChanges : Boolean;
    FPollInterval : Integer; // 500
    FLayout : String; // 'anchor'
    FOnBeforeaction : TExtFormPanelOnBeforeaction;
    FOnActionfailed : TExtFormPanelOnActionfailed;
    FOnActioncomplete : TExtFormPanelOnActioncomplete;
    FOnValiditychange : TExtFormPanelOnValiditychange;
    FOnDirtychange : TExtFormPanelOnDirtychange;
    procedure SetFPollForChanges(Value : Boolean);
    procedure SetFPollInterval(Value : Integer);
    procedure SetFLayout(Value : String);
    procedure SetFOnBeforeaction(Value : TExtFormPanelOnBeforeaction);
    procedure SetFOnActionfailed(Value : TExtFormPanelOnActionfailed);
    procedure SetFOnActioncomplete(Value : TExtFormPanelOnActioncomplete);
    procedure SetFOnValiditychange(Value : TExtFormPanelOnValiditychange);
    procedure SetFOnDirtychange(Value : TExtFormPanelOnDirtychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetForm : TExtFunction;
    function LoadRecord(RecordJS : TExtDataModel) : TExtFunction;
    function GetRecord : TExtFunction;
    function GetValues : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function Submit(Options : TExtObject) : TExtFunction;
    function StartPolling(Interval : Integer) : TExtFunction;
    function StopPolling : TExtFunction;
    function CheckChange : TExtFunction;
    property PollForChanges : Boolean read FPollForChanges write SetFPollForChanges;
    property PollInterval : Integer read FPollInterval write SetFPollInterval;
    property Layout : String read FLayout write SetFLayout;
    property OnBeforeaction : TExtFormPanelOnBeforeaction read FOnBeforeaction write SetFOnBeforeaction;
    property OnActionfailed : TExtFormPanelOnActionfailed read FOnActionfailed write SetFOnActionfailed;
    property OnActioncomplete : TExtFormPanelOnActioncomplete read FOnActioncomplete write SetFOnActioncomplete;
    property OnValiditychange : TExtFormPanelOnValiditychange read FOnValiditychange write SetFOnValiditychange;
    property OnDirtychange : TExtFormPanelOnDirtychange read FOnDirtychange write SetFOnDirtychange;
  end;

  TExtChartSeriesBar = class(TExtChartSeriesCartesian)
  private
    FColumn : Boolean;
    FGutter : Integer;
    FGroupGutter : Integer;
    FXPadding : Integer;
    FYPadding : Integer;
    procedure SetFColumn(Value : Boolean);
    procedure SetFGutter(Value : Integer);
    procedure SetFGroupGutter(Value : Integer);
    procedure SetFXPadding(Value : Integer);
    procedure SetFYPadding(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function DrawSeries : TExtFunction;
    function GetLegendColor : TExtFunction;
    property Column : Boolean read FColumn write SetFColumn;
    property Gutter : Integer read FGutter write SetFGutter;
    property GroupGutter : Integer read FGroupGutter write SetFGroupGutter;
    property XPadding : Integer read FXPadding write SetFXPadding;
    property YPadding : Integer read FYPadding write SetFYPadding;
  end;

  // Procedural types for events TExtTab
  TExtTabOnActivate = procedure(This : TExtTab) of object;
  TExtTabOnDeactivate = procedure(This : TExtTab) of object;
  TExtTabOnBeforeclose = procedure(Tab : TExtTab) of object;
  TExtTabOnClose = procedure(Tab : TExtTab) of object;

  TExtTab = class(TExtButton)
  private
    FActiveCls : String;
    FDisabledCls : String;
    FClosableCls : String;
    FClosable : Boolean;
    FCloseText : String;
    FActive : Boolean;
    FClosable_ : Boolean;
    FOnActivate : TExtTabOnActivate;
    FOnDeactivate : TExtTabOnDeactivate;
    FOnBeforeclose : TExtTabOnBeforeclose;
    FOnClose : TExtTabOnClose;
    procedure SetFActiveCls(Value : String);
    procedure SetFDisabledCls(Value : String);
    procedure SetFClosableCls(Value : String);
    procedure SetFClosable(Value : Boolean);
    procedure SetFCloseText(Value : String);
    procedure SetFActive(Value : Boolean);
    procedure SetFClosable_(Value : Boolean);
    procedure SetFOnActivate(Value : TExtTabOnActivate);
    procedure SetFOnDeactivate(Value : TExtTabOnDeactivate);
    procedure SetFOnBeforeclose(Value : TExtTabOnBeforeclose);
    procedure SetFOnClose(Value : TExtTabOnClose);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetClosable(Closable : Boolean) : TExtFunction;
    function SetCard(Card : TExtComponent) : TExtFunction;
    property ActiveCls : String read FActiveCls write SetFActiveCls;
    property DisabledCls : String read FDisabledCls write SetFDisabledCls;
    property ClosableCls : String read FClosableCls write SetFClosableCls;
    property Closable : Boolean read FClosable write SetFClosable;
    property CloseText : String read FCloseText write SetFCloseText;
    property Active : Boolean read FActive write SetFActive;
    property Closable_ : Boolean read FClosable_ write SetFClosable_;
    property OnActivate : TExtTabOnActivate read FOnActivate write SetFOnActivate;
    property OnDeactivate : TExtTabOnDeactivate read FOnDeactivate write SetFOnDeactivate;
    property OnBeforeclose : TExtTabOnBeforeclose read FOnBeforeclose write SetFOnBeforeclose;
    property OnClose : TExtTabOnClose read FOnClose write SetFOnClose;
  end;

  TExtChartSeriesArea = class(TExtChartSeriesCartesian)
  private
    FStyle : TExtObject;
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function HighlightSeries(Item : TExtObject) : TExtFunction;
    function UnHighlightSeries(Item : TExtObject) : TExtFunction;
    function HighlightItem(Info : TExtObject) : TExtFunction;
    function UnHighlightItem(Item : TExtObject) : TExtFunction;
    function GetLegendColor(Item : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtDataStore = class(TExtDataAbstractStore)
  private
    FRemoteGroup : Boolean;
    FProxy : String;
    FProxyTExtDataProxy : TExtDataProxy;
    FProxyTExtObject : TExtObject;
    FData : TExtObjectList;
    FDataTExtObjectList : TExtObjectList;
    FGroupField : String;
    FGroupDir : String;
    FTrailingBufferZone : Integer;
    FLeadingBufferZone : Integer;
    FPageSize : Integer; // 25
    FClearOnPageLoad : Boolean;
    FSortOnFilter : Boolean; // true
    FPurgePageCount : Integer;
    FClearRemovedOnLoad : Boolean;
    FData_ : TExtObjectList;
    FGroupers : TExtObjectList;
    FSnapshot : TExtObjectList;
    procedure SetFRemoteGroup(Value : Boolean);
    procedure SetFProxy(Value : String);
    procedure SetFProxyTExtDataProxy(Value : TExtDataProxy);
    procedure SetFProxyTExtObject(Value : TExtObject);
    procedure SetFData(Value : TExtObjectList);
    procedure SetFDataTExtObjectList(Value : TExtObjectList);
    procedure SetFGroupField(Value : String);
    procedure SetFGroupDir(Value : String);
    procedure SetFTrailingBufferZone(Value : Integer);
    procedure SetFLeadingBufferZone(Value : Integer);
    procedure SetFPageSize(Value : Integer);
    procedure SetFClearOnPageLoad(Value : Boolean);
    procedure SetFSortOnFilter(Value : Boolean);
    procedure SetFPurgePageCount(Value : Integer);
    procedure SetFClearRemovedOnLoad(Value : Boolean);
    procedure SetFData_(Value : TExtObjectList);
    procedure SetFGroupers(Value : TExtObjectList);
    procedure SetFSnapshot(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ClearFilter(SuppressEvent : Boolean) : TExtFunction;
    function IsFiltered : TExtFunction;
    function FilterBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil) : TExtFunction;
    function QueryBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil) : TExtFunction;
    function Query(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function Query(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function LoadData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; overload;
    function LoadRawData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction;
    function LoadRecords(Records : TExtObjectList; Options : TExtObject; OptionsAddRecords : Boolean = false; Param : Integer = 0) : TExtFunction;
    function LoadPage(Page : Integer; Options : TExtObject) : TExtFunction;
    function NextPage(Options : TExtObject) : TExtFunction;
    function PreviousPage(Options : TExtObject) : TExtFunction;
    function Prefetch(Options : TExtObject = nil) : TExtFunction;
    function PrefetchPage(Page : Integer; Options : TExtObject = nil) : TExtFunction;
    function GetPageFromRecordIndex(Index : Integer) : TExtFunction;
    function PrefetchRange : TExtFunction;
    function GuaranteeRange : TExtFunction;
    function Find(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function Find(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function FindRecord(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function FindRecord(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function FindExact(FieldName : String; Value : TExtObject; StartIndex : Integer = 0) : TExtFunction;
    function FindBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil; StartIndex : Integer = 0) : TExtFunction;
    function Collect(DataIndex : String; AllowNull : Boolean = false; BypassFilter : Boolean = false) : TExtFunction;
    function GetCount : TExtFunction;
    function GetTotalCount : TExtFunction;
    function GetAt(Index : Integer) : TExtFunction;
    function GetRange(StartIndex : Integer = 0; EndIndex : Integer = 0) : TExtFunction;
    function GetById(Id : String) : TExtFunction;
    function IndexOf(RecordJS : TExtDataModel) : TExtFunction;
    function IndexOfTotal(RecordJS : TExtDataModel) : TExtFunction;
    function IndexOfId(Id : String) : TExtFunction;
    function RemoveAll(Silent : Boolean) : TExtFunction;
    function First(Grouped : Boolean = false) : TExtFunction;
    function Last(Grouped : Boolean = false) : TExtFunction;
    function Sum(Field : String; Grouped : Boolean = false) : TExtFunction;
    function Count(Grouped : Boolean = false) : TExtFunction;
    function Min(Field : String; Grouped : Boolean = false) : TExtFunction;
    function Max(Field : String; Grouped : Boolean = false) : TExtFunction;
    function Average(Field : String; Grouped : Boolean = false) : TExtFunction;
    function Aggregate(Fn : TExtFunction; Scope : TExtObject = nil; Grouped : Boolean = false; Args : TExtObjectList = nil) : TExtFunction;
    function CommitChanges : TExtFunction;
    function RejectChanges : TExtFunction;
    destructor Destroy; override;
    property RemoteGroup : Boolean read FRemoteGroup write SetFRemoteGroup;
    property Proxy : String read FProxy write SetFProxy;
    property ProxyTExtDataProxy : TExtDataProxy read FProxyTExtDataProxy write SetFProxyTExtDataProxy;
    property ProxyTExtObject : TExtObject read FProxyTExtObject write SetFProxyTExtObject;
    property Data : TExtObjectList read FData write SetFData;
    property DataTExtObjectList : TExtObjectList read FDataTExtObjectList write SetFDataTExtObjectList;
    property GroupField : String read FGroupField write SetFGroupField;
    property GroupDir : String read FGroupDir write SetFGroupDir;
    property TrailingBufferZone : Integer read FTrailingBufferZone write SetFTrailingBufferZone;
    property LeadingBufferZone : Integer read FLeadingBufferZone write SetFLeadingBufferZone;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property ClearOnPageLoad : Boolean read FClearOnPageLoad write SetFClearOnPageLoad;
    property SortOnFilter : Boolean read FSortOnFilter write SetFSortOnFilter;
    property PurgePageCount : Integer read FPurgePageCount write SetFPurgePageCount;
    property ClearRemovedOnLoad : Boolean read FClearRemovedOnLoad write SetFClearRemovedOnLoad;
    property Data_ : TExtObjectList read FData_ write SetFData_;
    property Groupers : TExtObjectList read FGroupers write SetFGroupers;
    property Snapshot : TExtObjectList read FSnapshot write SetFSnapshot;
  end;

  // Procedural types for events TExtTabBar
  TExtTabBarOnChange = procedure(TabBar : TExtTabBar; Tab : TExtTab; Card : TExtComponent) of object;

  TExtTabBar = class(TExtPanelHeader)
  private
    FTitle : String;
    FPlain : Boolean;
    FMinTabWidth : Integer;
    FMaxTabWidth : Integer;
    FOnChange : TExtTabBarOnChange;
    procedure SetFTitle(Value : String);
    procedure SetFPlain(Value : Boolean);
    procedure SetFMinTabWidth(Value : Integer);
    procedure SetFMaxTabWidth(Value : Integer);
    procedure SetFOnChange(Value : TExtTabBarOnChange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Title : String read FTitle write SetFTitle;
    property Plain : Boolean read FPlain write SetFPlain;
    property MinTabWidth : Integer read FMinTabWidth write SetFMinTabWidth;
    property MaxTabWidth : Integer read FMaxTabWidth write SetFMaxTabWidth;
    property OnChange : TExtTabBarOnChange read FOnChange write SetFOnChange;
  end;

  TExtFormActionDirectSubmit = class(TExtFormActionSubmit)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtSliderMulti
  TExtSliderMultiOnBeforechange = procedure(Slider : TExtSliderMulti; NewValue : Integer; OldValue : Integer) of object;
  TExtSliderMultiOnChange = procedure(Slider : TExtSliderMulti; NewValue : Integer; Thumb : TExtSliderThumb) of object;
  TExtSliderMultiOnChangecomplete = procedure(Slider : TExtSliderMulti; NewValue : Integer; Thumb : TExtSliderThumb) of object;
  TExtSliderMultiOnDragstart = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;
  TExtSliderMultiOnDrag = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;
  TExtSliderMultiOnDragend = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;

  TExtSliderMulti = class(TExtFormFieldBase)
  private
    FValue : Integer;
    FValues : TArrayOfInteger;
    FVertical : Boolean;
    FMinValue : Integer;
    FMaxValue : Integer;
    FDecimalPrecision : Integer;
    FDecimalPrecisionBoolean : Boolean;
    FKeyIncrement : Integer;
    FIncrement : Integer;
    FZeroBasedSnapping : Boolean;
    FClickToChange : Boolean;
    FAnimate : Boolean;
    FConstrainThumbs : Boolean;
    FUseTips : TExtObject;
    FUseTipsBoolean : Boolean;
    FTipText : TExtFunction;
    FThumbs : TExtObjectList;
    FOnBeforechange : TExtSliderMultiOnBeforechange;
    FOnChange : TExtSliderMultiOnChange;
    FOnChangecomplete : TExtSliderMultiOnChangecomplete;
    FOnDragstart : TExtSliderMultiOnDragstart;
    FOnDrag : TExtSliderMultiOnDrag;
    FOnDragend : TExtSliderMultiOnDragend;
    procedure SetFValue(Value : Integer);
    procedure SetFValues(Value : TArrayOfInteger);
    procedure SetFVertical(Value : Boolean);
    procedure SetFMinValue(Value : Integer);
    procedure SetFMaxValue(Value : Integer);
    procedure SetFDecimalPrecision(Value : Integer);
    procedure SetFDecimalPrecisionBoolean(Value : Boolean);
    procedure SetFKeyIncrement(Value : Integer);
    procedure SetFIncrement(Value : Integer);
    procedure SetFZeroBasedSnapping(Value : Boolean);
    procedure SetFClickToChange(Value : Boolean);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFConstrainThumbs(Value : Boolean);
    procedure SetFUseTips(Value : TExtObject);
    procedure SetFUseTipsBoolean(Value : Boolean);
    procedure SetFTipText(Value : TExtFunction);
    procedure SetFThumbs(Value : TExtObjectList);
    procedure SetFOnBeforechange(Value : TExtSliderMultiOnBeforechange);
    procedure SetFOnChange(Value : TExtSliderMultiOnChange);
    procedure SetFOnChangecomplete(Value : TExtSliderMultiOnChangecomplete);
    procedure SetFOnDragstart(Value : TExtSliderMultiOnDragstart);
    procedure SetFOnDrag(Value : TExtSliderMultiOnDrag);
    procedure SetFOnDragend(Value : TExtSliderMultiOnDragend);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function AddThumb(Value : Integer = 0) : TExtFunction;
    function SetMinValue(Val : Integer) : TExtFunction;
    function SetMaxValue(Val : Integer) : TExtFunction;
    function SetValue(Index : Integer; Value : Integer; Animate : Boolean = false) : TExtFunction;
    function SyncThumbs : TExtFunction;
    function GetValue(Index : Integer) : TExtFunction;
    function GetValues : TExtFunction;
    destructor Destroy; override;
    property Value : Integer read FValue write SetFValue;
    property Values : TArrayOfInteger read FValues write SetFValues;
    property Vertical : Boolean read FVertical write SetFVertical;
    property MinValue : Integer read FMinValue write SetFMinValue;
    property MaxValue : Integer read FMaxValue write SetFMaxValue;
    property DecimalPrecision : Integer read FDecimalPrecision write SetFDecimalPrecision;
    property DecimalPrecisionBoolean : Boolean read FDecimalPrecisionBoolean write SetFDecimalPrecisionBoolean;
    property KeyIncrement : Integer read FKeyIncrement write SetFKeyIncrement;
    property Increment : Integer read FIncrement write SetFIncrement;
    property ZeroBasedSnapping : Boolean read FZeroBasedSnapping write SetFZeroBasedSnapping;
    property ClickToChange : Boolean read FClickToChange write SetFClickToChange;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property ConstrainThumbs : Boolean read FConstrainThumbs write SetFConstrainThumbs;
    property UseTips : TExtObject read FUseTips write SetFUseTips;
    property UseTipsBoolean : Boolean read FUseTipsBoolean write SetFUseTipsBoolean;
    property TipText : TExtFunction read FTipText write SetFTipText;
    property Thumbs : TExtObjectList read FThumbs write SetFThumbs;
    property OnBeforechange : TExtSliderMultiOnBeforechange read FOnBeforechange write SetFOnBeforechange;
    property OnChange : TExtSliderMultiOnChange read FOnChange write SetFOnChange;
    property OnChangecomplete : TExtSliderMultiOnChangecomplete read FOnChangecomplete write SetFOnChangecomplete;
    property OnDragstart : TExtSliderMultiOnDragstart read FOnDragstart write SetFOnDragstart;
    property OnDrag : TExtSliderMultiOnDrag read FOnDrag write SetFOnDrag;
    property OnDragend : TExtSliderMultiOnDragend read FOnDragend write SetFOnDragend;
  end;

  TExtChartSeriesLine = class(TExtChartSeriesCartesian)
  private
    FAxis : String;
    FSelectionTolerance : Integer;
    FShowMarkers : Boolean;
    FMarkerConfig : TExtObject;
    FStyle : TExtObject;
    FSmooth : Boolean;
    FSmoothInteger : Integer;
    FFill : Boolean;
    procedure SetFAxis(Value : String);
    procedure SetFSelectionTolerance(Value : Integer);
    procedure SetFShowMarkers(Value : Boolean);
    procedure SetFMarkerConfig(Value : TExtObject);
    procedure SetFStyle(Value : TExtObject);
    procedure SetFSmooth(Value : Boolean);
    procedure SetFSmoothInteger(Value : Integer);
    procedure SetFFill(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property Axis : String read FAxis write SetFAxis;
    property SelectionTolerance : Integer read FSelectionTolerance write SetFSelectionTolerance;
    property ShowMarkers : Boolean read FShowMarkers write SetFShowMarkers;
    property MarkerConfig : TExtObject read FMarkerConfig write SetFMarkerConfig;
    property Style : TExtObject read FStyle write SetFStyle;
    property Smooth : Boolean read FSmooth write SetFSmooth;
    property SmoothInteger : Integer read FSmoothInteger write SetFSmoothInteger;
    property Fill : Boolean read FFill write SetFFill;
  end;

  TExtGridPluginRowEditing = class(TExtGridPluginEditing)
  private
    FAutoCancel : Boolean; // true
    FClicksToMoveEditor : Integer;
    FErrorSummary : Boolean; // true
    procedure SetFAutoCancel(Value : Boolean);
    procedure SetFClicksToMoveEditor(Value : Integer);
    procedure SetFErrorSummary(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction;
    property AutoCancel : Boolean read FAutoCancel write SetFAutoCancel;
    property ClicksToMoveEditor : Integer read FClicksToMoveEditor write SetFClicksToMoveEditor;
    property ErrorSummary : Boolean read FErrorSummary write SetFErrorSummary;
  end;

  // Procedural types for events TExtButtonSplit
  TExtButtonSplitOnArrowclick = procedure(This : TExtButtonSplit; E : TExtDirectEvent) of object;

  TExtButtonSplit = class(TExtButton)
  private
    FArrowHandler : TExtFunction;
    FArrowTooltip : String;
    FOnArrowclick : TExtButtonSplitOnArrowclick;
    procedure SetFArrowHandler(Value : TExtFunction);
    procedure SetFArrowTooltip(Value : String);
    procedure SetFOnArrowclick(Value : TExtButtonSplitOnArrowclick);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetArrowHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    property ArrowHandler : TExtFunction read FArrowHandler write SetFArrowHandler;
    property ArrowTooltip : String read FArrowTooltip write SetFArrowTooltip;
    property OnArrowclick : TExtButtonSplitOnArrowclick read FOnArrowclick write SetFOnArrowclick;
  end;

  // Procedural types for events TExtChart
  TExtChartOnBeforerefresh = procedure(This : TExtChart) of object;
  TExtChartOnRefresh = procedure(This : TExtChart) of object;

  TExtChart = class(TExtDrawComponent)
  private
    FTheme : String;
    FAnimate : Boolean;
    FAnimateTExtObject : TExtObject;
    FLegend : Boolean;
    FLegendTExtObject : TExtObject;
    FInsetPadding : Integer; // 10
    FEnginePriority : TExtObjectList;
    FBackground : TExtObject;
    FBackgroundBoolean : Boolean;
    FGradients : TExtObjectList;
    FStore : TExtDataStore;
    FSeries : TExtObjectList;
    FAxes : TExtObjectList;
    FOnBeforerefresh : TExtChartOnBeforerefresh;
    FOnRefresh : TExtChartOnRefresh;
    procedure SetFTheme(Value : String);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFAnimateTExtObject(Value : TExtObject);
    procedure SetFLegend(Value : Boolean);
    procedure SetFLegendTExtObject(Value : TExtObject);
    procedure SetFInsetPadding(Value : Integer);
    procedure SetFEnginePriority(Value : TExtObjectList);
    procedure SetFBackground(Value : TExtObject);
    procedure SetFBackgroundBoolean(Value : Boolean);
    procedure SetFGradients(Value : TExtObjectList);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFSeries(Value : TExtObjectList);
    procedure SetFAxes(Value : TExtObjectList);
    procedure SetFOnBeforerefresh(Value : TExtChartOnBeforerefresh);
    procedure SetFOnRefresh(Value : TExtChartOnRefresh);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Redraw(Resize : Boolean = false) : TExtFunction;
    function Save(Config : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property Theme : String read FTheme write SetFTheme;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property AnimateTExtObject : TExtObject read FAnimateTExtObject write SetFAnimateTExtObject;
    property Legend : Boolean read FLegend write SetFLegend;
    property LegendTExtObject : TExtObject read FLegendTExtObject write SetFLegendTExtObject;
    property InsetPadding : Integer read FInsetPadding write SetFInsetPadding;
    property EnginePriority : TExtObjectList read FEnginePriority write SetFEnginePriority;
    property Background : TExtObject read FBackground write SetFBackground;
    property BackgroundBoolean : Boolean read FBackgroundBoolean write SetFBackgroundBoolean;
    property Gradients : TExtObjectList read FGradients write SetFGradients;
    property Store : TExtDataStore read FStore write SetFStore;
    property Series : TExtObjectList read FSeries write SetFSeries;
    property Axes : TExtObjectList read FAxes write SetFAxes;
    property OnBeforerefresh : TExtChartOnBeforerefresh read FOnBeforerefresh write SetFOnBeforerefresh;
    property OnRefresh : TExtChartOnRefresh read FOnRefresh write SetFOnRefresh;
  end;

  TExtDdDropTarget = class(TExtDdDDTarget)
  private
    FDdGroup : String;
    FOverClass : String;
    FDropAllowed : String;
    FDropNotAllowed : String;
    procedure SetFDdGroup(Value : String);
    procedure SetFOverClass(Value : String);
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property OverClass : String read FOverClass write SetFOverClass;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
  end;

  TExtSliderTip = class(TExtTip)
  private
    FOffsets : TExtObjectList;
    FAlign : String;
    FPosition : String;
    procedure SetFOffsets(Value : TExtObjectList);
    procedure SetFAlign(Value : String);
    procedure SetFPosition(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Offsets : TExtObjectList read FOffsets write SetFOffsets;
    property Align : String read FAlign write SetFAlign;
    property Position : String read FPosition write SetFPosition;
  end;

  TExtFormActionDirectLoad = class(TExtFormActionLoad)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtTreeView
  TExtTreeViewOnAfteritemexpand = procedure(Node : TExtDataNodeInterface; Index : Integer; Item : THTMLElement) of object;
  TExtTreeViewOnAfteritemcollapse = procedure(Node : TExtDataNodeInterface; Index : Integer; Item : THTMLElement) of object;

  TExtTreeView = class(TExtViewTable)
  private
    FRootVisible : Boolean;
    FDeferInitialRefresh : Boolean;
    FAnimate : Boolean;
    FOnAfteritemexpand : TExtTreeViewOnAfteritemexpand;
    FOnAfteritemcollapse : TExtTreeViewOnAfteritemcollapse;
    procedure SetFRootVisible(Value : Boolean);
    procedure SetFDeferInitialRefresh(Value : Boolean);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFOnAfteritemexpand(Value : TExtTreeViewOnAfteritemexpand);
    procedure SetFOnAfteritemcollapse(Value : TExtTreeViewOnAfteritemcollapse);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Expand(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Collapse(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Toggle(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function GetTreeStore : TExtFunction;
    property RootVisible : Boolean read FRootVisible write SetFRootVisible;
    property DeferInitialRefresh : Boolean read FDeferInitialRefresh write SetFDeferInitialRefresh;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property OnAfteritemexpand : TExtTreeViewOnAfteritemexpand read FOnAfteritemexpand write SetFOnAfteritemexpand;
    property OnAfteritemcollapse : TExtTreeViewOnAfteritemcollapse read FOnAfteritemcollapse write SetFOnAfteritemcollapse;
  end;

  TExtChartAxisTime = class(TExtChartAxisNumeric)
  private
    FDateFormat : String;
    FDateFormatBoolean : Boolean;
    FFromDate : TDateTime;
    FToDate : TDateTime;
    FStep : TExtObjectList;
    FStepBoolean : Boolean;
    FConstrain : Boolean;
    procedure SetFDateFormat(Value : String);
    procedure SetFDateFormatBoolean(Value : Boolean);
    procedure SetFFromDate(Value : TDateTime);
    procedure SetFToDate(Value : TDateTime);
    procedure SetFStep(Value : TExtObjectList);
    procedure SetFStepBoolean(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DateFormat : String read FDateFormat write SetFDateFormat;
    property DateFormatBoolean : Boolean read FDateFormatBoolean write SetFDateFormatBoolean;
    property FromDate : TDateTime read FFromDate write SetFFromDate;
    property ToDate : TDateTime read FToDate write SetFToDate;
    property Step : TExtObjectList read FStep write SetFStep;
    property StepBoolean : Boolean read FStepBoolean write SetFStepBoolean;
    property Constrain : Boolean read FConstrain write SetFConstrain;
  end;

  // Procedural types for events TExtTreePanel
  TExtTreePanelOnBeforeload = procedure of object;
  TExtTreePanelOnLoad = procedure of object;
  TExtTreePanelOnItemappend = procedure of object;
  TExtTreePanelOnItemremove = procedure of object;
  TExtTreePanelOnItemmove = procedure of object;
  TExtTreePanelOnIteminsert = procedure of object;
  TExtTreePanelOnBeforeitemappend = procedure of object;
  TExtTreePanelOnBeforeitemremove = procedure of object;
  TExtTreePanelOnBeforeitemmove = procedure of object;
  TExtTreePanelOnBeforeiteminsert = procedure of object;
  TExtTreePanelOnItemexpand = procedure of object;
  TExtTreePanelOnItemcollapse = procedure of object;
  TExtTreePanelOnBeforeitemexpand = procedure of object;
  TExtTreePanelOnBeforeitemcollapse = procedure of object;
  TExtTreePanelOnCheckchange = procedure(Node : TExtDataNodeInterface; Checked : Boolean) of object;
  TExtTreePanelOnAfteritemexpand = procedure of object;
  TExtTreePanelOnAfteritemcollapse = procedure of object;

  TExtTreePanel = class(TExtPanelTable)
  private
    FRowLines : Boolean;
    FLines : Boolean;
    FUseArrows : Boolean;
    FSingleExpand : Boolean;
    FAnimate : Boolean;
    FRootVisible : Boolean;
    FDisplayField : String;
    FRoot : TExtDataModel;
    FRootTExtDataNodeInterface : TExtDataNodeInterface;
    FRootTExtObject : TExtObject;
    FHideHeaders : Boolean;
    FFolderSort : Boolean;
    FStore : TExtDataTreeStore;
    FOnBeforeload : TExtTreePanelOnBeforeload;
    FOnLoad : TExtTreePanelOnLoad;
    FOnItemappend : TExtTreePanelOnItemappend;
    FOnItemremove : TExtTreePanelOnItemremove;
    FOnItemmove : TExtTreePanelOnItemmove;
    FOnIteminsert : TExtTreePanelOnIteminsert;
    FOnBeforeitemappend : TExtTreePanelOnBeforeitemappend;
    FOnBeforeitemremove : TExtTreePanelOnBeforeitemremove;
    FOnBeforeitemmove : TExtTreePanelOnBeforeitemmove;
    FOnBeforeiteminsert : TExtTreePanelOnBeforeiteminsert;
    FOnItemexpand : TExtTreePanelOnItemexpand;
    FOnItemcollapse : TExtTreePanelOnItemcollapse;
    FOnBeforeitemexpand : TExtTreePanelOnBeforeitemexpand;
    FOnBeforeitemcollapse : TExtTreePanelOnBeforeitemcollapse;
    FOnCheckchange : TExtTreePanelOnCheckchange;
    FOnAfteritemexpand : TExtTreePanelOnAfteritemexpand;
    FOnAfteritemcollapse : TExtTreePanelOnAfteritemcollapse;
    procedure SetFRowLines(Value : Boolean);
    procedure SetFLines(Value : Boolean);
    procedure SetFUseArrows(Value : Boolean);
    procedure SetFSingleExpand(Value : Boolean);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFRootVisible(Value : Boolean);
    procedure SetFDisplayField(Value : String);
    procedure SetFRoot(Value : TExtDataModel);
    procedure SetFRootTExtDataNodeInterface(Value : TExtDataNodeInterface);
    procedure SetFRootTExtObject(Value : TExtObject);
    procedure SetFHideHeaders(Value : Boolean);
    procedure SetFFolderSort(Value : Boolean);
    procedure SetFStore(Value : TExtDataTreeStore);
    procedure SetFOnBeforeload(Value : TExtTreePanelOnBeforeload);
    procedure SetFOnLoad(Value : TExtTreePanelOnLoad);
    procedure SetFOnItemappend(Value : TExtTreePanelOnItemappend);
    procedure SetFOnItemremove(Value : TExtTreePanelOnItemremove);
    procedure SetFOnItemmove(Value : TExtTreePanelOnItemmove);
    procedure SetFOnIteminsert(Value : TExtTreePanelOnIteminsert);
    procedure SetFOnBeforeitemappend(Value : TExtTreePanelOnBeforeitemappend);
    procedure SetFOnBeforeitemremove(Value : TExtTreePanelOnBeforeitemremove);
    procedure SetFOnBeforeitemmove(Value : TExtTreePanelOnBeforeitemmove);
    procedure SetFOnBeforeiteminsert(Value : TExtTreePanelOnBeforeiteminsert);
    procedure SetFOnItemexpand(Value : TExtTreePanelOnItemexpand);
    procedure SetFOnItemcollapse(Value : TExtTreePanelOnItemcollapse);
    procedure SetFOnBeforeitemexpand(Value : TExtTreePanelOnBeforeitemexpand);
    procedure SetFOnBeforeitemcollapse(Value : TExtTreePanelOnBeforeitemcollapse);
    procedure SetFOnCheckchange(Value : TExtTreePanelOnCheckchange);
    procedure SetFOnAfteritemexpand(Value : TExtTreePanelOnAfteritemexpand);
    procedure SetFOnAfteritemcollapse(Value : TExtTreePanelOnAfteritemcollapse);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetRootNode(Root : TExtDataModel) : TExtFunction; overload;
    function SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; overload;
    function SetRootNode(Root : TExtObject) : TExtFunction; overload;
    function GetRootNode : TExtFunction;
    function GetChecked : TExtFunction;
    function ExpandNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function CollapseNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function CollapseAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function SelectPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property Lines : Boolean read FLines write SetFLines;
    property UseArrows : Boolean read FUseArrows write SetFUseArrows;
    property SingleExpand : Boolean read FSingleExpand write SetFSingleExpand;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property RootVisible : Boolean read FRootVisible write SetFRootVisible;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property Root : TExtDataModel read FRoot write SetFRoot;
    property RootTExtDataNodeInterface : TExtDataNodeInterface read FRootTExtDataNodeInterface write SetFRootTExtDataNodeInterface;
    property RootTExtObject : TExtObject read FRootTExtObject write SetFRootTExtObject;
    property HideHeaders : Boolean read FHideHeaders write SetFHideHeaders;
    property FolderSort : Boolean read FFolderSort write SetFFolderSort;
    property Store : TExtDataTreeStore read FStore write SetFStore;
    property OnBeforeload : TExtTreePanelOnBeforeload read FOnBeforeload write SetFOnBeforeload;
    property OnLoad : TExtTreePanelOnLoad read FOnLoad write SetFOnLoad;
    property OnItemappend : TExtTreePanelOnItemappend read FOnItemappend write SetFOnItemappend;
    property OnItemremove : TExtTreePanelOnItemremove read FOnItemremove write SetFOnItemremove;
    property OnItemmove : TExtTreePanelOnItemmove read FOnItemmove write SetFOnItemmove;
    property OnIteminsert : TExtTreePanelOnIteminsert read FOnIteminsert write SetFOnIteminsert;
    property OnBeforeitemappend : TExtTreePanelOnBeforeitemappend read FOnBeforeitemappend write SetFOnBeforeitemappend;
    property OnBeforeitemremove : TExtTreePanelOnBeforeitemremove read FOnBeforeitemremove write SetFOnBeforeitemremove;
    property OnBeforeitemmove : TExtTreePanelOnBeforeitemmove read FOnBeforeitemmove write SetFOnBeforeitemmove;
    property OnBeforeiteminsert : TExtTreePanelOnBeforeiteminsert read FOnBeforeiteminsert write SetFOnBeforeiteminsert;
    property OnItemexpand : TExtTreePanelOnItemexpand read FOnItemexpand write SetFOnItemexpand;
    property OnItemcollapse : TExtTreePanelOnItemcollapse read FOnItemcollapse write SetFOnItemcollapse;
    property OnBeforeitemexpand : TExtTreePanelOnBeforeitemexpand read FOnBeforeitemexpand write SetFOnBeforeitemexpand;
    property OnBeforeitemcollapse : TExtTreePanelOnBeforeitemcollapse read FOnBeforeitemcollapse write SetFOnBeforeitemcollapse;
    property OnCheckchange : TExtTreePanelOnCheckchange read FOnCheckchange write SetFOnCheckchange;
    property OnAfteritemexpand : TExtTreePanelOnAfteritemexpand read FOnAfteritemexpand write SetFOnAfteritemexpand;
    property OnAfteritemcollapse : TExtTreePanelOnAfteritemcollapse read FOnAfteritemcollapse write SetFOnAfteritemcollapse;
  end;

  TExtFxTargetCompositeElementCSS = class(TExtFxTargetCompositeElement)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataReaderXml = class(TExtDataReader)
  private
    FRecordJS : String;
    FXmlData : TExtObject;
    procedure SetFRecordJS(Value : String);
    procedure SetFXmlData(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property RecordJS : String read FRecordJS write SetFRecordJS;
    property XmlData : TExtObject read FXmlData write SetFXmlData;
  end;

  TExtDirectExceptionEvent = class(TExtDirectRemotingEvent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartLegendItem = class(TExtDrawCompositeSprite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateLegend : TExtFunction;
    function UpdatePosition(RelativeTo : TExtObject = nil) : TExtFunction;
  end;

  TExtDataReaderJson = class(TExtDataReader)
  private
    FRecordJS : String;
    FUseSimpleAccessors : Boolean;
    FJsonData : TExtObject;
    procedure SetFRecordJS(Value : String);
    procedure SetFUseSimpleAccessors(Value : Boolean);
    procedure SetFJsonData(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property RecordJS : String read FRecordJS write SetFRecordJS;
    property UseSimpleAccessors : Boolean read FUseSimpleAccessors write SetFUseSimpleAccessors;
    property JsonData : TExtObject read FJsonData write SetFJsonData;
  end;

  TExtTipToolTip = class(TExtTip)
  private
    FTarget : THTMLElement;
    FTargetTExtElement : TExtElement;
    FTargetString : String;
    FAutoHide : Boolean;
    FShowDelay : Integer;
    FHideDelay : Integer;
    FDismissDelay : Integer;
    FMouseOffset : TArrayOfInteger;
    FTrackMouse : Boolean;
    FAnchor : String;
    FAnchorToTarget : Boolean;
    FAnchorOffset : Integer;
    FDelegate : String;
    procedure SetFTarget(Value : THTMLElement);
    procedure SetFTargetTExtElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFAutoHide(Value : Boolean);
    procedure SetFShowDelay(Value : Integer);
    procedure SetFHideDelay(Value : Integer);
    procedure SetFDismissDelay(Value : Integer);
    procedure SetFMouseOffset(Value : TArrayOfInteger);
    procedure SetFTrackMouse(Value : Boolean);
    procedure SetFAnchor(Value : String);
    procedure SetFAnchorToTarget(Value : Boolean);
    procedure SetFAnchorOffset(Value : Integer);
    procedure SetFDelegate(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetTarget(T : String) : TExtFunction; overload;
    function SetTarget(T : THTMLElement) : TExtFunction; overload;
    function SetTarget(T : TExtElement) : TExtFunction; overload;
    function Hide : TExtFunction;
    function Show : TExtFunction;
    destructor Destroy; override;
    property Target : THTMLElement read FTarget write SetFTarget;
    property TargetTExtElement : TExtElement read FTargetTExtElement write SetFTargetTExtElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property AutoHide : Boolean read FAutoHide write SetFAutoHide;
    property ShowDelay : Integer read FShowDelay write SetFShowDelay;
    property HideDelay : Integer read FHideDelay write SetFHideDelay;
    property DismissDelay : Integer read FDismissDelay write SetFDismissDelay;
    property MouseOffset : TArrayOfInteger read FMouseOffset write SetFMouseOffset;
    property TrackMouse : Boolean read FTrackMouse write SetFTrackMouse;
    property Anchor : String read FAnchor write SetFAnchor;
    property AnchorToTarget : Boolean read FAnchorToTarget write SetFAnchorToTarget;
    property AnchorOffset : Integer read FAnchorOffset write SetFAnchorOffset;
    property Delegate : String read FDelegate write SetFDelegate;
  end;

  // Procedural types for events TExtGridPluginCellEditing
  TExtGridPluginCellEditingOnBeforeedit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnEdit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnValidateedit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnCanceledit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;

  TExtGridPluginCellEditing = class(TExtGridPluginEditing)
  private
    FOnBeforeedit : TExtGridPluginCellEditingOnBeforeedit;
    FOnEdit : TExtGridPluginCellEditingOnEdit;
    FOnValidateedit : TExtGridPluginCellEditingOnValidateedit;
    FOnCanceledit : TExtGridPluginCellEditingOnCanceledit;
    procedure SetFOnBeforeedit(Value : TExtGridPluginCellEditingOnBeforeedit);
    procedure SetFOnEdit(Value : TExtGridPluginCellEditingOnEdit);
    procedure SetFOnValidateedit(Value : TExtGridPluginCellEditingOnValidateedit);
    procedure SetFOnCanceledit(Value : TExtGridPluginCellEditingOnCanceledit);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction;
    function CancelEdit : TExtFunction;
    function StartEditByPosition(Position : TExtObject) : TExtFunction;
    property OnBeforeedit : TExtGridPluginCellEditingOnBeforeedit read FOnBeforeedit write SetFOnBeforeedit;
    property OnEdit : TExtGridPluginCellEditingOnEdit read FOnEdit write SetFOnEdit;
    property OnValidateedit : TExtGridPluginCellEditingOnValidateedit read FOnValidateedit write SetFOnValidateedit;
    property OnCanceledit : TExtGridPluginCellEditingOnCanceledit read FOnCanceledit write SetFOnCanceledit;
  end;

  TExtGridColumn = class(TExtGridHeaderContainer)
  private
    FColumns : TExtObjectList;
    FStateId : String;
    FDataIndex : String;
    FText : String;
    FHeader : String;
    FMenuText : String;
    FEmptyCellText : String;
    FSortable : Boolean;
    FGroupable : Boolean;
    FFixed : Boolean;
    FLocked : Boolean;
    FResizable : Boolean;
    FHideable : Boolean;
    FMenuDisabled : Boolean;
    FRenderer : TExtFunction;
    FRendererString : String;
    FScope : TExtObject;
    FEditRenderer : TExtFunction;
    FAlign : String;
    FDraggable : Boolean;
    FTooltip : String;
    FTooltipType : String;
    FTdCls : String;
    FEditor : TExtObject;
    FEditorString : String;
    FField : TExtObject;
    FFieldString : String;
    FTriggerEl : TExtElement;
    FTextEl : TExtElement;
    FIsHeader : Boolean;
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFStateId(Value : String);
    procedure SetFDataIndex(Value : String);
    procedure SetFText(Value : String);
    procedure SetFHeader(Value : String);
    procedure SetFMenuText(Value : String);
    procedure SetFEmptyCellText(Value : String);
    procedure SetFSortable(Value : Boolean);
    procedure SetFGroupable(Value : Boolean);
    procedure SetFFixed(Value : Boolean);
    procedure SetFLocked(Value : Boolean);
    procedure SetFResizable(Value : Boolean);
    procedure SetFHideable(Value : Boolean);
    procedure SetFMenuDisabled(Value : Boolean);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFRendererString(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFEditRenderer(Value : TExtFunction);
    procedure SetFAlign(Value : String);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipType(Value : String);
    procedure SetFTdCls(Value : String);
    procedure SetFEditor(Value : TExtObject);
    procedure SetFEditorString(Value : String);
    procedure SetFField(Value : TExtObject);
    procedure SetFFieldString(Value : String);
    procedure SetFTriggerEl(Value : TExtElement);
    procedure SetFTextEl(Value : TExtElement);
    procedure SetFIsHeader(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetText(Text : String) : TExtFunction;
    function GetIndex : TExtFunction;
    function GetVisibleIndex : TExtFunction;
    function GetSortParam : TExtFunction;
    destructor Destroy; override;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property StateId : String read FStateId write SetFStateId;
    property DataIndex : String read FDataIndex write SetFDataIndex;
    property Text : String read FText write SetFText;
    property Header : String read FHeader write SetFHeader;
    property MenuText : String read FMenuText write SetFMenuText;
    property EmptyCellText : String read FEmptyCellText write SetFEmptyCellText;
    property Sortable : Boolean read FSortable write SetFSortable;
    property Groupable : Boolean read FGroupable write SetFGroupable;
    property Fixed : Boolean read FFixed write SetFFixed;
    property Locked : Boolean read FLocked write SetFLocked;
    property Resizable : Boolean read FResizable write SetFResizable;
    property Hideable : Boolean read FHideable write SetFHideable;
    property MenuDisabled : Boolean read FMenuDisabled write SetFMenuDisabled;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property RendererString : String read FRendererString write SetFRendererString;
    property Scope : TExtObject read FScope write SetFScope;
    property EditRenderer : TExtFunction read FEditRenderer write SetFEditRenderer;
    property Align : String read FAlign write SetFAlign;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property TdCls : String read FTdCls write SetFTdCls;
    property Editor : TExtObject read FEditor write SetFEditor;
    property EditorString : String read FEditorString write SetFEditorString;
    property Field : TExtObject read FField write SetFField;
    property FieldString : String read FFieldString write SetFFieldString;
    property TriggerEl : TExtElement read FTriggerEl write SetFTriggerEl;
    property TextEl : TExtElement read FTextEl write SetFTextEl;
    property IsHeader : Boolean read FIsHeader write SetFIsHeader;
  end;

  TExtDrawText = class(TExtDrawComponent)
  private
    FText : String;
    FStyleSelector : String;
    FDegrees : Integer;
    procedure SetFText(Value : String);
    procedure SetFStyleSelector(Value : String);
    procedure SetFDegrees(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetAngle(Degrees : Integer) : TExtFunction;
    function SetText(T : String) : TExtFunction;
    property Text : String read FText write SetFText;
    property StyleSelector : String read FStyleSelector write SetFStyleSelector;
    property Degrees : Integer read FDegrees write SetFDegrees;
  end;

  TExtToolbarSeparator = class(TExtToolbarItem)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtToolbarTextItem = class(TExtToolbarItem)
  private
    FText : String;
    procedure SetFText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetText(Text : String) : TExtFunction;
    property Text : String read FText write SetFText;
  end;

  // Procedural types for events TExtGridPanel
  TExtGridPanelOnReconfigure = procedure(This : TExtGridPanel; Store : TExtDataStore; Columns : TExtObjectList) of object;

  TExtGridPanel = class(TExtPanelTable)
  private
    FRowLines : Boolean;
    FColumns : TExtObjectList;
    FColumnsTExtObject : TExtObject;
    FOnReconfigure : TExtGridPanelOnReconfigure;
    procedure SetFRowLines(Value : Boolean);
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFColumnsTExtObject(Value : TExtObject);
    procedure SetFOnReconfigure(Value : TExtGridPanelOnReconfigure);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property ColumnsTExtObject : TExtObject read FColumnsTExtObject write SetFColumnsTExtObject;
    property OnReconfigure : TExtGridPanelOnReconfigure read FOnReconfigure write SetFOnReconfigure;
  end;

  // Procedural types for events TExtToolbarPaging
  TExtToolbarPagingOnChange = procedure(This : TExtToolbarPaging; PageData : TExtObject) of object;
  TExtToolbarPagingOnBeforechange = procedure(This : TExtToolbarPaging; Page : Integer) of object;

  TExtToolbarPaging = class(TExtToolbar)
  private
    FStore : TExtDataStore;
    FDisplayInfo : Boolean;
    FPrependButtons : Boolean;
    FDisplayMsg : String;
    FEmptyMsg : String;
    FBeforePageText : String;
    FAfterPageText : String;
    FFirstText : String;
    FPrevText : String;
    FNextText : String;
    FLastText : String;
    FRefreshText : String;
    FInputItemWidth : Integer;
    FOnChange : TExtToolbarPagingOnChange;
    FOnBeforechange : TExtToolbarPagingOnBeforechange;
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFDisplayInfo(Value : Boolean);
    procedure SetFPrependButtons(Value : Boolean);
    procedure SetFDisplayMsg(Value : String);
    procedure SetFEmptyMsg(Value : String);
    procedure SetFBeforePageText(Value : String);
    procedure SetFAfterPageText(Value : String);
    procedure SetFFirstText(Value : String);
    procedure SetFPrevText(Value : String);
    procedure SetFNextText(Value : String);
    procedure SetFLastText(Value : String);
    procedure SetFRefreshText(Value : String);
    procedure SetFInputItemWidth(Value : Integer);
    procedure SetFOnChange(Value : TExtToolbarPagingOnChange);
    procedure SetFOnBeforechange(Value : TExtToolbarPagingOnBeforechange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function MoveFirst : TExtFunction;
    function MovePrevious : TExtFunction;
    function MoveNext : TExtFunction;
    function MoveLast : TExtFunction;
    function DoRefresh : TExtFunction;
    function Unbind(Store : TExtDataStore) : TExtFunction;
    function Bind(Store : TExtDataStore) : TExtFunction;
    destructor Destroy; override;
    property Store : TExtDataStore read FStore write SetFStore;
    property DisplayInfo : Boolean read FDisplayInfo write SetFDisplayInfo;
    property PrependButtons : Boolean read FPrependButtons write SetFPrependButtons;
    property DisplayMsg : String read FDisplayMsg write SetFDisplayMsg;
    property EmptyMsg : String read FEmptyMsg write SetFEmptyMsg;
    property BeforePageText : String read FBeforePageText write SetFBeforePageText;
    property AfterPageText : String read FAfterPageText write SetFAfterPageText;
    property FirstText : String read FFirstText write SetFFirstText;
    property PrevText : String read FPrevText write SetFPrevText;
    property NextText : String read FNextText write SetFNextText;
    property LastText : String read FLastText write SetFLastText;
    property RefreshText : String read FRefreshText write SetFRefreshText;
    property InputItemWidth : Integer read FInputItemWidth write SetFInputItemWidth;
    property OnChange : TExtToolbarPagingOnChange read FOnChange write SetFOnChange;
    property OnBeforechange : TExtToolbarPagingOnBeforechange read FOnBeforechange write SetFOnBeforechange;
  end;

  TExtDataWriterXml = class(TExtDataWriter)
  private
    FDocumentRoot : String; // 'xmlData'
    FDefaultDocumentRoot : String;
    FHeader : String;
    FRecordJS : String; // 'record'
    procedure SetFDocumentRoot(Value : String);
    procedure SetFDefaultDocumentRoot(Value : String);
    procedure SetFHeader(Value : String);
    procedure SetFRecordJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property DocumentRoot : String read FDocumentRoot write SetFDocumentRoot;
    property DefaultDocumentRoot : String read FDefaultDocumentRoot write SetFDefaultDocumentRoot;
    property Header : String read FHeader write SetFHeader;
    property RecordJS : String read FRecordJS write SetFRecordJS;
  end;

  TExtLayoutContainerTable = class(TExtLayoutContainer)
  private
    FColumns : Integer;
    FTableAttrs : TExtObject;
    FTrAttrs : TExtObject;
    FTdAttrs : TExtObject;
    procedure SetFColumns(Value : Integer);
    procedure SetFTableAttrs(Value : TExtObject);
    procedure SetFTrAttrs(Value : TExtObject);
    procedure SetFTdAttrs(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Columns : Integer read FColumns write SetFColumns;
    property TableAttrs : TExtObject read FTableAttrs write SetFTableAttrs;
    property TrAttrs : TExtObject read FTrAttrs write SetFTrAttrs;
    property TdAttrs : TExtObject read FTdAttrs write SetFTdAttrs;
  end;

  TExtLayoutContainerColumn = class(TExtLayoutContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerFit = class(TExtLayoutContainer)
  private
    FDefaultMargins : TExtObject;
    procedure SetFDefaultMargins(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DefaultMargins : TExtObject read FDefaultMargins write SetFDefaultMargins;
  end;

  // Procedural types for events TExtMenuColorPicker
  TExtMenuColorPickerOnSelect = procedure of object;

  TExtMenuColorPicker = class(TExtMenu)
  private
    FHideOnClick : Boolean;
    FPickerId : String;
    FPicker : TExtPickerColor;
    FOnSelect : TExtMenuColorPickerOnSelect;
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFPickerId(Value : String);
    procedure SetFPicker(Value : TExtPickerColor);
    procedure SetFOnSelect(Value : TExtMenuColorPickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property PickerId : String read FPickerId write SetFPickerId;
    property Picker : TExtPickerColor read FPicker write SetFPicker;
    property OnSelect : TExtMenuColorPickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtMenuDatePicker
  TExtMenuDatePickerOnSelect = procedure of object;

  TExtMenuDatePicker = class(TExtMenu)
  private
    FHideOnClick : Boolean;
    FPickerId : String;
    FPicker : TExtPickerDate;
    FOnSelect : TExtMenuDatePickerOnSelect;
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFPickerId(Value : String);
    procedure SetFPicker(Value : TExtPickerDate);
    procedure SetFOnSelect(Value : TExtMenuDatePickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property PickerId : String read FPickerId write SetFPickerId;
    property Picker : TExtPickerDate read FPicker write SetFPicker;
    property OnSelect : TExtMenuDatePickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtDdDDProxy = class(TExtDdDD)
  private
    FResizeFrame : Boolean;
    FCenterFrame : Boolean;
    procedure SetFResizeFrame(Value : Boolean);
    procedure SetFCenterFrame(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateFrame : TExtFunction;
    function InitFrame : TExtFunction;
    property ResizeFrame : Boolean read FResizeFrame write SetFResizeFrame;
    property CenterFrame : Boolean read FCenterFrame write SetFCenterFrame;
  end;

  // Procedural types for events TExtMenuCheckItem
  TExtMenuCheckItemOnBeforecheckchange = procedure(This : TExtMenuCheckItem; Checked : Boolean) of object;
  TExtMenuCheckItemOnCheckchange = procedure(This : TExtMenuCheckItem; Checked : Boolean) of object;

  TExtMenuCheckItem = class(TExtMenuItem)
  private
    FChecked : Boolean;
    FCheckHandler : TExtFunction;
    FScope : TExtObject;
    FGroup : String;
    FCheckedCls : String;
    FUncheckedCls : String;
    FGroupCls : String;
    FHideOnClick : Boolean; // true
    FCheckChangeDisabled : Boolean;
    FOnBeforecheckchange : TExtMenuCheckItemOnBeforecheckchange;
    FOnCheckchange : TExtMenuCheckItemOnCheckchange;
    procedure SetFChecked(Value : Boolean);
    procedure SetFCheckHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFGroup(Value : String);
    procedure SetFCheckedCls(Value : String);
    procedure SetFUncheckedCls(Value : String);
    procedure SetFGroupCls(Value : String);
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFCheckChangeDisabled(Value : Boolean);
    procedure SetFOnBeforecheckchange(Value : TExtMenuCheckItemOnBeforecheckchange);
    procedure SetFOnCheckchange(Value : TExtMenuCheckItemOnCheckchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DisableCheckChange : TExtFunction;
    function EnableCheckChange : TExtFunction;
    function SetChecked(Checked : Boolean; SuppressEvents : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property Checked : Boolean read FChecked write SetFChecked;
    property CheckHandler : TExtFunction read FCheckHandler write SetFCheckHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property Group : String read FGroup write SetFGroup;
    property CheckedCls : String read FCheckedCls write SetFCheckedCls;
    property UncheckedCls : String read FUncheckedCls write SetFUncheckedCls;
    property GroupCls : String read FGroupCls write SetFGroupCls;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property CheckChangeDisabled : Boolean read FCheckChangeDisabled write SetFCheckChangeDisabled;
    property OnBeforecheckchange : TExtMenuCheckItemOnBeforecheckchange read FOnBeforecheckchange write SetFOnBeforecheckchange;
    property OnCheckchange : TExtMenuCheckItemOnCheckchange read FOnCheckchange write SetFOnCheckchange;
  end;

  TExtLayoutContainerAnchor = class(TExtLayoutContainer)
  private
    FAnchor : String;
    FDefaultAnchor : String;
    FAnchorSize : Integer;
    FAnchorSizeTExtObject : TExtObject;
    procedure SetFAnchor(Value : String);
    procedure SetFDefaultAnchor(Value : String);
    procedure SetFAnchorSize(Value : Integer);
    procedure SetFAnchorSizeTExtObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Anchor : String read FAnchor write SetFAnchor;
    property DefaultAnchor : String read FDefaultAnchor write SetFDefaultAnchor;
    property AnchorSize : Integer read FAnchorSize write SetFAnchorSize;
    property AnchorSizeTExtObject : TExtObject read FAnchorSizeTExtObject write SetFAnchorSizeTExtObject;
  end;

  TExtLayoutContainerAuto = class(TExtLayoutContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormFieldText
  TExtFormFieldTextOnAutosize = procedure(This : TExtFormFieldText; Width : Integer) of object;
  TExtFormFieldTextOnKeydown = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;
  TExtFormFieldTextOnKeyup = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;
  TExtFormFieldTextOnKeypress = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;

  TExtFormFieldText = class(TExtFormFieldBase)
  private
    FVtypeText : String;
    FStripCharsRe : TRegExp;
    FSize : Integer; // 20
    FGrow : Boolean;
    FGrowMin : Integer;
    FGrowMax : Integer;
    FGrowAppend : String; // 'W'
    FVtype : String;
    FMaskRe : TRegExp;
    FDisableKeyFilter : Boolean;
    FAllowBlank : Boolean;
    FMinLength : Integer;
    FMaxLength : Integer;
    FEnforceMaxLength : Boolean;
    FMaxLengthText : String;
    FSelectOnFocus : Boolean;
    FBlankText : String;
    FValidator : TExtFunction;
    FRegex : TRegExp;
    FRegexText : String;
    FEmptyText : String;
    FEmptyCls : String;
    FRequiredCls : String;
    FEnableKeyEvents : Boolean;
    FOnAutosize : TExtFormFieldTextOnAutosize;
    FOnKeydown : TExtFormFieldTextOnKeydown;
    FOnKeyup : TExtFormFieldTextOnKeyup;
    FOnKeypress : TExtFormFieldTextOnKeypress;
    procedure SetFVtypeText(Value : String);
    procedure SetFStripCharsRe(Value : TRegExp);
    procedure SetFSize(Value : Integer);
    procedure SetFGrow(Value : Boolean);
    procedure SetFGrowMin(Value : Integer);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowAppend(Value : String);
    procedure SetFVtype(Value : String);
    procedure SetFMaskRe(Value : TRegExp);
    procedure SetFDisableKeyFilter(Value : Boolean);
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFMinLength(Value : Integer);
    procedure SetFMaxLength(Value : Integer);
    procedure SetFEnforceMaxLength(Value : Boolean);
    procedure SetFMaxLengthText(Value : String);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFValidator(Value : TExtFunction);
    procedure SetFRegex(Value : TRegExp);
    procedure SetFRegexText(Value : String);
    procedure SetFEmptyText(Value : String);
    procedure SetFEmptyCls(Value : String);
    procedure SetFRequiredCls(Value : String);
    procedure SetFEnableKeyEvents(Value : Boolean);
    procedure SetFOnAutosize(Value : TExtFormFieldTextOnAutosize);
    procedure SetFOnKeydown(Value : TExtFormFieldTextOnKeydown);
    procedure SetFOnKeyup(Value : TExtFormFieldTextOnKeyup);
    procedure SetFOnKeypress(Value : TExtFormFieldTextOnKeypress);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ProcessRawValue(Value : String) : TExtFunction;
    function Reset : TExtFunction;
    function GetRawValue : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    function AutoSize : TExtFunction;
    property VtypeText : String read FVtypeText write SetFVtypeText;
    property StripCharsRe : TRegExp read FStripCharsRe write SetFStripCharsRe;
    property Size : Integer read FSize write SetFSize;
    property Grow : Boolean read FGrow write SetFGrow;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowAppend : String read FGrowAppend write SetFGrowAppend;
    property Vtype : String read FVtype write SetFVtype;
    property MaskRe : TRegExp read FMaskRe write SetFMaskRe;
    property DisableKeyFilter : Boolean read FDisableKeyFilter write SetFDisableKeyFilter;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property MinLength : Integer read FMinLength write SetFMinLength;
    property MaxLength : Integer read FMaxLength write SetFMaxLength;
    property EnforceMaxLength : Boolean read FEnforceMaxLength write SetFEnforceMaxLength;
    property MaxLengthText : String read FMaxLengthText write SetFMaxLengthText;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property BlankText : String read FBlankText write SetFBlankText;
    property Validator : TExtFunction read FValidator write SetFValidator;
    property Regex : TRegExp read FRegex write SetFRegex;
    property RegexText : String read FRegexText write SetFRegexText;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property EmptyCls : String read FEmptyCls write SetFEmptyCls;
    property RequiredCls : String read FRequiredCls write SetFRequiredCls;
    property EnableKeyEvents : Boolean read FEnableKeyEvents write SetFEnableKeyEvents;
    property OnAutosize : TExtFormFieldTextOnAutosize read FOnAutosize write SetFOnAutosize;
    property OnKeydown : TExtFormFieldTextOnKeydown read FOnKeydown write SetFOnKeydown;
    property OnKeyup : TExtFormFieldTextOnKeyup read FOnKeyup write SetFOnKeyup;
    property OnKeypress : TExtFormFieldTextOnKeypress read FOnKeypress write SetFOnKeypress;
  end;

  TExtWindowMessageBox = class(TExtWindow)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Show(Config : TExtObject; ConfigAnimateTarget : String; ConfigButtons : Integer = 0; ConfigClosable : Boolean = false; ConfigCls : String = ''; ConfigDefaultTextHeight : Integer = 0; ConfigFn : TExtFunction = nil; ConfigFnButtonId : String = ''; ConfigFnText : String = ''; ConfigFnOpt : TExtObject = nil; ConfigButtonText : TExtObject = nil; ConfigScope : TExtObject = nil; ConfigIcon : String = ''; ConfigIconCls : String = ''; ConfigMaxWidth : Integer = 0; ConfigMinWidth : Integer = 0; ConfigModal : Boolean = false; ConfigMsg : String = ''; ConfigMultiline : Boolean = false; ConfigProgress : Boolean = false; ConfigProgressText : String = ''; ConfigPrompt : Boolean = false; ConfigProxyDrag : Boolean = false; ConfigTitle : String = ''; ConfigValue : String = ''; ConfigWait : Boolean = false; ConfigWaitConfig : TExtObject = nil; ConfigWidth : Integer = 0) : TExtFunction; overload;
    function Show(Config : TExtObject; ConfigAnimateTarget : TExtDomElement; ConfigButtons : Integer = 0; ConfigClosable : Boolean = false; ConfigCls : String = ''; ConfigDefaultTextHeight : Integer = 0; ConfigFn : TExtFunction = nil; ConfigFnButtonId : String = ''; ConfigFnText : String = ''; ConfigFnOpt : TExtObject = nil; ConfigButtonText : TExtObject = nil; ConfigScope : TExtObject = nil; ConfigIcon : String = ''; ConfigIconCls : String = ''; ConfigMaxWidth : Integer = 0; ConfigMinWidth : Integer = 0; ConfigModal : Boolean = false; ConfigMsg : String = ''; ConfigMultiline : Boolean = false; ConfigProgress : Boolean = false; ConfigProgressText : String = ''; ConfigPrompt : Boolean = false; ConfigProxyDrag : Boolean = false; ConfigTitle : String = ''; ConfigValue : String = ''; ConfigWait : Boolean = false; ConfigWaitConfig : TExtObject = nil; ConfigWidth : Integer = 0) : TExtFunction; overload;
    function SetIcon(Icon : String) : TExtFunction;
    function UpdateProgress(Value : Integer = 0; ProgressText : String = ''; Msg : String = '') : TExtFunction;
    function Confirm(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Prompt(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Multiline : Boolean = false; Value : String = '') : TExtFunction; overload;
    function Prompt(Title : String; Msg : String; Fn : TExtFunction; Scope : TExtObject; Multiline : Integer; Value : String = '') : TExtFunction; overload;
    function Wait(Msg : String; Title : String = ''; Config : TExtObject = nil) : TExtFunction;
    function Alert(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Progress(Title : String; Msg : String; ProgressText : String = '') : TExtFunction;
  end;

  TExtDataWriterJson = class(TExtDataWriter)
  private
    FRoot : String;
    FEncode : Boolean;
    FAllowSingle : Boolean; // true
    procedure SetFRoot(Value : String);
    procedure SetFEncode(Value : Boolean);
    procedure SetFAllowSingle(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property Root : String read FRoot write SetFRoot;
    property Encode : Boolean read FEncode write SetFEncode;
    property AllowSingle : Boolean read FAllowSingle write SetFAllowSingle;
  end;

  TExtLayoutContainerCheckboxGroup = class(TExtLayoutContainer)
  private
    FAutoFlex : Boolean;
    procedure SetFAutoFlex(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AutoFlex : Boolean read FAutoFlex write SetFAutoFlex;
  end;

  TExtLayoutContainerBorder = class(TExtLayoutContainer)
  private
    FSplit : Boolean;
    FSplitterResize : Boolean;
    FPadding : Integer;
    FPaddingString : String;
    FPaddingTExtObject : TExtObject;
    FRegionWeights : TExtObject;
    procedure SetFSplit(Value : Boolean);
    procedure SetFSplitterResize(Value : Boolean);
    procedure SetFPadding(Value : Integer);
    procedure SetFPaddingString(Value : String);
    procedure SetFPaddingTExtObject(Value : TExtObject);
    procedure SetFRegionWeights(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Split : Boolean read FSplit write SetFSplit;
    property SplitterResize : Boolean read FSplitterResize write SetFSplitterResize;
    property Padding : Integer read FPadding write SetFPadding;
    property PaddingString : String read FPaddingString write SetFPaddingString;
    property PaddingTExtObject : TExtObject read FPaddingTExtObject write SetFPaddingTExtObject;
    property RegionWeights : TExtObject read FRegionWeights write SetFRegionWeights;
  end;

  TExtLayoutContainerBox = class(TExtLayoutContainer)
  private
    FDefaultMargins : TExtObject;
    FPadding : String;
    FPack : String;
    FFlex : Integer;
    FStretchMaxPartner : String;
    FStretchMaxPartnerTExtComponent : TExtComponent;
    procedure SetFDefaultMargins(Value : TExtObject);
    procedure SetFPadding(Value : String);
    procedure SetFPack(Value : String);
    procedure SetFFlex(Value : Integer);
    procedure SetFStretchMaxPartner(Value : String);
    procedure SetFStretchMaxPartnerTExtComponent(Value : TExtComponent);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DefaultMargins : TExtObject read FDefaultMargins write SetFDefaultMargins;
    property Padding : String read FPadding write SetFPadding;
    property Pack : String read FPack write SetFPack;
    property Flex : Integer read FFlex write SetFFlex;
    property StretchMaxPartner : String read FStretchMaxPartner write SetFStretchMaxPartner;
    property StretchMaxPartnerTExtComponent : TExtComponent read FStretchMaxPartnerTExtComponent write SetFStretchMaxPartnerTExtComponent;
  end;

  TExtFormFieldDisplay = class(TExtFormFieldBase)
  private
    FFieldCls : String;
    FHtmlEncode : Boolean;
    FRenderer : TExtFunction;
    FScope : TExtObject;
    procedure SetFFieldCls(Value : String);
    procedure SetFHtmlEncode(Value : Boolean);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property HtmlEncode : Boolean read FHtmlEncode write SetFHtmlEncode;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property Scope : TExtObject read FScope write SetFScope;
  end;

  TExtFormFieldCheckbox = class(TExtFormFieldBase)
  private
    FBeforeBoxLabelTpl : String;
    FBeforeBoxLabelTplTExtObjectList : TExtObjectList;
    FBeforeBoxLabelTplTExtXTemplate : TExtXTemplate;
    FAfterBoxLabelTpl : String;
    FAfterBoxLabelTplTExtObjectList : TExtObjectList;
    FAfterBoxLabelTplTExtXTemplate : TExtXTemplate;
    FBeforeBoxLabelTextTpl : String;
    FBeforeBoxLabelTextTplTExtObjectList : TExtObjectList;
    FBeforeBoxLabelTextTplTExtXTemplate : TExtXTemplate;
    FAfterBoxLabelTextTpl : String;
    FAfterBoxLabelTextTplTExtObjectList : TExtObjectList;
    FAfterBoxLabelTextTplTExtXTemplate : TExtXTemplate;
    FBoxLabelAttrTpl : String;
    FBoxLabelAttrTplTExtObjectList : TExtObjectList;
    FBoxLabelAttrTplTExtXTemplate : TExtXTemplate;
    FFocusCls : String;
    FFieldCls : String;
    FFieldBodyCls : String;
    FChecked : Boolean;
    FCheckedCls : String;
    FBoxLabel : String;
    FBoxLabelCls : String;
    FBoxLabelAlign : String;
    FInputValue : String;
    FUncheckedValue : String;
    FHandler : TExtFunction;
    FScope : TExtObject;
    FOriginalValue : TExtObject;
    procedure SetFBeforeBoxLabelTpl(Value : String);
    procedure SetFBeforeBoxLabelTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeBoxLabelTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterBoxLabelTpl(Value : String);
    procedure SetFAfterBoxLabelTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterBoxLabelTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBeforeBoxLabelTextTpl(Value : String);
    procedure SetFBeforeBoxLabelTextTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBeforeBoxLabelTextTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFAfterBoxLabelTextTpl(Value : String);
    procedure SetFAfterBoxLabelTextTplTExtObjectList(Value : TExtObjectList);
    procedure SetFAfterBoxLabelTextTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFBoxLabelAttrTpl(Value : String);
    procedure SetFBoxLabelAttrTplTExtObjectList(Value : TExtObjectList);
    procedure SetFBoxLabelAttrTplTExtXTemplate(Value : TExtXTemplate);
    procedure SetFFocusCls(Value : String);
    procedure SetFFieldCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFChecked(Value : Boolean);
    procedure SetFCheckedCls(Value : String);
    procedure SetFBoxLabel(Value : String);
    procedure SetFBoxLabelCls(Value : String);
    procedure SetFBoxLabelAlign(Value : String);
    procedure SetFInputValue(Value : String);
    procedure SetFUncheckedValue(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFOriginalValue(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetRawValue : TExtFunction;
    function GetValue : TExtFunction;
    function GetSubmitValue : TExtFunction;
    function SetRawValue(Value : Boolean) : TExtFunction; overload;
    function SetRawValue(Value : String) : TExtFunction; overload;
    function SetRawValue(Value : Integer) : TExtFunction; overload;
    function SetValue(Checked : Boolean) : TExtFunction; overload;
    function SetValue(Checked : String) : TExtFunction; overload;
    destructor Destroy; override;
    property BeforeBoxLabelTpl : String read FBeforeBoxLabelTpl write SetFBeforeBoxLabelTpl;
    property BeforeBoxLabelTplTExtObjectList : TExtObjectList read FBeforeBoxLabelTplTExtObjectList write SetFBeforeBoxLabelTplTExtObjectList;
    property BeforeBoxLabelTplTExtXTemplate : TExtXTemplate read FBeforeBoxLabelTplTExtXTemplate write SetFBeforeBoxLabelTplTExtXTemplate;
    property AfterBoxLabelTpl : String read FAfterBoxLabelTpl write SetFAfterBoxLabelTpl;
    property AfterBoxLabelTplTExtObjectList : TExtObjectList read FAfterBoxLabelTplTExtObjectList write SetFAfterBoxLabelTplTExtObjectList;
    property AfterBoxLabelTplTExtXTemplate : TExtXTemplate read FAfterBoxLabelTplTExtXTemplate write SetFAfterBoxLabelTplTExtXTemplate;
    property BeforeBoxLabelTextTpl : String read FBeforeBoxLabelTextTpl write SetFBeforeBoxLabelTextTpl;
    property BeforeBoxLabelTextTplTExtObjectList : TExtObjectList read FBeforeBoxLabelTextTplTExtObjectList write SetFBeforeBoxLabelTextTplTExtObjectList;
    property BeforeBoxLabelTextTplTExtXTemplate : TExtXTemplate read FBeforeBoxLabelTextTplTExtXTemplate write SetFBeforeBoxLabelTextTplTExtXTemplate;
    property AfterBoxLabelTextTpl : String read FAfterBoxLabelTextTpl write SetFAfterBoxLabelTextTpl;
    property AfterBoxLabelTextTplTExtObjectList : TExtObjectList read FAfterBoxLabelTextTplTExtObjectList write SetFAfterBoxLabelTextTplTExtObjectList;
    property AfterBoxLabelTextTplTExtXTemplate : TExtXTemplate read FAfterBoxLabelTextTplTExtXTemplate write SetFAfterBoxLabelTextTplTExtXTemplate;
    property BoxLabelAttrTpl : String read FBoxLabelAttrTpl write SetFBoxLabelAttrTpl;
    property BoxLabelAttrTplTExtObjectList : TExtObjectList read FBoxLabelAttrTplTExtObjectList write SetFBoxLabelAttrTplTExtObjectList;
    property BoxLabelAttrTplTExtXTemplate : TExtXTemplate read FBoxLabelAttrTplTExtXTemplate write SetFBoxLabelAttrTplTExtXTemplate;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property Checked : Boolean read FChecked write SetFChecked;
    property CheckedCls : String read FCheckedCls write SetFCheckedCls;
    property BoxLabel : String read FBoxLabel write SetFBoxLabel;
    property BoxLabelCls : String read FBoxLabelCls write SetFBoxLabelCls;
    property BoxLabelAlign : String read FBoxLabelAlign write SetFBoxLabelAlign;
    property InputValue : String read FInputValue write SetFInputValue;
    property UncheckedValue : String read FUncheckedValue write SetFUncheckedValue;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
  end;

  // Procedural types for events TExtDataTreeStore
  TExtDataTreeStoreOnAppend = procedure of object;
  TExtDataTreeStoreOnRemove = procedure of object;
  TExtDataTreeStoreOnMove = procedure of object;
  TExtDataTreeStoreOnInsert = procedure of object;
  TExtDataTreeStoreOnBeforeappend = procedure of object;
  TExtDataTreeStoreOnBeforeremove = procedure of object;
  TExtDataTreeStoreOnBeforemove = procedure of object;
  TExtDataTreeStoreOnBeforeinsert = procedure of object;
  TExtDataTreeStoreOnExpand = procedure of object;
  TExtDataTreeStoreOnCollapse = procedure of object;
  TExtDataTreeStoreOnBeforeexpand = procedure of object;
  TExtDataTreeStoreOnBeforecollapse = procedure of object;
  TExtDataTreeStoreOnSort = procedure of object;
  TExtDataTreeStoreOnRootchange = procedure of object;
  TExtDataTreeStoreOnLoad = procedure(This : TExtDataTreeStore; Node : TExtDataNodeInterface; Records : TExtObjectList; Successful : Boolean) of object;

  TExtDataTreeStore = class(TExtDataAbstractStore)
  private
    FRoot : TExtDataModel;
    FRootTExtDataNodeInterface : TExtDataNodeInterface;
    FRootTExtObject : TExtObject;
    FClearOnLoad : Boolean;
    FClearRemovedOnLoad : Boolean;
    FNodeParam : String;
    FDefaultRootId : String;
    FDefaultRootProperty : String;
    FFolderSort : Boolean;
    FOnAppend : TExtDataTreeStoreOnAppend;
    FOnRemove : TExtDataTreeStoreOnRemove;
    FOnMove : TExtDataTreeStoreOnMove;
    FOnInsert : TExtDataTreeStoreOnInsert;
    FOnBeforeappend : TExtDataTreeStoreOnBeforeappend;
    FOnBeforeremove : TExtDataTreeStoreOnBeforeremove;
    FOnBeforemove : TExtDataTreeStoreOnBeforemove;
    FOnBeforeinsert : TExtDataTreeStoreOnBeforeinsert;
    FOnExpand : TExtDataTreeStoreOnExpand;
    FOnCollapse : TExtDataTreeStoreOnCollapse;
    FOnBeforeexpand : TExtDataTreeStoreOnBeforeexpand;
    FOnBeforecollapse : TExtDataTreeStoreOnBeforecollapse;
    FOnSort : TExtDataTreeStoreOnSort;
    FOnRootchange : TExtDataTreeStoreOnRootchange;
    FOnLoad : TExtDataTreeStoreOnLoad;
    procedure SetFRoot(Value : TExtDataModel);
    procedure SetFRootTExtDataNodeInterface(Value : TExtDataNodeInterface);
    procedure SetFRootTExtObject(Value : TExtObject);
    procedure SetFClearOnLoad(Value : Boolean);
    procedure SetFClearRemovedOnLoad(Value : Boolean);
    procedure SetFNodeParam(Value : String);
    procedure SetFDefaultRootId(Value : String);
    procedure SetFDefaultRootProperty(Value : String);
    procedure SetFFolderSort(Value : Boolean);
    procedure SetFOnAppend(Value : TExtDataTreeStoreOnAppend);
    procedure SetFOnRemove(Value : TExtDataTreeStoreOnRemove);
    procedure SetFOnMove(Value : TExtDataTreeStoreOnMove);
    procedure SetFOnInsert(Value : TExtDataTreeStoreOnInsert);
    procedure SetFOnBeforeappend(Value : TExtDataTreeStoreOnBeforeappend);
    procedure SetFOnBeforeremove(Value : TExtDataTreeStoreOnBeforeremove);
    procedure SetFOnBeforemove(Value : TExtDataTreeStoreOnBeforemove);
    procedure SetFOnBeforeinsert(Value : TExtDataTreeStoreOnBeforeinsert);
    procedure SetFOnExpand(Value : TExtDataTreeStoreOnExpand);
    procedure SetFOnCollapse(Value : TExtDataTreeStoreOnCollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataTreeStoreOnBeforeexpand);
    procedure SetFOnBeforecollapse(Value : TExtDataTreeStoreOnBeforecollapse);
    procedure SetFOnSort(Value : TExtDataTreeStoreOnSort);
    procedure SetFOnRootchange(Value : TExtDataTreeStoreOnRootchange);
    procedure SetFOnLoad(Value : TExtDataTreeStoreOnLoad);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Root : TExtDataModel read FRoot write SetFRoot;
    property RootTExtDataNodeInterface : TExtDataNodeInterface read FRootTExtDataNodeInterface write SetFRootTExtDataNodeInterface;
    property RootTExtObject : TExtObject read FRootTExtObject write SetFRootTExtObject;
    property ClearOnLoad : Boolean read FClearOnLoad write SetFClearOnLoad;
    property ClearRemovedOnLoad : Boolean read FClearRemovedOnLoad write SetFClearRemovedOnLoad;
    property NodeParam : String read FNodeParam write SetFNodeParam;
    property DefaultRootId : String read FDefaultRootId write SetFDefaultRootId;
    property DefaultRootProperty : String read FDefaultRootProperty write SetFDefaultRootProperty;
    property FolderSort : Boolean read FFolderSort write SetFFolderSort;
    property OnAppend : TExtDataTreeStoreOnAppend read FOnAppend write SetFOnAppend;
    property OnRemove : TExtDataTreeStoreOnRemove read FOnRemove write SetFOnRemove;
    property OnMove : TExtDataTreeStoreOnMove read FOnMove write SetFOnMove;
    property OnInsert : TExtDataTreeStoreOnInsert read FOnInsert write SetFOnInsert;
    property OnBeforeappend : TExtDataTreeStoreOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforeremove : TExtDataTreeStoreOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnBeforemove : TExtDataTreeStoreOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeinsert : TExtDataTreeStoreOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnExpand : TExtDataTreeStoreOnExpand read FOnExpand write SetFOnExpand;
    property OnCollapse : TExtDataTreeStoreOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnBeforeexpand : TExtDataTreeStoreOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforecollapse : TExtDataTreeStoreOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnSort : TExtDataTreeStoreOnSort read FOnSort write SetFOnSort;
    property OnRootchange : TExtDataTreeStoreOnRootchange read FOnRootchange write SetFOnRootchange;
    property OnLoad : TExtDataTreeStoreOnLoad read FOnLoad write SetFOnLoad;
  end;

  TExtPickerTime = class(TExtViewBoundList)
  private
    FMinValue : TDateTime;
    FMaxValue : TDateTime;
    FIncrement : Integer;
    FFormat : String; // 'g:i A'
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFIncrement(Value : Integer);
    procedure SetFFormat(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetMinValue(Value : TDateTime) : TExtFunction;
    function SetMaxValue(Value : TDateTime) : TExtFunction;
    function UpdateList : TExtFunction;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property Increment : Integer read FIncrement write SetFIncrement;
    property Format : String read FFormat write SetFFormat;
  end;

  TExtFormCheckboxGroup = class(TExtFormFieldContainer)
  private
    FItems : TExtObjectList;
    FItemsTExtObjectList : TExtObjectList;
    FColumns : String;
    FColumnsInteger : Integer;
    FColumnsTArrayOfInteger : TArrayOfInteger;
    FVertical : Boolean;
    FAllowBlank : Boolean;
    FBlankText : String;
    FFieldBodyCls : String;
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFItemsTExtObjectList(Value : TExtObjectList);
    procedure SetFColumns(Value : String);
    procedure SetFColumnsInteger(Value : Integer);
    procedure SetFColumnsTArrayOfInteger(Value : TArrayOfInteger);
    procedure SetFVertical(Value : Boolean);
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFFieldBodyCls(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors : TExtFunction;
    function GetChecked : TExtFunction;
    function Reset : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function GetValue : TExtFunction;
    destructor Destroy; override;
    property Items : TExtObjectList read FItems write SetFItems;
    property ItemsTExtObjectList : TExtObjectList read FItemsTExtObjectList write SetFItemsTExtObjectList;
    property Columns : String read FColumns write SetFColumns;
    property ColumnsInteger : Integer read FColumnsInteger write SetFColumnsInteger;
    property ColumnsTArrayOfInteger : TArrayOfInteger read FColumnsTArrayOfInteger write SetFColumnsTArrayOfInteger;
    property Vertical : Boolean read FVertical write SetFVertical;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
  end;

  TExtFormActionStandardSubmit = class(TExtFormActionSubmit)
  private
    FTarget : String;
    procedure SetFTarget(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Target : String read FTarget write SetFTarget;
  end;

  TExtGridView = class(TExtViewTable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtMenuSeparator = class(TExtMenuItem)
  private
    FSeparatorCls : String;
    procedure SetFSeparatorCls(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property SeparatorCls : String read FSeparatorCls write SetFSeparatorCls;
  end;

  TExtChartSeriesScatter = class(TExtChartSeriesCartesian)
  private
    FMarkerConfig : TExtObject;
    FStyle : TExtObject;
    FAxis : String;
    FAxisTExtObjectList : TExtObjectList;
    procedure SetFMarkerConfig(Value : TExtObject);
    procedure SetFStyle(Value : TExtObject);
    procedure SetFAxis(Value : String);
    procedure SetFAxisTExtObjectList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property MarkerConfig : TExtObject read FMarkerConfig write SetFMarkerConfig;
    property Style : TExtObject read FStyle write SetFStyle;
    property Axis : String read FAxis write SetFAxis;
    property AxisTExtObjectList : TExtObjectList read FAxisTExtObjectList write SetFAxisTExtObjectList;
  end;

  TExtSelectionCheckboxModel = class(TExtSelectionRowModel)
  private
    FMode : String;
    FInjectCheckbox : Integer;
    FInjectCheckboxString : String;
    FCheckOnly : Boolean;
    FShowHeaderCheckbox : Boolean;
    procedure SetFMode(Value : String);
    procedure SetFInjectCheckbox(Value : Integer);
    procedure SetFInjectCheckboxString(Value : String);
    procedure SetFCheckOnly(Value : Boolean);
    procedure SetFShowHeaderCheckbox(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function OnHeaderClick : TExtFunction;
    function GetHeaderConfig : TExtFunction;
    function Renderer : TExtFunction;
    property Mode : String read FMode write SetFMode;
    property InjectCheckbox : Integer read FInjectCheckbox write SetFInjectCheckbox;
    property InjectCheckboxString : String read FInjectCheckboxString write SetFInjectCheckboxString;
    property CheckOnly : Boolean read FCheckOnly write SetFCheckOnly;
    property ShowHeaderCheckbox : Boolean read FShowHeaderCheckbox write SetFShowHeaderCheckbox;
  end;

  TExtFormFieldHidden = class(TExtFormFieldBase)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPropertyHeaderContainer = class(TExtGridHeaderContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Grid : TExtGridPropertyGrid; Source : TExtObject);
  end;

  TExtGridColumnBoolean = class(TExtGridColumn)
  private
    FTrueText : String;
    FFalseText : String;
    FUndefinedText : String;
    procedure SetFTrueText(Value : String);
    procedure SetFFalseText(Value : String);
    procedure SetFUndefinedText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property TrueText : String read FTrueText write SetFTrueText;
    property FalseText : String read FFalseText write SetFFalseText;
    property UndefinedText : String read FUndefinedText write SetFUndefinedText;
  end;

  TExtGridColumnDate = class(TExtGridColumn)
  private
    FFormat : String;
    procedure SetFFormat(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Format : String read FFormat write SetFFormat;
  end;

  // Procedural types for events TExtButtonCycle
  TExtButtonCycleOnChange = procedure(This : TExtButtonCycle; Item : TExtMenuCheckItem) of object;

  TExtButtonCycle = class(TExtButtonSplit)
  private
    FItems : TExtObjectList;
    FShowText : Boolean;
    FPrependText : String;
    FChangeHandler : TExtFunction;
    FForceIcon : String;
    FMenu : TExtMenu;
    FOnChange : TExtButtonCycleOnChange;
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFShowText(Value : Boolean);
    procedure SetFPrependText(Value : String);
    procedure SetFChangeHandler(Value : TExtFunction);
    procedure SetFForceIcon(Value : String);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFOnChange(Value : TExtButtonCycleOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function ToggleSelected : TExtFunction;
    destructor Destroy; override;
    property Items : TExtObjectList read FItems write SetFItems;
    property ShowText : Boolean read FShowText write SetFShowText;
    property PrependText : String read FPrependText write SetFPrependText;
    property ChangeHandler : TExtFunction read FChangeHandler write SetFChangeHandler;
    property ForceIcon : String read FForceIcon write SetFForceIcon;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property OnChange : TExtButtonCycleOnChange read FOnChange write SetFOnChange;
  end;

  TExtDataXmlStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridColumnNumber = class(TExtGridColumn)
  private
    FFormat : String;
    procedure SetFFormat(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Format : String read FFormat write SetFFormat;
  end;

  TExtGridColumnTemplate = class(TExtGridColumn)
  private
    FTpl : String;
    FTplTExtXTemplate : TExtXTemplate;
    procedure SetFTpl(Value : String);
    procedure SetFTplTExtXTemplate(Value : TExtXTemplate);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Tpl : String read FTpl write SetFTpl;
    property TplTExtXTemplate : TExtXTemplate read FTplTExtXTemplate write SetFTplTExtXTemplate;
  end;

  TExtGridColumnAction = class(TExtGridColumn)
  private
    FIcon : String;
    FIconCls : String;
    FHandler : TExtFunction;
    FScope : TExtObject;
    FTooltip : String;
    FDisabled : Boolean;
    FStopSelection : Boolean;
    FGetClass : TExtFunction;
    FItems : TExtObjectList;
    FAltText : String;
    FMenuText : String;
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFTooltip(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFStopSelection(Value : Boolean);
    procedure SetFGetClass(Value : TExtFunction);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFAltText(Value : String);
    procedure SetFMenuText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function EnableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; overload;
    function EnableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; overload;
    function DisableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; overload;
    function DisableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; overload;
    destructor Destroy; override;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Scope : TExtObject read FScope write SetFScope;
    property Tooltip : String read FTooltip write SetFTooltip;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property StopSelection : Boolean read FStopSelection write SetFStopSelection;
    property GetClass : TExtFunction read FGetClass write SetFGetClass;
    property Items : TExtObjectList read FItems write SetFItems;
    property AltText : String read FAltText write SetFAltText;
    property MenuText : String read FMenuText write SetFMenuText;
  end;

  TExtDdDragSource = class(TExtDdDDProxy)
  private
    FDdGroup : String;
    FDropAllowed : String;
    FDropNotAllowed : String;
    FAnimRepair : Boolean;
    FRepairHighlightColor : String;
    procedure SetFDdGroup(Value : String);
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
    procedure SetFAnimRepair(Value : Boolean);
    procedure SetFRepairHighlightColor(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(El : String; Config : TExtObject = nil); overload;
    constructor Create(El : THTMLElement; Config : TExtObject = nil); overload;
    constructor Create(El : TExtElement; Config : TExtObject = nil); overload;
    function GetDragData : TExtFunction;
    function GetProxy : TExtFunction;
    function HideProxy : TExtFunction;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
    property AnimRepair : Boolean read FAnimRepair write SetFAnimRepair;
    property RepairHighlightColor : String read FRepairHighlightColor write SetFRepairHighlightColor;
  end;

  TExtDdDropZone = class(TExtDdDropTarget)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetTargetFromEvent(E : TEvent) : TExtFunction;
    function OnNodeEnter(NodeData : TExtObject; Source : TExtDdDragSource; E : TEvent; Data : TExtObject) : TExtFunction;
  end;

  TExtFormFieldTrigger = class(TExtFormFieldText)
  private
    FTriggerCls : String;
    FHideTrigger : Boolean;
    FEditable : Boolean;
    FReadOnly : Boolean;
    FSelectOnFocus : Boolean;
    FRepeatTriggerClick : Boolean;
    FGrow : Boolean;
    procedure SetFTriggerCls(Value : String);
    procedure SetFHideTrigger(Value : Boolean);
    procedure SetFEditable(Value : Boolean);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFRepeatTriggerClick(Value : Boolean);
    procedure SetFGrow(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property HideTrigger : Boolean read FHideTrigger write SetFHideTrigger;
    property Editable : Boolean read FEditable write SetFEditable;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property RepeatTriggerClick : Boolean read FRepeatTriggerClick write SetFRepeatTriggerClick;
    property Grow : Boolean read FGrow write SetFGrow;
  end;

  TExtLayoutContainerVBox = class(TExtLayoutContainerBox)
  private
    FAlign : String;
    procedure SetFAlign(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Align : String read FAlign write SetFAlign;
  end;

  TExtFormFieldRadio = class(TExtFormFieldCheckbox)
  private
    FUncheckedValue : String;
    procedure SetFUncheckedValue(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetGroupValue : TExtFunction;
    function SetValue(Value : String) : TExtFunction; overload;
    function SetValue(Value : Boolean) : TExtFunction; overload;
    function GetSubmitValue : TExtFunction;
    property UncheckedValue : String read FUncheckedValue write SetFUncheckedValue;
  end;

  TExtGridRowNumberer = class(TExtGridColumn)
  private
    FText : String;
    FWidth : Integer;
    FDraggable : Boolean;
    procedure SetFText(Value : String);
    procedure SetFWidth(Value : Integer);
    procedure SetFDraggable(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Text : String read FText write SetFText;
    property Width : Integer read FWidth write SetFWidth;
    property Draggable : Boolean read FDraggable write SetFDraggable;
  end;

  TExtDataDirectStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerAbsolute = class(TExtLayoutContainerAnchor)
  private
    FIgnoreOnContentChange : Boolean;
    procedure SetFIgnoreOnContentChange(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IgnoreOnContentChange : Boolean read FIgnoreOnContentChange write SetFIgnoreOnContentChange;
  end;

  // Procedural types for events TExtFormFieldTextArea
  TExtFormFieldTextAreaOnAutosize = procedure(This : TExtFormFieldTextArea; Height : Integer) of object;

  TExtFormFieldTextArea = class(TExtFormFieldText)
  private
    FGrowMin : Integer;
    FGrowMax : Integer;
    FGrowAppend : String;
    FCols : Integer;
    FRows : Integer; // 4
    FEnterIsSpecial : Boolean;
    FPreventScrollbars : Boolean;
    FOnAutosize : TExtFormFieldTextAreaOnAutosize;
    procedure SetFGrowMin(Value : Integer);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowAppend(Value : String);
    procedure SetFCols(Value : Integer);
    procedure SetFRows(Value : Integer);
    procedure SetFEnterIsSpecial(Value : Boolean);
    procedure SetFPreventScrollbars(Value : Boolean);
    procedure SetFOnAutosize(Value : TExtFormFieldTextAreaOnAutosize);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowAppend : String read FGrowAppend write SetFGrowAppend;
    property Cols : Integer read FCols write SetFCols;
    property Rows : Integer read FRows write SetFRows;
    property EnterIsSpecial : Boolean read FEnterIsSpecial write SetFEnterIsSpecial;
    property PreventScrollbars : Boolean read FPreventScrollbars write SetFPreventScrollbars;
    property OnAutosize : TExtFormFieldTextAreaOnAutosize read FOnAutosize write SetFOnAutosize;
  end;

  TExtLayoutContainerCard = class(TExtLayoutContainerFit)
  private
    FDeferredRender : Boolean;
    procedure SetFDeferredRender(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetActiveItem : TExtFunction;
    function GetNext : TExtFunction;
    function Next : TExtFunction;
    function GetPrev : TExtFunction;
    function Prev : TExtFunction;
    function SetActiveItem(NewCard : TExtComponent) : TExtFunction; overload;
    function SetActiveItem(NewCard : Integer) : TExtFunction; overload;
    function SetActiveItem(NewCard : String) : TExtFunction; overload;
    property DeferredRender : Boolean read FDeferredRender write SetFDeferredRender;
  end;

  TExtLayoutContainerHBox = class(TExtLayoutContainerBox)
  private
    FAlign : String;
    procedure SetFAlign(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Align : String read FAlign write SetFAlign;
  end;

  TExtLayoutContainerForm = class(TExtLayoutContainerAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormRadioGroup = class(TExtFormCheckboxGroup)
  private
    FItems : TExtObjectList;
    FItemsTExtObjectList : TExtObjectList;
    FAllowBlank : Boolean;
    FBlankText : String;
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFItemsTExtObjectList(Value : TExtObjectList);
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetValue(Value : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Items : TExtObjectList read FItems write SetFItems;
    property ItemsTExtObjectList : TExtObjectList read FItemsTExtObjectList write SetFItemsTExtObjectList;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
  end;

  TExtDataJsonStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtTipQuickTip = class(TExtTipToolTip)
  private
    FTarget : String;
    FTargetTHTMLElement : THTMLElement;
    FTargetTExtElement : TExtElement;
    FInterceptTitles : Boolean;
    procedure SetFTarget(Value : String);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
    procedure SetFTargetTExtElement(Value : TExtElement);
    procedure SetFInterceptTitles(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Register(Config : TExtObject) : TExtFunction;
    function Unregister(El : String) : TExtFunction; overload;
    function Unregister(El : THTMLElement) : TExtFunction; overload;
    function Unregister(El : TExtElement) : TExtFunction; overload;
    function CancelShow(El : String) : TExtFunction; overload;
    function CancelShow(El : THTMLElement) : TExtFunction; overload;
    function CancelShow(El : TExtElement) : TExtFunction; overload;
    destructor Destroy; override;
    property Target : String read FTarget write SetFTarget;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
    property TargetTExtElement : TExtElement read FTargetTExtElement write SetFTargetTExtElement;
    property InterceptTitles : Boolean read FInterceptTitles write SetFInterceptTitles;
  end;

  TExtDataReaderArray = class(TExtDataReaderJson)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataArrayStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridPropertyGrid
  TExtGridPropertyGridOnBeforepropertychange = procedure(Source : TExtObject; RecordId : String; Value : TExtObject; OldValue : TExtObject) of object;
  TExtGridPropertyGridOnPropertychange = procedure(Source : TExtObject; RecordId : String; Value : TExtObject; OldValue : TExtObject) of object;

  TExtGridPropertyGrid = class(TExtGridPanel)
  private
    FPropertyNames : TExtObject;
    FSource : TExtObject;
    FCustomEditors : TExtObject;
    FCustomRenderers : TExtObject;
    FValueField : String;
    FNameField : String;
    FNameColumnWidth : Integer;
    FOnBeforepropertychange : TExtGridPropertyGridOnBeforepropertychange;
    FOnPropertychange : TExtGridPropertyGridOnPropertychange;
    procedure SetFPropertyNames(Value : TExtObject);
    procedure SetFSource(Value : TExtObject);
    procedure SetFCustomEditors(Value : TExtObject);
    procedure SetFCustomRenderers(Value : TExtObject);
    procedure SetFValueField(Value : String);
    procedure SetFNameField(Value : String);
    procedure SetFNameColumnWidth(Value : Integer);
    procedure SetFOnBeforepropertychange(Value : TExtGridPropertyGridOnBeforepropertychange);
    procedure SetFOnPropertychange(Value : TExtGridPropertyGridOnPropertychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetSource(Source : TExtObject) : TExtFunction;
    function GetSource : TExtFunction;
    function SetProperty(Prop : String; Value : TExtObject; Create : Boolean = false) : TExtFunction;
    function RemoveProperty(Prop : String) : TExtFunction;
    destructor Destroy; override;
    property PropertyNames : TExtObject read FPropertyNames write SetFPropertyNames;
    property Source : TExtObject read FSource write SetFSource;
    property CustomEditors : TExtObject read FCustomEditors write SetFCustomEditors;
    property CustomRenderers : TExtObject read FCustomRenderers write SetFCustomRenderers;
    property ValueField : String read FValueField write SetFValueField;
    property NameField : String read FNameField write SetFNameField;
    property NameColumnWidth : Integer read FNameColumnWidth write SetFNameColumnWidth;
    property OnBeforepropertychange : TExtGridPropertyGridOnBeforepropertychange read FOnBeforepropertychange write SetFOnBeforepropertychange;
    property OnPropertychange : TExtGridPropertyGridOnPropertychange read FOnPropertychange write SetFOnPropertychange;
  end;

  TExtGridPropertyStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Grid : TExtGridPanel; Source : TExtObject);
  end;

  TExtSliderSingle = class(TExtSliderMulti)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetValue : TExtFunction;
    function SetValue(Value : Integer; Animate : Boolean = false) : TExtFunction;
  end;

  TExtChartSeriesColumn = class(TExtChartSeriesBar)
  private
    FXPadding : Integer;
    FYPadding : Integer;
    procedure SetFXPadding(Value : Integer);
    procedure SetFYPadding(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property XPadding : Integer read FXPadding write SetFXPadding;
    property YPadding : Integer read FYPadding write SetFYPadding;
  end;

  TExtDataJsonPStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormFieldPicker
  TExtFormFieldPickerOnExpand = procedure(Field : TExtFormFieldPicker) of object;
  TExtFormFieldPickerOnCollapse = procedure(Field : TExtFormFieldPicker) of object;
  TExtFormFieldPickerOnSelect = procedure(Field : TExtFormFieldPicker; Value : TExtObject) of object;

  TExtFormFieldPicker = class(TExtFormFieldTrigger)
  private
    FMatchFieldWidth : Boolean; // true
    FPickerAlign : String; // 'tl-bl?'
    FOpenCls : String;
    FEditable : Boolean;
    FOnExpand : TExtFormFieldPickerOnExpand;
    FOnCollapse : TExtFormFieldPickerOnCollapse;
    FOnSelect : TExtFormFieldPickerOnSelect;
    procedure SetFMatchFieldWidth(Value : Boolean);
    procedure SetFPickerAlign(Value : String);
    procedure SetFOpenCls(Value : String);
    procedure SetFEditable(Value : Boolean);
    procedure SetFOnExpand(Value : TExtFormFieldPickerOnExpand);
    procedure SetFOnCollapse(Value : TExtFormFieldPickerOnCollapse);
    procedure SetFOnSelect(Value : TExtFormFieldPickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Expand : TExtFunction;
    function Collapse : TExtFunction;
    function GetPicker : TExtFunction;
    property MatchFieldWidth : Boolean read FMatchFieldWidth write SetFMatchFieldWidth;
    property PickerAlign : String read FPickerAlign write SetFPickerAlign;
    property OpenCls : String read FOpenCls write SetFOpenCls;
    property Editable : Boolean read FEditable write SetFEditable;
    property OnExpand : TExtFormFieldPickerOnExpand read FOnExpand write SetFOnExpand;
    property OnCollapse : TExtFormFieldPickerOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnSelect : TExtFormFieldPickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtFormFieldFile = class(TExtFormFieldTrigger)
  private
    FButtonText : String;
    FButtonOnly : Boolean;
    FButtonMargin : Integer;
    FButtonConfig : TExtObject;
    FFieldBodyCls : String;
    FReadOnly : Boolean;
    procedure SetFButtonText(Value : String);
    procedure SetFButtonOnly(Value : Boolean);
    procedure SetFButtonMargin(Value : Integer);
    procedure SetFButtonConfig(Value : TExtObject);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFReadOnly(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTriggerMarkup : TExtFunction;
    function SetValueExtEmptyFnReset : TExtFunction;
    destructor Destroy; override;
    property ButtonText : String read FButtonText write SetFButtonText;
    property ButtonOnly : Boolean read FButtonOnly write SetFButtonOnly;
    property ButtonMargin : Integer read FButtonMargin write SetFButtonMargin;
    property ButtonConfig : TExtObject read FButtonConfig write SetFButtonConfig;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
  end;

  TExtFormFieldSpinner = class(TExtFormFieldTrigger)
  private
    FSpinUpEnabled : Boolean; // true
    FSpinDownEnabled : Boolean; // true
    FKeyNavEnabled : Boolean; // true
    FMouseWheelEnabled : Boolean; // true
    FRepeatTriggerClick : Boolean; // true
    FSpinUpEl : TExtElement;
    FSpinDownEl : TExtElement;
    procedure SetFSpinUpEnabled(Value : Boolean);
    procedure SetFSpinDownEnabled(Value : Boolean);
    procedure SetFKeyNavEnabled(Value : Boolean);
    procedure SetFMouseWheelEnabled(Value : Boolean);
    procedure SetFRepeatTriggerClick(Value : Boolean);
    procedure SetFSpinUpEl(Value : TExtElement);
    procedure SetFSpinDownEl(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTriggerWidth : TExtFunction;
    function SpinUp : TExtFunction;
    function SpinDown : TExtFunction;
    function SetSpinUpEnabled(Enabled : Boolean) : TExtFunction;
    function SetSpinDownEnabled(Enabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property SpinUpEnabled : Boolean read FSpinUpEnabled write SetFSpinUpEnabled;
    property SpinDownEnabled : Boolean read FSpinDownEnabled write SetFSpinDownEnabled;
    property KeyNavEnabled : Boolean read FKeyNavEnabled write SetFKeyNavEnabled;
    property MouseWheelEnabled : Boolean read FMouseWheelEnabled write SetFMouseWheelEnabled;
    property RepeatTriggerClick : Boolean read FRepeatTriggerClick write SetFRepeatTriggerClick;
    property SpinUpEl : TExtElement read FSpinUpEl write SetFSpinUpEl;
    property SpinDownEl : TExtElement read FSpinDownEl write SetFSpinDownEl;
  end;

  TExtLayoutContainerAccordion = class(TExtLayoutContainerVBox)
  private
    FFill : Boolean;
    FAutoWidth : Boolean;
    FTitleCollapse : Boolean;
    FHideCollapseTool : Boolean;
    FCollapseFirst : Boolean;
    FAnimate : Boolean;
    FActiveOnTop : Boolean;
    FMulti : Boolean;
    procedure SetFFill(Value : Boolean);
    procedure SetFAutoWidth(Value : Boolean);
    procedure SetFTitleCollapse(Value : Boolean);
    procedure SetFHideCollapseTool(Value : Boolean);
    procedure SetFCollapseFirst(Value : Boolean);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFActiveOnTop(Value : Boolean);
    procedure SetFMulti(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Fill : Boolean read FFill write SetFFill;
    property AutoWidth : Boolean read FAutoWidth write SetFAutoWidth;
    property TitleCollapse : Boolean read FTitleCollapse write SetFTitleCollapse;
    property HideCollapseTool : Boolean read FHideCollapseTool write SetFHideCollapseTool;
    property CollapseFirst : Boolean read FCollapseFirst write SetFCollapseFirst;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property ActiveOnTop : Boolean read FActiveOnTop write SetFActiveOnTop;
    property Multi : Boolean read FMulti write SetFMulti;
  end;

  TExtDdDragZone = class(TExtDdDragSource)
  private
    FContainerScroll : Boolean;
    procedure SetFContainerScroll(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetDragData(E : TEvent) : TExtFunction;
    property ContainerScroll : Boolean read FContainerScroll write SetFContainerScroll;
  end;

  // Procedural types for events TExtFormFieldComboBox
  TExtFormFieldComboBoxOnBeforequery = procedure(QueryEvent : TExtObject) of object;
  TExtFormFieldComboBoxOnSelect = procedure(Combo : TExtFormFieldComboBox; Records : TExtObjectList) of object;
  TExtFormFieldComboBoxOnBeforeselect = procedure(Combo : TExtFormFieldComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;
  TExtFormFieldComboBoxOnBeforedeselect = procedure(Combo : TExtFormFieldComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;

  TExtFormFieldComboBox = class(TExtFormFieldPicker)
  private
    FTriggerCls : String;
    FHiddenName : String;
    FStore : TExtDataStore;
    FStoreTExtObjectList : TExtObjectList;
    FMultiSelect : Boolean;
    FDelimiter : String;
    FDisplayField : String;
    FValueField : String;
    FTriggerAction : String;
    FAllQuery : String;
    FQueryParam : String;
    FQueryMode : String;
    FQueryCaching : Boolean;
    FPageSize : Integer;
    FQueryDelay : Integer; // 500
    FAutoSelect : Boolean;
    FTypeAhead : Boolean;
    FTypeAheadDelay : Integer;
    FSelectOnTab : Boolean;
    FForceSelection : Boolean;
    FGrowToLongestValue : Boolean;
    FValueNotFoundText : String;
    FDefaultListConfig : TExtObject;
    FTransform : String;
    FTransformTHTMLElement : THTMLElement;
    FTransformTExtElement : TExtElement;
    FListConfig : TExtObject;
    FOnBeforequery : TExtFormFieldComboBoxOnBeforequery;
    FOnSelect : TExtFormFieldComboBoxOnSelect;
    FOnBeforeselect : TExtFormFieldComboBoxOnBeforeselect;
    FOnBeforedeselect : TExtFormFieldComboBoxOnBeforedeselect;
    procedure SetFTriggerCls(Value : String);
    procedure SetFHiddenName(Value : String);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFStoreTExtObjectList(Value : TExtObjectList);
    procedure SetFMultiSelect(Value : Boolean);
    procedure SetFDelimiter(Value : String);
    procedure SetFDisplayField(Value : String);
    procedure SetFValueField(Value : String);
    procedure SetFTriggerAction(Value : String);
    procedure SetFAllQuery(Value : String);
    procedure SetFQueryParam(Value : String);
    procedure SetFQueryMode(Value : String);
    procedure SetFQueryCaching(Value : Boolean);
    procedure SetFPageSize(Value : Integer);
    procedure SetFQueryDelay(Value : Integer);
    procedure SetFAutoSelect(Value : Boolean);
    procedure SetFTypeAhead(Value : Boolean);
    procedure SetFTypeAheadDelay(Value : Integer);
    procedure SetFSelectOnTab(Value : Boolean);
    procedure SetFForceSelection(Value : Boolean);
    procedure SetFGrowToLongestValue(Value : Boolean);
    procedure SetFValueNotFoundText(Value : String);
    procedure SetFDefaultListConfig(Value : TExtObject);
    procedure SetFTransform(Value : String);
    procedure SetFTransformTHTMLElement(Value : THTMLElement);
    procedure SetFTransformTExtElement(Value : TExtElement);
    procedure SetFListConfig(Value : TExtObject);
    procedure SetFOnBeforequery(Value : TExtFormFieldComboBoxOnBeforequery);
    procedure SetFOnSelect(Value : TExtFormFieldComboBoxOnSelect);
    procedure SetFOnBeforeselect(Value : TExtFormFieldComboBoxOnBeforeselect);
    procedure SetFOnBeforedeselect(Value : TExtFormFieldComboBoxOnBeforedeselect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetStore : TExtFunction;
    function DoQuery(QueryString : String; ForceAll : Boolean = false; RawQuery : Boolean = false) : TExtFunction;
    function Select(R : TExtObject) : TExtFunction;
    function FindRecord(Field : String; Value : TExtObject) : TExtFunction;
    function FindRecordByValue(Value : TExtObject) : TExtFunction;
    function FindRecordByDisplay(Value : TExtObject) : TExtFunction;
    function SetValue(Value : String) : TExtFunction; overload;
    function SetValue(Value : TExtObjectList) : TExtFunction; overload;
    function ClearValue : TExtFunction;
    destructor Destroy; override;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property HiddenName : String read FHiddenName write SetFHiddenName;
    property Store : TExtDataStore read FStore write SetFStore;
    property StoreTExtObjectList : TExtObjectList read FStoreTExtObjectList write SetFStoreTExtObjectList;
    property MultiSelect : Boolean read FMultiSelect write SetFMultiSelect;
    property Delimiter : String read FDelimiter write SetFDelimiter;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property ValueField : String read FValueField write SetFValueField;
    property TriggerAction : String read FTriggerAction write SetFTriggerAction;
    property AllQuery : String read FAllQuery write SetFAllQuery;
    property QueryParam : String read FQueryParam write SetFQueryParam;
    property QueryMode : String read FQueryMode write SetFQueryMode;
    property QueryCaching : Boolean read FQueryCaching write SetFQueryCaching;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property QueryDelay : Integer read FQueryDelay write SetFQueryDelay;
    property AutoSelect : Boolean read FAutoSelect write SetFAutoSelect;
    property TypeAhead : Boolean read FTypeAhead write SetFTypeAhead;
    property TypeAheadDelay : Integer read FTypeAheadDelay write SetFTypeAheadDelay;
    property SelectOnTab : Boolean read FSelectOnTab write SetFSelectOnTab;
    property ForceSelection : Boolean read FForceSelection write SetFForceSelection;
    property GrowToLongestValue : Boolean read FGrowToLongestValue write SetFGrowToLongestValue;
    property ValueNotFoundText : String read FValueNotFoundText write SetFValueNotFoundText;
    property DefaultListConfig : TExtObject read FDefaultListConfig write SetFDefaultListConfig;
    property Transform : String read FTransform write SetFTransform;
    property TransformTHTMLElement : THTMLElement read FTransformTHTMLElement write SetFTransformTHTMLElement;
    property TransformTExtElement : TExtElement read FTransformTExtElement write SetFTransformTExtElement;
    property ListConfig : TExtObject read FListConfig write SetFListConfig;
    property OnBeforequery : TExtFormFieldComboBoxOnBeforequery read FOnBeforequery write SetFOnBeforequery;
    property OnSelect : TExtFormFieldComboBoxOnSelect read FOnSelect write SetFOnSelect;
    property OnBeforeselect : TExtFormFieldComboBoxOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnBeforedeselect : TExtFormFieldComboBoxOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
  end;

  TExtFormFieldDate = class(TExtFormFieldPicker)
  private
    FFormat : String;
    FAltFormats : String;
    FDisabledDaysText : String;
    FDisabledDatesText : String;
    FMinText : String;
    FMaxText : String;
    FInvalidText : String;
    FTriggerCls : String;
    FShowToday : Boolean;
    FMinValue : TDateTime;
    FMinValueString : String;
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FDisabledDays : TArrayOfInteger;
    FDisabledDates : TExtObjectList;
    FSubmitFormat : String;
    FUseStrict : Boolean;
    FStartDay : Integer; // 0
    FGrow : Boolean;
    procedure SetFFormat(Value : String);
    procedure SetFAltFormats(Value : String);
    procedure SetFDisabledDaysText(Value : String);
    procedure SetFDisabledDatesText(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFTriggerCls(Value : String);
    procedure SetFShowToday(Value : Boolean);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFDisabledDays(Value : TArrayOfInteger);
    procedure SetFDisabledDates(Value : TExtObjectList);
    procedure SetFSubmitFormat(Value : String);
    procedure SetFUseStrict(Value : Boolean);
    procedure SetFStartDay(Value : Integer);
    procedure SetFGrow(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Format : String read FFormat write SetFFormat;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property DisabledDaysText : String read FDisabledDaysText write SetFDisabledDaysText;
    property DisabledDatesText : String read FDisabledDatesText write SetFDisabledDatesText;
    property MinText : String read FMinText write SetFMinText;
    property MaxText : String read FMaxText write SetFMaxText;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property ShowToday : Boolean read FShowToday write SetFShowToday;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property DisabledDays : TArrayOfInteger read FDisabledDays write SetFDisabledDays;
    property DisabledDates : TExtObjectList read FDisabledDates write SetFDisabledDates;
    property SubmitFormat : String read FSubmitFormat write SetFSubmitFormat;
    property UseStrict : Boolean read FUseStrict write SetFUseStrict;
    property StartDay : Integer read FStartDay write SetFStartDay;
    property Grow : Boolean read FGrow write SetFGrow;
  end;

  TExtFormFieldNumber = class(TExtFormFieldSpinner)
  private
    FAllowDecimals : Boolean;
    FDecimalSeparator : String;
    FSubmitLocaleSeparator : Boolean;
    FDecimalPrecision : Integer;
    FMinValue : Integer;
    FMaxValue : Integer;
    FStep : Integer;
    FMinText : String;
    FMaxText : String;
    FNanText : String;
    FNegativeText : String;
    FBaseChars : String;
    FAutoStripChars : Boolean;
    procedure SetFAllowDecimals(Value : Boolean);
    procedure SetFDecimalSeparator(Value : String);
    procedure SetFSubmitLocaleSeparator(Value : Boolean);
    procedure SetFDecimalPrecision(Value : Integer);
    procedure SetFMinValue(Value : Integer);
    procedure SetFMaxValue(Value : Integer);
    procedure SetFStep(Value : Integer);
    procedure SetFMinText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFNanText(Value : String);
    procedure SetFNegativeText(Value : String);
    procedure SetFBaseChars(Value : String);
    procedure SetFAutoStripChars(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetErrors(Value : TExtObject = nil) : TExtFunction;
    function SetMinValue(Value : Integer) : TExtFunction;
    function SetMaxValue(Value : Integer) : TExtFunction;
    property AllowDecimals : Boolean read FAllowDecimals write SetFAllowDecimals;
    property DecimalSeparator : String read FDecimalSeparator write SetFDecimalSeparator;
    property SubmitLocaleSeparator : Boolean read FSubmitLocaleSeparator write SetFSubmitLocaleSeparator;
    property DecimalPrecision : Integer read FDecimalPrecision write SetFDecimalPrecision;
    property MinValue : Integer read FMinValue write SetFMinValue;
    property MaxValue : Integer read FMaxValue write SetFMaxValue;
    property Step : Integer read FStep write SetFStep;
    property MinText : String read FMinText write SetFMinText;
    property MaxText : String read FMaxText write SetFMaxText;
    property NanText : String read FNanText write SetFNanText;
    property NegativeText : String read FNegativeText write SetFNegativeText;
    property BaseChars : String read FBaseChars write SetFBaseChars;
    property AutoStripChars : Boolean read FAutoStripChars write SetFAutoStripChars;
  end;

  TExtFormFieldTime = class(TExtFormFieldComboBox)
  private
    FTriggerCls : String;
    FMinValue : TDateTime;
    FMinValueString : String;
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FMinText : String;
    FMaxText : String;
    FInvalidText : String;
    FFormat : String; // 'g:i A'
    FSubmitFormat : String;
    FAltFormats : String;
    FIncrement : Integer;
    FPickerMaxHeight : Integer;
    FSelectOnTab : Boolean;
    FSnapToIncrement : Boolean;
    procedure SetFTriggerCls(Value : String);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFSubmitFormat(Value : String);
    procedure SetFAltFormats(Value : String);
    procedure SetFIncrement(Value : Integer);
    procedure SetFPickerMaxHeight(Value : Integer);
    procedure SetFSelectOnTab(Value : Boolean);
    procedure SetFSnapToIncrement(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetMinValue(Value : TDateTime) : TExtFunction; overload;
    function SetMinValue(Value : String) : TExtFunction; overload;
    function SetMaxValue(Value : TDateTime) : TExtFunction; overload;
    function SetMaxValue(Value : String) : TExtFunction; overload;
    function GetErrors(Value : TExtObject = nil) : TExtFunction;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property MinText : String read FMinText write SetFMinText;
    property MaxText : String read FMaxText write SetFMaxText;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property Format : String read FFormat write SetFFormat;
    property SubmitFormat : String read FSubmitFormat write SetFSubmitFormat;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property Increment : Integer read FIncrement write SetFIncrement;
    property PickerMaxHeight : Integer read FPickerMaxHeight write SetFPickerMaxHeight;
    property SelectOnTab : Boolean read FSelectOnTab write SetFSelectOnTab;
    property SnapToIncrement : Boolean read FSnapToIncrement write SetFSnapToIncrement;
  end;

var
  ExtEventObjectImpl : TExtEventObjectImplSingleton;
  Mother : TMotherSingleton;
  ExtFormFieldVTypes : TExtFormFieldVTypesSingleton;
  ExtDomHelper : TExtDomHelperSingleton;
  ExtDrawEngineSvgExporter : TExtDrawEngineSvgExporterSingleton;
  ExtDirectManager : TExtDirectManagerSingleton;
  ExtUtilCSS : TExtUtilCSSSingleton;
  ExtMenuManager : TExtMenuManagerSingleton;
  ExtTipQuickTipManager : TExtTipQuickTipManagerSingleton;
  ExtStateManager : TExtStateManagerSingleton;
  ExtDataJsonP : TExtDataJsonPSingleton;
  ExtDataTypes : TExtDataTypesSingleton;
  ExtDataSortTypes : TExtDataSortTypesSingleton;
  ExtAjax : TExtAjaxSingleton;
  ExtModelManager : TExtModelManagerSingleton;
  ExtComponentManager : TExtComponentManagerSingleton;
  MyAppCoolPanel : TMyAppCoolPanelSingleton;

implementation

procedure TExtUtilObservable.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtUtilObservable.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilObservable.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

function TExtUtilObservable.JSClassName : string; begin
  Result := 'Ext.util.Observable';
end;

procedure TExtUtilObservable.InitDefaults; begin
  inherited;
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
end;

{$IFDEF FPC}constructor TExtUtilObservable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilObservable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Opt, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Opt, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Opt, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Opt : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Opt, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil; OptionsScope : TExtObject = nil; OptionsDelay : Integer = 0; OptionsSingle : Boolean = false; OptionsBuffer : Integer = 0; OptionsTarget : TExtUtilObservable = nil; OptionsElement : String = '') : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false, OptionsScope, false, OptionsDelay, OptionsSingle, OptionsBuffer, OptionsTarget, false, OptionsElement]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil; OptionsScope : TExtObject = nil; OptionsDelay : Integer = 0; OptionsSingle : Boolean = false; OptionsBuffer : Integer = 0; OptionsTarget : TExtUtilObservable = nil; OptionsElement : String = '') : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false, OptionsScope, false, OptionsDelay, OptionsSingle, OptionsBuffer, OptionsTarget, false, OptionsElement]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RelayEvents(Origin : TExtObject; Events : TExtObjectList; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false]) + ',' + VarToJSON(Events) + ',' + VarToJSON([Prefix]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.EnableBubble(EventNames : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON(EventNames) + ');', 'TExtUtilObservable');
  Result := Self;
end;

destructor TExtUtilObservable.Destroy; begin
  try
    FListeners.Free;
    FHasListeners.Free;
  except end;
  inherited;
end;

procedure TExtFormAction.SetFForm(Value : TExtFormBasic); begin
  FForm := Value;
  Value.DeleteFromGarbage;
  JSCode('form:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFReset(Value : Boolean); begin
  FReset := Value;
  JSCode('reset:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFParamsString(Value : String); begin
  FParamsString := Value;
  JSCode('params:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFHeaders(Value : TExtObject); begin
  FHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('headers:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFSuccess(Value : TExtFunction); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFFailure(Value : TExtFunction); begin
  FFailure := Value;
  JSCode('failure:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFWaitMsg(Value : String); begin
  FWaitMsg := Value;
  JSCode('waitMsg:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFSubmitEmptyText(Value : Boolean); begin
  FSubmitEmptyText := Value;
  JSCode('submitEmptyText:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode(JSName + '.typeJS=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormAction.SetFFailureType(Value : String); begin
  FFailureType := Value;
  JSCode(JSName + '.failureType=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormAction.SetFResponse(Value : TExtObject); begin
  FResponse := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.response=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormAction.SetFResultJS(Value : TExtObject); begin
  FResultJS := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.resultJS=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormAction.JSClassName : string; begin
  Result := 'Ext.form.action.Action';
end;

procedure TExtFormAction.InitDefaults; begin
  inherited;
  FForm := TExtFormBasic.CreateInternal(Self, 'form');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FHeaders := TExtObject.CreateInternal(Self, 'headers');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FResponse := TExtObject.CreateInternal(Self, 'response');
  FResultJS := TExtObject.CreateInternal(Self, 'resultJS');
end;

{$IFDEF FPC}constructor TExtFormAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormAction.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtFormAction.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtFormAction.Destroy; begin
  try
    FForm.Free;
    FParams.Free;
    FHeaders.Free;
    FScope.Free;
    FResponse.Free;
    FResultJS.Free;
  except end;
  inherited;
end;

procedure TExtFormBasic.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFReader(Value : TExtDataReader); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFErrorReader(Value : TExtDataReader); begin
  FErrorReader := Value;
  Value.DeleteFromGarbage;
  JSCode('errorReader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFParamOrder(Value : String); begin
  FParamOrder := Value;
  JSCode('paramOrder:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFParamOrderTExtObjectList(Value : TExtObjectList); begin
  FParamOrderTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('paramOrder:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFParamsAsHash(Value : Boolean); begin
  FParamsAsHash := Value;
  JSCode('paramsAsHash:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFTrackResetOnLoad(Value : Boolean); begin
  FTrackResetOnLoad := Value;
  JSCode('trackResetOnLoad:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFStandardSubmit(Value : Boolean); begin
  FStandardSubmit := Value;
  JSCode('standardSubmit:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFWaitMsgTarget(Value : String); begin
  FWaitMsgTarget := Value;
  JSCode('waitMsgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFWaitMsgTargetTHTMLElement(Value : THTMLElement); begin
  FWaitMsgTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('waitMsgTarget:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFWaitMsgTargetTExtElement(Value : TExtElement); begin
  FWaitMsgTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('waitMsgTarget:' + VarToJSON([Value, false]));
end;

function TExtFormBasic.JSClassName : string; begin
  Result := 'Ext.form.Basic';
end;

procedure TExtFormBasic.InitDefaults; begin
  inherited;
  FReader := TExtDataReader.CreateInternal(Self, 'reader');
  FErrorReader := TExtDataReader.CreateInternal(Self, 'errorReader');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FApi := TExtObject.CreateInternal(Self, 'api');
  FParamOrderTExtObjectList := TExtObjectList.Create(Self, 'paramOrder');
  FWaitMsgTargetTExtElement := TExtElement.CreateInternal(Self, 'waitMsgTarget');
end;

{$IFDEF FPC}constructor TExtFormBasic.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormBasic.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormBasic.GetFields : TExtFunction; begin
  JSCode(JSName + '.getFields();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.HasInvalidField : TExtFunction; begin
  JSCode(JSName + '.hasInvalidField();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.CheckValidity : TExtFunction; begin
  JSCode(JSName + '.checkValidity();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.HasUpload : TExtFunction; begin
  JSCode(JSName + '.hasUpload();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.DoAction(Action : String; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : String = ''; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.doAction(' + VarToJSON([Action, Options, false, OptionsUrl, OptionsMethod, OptionsParams, OptionsHeaders, false, OptionsSuccess, true, OptionsSuccessForm, false, OptionsSuccessAction, false, OptionsFailure, true, OptionsFailureForm, false, OptionsFailureAction, false, OptionsScope, false, OptionsClientValidation]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.DoAction(Action : TExtFormAction; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : String = ''; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.DoAction(' + VarToJSON([Action, false, Options, false, OptionsUrl, OptionsMethod, OptionsParams, OptionsHeaders, false, OptionsSuccess, true, OptionsSuccessForm, false, OptionsSuccessAction, false, OptionsFailure, true, OptionsFailureForm, false, OptionsFailureAction, false, OptionsScope, false, OptionsClientValidation]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.DoAction(Action : TExtFormAction; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : TExtObject = nil; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.DoAction(' + VarToJSON([Action, false, Options, false, OptionsUrl, OptionsMethod, OptionsParams, false, OptionsHeaders, false, OptionsSuccess, true, OptionsSuccessForm, false, OptionsSuccessAction, false, OptionsFailure, true, OptionsFailureForm, false, OptionsFailureAction, false, OptionsScope, false, OptionsClientValidation]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.DoAction(Action : String; Options : TExtObject = nil; OptionsUrl : String = ''; OptionsMethod : String = ''; OptionsParams : TExtObject = nil; OptionsHeaders : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessForm : TExtFormBasic = nil; OptionsSuccessAction : TExtFormAction = nil; OptionsFailure : TExtFunction = nil; OptionsFailureForm : TExtFormBasic = nil; OptionsFailureAction : TExtFormAction = nil; OptionsScope : TExtObject = nil; OptionsClientValidation : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.DoAction(' + VarToJSON([Action, Options, false, OptionsUrl, OptionsMethod, OptionsParams, false, OptionsHeaders, false, OptionsSuccess, true, OptionsSuccessForm, false, OptionsSuccessAction, false, OptionsFailure, true, OptionsFailureForm, false, OptionsFailureAction, false, OptionsScope, false, OptionsClientValidation]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Submit(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.submit(' + VarToJSON([Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.UpdateRecord(RecordJS : TExtDataModel = nil) : TExtFunction; begin
  JSCode(JSName + '.updateRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.LoadRecord(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.loadRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetRecord : TExtFunction; begin
  JSCode(JSName + '.getRecord();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.FindField(Id : String) : TExtFunction; begin
  JSCode(JSName + '.findField(' + VarToJSON([Id]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Errors, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON(Errors) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtDataErrors) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON([Errors, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.SetValues(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValues(' + VarToJSON([Values, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.SetValues(Values : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.SetValues(' + VarToJSON(Values) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetValues(AsString : Boolean = false; DirtyOnly : Boolean = false; IncludeEmptyText : Boolean = false; UseDataValues : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getValues(' + VarToJSON([AsString, DirtyOnly, IncludeEmptyText, UseDataValues]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getFieldValues(' + VarToJSON([DirtyOnly]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.ApplyToFields(Obj : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyToFields(' + VarToJSON([Obj, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.ApplyIfToFields(Obj : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyIfToFields(' + VarToJSON([Obj, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

destructor TExtFormBasic.Destroy; begin
  try
    FReader.Free;
    FErrorReader.Free;
    FBaseParams.Free;
    FApi.Free;
    FParamOrderTExtObjectList.Free;
    FWaitMsgTargetTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldAncestor.SetFFieldDefaults(Value : TExtObject); begin
  FFieldDefaults := Value;
  Value.DeleteFromGarbage;
  JSCode('fieldDefaults:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldAncestor.SetFOnFieldvaliditychange(Value : TExtFormFieldAncestorOnFieldvaliditychange); begin
  if Assigned(FOnFieldvaliditychange) then
    JSCode(JSName+'.events ["fieldvaliditychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fieldvaliditychange', Ajax('fieldvaliditychange', ['This', '%0.nm','The', '%1.nm','IsValid', '%2'], true));
  FOnFieldvaliditychange := Value;
end;

procedure TExtFormFieldAncestor.SetFOnFielderrorchange(Value : TExtFormFieldAncestorOnFielderrorchange); begin
  if Assigned(FOnFielderrorchange) then
    JSCode(JSName+'.events ["fielderrorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fielderrorchange', Ajax('fielderrorchange', ['This', '%0.nm','The', '%1.nm','Error', '%2'], true));
  FOnFielderrorchange := Value;
end;

function TExtFormFieldAncestor.JSClassName : string; begin
  Result := 'Ext.form.FieldAncestor';
end;

procedure TExtFormFieldAncestor.InitDefaults; begin
  inherited;
  FFieldDefaults := TExtObject.CreateInternal(Self, 'fieldDefaults');
end;

{$IFDEF FPC}constructor TExtFormFieldAncestor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldAncestor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldAncestor.Destroy; begin
  try
    FFieldDefaults.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldAncestor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'fieldvaliditychange') and Assigned(FOnFieldvaliditychange) then
    FOnFieldvaliditychange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('IsValid'))
  else if (AEvtName = 'fielderrorchange') and Assigned(FOnFielderrorchange) then
    FOnFielderrorchange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('Error'));
end;

procedure TExtFormField.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtFormField.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidateOnChange(Value : Boolean); begin
  FValidateOnChange := Value;
  JSCode('validateOnChange:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormField.JSClassName : string; begin
  Result := 'Ext.form.field.Field';
end;

procedure TExtFormField.InitDefaults; begin
  inherited;
  FValue := TExtObject.CreateInternal(Self, 'value');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
end;

{$IFDEF FPC}constructor TExtFormField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormField.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isEqual(' + VarToJSON([Value1, false, Value2, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetSubmitData : TExtFunction; begin
  JSCode(JSName + '.getSubmitData();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetModelData : TExtFunction; begin
  JSCode(JSName + '.getModelData();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.ResetOriginalValue : TExtFunction; begin
  JSCode(JSName + '.resetOriginalValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.BatchChanges(Fn : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.batchChanges(' + VarToJSON([Fn, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsFileUpload : TExtFunction; begin
  JSCode(JSName + '.isFileUpload();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.ExtractFileInput : TExtFunction; begin
  JSCode(JSName + '.extractFileInput();', 'TExtFormField');
  Result := Self;
end;

destructor TExtFormField.Destroy; begin
  try
    FValue.Free;
    FOriginalValue.Free;
  except end;
  inherited;
end;

function TExtFoo.JSClassName : string; begin
  Result := 'Ext.Foo';
end;

{$IFDEF FPC}constructor TExtFoo.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFoo.Handle(Err : TExtError) : TExtFunction; begin
  JSCode(JSName + '.handle(' + VarToJSON([Err, false]) + ');', 'TExtFoo');
  Result := Self;
end;

constructor TExtFoo.Create(Config : String); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config]) + ');');
  InitDefaults;
end;

constructor TExtFoo.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtFoo.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtFoo');
  Result := Self;
end;

procedure TExtDrawSurface.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtDrawSurface.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtDrawSurface.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

function TExtDrawSurface.JSClassName : string; begin
  Result := 'Ext.draw.Surface';
end;

procedure TExtDrawSurface.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtDrawSurface.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawSurface.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDrawSurface.SetSize(W : Integer; H : Integer) : TExtFunction; begin
  JSCode(JSName + '.setSize(' + VarToJSON([W, H]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.Remove(Sprite : TExtDrawSprite; DestroySprite : Boolean) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Sprite, false, DestroySprite]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveAll(DestroySprites : Boolean) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([DestroySprites]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.GetGroup(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getGroup(' + VarToJSON([Id]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

destructor TExtDrawSurface.Destroy; begin
  try
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtDrawSprite.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadius(Value : Integer); begin
  FRadius := Value;
  JSCode('radius:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadiusX(Value : Integer); begin
  FRadiusX := Value;
  JSCode('radiusX:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadiusY(Value : Integer); begin
  FRadiusY := Value;
  JSCode('radiusY:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFPath(Value : String); begin
  FPath := Value;
  JSCode('path:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFOpacity(Value : Integer); begin
  FOpacity := Value;
  JSCode('opacity:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFFill(Value : String); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFStroke(Value : String); begin
  FStroke := Value;
  JSCode('stroke:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFStrokeWidth(Value : Integer); begin
  FStrokeWidth := Value;
  JSCode('strokeWidth:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFFont(Value : String); begin
  FFont := Value;
  JSCode('font:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFSrc(Value : String); begin
  FSrc := Value;
  JSCode('src:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFGroup(Value : String); begin
  FGroup := Value;
  JSCode('group:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFGroupTExtObjectList(Value : TExtObjectList); begin
  FGroupTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('group:' + VarToJSON([Value, false]));
end;

procedure TExtDrawSprite.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFIsSprite(Value : Boolean); begin
  FIsSprite := Value;
  JSCode(JSName + '.isSprite=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawSprite.SetFDd(Value : TExtDdDragSource); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

function TExtDrawSprite.JSClassName : string; begin
  Result := 'Ext.draw.Sprite';
end;

procedure TExtDrawSprite.InitDefaults; begin
  inherited;
  FGroupTExtObjectList := TExtObjectList.Create(Self, 'group');
  FDd := TExtDdDragSource.CreateInternal(Self, 'dd');
end;

{$IFDEF FPC}constructor TExtDrawSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawSprite.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDrawSprite.SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAttributes(' + VarToJSON([Attrs, false, Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.GetBBox : TExtFunction; begin
  JSCode(JSName + '.getBBox();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Hide(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Show(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Remove : TExtFunction; begin
  JSCode(JSName + '.remove();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Redraw : TExtFunction; begin
  JSCode(JSName + '.redraw();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([PropertyJS, Value]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.SetStyle(' + VarToJSON([PropertyJS, false, Value]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddCls(ClassName : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddCls(' + VarToJSON(ClassName) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveCls(ClassName : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.RemoveCls(' + VarToJSON(ClassName) + ');', 'TExtDrawSprite');
  Result := Self;
end;

destructor TExtDrawSprite.Destroy; begin
  try
    FGroupTExtObjectList.Free;
    FDd.Free;
  except end;
  inherited;
end;

procedure TExtElementLoader.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFAutoLoad(Value : Boolean); begin
  FAutoLoad := Value;
  JSCode('autoLoad:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFAutoLoadTExtObject(Value : TExtObject); begin
  FAutoLoadTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoLoad:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFTarget(Value : THTMLElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFTargetTExtElement(Value : TExtElement); begin
  FTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFLoadMask(Value : Boolean); begin
  FLoadMask := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFLoadMaskString(Value : String); begin
  FLoadMaskString := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFAjaxOptions(Value : TExtObject); begin
  FAjaxOptions := Value;
  Value.DeleteFromGarbage;
  JSCode('ajaxOptions:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFScripts(Value : Boolean); begin
  FScripts := Value;
  JSCode('scripts:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFSuccess(Value : TExtFunction); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFFailure(Value : TExtFunction); begin
  FFailure := Value;
  JSCode('failure:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFIsLoader(Value : Boolean); begin
  FIsLoader := Value;
  JSCode(JSName + '.isLoader=' + VarToJSON([Value]) + ';');
end;

procedure TExtElementLoader.SetFOnBeforeload(Value : TExtElementLoaderOnBeforeload); begin
  if Assigned(FOnBeforeload) then
    JSCode(JSName+'.events ["beforeload"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeload', Ajax('beforeload', ['This', '%0.nm','Options', '%1.nm'], true));
  FOnBeforeload := Value;
end;

procedure TExtElementLoader.SetFOnException(Value : TExtElementLoaderOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['This', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnException := Value;
end;

procedure TExtElementLoader.SetFOnLoad(Value : TExtElementLoaderOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['This', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnLoad := Value;
end;

function TExtElementLoader.JSClassName : string; begin
  Result := 'Ext.ElementLoader';
end;

procedure TExtElementLoader.InitDefaults; begin
  inherited;
  FParams := TExtObject.CreateInternal(Self, 'params');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FAutoLoadTExtObject := TExtObject.CreateInternal(Self, 'autoLoad');
  FTargetTExtElement := TExtElement.CreateInternal(Self, 'target');
  FAjaxOptions := TExtObject.CreateInternal(Self, 'ajaxOptions');
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtElementLoader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtElementLoader.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtElementLoader.SetTarget(Target : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([Target]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SetTarget(Target : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SetTarget(Target : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.Abort : TExtFunction; begin
  JSCode(JSName + '.abort();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.StartAutoRefresh(Interval : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.startAutoRefresh(' + VarToJSON([Interval, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.StopAutoRefresh : TExtFunction; begin
  JSCode(JSName + '.stopAutoRefresh();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.IsAutoRefreshing : TExtFunction; begin
  JSCode(JSName + '.isAutoRefreshing();', 'TExtElementLoader');
  Result := Self;
end;

destructor TExtElementLoader.Destroy; begin
  try
    FParams.Free;
    FBaseParams.Free;
    FAutoLoadTExtObject.Free;
    FTargetTExtElement.Free;
    FAjaxOptions.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtElementLoader.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeload') and Assigned(FOnBeforeload) then
    FOnBeforeload(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')));
end;

procedure TExtFocusManager.SetFEnabled(Value : Boolean); begin
  FEnabled := Value;
  JSCode(JSName + '.enabled=' + VarToJSON([Value]) + ';');
end;

procedure TExtFocusManager.SetFFocusedCmp(Value : TExtComponent); begin
  FFocusedCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.focusedCmp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFocusManager.SetFWhitelist(Value : TExtObjectList); begin
  FWhitelist := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.whitelist=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFocusManager.SetFOnBeforecomponentfocus(Value : TExtFocusManagerOnBeforecomponentfocus); begin
  if Assigned(FOnBeforecomponentfocus) then
    JSCode(JSName+'.events ["beforecomponentfocus"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecomponentfocus', Ajax('beforecomponentfocus', ['Fm', '%0.nm','Cmp', '%1.nm','PreviousCmp', '%2.nm'], true));
  FOnBeforecomponentfocus := Value;
end;

procedure TExtFocusManager.SetFOnComponentfocus(Value : TExtFocusManagerOnComponentfocus); begin
  if Assigned(FOnComponentfocus) then
    JSCode(JSName+'.events ["componentfocus"].listeners=[];');
  if Assigned(Value) then
    AddListener('componentfocus', Ajax('componentfocus', ['Fm', '%0.nm','Cmp', '%1.nm','PreviousCmp', '%2.nm'], true));
  FOnComponentfocus := Value;
end;

procedure TExtFocusManager.SetFOnDisable(Value : TExtFocusManagerOnDisable); begin
  if Assigned(FOnDisable) then
    JSCode(JSName+'.events ["disable"].listeners=[];');
  if Assigned(Value) then
    AddListener('disable', Ajax('disable', ['Fm', '%0.nm'], true));
  FOnDisable := Value;
end;

procedure TExtFocusManager.SetFOnEnable(Value : TExtFocusManagerOnEnable); begin
  if Assigned(FOnEnable) then
    JSCode(JSName+'.events ["enable"].listeners=[];');
  if Assigned(Value) then
    AddListener('enable', Ajax('enable', ['Fm', '%0.nm'], true));
  FOnEnable := Value;
end;

function TExtFocusManager.JSClassName : string; begin
  Result := 'Ext.FocusManager';
end;

procedure TExtFocusManager.InitDefaults; begin
  inherited;
  FFocusedCmp := TExtComponent.CreateInternal(Self, 'focusedCmp');
  FWhitelist := TExtObjectList.Create(Self, 'whitelist');
end;

{$IFDEF FPC}constructor TExtFocusManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFocusManager.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFocusManager.AddXTypeToWhitelist(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.addXTypeToWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.AddXTypeToWhitelist(Xtype : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddXTypeToWhitelist(' + VarToJSON(Xtype) + ');', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.Enable(Options : Boolean; FocusFrame : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.enable(' + VarToJSON([Options, FocusFrame]) + ');', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.Enable(Options : TExtObject; FocusFrame : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Enable(' + VarToJSON([Options, false, FocusFrame]) + ');', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.RemoveXTypeFromWhitelist(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.removeXTypeFromWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManager');
  Result := Self;
end;

function TExtFocusManager.RemoveXTypeFromWhitelist(Xtype : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.RemoveXTypeFromWhitelist(' + VarToJSON(Xtype) + ');', 'TExtFocusManager');
  Result := Self;
end;

destructor TExtFocusManager.Destroy; begin
  try
    FFocusedCmp.Free;
    FWhitelist.Free;
  except end;
  inherited;
end;

procedure TExtFocusManager.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecomponentfocus') and Assigned(FOnBeforecomponentfocus) then
    FOnBeforecomponentfocus(TExtFocusManager(ParamAsObject('Fm')), TExtComponent(ParamAsObject('Cmp')), TExtComponent(ParamAsObject('PreviousCmp')))
  else if (AEvtName = 'componentfocus') and Assigned(FOnComponentfocus) then
    FOnComponentfocus(TExtFocusManager(ParamAsObject('Fm')), TExtComponent(ParamAsObject('Cmp')), TExtComponent(ParamAsObject('PreviousCmp')))
  else if (AEvtName = 'disable') and Assigned(FOnDisable) then
    FOnDisable(TExtFocusManager(ParamAsObject('Fm')))
  else if (AEvtName = 'enable') and Assigned(FOnEnable) then
    FOnEnable(TExtFocusManager(ParamAsObject('Fm')));
end;

procedure TExtEventObjectImplSingleton.SetFCtrlKey(Value : Boolean); begin
  FCtrlKey := Value;
  JSCode(JSName + '.ctrlKey=' + VarToJSON([Value]) + ';');
end;

procedure TExtEventObjectImplSingleton.SetFAltKey(Value : Boolean); begin
  FAltKey := Value;
  JSCode(JSName + '.altKey=' + VarToJSON([Value]) + ';');
end;

procedure TExtEventObjectImplSingleton.SetFShiftKey(Value : Boolean); begin
  FShiftKey := Value;
  JSCode(JSName + '.shiftKey=' + VarToJSON([Value]) + ';');
end;

function TExtEventObjectImplSingleton.JSClassName : string; begin
  Result := 'Ext.EventObjectImpl';
end;

{$IFDEF FPC}constructor TExtEventObjectImplSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtEventObjectImplSingleton.StopEvent : TExtFunction; begin
  JSCode(JSName + '.stopEvent();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.PreventDefault : TExtFunction; begin
  JSCode(JSName + '.preventDefault();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.StopPropagation : TExtFunction; begin
  JSCode(JSName + '.stopPropagation();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetCharCode : TExtFunction; begin
  JSCode(JSName + '.getCharCode();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetKey : TExtFunction; begin
  JSCode(JSName + '.getKey();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetPageX : TExtFunction; begin
  JSCode(JSName + '.getPageX();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetPageY : TExtFunction; begin
  JSCode(JSName + '.getPageY();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetX : TExtFunction; begin
  JSCode(JSName + '.getX();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetY : TExtFunction; begin
  JSCode(JSName + '.getY();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetXY : TExtFunction; begin
  JSCode(JSName + '.getXY();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getTarget(' + VarToJSON([Selector, MaxDepth, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetTarget(' + VarToJSON([Selector, MaxDepth, false, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetRelatedTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getRelatedTarget(' + VarToJSON([Selector, MaxDepth, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetRelatedTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetRelatedTarget(' + VarToJSON([Selector, MaxDepth, false, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : String; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.within(' + VarToJSON([El, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : THTMLElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Within(' + VarToJSON([El, false, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : TExtElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Within(' + VarToJSON([El, false, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.IsNavKeyPress : TExtFunction; begin
  JSCode(JSName + '.isNavKeyPress();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.IsSpecialKey : TExtFunction; begin
  JSCode(JSName + '.isSpecialKey();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetPoint : TExtFunction; begin
  JSCode(JSName + '.getPoint();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.HasModifier : TExtFunction; begin
  JSCode(JSName + '.hasModifier();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

procedure TExtFxAnimator.SetFDuration(Value : Integer); begin
  FDuration := Value;
  JSCode('duration:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFEasing(Value : String); begin
  FEasing := Value;
  JSCode('easing:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFIterations(Value : Integer); begin
  FIterations := Value;
  JSCode('iterations:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFTarget(Value : TExtFxTarget); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnimator.SetFKeyframes(Value : TExtObject); begin
  FKeyframes := Value;
  Value.DeleteFromGarbage;
  JSCode('keyframes:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnimator.SetFOnBeforeanimate(Value : TExtFxAnimatorOnBeforeanimate); begin
  if Assigned(FOnBeforeanimate) then
    JSCode(JSName+'.events ["beforeanimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeanimate', Ajax('beforeanimate', ['This', '%0.nm'], true));
  FOnBeforeanimate := Value;
end;

procedure TExtFxAnimator.SetFOnKeyframe(Value : TExtFxAnimatorOnKeyframe); begin
  if Assigned(FOnKeyframe) then
    JSCode(JSName+'.events ["keyframe"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyframe', Ajax('keyframe', ['This', '%0.nm','Keyframe', '%1'], true));
  FOnKeyframe := Value;
end;

procedure TExtFxAnimator.SetFOnAfteranimate(Value : TExtFxAnimatorOnAfteranimate); begin
  if Assigned(FOnAfteranimate) then
    JSCode(JSName+'.events ["afteranimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteranimate', Ajax('afteranimate', ['This', '%0.nm','StartTime', '%1'], true));
  FOnAfteranimate := Value;
end;

function TExtFxAnimator.JSClassName : string; begin
  Result := 'Ext.fx.Animator';
end;

procedure TExtFxAnimator.InitDefaults; begin
  inherited;
  FDuration := 250;
  FDelay := 0;
  FIterations := 1;
  FTarget := TExtFxTarget.CreateInternal(Self, 'target');
  FKeyframes := TExtObject.CreateInternal(Self, 'keyframes');
end;

{$IFDEF FPC}constructor TExtFxAnimator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFxAnimator.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFxAnimator.EndJS : TExtFunction; begin
  JSCode(JSName + '.end();', 'TExtFxAnimator');
  Result := Self;
end;

destructor TExtFxAnimator.Destroy; begin
  try
    FTarget.Free;
    FKeyframes.Free;
  except end;
  inherited;
end;

procedure TExtFxAnimator.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeanimate') and Assigned(FOnBeforeanimate) then
    FOnBeforeanimate(TExtFxAnimator(ParamAsObject('This')))
  else if (AEvtName = 'keyframe') and Assigned(FOnKeyframe) then
    FOnKeyframe(TExtFxAnimator(ParamAsObject('This')), ParamAsInteger('Keyframe'))
  else if (AEvtName = 'afteranimate') and Assigned(FOnAfteranimate) then
    FOnAfteranimate(TExtFxAnimator(ParamAsObject('This')), ParamAsTDateTime('StartTime'));
end;

procedure TExtFxAnim.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtFxAnim.SetFScope(Value : TExtFunction); begin
  FScope := Value;
  JSCode('scope:' + VarToJSON([Value, true]));
end;

procedure TExtFxAnim.SetFDuration(Value : Integer); begin
  FDuration := Value;
  JSCode('duration:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFEasing(Value : String); begin
  FEasing := Value;
  JSCode('easing:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFKeyframes(Value : TExtObject); begin
  FKeyframes := Value;
  Value.DeleteFromGarbage;
  JSCode('keyframes:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFReverse(Value : Boolean); begin
  FReverse := Value;
  JSCode('reverse:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFIterations(Value : Integer); begin
  FIterations := Value;
  JSCode('iterations:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFAlternate(Value : Boolean); begin
  FAlternate := Value;
  JSCode('alternate:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFTargetTExtObject(Value : TExtObject); begin
  FTargetTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFFrom(Value : TExtObject); begin
  FFrom := Value;
  Value.DeleteFromGarbage;
  JSCode('from:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFToJS(Value : TExtObject); begin
  FToJS := Value;
  Value.DeleteFromGarbage;
  JSCode('toJS:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFOnBeforeanimate(Value : TExtFxAnimOnBeforeanimate); begin
  if Assigned(FOnBeforeanimate) then
    JSCode(JSName+'.events ["beforeanimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeanimate', Ajax('beforeanimate', ['This', '%0.nm'], true));
  FOnBeforeanimate := Value;
end;

procedure TExtFxAnim.SetFOnAfteranimate(Value : TExtFxAnimOnAfteranimate); begin
  if Assigned(FOnAfteranimate) then
    JSCode(JSName+'.events ["afteranimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteranimate', Ajax('afteranimate', ['This', '%0.nm','StartTime', '%1'], true));
  FOnAfteranimate := Value;
end;

procedure TExtFxAnim.SetFOnLastframe(Value : TExtFxAnimOnLastframe); begin
  if Assigned(FOnLastframe) then
    JSCode(JSName+'.events ["lastframe"].listeners=[];');
  if Assigned(Value) then
    AddListener('lastframe', Ajax('lastframe', ['This', '%0.nm','StartTime', '%1'], true));
  FOnLastframe := Value;
end;

function TExtFxAnim.JSClassName : string; begin
  Result := 'Ext.fx.Anim';
end;

procedure TExtFxAnim.InitDefaults; begin
  inherited;
  FKeyframes := TExtObject.CreateInternal(Self, 'keyframes');
  FTargetTExtObject := TExtObject.CreateInternal(Self, 'target');
  FFrom := TExtObject.CreateInternal(Self, 'from');
  FToJS := TExtObject.CreateInternal(Self, 'toJS');
end;

{$IFDEF FPC}constructor TExtFxAnim.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFxAnim.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFxAnim.EndJS : TExtFunction; begin
  JSCode(JSName + '.end();', 'TExtFxAnim');
  Result := Self;
end;

destructor TExtFxAnim.Destroy; begin
  try
    FKeyframes.Free;
    FTargetTExtObject.Free;
    FFrom.Free;
    FToJS.Free;
  except end;
  inherited;
end;

procedure TExtFxAnim.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeanimate') and Assigned(FOnBeforeanimate) then
    FOnBeforeanimate(TExtFxAnim(ParamAsObject('This')))
  else if (AEvtName = 'afteranimate') and Assigned(FOnAfteranimate) then
    FOnAfteranimate(TExtFxAnim(ParamAsObject('This')), ParamAsTDateTime('StartTime'))
  else if (AEvtName = 'lastframe') and Assigned(FOnLastframe) then
    FOnLastframe(TExtFxAnim(ParamAsObject('This')), ParamAsTDateTime('StartTime'));
end;

function TExtFxTargetComponent.JSClassName : string; begin
  Result := 'Ext.fx.target.Component';
end;

{$IFDEF FPC}constructor TExtFxTargetComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxTargetSprite.JSClassName : string; begin
  Result := 'Ext.fx.target.Sprite';
end;

{$IFDEF FPC}constructor TExtFxTargetSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxTargetElement.JSClassName : string; begin
  Result := 'Ext.fx.target.Element';
end;

{$IFDEF FPC}constructor TExtFxTargetElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TMotherSingleton.SetFUsesJS(Value : TExtObjectList); begin
  FUsesJS := Value;
  Value.DeleteFromGarbage;
  JSCode('usesJS:' + VarToJSON([Value, false]));
end;

function TMotherSingleton.JSClassName : string; begin
  Result := 'Mother';
end;

procedure TMotherSingleton.InitDefaults; begin
  inherited;
  FUsesJS := TExtObjectList.Create(Self, 'usesJS');
end;

{$IFDEF FPC}constructor TMotherSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

destructor TMotherSingleton.Destroy; begin
  try
    FUsesJS.Free;
  except end;
  inherited;
end;

procedure TMyCoolClass.SetFSelf(Value : TExtClass); begin
  FSelf := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.self=' + VarToJSON([Value, false]) + ';');
end;

function TMyCoolClass.JSClassName : string; begin
  Result := 'My.cool.Class';
end;

procedure TMyCoolClass.InitDefaults; begin
  inherited;
  FSelf := TExtClass.CreateInternal(Self, 'self');
end;

{$IFDEF FPC}constructor TMyCoolClass.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TMyCoolClass.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TMyCoolClass.GetInitialConfig(Name : String = '') : TExtFunction; begin
  JSCode(JSName + '.getInitialConfig(' + VarToJSON([Name]) + ');', 'TMyCoolClass');
  Result := Self;
end;

destructor TMyCoolClass.Destroy; begin
  try
    FSelf.Free;
  except end;
  inherited;
end;

function TExtZIndexManager.JSClassName : string; begin
  Result := 'Ext.ZIndexManager';
end;

{$IFDEF FPC}constructor TExtZIndexManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtZIndexManager.Register(Comp : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Unregister(Comp : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Get(Id : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Id]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Get(Id : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Id, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.BringToFront(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.bringToFront(' + VarToJSON([Comp]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.BringToFront(Comp : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.BringToFront(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.SendToBack(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.sendToBack(' + VarToJSON([Comp]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.SendToBack(Comp : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SendToBack(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.GetActive : TExtFunction; begin
  JSCode(JSName + '.getActive();', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.GetBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

procedure TExtFormLabelable.SetFLabelableRenderTpl(Value : String); begin
  FLabelableRenderTpl := Value;
  JSCode('labelableRenderTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelableRenderTplTExtObjectList(Value : TExtObjectList); begin
  FLabelableRenderTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('labelableRenderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFLabelableRenderTplTExtXTemplate(Value : TExtXTemplate); begin
  FLabelableRenderTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('labelableRenderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFActiveErrorsTpl(Value : String); begin
  FActiveErrorsTpl := Value;
  JSCode('activeErrorsTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFActiveErrorsTplTExtObjectList(Value : TExtObjectList); begin
  FActiveErrorsTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('activeErrorsTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFActiveErrorsTplTExtXTemplate(Value : TExtXTemplate); begin
  FActiveErrorsTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('activeErrorsTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFFormItemCls(Value : String); begin
  FFormItemCls := Value;
  JSCode('formItemCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelCls(Value : String); begin
  FLabelCls := Value;
  JSCode('labelCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelClsExtra(Value : String); begin
  FLabelClsExtra := Value;
  JSCode('labelClsExtra:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFErrorMsgCls(Value : String); begin
  FErrorMsgCls := Value;
  JSCode('errorMsgCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBaseBodyCls(Value : String); begin
  FBaseBodyCls := Value;
  JSCode('baseBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFClearCls(Value : String); begin
  FClearCls := Value;
  JSCode('clearCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFInvalidCls(Value : String); begin
  FInvalidCls := Value;
  JSCode('invalidCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFFieldLabel(Value : String); begin
  FFieldLabel := Value;
  if not ConfigAvailable(JSName) then
    SetFieldLabel(Value)
  else
    JSCode('fieldLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelAlign(Value : String); begin
  FLabelAlign := Value;
  JSCode('labelAlign:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelPad(Value : Integer); begin
  FLabelPad := Value;
  JSCode('labelPad:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelSeparator(Value : String); begin
  FLabelSeparator := Value;
  JSCode('labelSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelStyle(Value : String); begin
  FLabelStyle := Value;
  JSCode('labelStyle:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFHideLabel(Value : Boolean); begin
  FHideLabel := Value;
  JSCode('hideLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFHideEmptyLabel(Value : Boolean); begin
  FHideEmptyLabel := Value;
  JSCode('hideEmptyLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFPreventMark(Value : Boolean); begin
  FPreventMark := Value;
  JSCode('preventMark:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAutoFitErrors(Value : Boolean); begin
  FAutoFitErrors := Value;
  JSCode('autoFitErrors:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFMsgTarget(Value : String); begin
  FMsgTarget := Value;
  JSCode('msgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFActiveError(Value : String); begin
  FActiveError := Value;
  if not ConfigAvailable(JSName) then
    SetActiveError(Value)
  else
    JSCode('activeError:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeBodyEl(Value : String); begin
  FBeforeBodyEl := Value;
  JSCode('beforeBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeBodyElTExtObjectList(Value : TExtObjectList); begin
  FBeforeBodyElTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeBodyElTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeBodyElTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterBodyEl(Value : String); begin
  FAfterBodyEl := Value;
  JSCode('afterBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterBodyElTExtObjectList(Value : TExtObjectList); begin
  FAfterBodyElTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterBodyElTExtXTemplate(Value : TExtXTemplate); begin
  FAfterBodyElTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTpl(Value : String); begin
  FBeforeLabelTpl := Value;
  JSCode('beforeLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeLabelTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTpl(Value : String); begin
  FAfterLabelTpl := Value;
  JSCode('afterLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterLabelTplTExtObjectList(Value : TExtObjectList); begin
  FAfterLabelTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterLabelTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeSubTpl(Value : String); begin
  FBeforeSubTpl := Value;
  JSCode('beforeSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeSubTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeSubTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeSubTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeSubTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterSubTpl(Value : String); begin
  FAfterSubTpl := Value;
  JSCode('afterSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterSubTplTExtObjectList(Value : TExtObjectList); begin
  FAfterSubTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterSubTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterSubTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTpl(Value : String); begin
  FBeforeLabelTextTpl := Value;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeLabelTextTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTextTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTpl(Value : String); begin
  FAfterLabelTextTpl := Value;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTplTExtObjectList(Value : TExtObjectList); begin
  FAfterLabelTextTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterLabelTextTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFLabelAttrTpl(Value : String); begin
  FLabelAttrTpl := Value;
  JSCode('labelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelAttrTplTExtObjectList(Value : TExtObjectList); begin
  FLabelAttrTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFLabelAttrTplTExtXTemplate(Value : TExtXTemplate); begin
  FLabelAttrTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFOnErrorchange(Value : TExtFormLabelableOnErrorchange); begin
  if Assigned(FOnErrorchange) then
    JSCode(JSName+'.events ["errorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('errorchange', Ajax('errorchange', ['This', '%0.nm','Error', '%1'], true));
  FOnErrorchange := Value;
end;

function TExtFormLabelable.JSClassName : string; begin
  Result := 'Ext.form.Labelable';
end;

procedure TExtFormLabelable.InitDefaults; begin
  inherited;
  FLabelableRenderTplTExtObjectList := TExtObjectList.Create(Self, 'labelableRenderTpl');
  FLabelableRenderTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'labelableRenderTpl');
  FActiveErrorsTplTExtObjectList := TExtObjectList.Create(Self, 'activeErrorsTpl');
  FActiveErrorsTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'activeErrorsTpl');
  FBeforeBodyElTExtObjectList := TExtObjectList.Create(Self, 'beforeBodyEl');
  FBeforeBodyElTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBodyEl');
  FAfterBodyElTExtObjectList := TExtObjectList.Create(Self, 'afterBodyEl');
  FAfterBodyElTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterBodyEl');
  FBeforeLabelTplTExtObjectList := TExtObjectList.Create(Self, 'beforeLabelTpl');
  FBeforeLabelTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTpl');
  FAfterLabelTplTExtObjectList := TExtObjectList.Create(Self, 'afterLabelTpl');
  FAfterLabelTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTpl');
  FBeforeSubTplTExtObjectList := TExtObjectList.Create(Self, 'beforeSubTpl');
  FBeforeSubTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeSubTpl');
  FAfterSubTplTExtObjectList := TExtObjectList.Create(Self, 'afterSubTpl');
  FAfterSubTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterSubTpl');
  FBeforeLabelTextTplTExtObjectList := TExtObjectList.Create(Self, 'beforeLabelTextTpl');
  FBeforeLabelTextTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTextTpl');
  FAfterLabelTextTplTExtObjectList := TExtObjectList.Create(Self, 'afterLabelTextTpl');
  FAfterLabelTextTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTextTpl');
  FLabelAttrTplTExtObjectList := TExtObjectList.Create(Self, 'labelAttrTpl');
  FLabelAttrTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'labelAttrTpl');
end;

{$IFDEF FPC}constructor TExtFormLabelable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormLabelable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormLabelable.TrimLabelSeparator : TExtFunction; begin
  JSCode(JSName + '.trimLabelSeparator();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetFieldLabel(LabelJS : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldLabel(' + VarToJSON([LabelJS]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.HasVisibleLabel : TExtFunction; begin
  JSCode(JSName + '.hasVisibleLabel();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetInputId : TExtFunction; begin
  JSCode(JSName + '.getInputId();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetActiveError : TExtFunction; begin
  JSCode(JSName + '.getActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.HasActiveError : TExtFunction; begin
  JSCode(JSName + '.hasActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetActiveError(Msg : String) : TExtFunction; begin
  JSCode(JSName + '.setActiveError(' + VarToJSON([Msg]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetActiveErrors : TExtFunction; begin
  JSCode(JSName + '.getActiveErrors();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetActiveErrors(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.setActiveErrors(' + VarToJSON(Errors) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.UnsetActiveError : TExtFunction; begin
  JSCode(JSName + '.unsetActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetFieldDefaults(Defaults : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setFieldDefaults(' + VarToJSON([Defaults, false]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

destructor TExtFormLabelable.Destroy; begin
  try
    FLabelableRenderTplTExtObjectList.Free;
    FLabelableRenderTplTExtXTemplate.Free;
    FActiveErrorsTplTExtObjectList.Free;
    FActiveErrorsTplTExtXTemplate.Free;
    FBeforeBodyElTExtObjectList.Free;
    FBeforeBodyElTExtXTemplate.Free;
    FAfterBodyElTExtObjectList.Free;
    FAfterBodyElTExtXTemplate.Free;
    FBeforeLabelTplTExtObjectList.Free;
    FBeforeLabelTplTExtXTemplate.Free;
    FAfterLabelTplTExtObjectList.Free;
    FAfterLabelTplTExtXTemplate.Free;
    FBeforeSubTplTExtObjectList.Free;
    FBeforeSubTplTExtXTemplate.Free;
    FAfterSubTplTExtObjectList.Free;
    FAfterSubTplTExtXTemplate.Free;
    FBeforeLabelTextTplTExtObjectList.Free;
    FBeforeLabelTextTplTExtXTemplate.Free;
    FAfterLabelTextTplTExtObjectList.Free;
    FAfterLabelTextTplTExtXTemplate.Free;
    FLabelAttrTplTExtObjectList.Free;
    FLabelAttrTplTExtXTemplate.Free;
  except end;
  inherited;
end;

procedure TExtFormLabelable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'errorchange') and Assigned(FOnErrorchange) then
    FOnErrorchange(TExtFormLabelable(ParamAsObject('This')), ParamAsString('Error'));
end;

procedure TExtFormFieldVTypesSingleton.SetFEmailText(Value : String); begin
  FEmailText := Value;
  JSCode(JSName + '.emailText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFEmailMask(Value : TRegExp); begin
  FEmailMask := Value;
  JSCode(JSName + '.emailMask=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFUrlText(Value : String); begin
  FUrlText := Value;
  JSCode(JSName + '.urlText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFAlphaText(Value : String); begin
  FAlphaText := Value;
  JSCode(JSName + '.alphaText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFAlphanumText(Value : String); begin
  FAlphanumText := Value;
  JSCode(JSName + '.alphanumText=' + VarToJSON([Value]) + ';');
end;

function TExtFormFieldVTypesSingleton.JSClassName : string; begin
  Result := 'Ext.form.field.VTypes';
end;

procedure TExtFormFieldVTypesSingleton.InitDefaults; begin
  inherited;
  FEmailText := 'This field should be an e-mail address in the format';
  FUrlText := 'This field should be a URL in the format';
  FAlphaText := 'This field should only contain letters and _';
  FAlphanumText := 'This field should only contain letters, numbers and _';
end;

{$IFDEF FPC}constructor TExtFormFieldVTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdScrollManager.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode(JSName + '.ddGroup=' + VarToJSON([Value]) + ';');
end;

function TExtDdScrollManager.JSClassName : string; begin
  Result := 'Ext.dd.ScrollManager';
end;

{$IFDEF FPC}constructor TExtDdScrollManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdScrollManager.RefreshCache : TExtFunction; begin
  JSCode(JSName + '.refreshCache();', 'TExtDdScrollManager');
  Result := Self;
end;

function TExtDdRegistry.JSClassName : string; begin
  Result := 'Ext.dd.Registry';
end;

{$IFDEF FPC}constructor TExtDdRegistry.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdRegistry.Register(Element : String; Data : TExtObject; DataHandles : TExtObjectList; DataIsHandle : Boolean) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Element, Data, false]) + ',' + VarToJSON(DataHandles) + ',' + VarToJSON([DataIsHandle]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.Register(Element : THTMLElement; Data : TExtObject; DataHandles : TExtObjectList; DataIsHandle : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON([Element, false, Data, false]) + ',' + VarToJSON(DataHandles) + ',' + VarToJSON([DataIsHandle]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.Unregister(Element : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Element]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.Unregister(Element : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([Element, false]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetHandle(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getHandle(' + VarToJSON([Id]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetHandle(Id : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetHandle(' + VarToJSON([Id, false]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetHandleFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getHandleFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetTarget(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getTarget(' + VarToJSON([Id]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetTarget(Id : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetTarget(' + VarToJSON([Id, false]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDdRegistry.GetTargetFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getTargetFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdRegistry');
  Result := Self;
end;

function TExtDiagLayoutContext.JSClassName : string; begin
  Result := 'Ext.diag.layout.Context';
end;

{$IFDEF FPC}constructor TExtDiagLayoutContext.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectEvent.JSClassName : string; begin
  Result := 'Ext.direct.Event';
end;

{$IFDEF FPC}constructor TExtDirectEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectEvent.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDirectEvent.GetData : TExtFunction; begin
  JSCode(JSName + '.getData();', 'TExtDirectEvent');
  Result := Self;
end;

function TExtDiagLayoutContextItem.JSClassName : string; begin
  Result := 'Ext.diag.layout.ContextItem';
end;

{$IFDEF FPC}constructor TExtDiagLayoutContextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdDragDrop.SetFIgnoreSelf(Value : Boolean); begin
  FIgnoreSelf := Value;
  JSCode(JSName + '.ignoreSelf=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFId(Value : String); begin
  FId := Value;
  JSCode(JSName + '.id=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFConfig(Value : TExtObject); begin
  FConfig := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.config=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFInvalidHandleTypes(Value : TExtObject); begin
  FInvalidHandleTypes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.invalidHandleTypes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFInvalidHandleClasses(Value : TExtObjectList); begin
  FInvalidHandleClasses := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.invalidHandleClasses=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFGroups(Value : TExtObject); begin
  FGroups := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.groups=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFMoveOnly(Value : Boolean); begin
  FMoveOnly := Value;
  JSCode(JSName + '.moveOnly=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFIsTarget(Value : Boolean); begin
  FIsTarget := Value;
  JSCode(JSName + '.isTarget=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFPadding(Value : TArrayOfInteger); begin
  FPadding := Value;
  JSCode(JSName + '.padding=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFMaintainOffset(Value : Boolean); begin
  FMaintainOffset := Value;
  JSCode(JSName + '.maintainOffset=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFXTicks(Value : TArrayOfInteger); begin
  FXTicks := Value;
  JSCode(JSName + '.xTicks=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFYTicks(Value : TArrayOfInteger); begin
  FYTicks := Value;
  JSCode(JSName + '.yTicks=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFPrimaryButtonOnly(Value : Boolean); begin
  FPrimaryButtonOnly := Value;
  JSCode(JSName + '.primaryButtonOnly=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFAvailable(Value : Boolean); begin
  FAvailable := Value;
  JSCode(JSName + '.available=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFHasOuterHandles(Value : Boolean); begin
  FHasOuterHandles := Value;
  JSCode(JSName + '.hasOuterHandles=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFDefaultPadding(Value : TExtObject); begin
  FDefaultPadding := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.defaultPadding=' + VarToJSON([Value, false]) + ';');
end;

function TExtDdDragDrop.JSClassName : string; begin
  Result := 'Ext.dd.DragDrop';
end;

procedure TExtDdDragDrop.InitDefaults; begin
  inherited;
  FIgnoreSelf := true;
  FConfig := TExtObject.CreateInternal(Self, 'config');
  FInvalidHandleTypes := TExtObject.CreateInternal(Self, 'invalidHandleTypes');
  FInvalidHandleClasses := TExtObjectList.Create(Self, 'invalidHandleClasses');
  FGroups := TExtObject.CreateInternal(Self, 'groups');
  FDefaultPadding := TExtObject.CreateInternal(Self, 'defaultPadding');
end;

{$IFDEF FPC}constructor TExtDdDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragDrop.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : String; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.constrainTo(' + VarToJSON([ConstrainTo, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : THTMLElement; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : THTMLElement; Pad : Integer; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : TExtElement; Pad : TExtObject = nil; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : TExtElement; Pad : Integer; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : String; Pad : Integer; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.GetDragEl : TExtFunction; begin
  JSCode(JSName + '.getDragEl();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Init(Id : String; SGroup : String; Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.init(' + VarToJSON([Id, SGroup, Config, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.InitTarget(Id : String; SGroup : String; Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.initTarget(' + VarToJSON([Id, SGroup, Config, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ApplyConfig : TExtFunction; begin
  JSCode(JSName + '.applyConfig();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetPadding(ITop : Integer; IRight : Integer; IBot : Integer; ILeft : Integer) : TExtFunction; begin
  JSCode(JSName + '.setPadding(' + VarToJSON([ITop, IRight, IBot, ILeft]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetInitPosition(DiffX : Integer; DiffY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setInitPosition(' + VarToJSON([DiffX, DiffY]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddToGroup(SGroup : String) : TExtFunction; begin
  JSCode(JSName + '.addToGroup(' + VarToJSON([SGroup]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveFromGroup(SGroup : String) : TExtFunction; begin
  JSCode(JSName + '.removeFromGroup(' + VarToJSON([SGroup]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetDragElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setDragElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetHandleElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setHandleElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetOuterHandleElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setOuterHandleElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Unreg : TExtFunction; begin
  JSCode(JSName + '.unreg();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.IsLocked : TExtFunction; begin
  JSCode(JSName + '.isLocked();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddInvalidHandleType(TagName : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleType(' + VarToJSON([TagName]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddInvalidHandleId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddInvalidHandleClass(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleClass(' + VarToJSON([CssClass]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleType(TagName : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleType(' + VarToJSON([TagName]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleClass(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleClass(' + VarToJSON([CssClass]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.IsValidHandleChild(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.isValidHandleChild(' + VarToJSON([Node, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetXConstraint(ILeft : Integer; IRight : Integer; ITickSize : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setXConstraint(' + VarToJSON([ILeft, IRight, ITickSize]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ClearConstraints : TExtFunction; begin
  JSCode(JSName + '.clearConstraints();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ClearTicks : TExtFunction; begin
  JSCode(JSName + '.clearTicks();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetYConstraint(IUp : Integer; IDown : Integer; ITickSize : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setYConstraint(' + VarToJSON([IUp, IDown, ITickSize]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ResetConstraints(MaintainOffset : Boolean) : TExtFunction; begin
  JSCode(JSName + '.resetConstraints(' + VarToJSON([MaintainOffset]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtDdDragDrop');
  Result := Self;
end;

destructor TExtDdDragDrop.Destroy; begin
  try
    FConfig.Free;
    FInvalidHandleTypes.Free;
    FInvalidHandleClasses.Free;
    FGroups.Free;
    FDefaultPadding.Free;
  except end;
  inherited;
end;

procedure TExtDataValidations.SetFPresenceMessage(Value : String); begin
  FPresenceMessage := Value;
  JSCode(JSName + '.presenceMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFLengthMessage(Value : String); begin
  FLengthMessage := Value;
  JSCode(JSName + '.lengthMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFFormatMessage(Value : String); begin
  FFormatMessage := Value;
  JSCode(JSName + '.formatMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFInclusionMessage(Value : String); begin
  FInclusionMessage := Value;
  JSCode(JSName + '.inclusionMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFExclusionMessage(Value : String); begin
  FExclusionMessage := Value;
  JSCode(JSName + '.exclusionMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFEmailMessage(Value : String); begin
  FEmailMessage := Value;
  JSCode(JSName + '.emailMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidations.SetFEmailRe(Value : TRegExp); begin
  FEmailRe := Value;
  JSCode(JSName + '.emailRe=' + VarToJSON([#3 +Value]) + ';');
end;

function TExtDataValidations.JSClassName : string; begin
  Result := 'Ext.data.validations';
end;

{$IFDEF FPC}constructor TExtDataValidations.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataValidations.Presence(Config : TExtObject; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.presence(' + VarToJSON([Config, false, Value, false]) + ');', 'TExtDataValidations');
  Result := Self;
end;

function TExtDataValidations.Length(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.length(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidations');
  Result := Self;
end;

function TExtDataValidations.Email(Config : TExtObject; Email : String) : TExtFunction; begin
  JSCode(JSName + '.email(' + VarToJSON([Config, false, Email]) + ');', 'TExtDataValidations');
  Result := Self;
end;

function TExtDataValidations.Format(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.format(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidations');
  Result := Self;
end;

function TExtDataValidations.Inclusion(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.inclusion(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidations');
  Result := Self;
end;

function TExtDataValidations.Exclusion(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.exclusion(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidations');
  Result := Self;
end;

procedure TExtDdDragDropManager.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode(JSName + '.preventDefault=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFStopPropagation(Value : Boolean); begin
  FStopPropagation := Value;
  JSCode(JSName + '.stopPropagation=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFMode(Value : Integer); begin
  FMode := Value;
  JSCode(JSName + '.mode=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFNotifyOccluded(Value : Boolean); begin
  FNotifyOccluded := Value;
  JSCode(JSName + '.notifyOccluded=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFLocationCache(Value : TExtObject); begin
  FLocationCache := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.locationCache=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDropManager.SetFUseCache(Value : Boolean); begin
  FUseCache := Value;
  JSCode(JSName + '.useCache=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFClickPixelThresh(Value : Integer); begin
  FClickPixelThresh := Value;
  JSCode(JSName + '.clickPixelThresh=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFClickTimeThresh(Value : Integer); begin
  FClickTimeThresh := Value;
  JSCode(JSName + '.clickTimeThresh=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManager.SetFElementCache(Value : TExtObject); begin
  FElementCache := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.elementCache=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDropManager.SetF_timeoutCount(Value : Integer); begin
  F_timeoutCount := Value;
  JSCode(JSName + '.timeoutCount=' + VarToJSON([Value]) + ';');
end;

function TExtDdDragDropManager.JSClassName : string; begin
  Result := 'Ext.dd.DragDropManager';
end;

class function TExtDdDragDropManager.POINT : Integer; begin
  Result := 0
end;

class function TExtDdDragDropManager.INTERSECT : Integer; begin
  Result := 0
end;

procedure TExtDdDragDropManager.InitDefaults; begin
  inherited;
  FLocationCache := TExtObject.CreateInternal(Self, 'locationCache');
  FElementCache := TExtObject.CreateInternal(Self, 'elementCache');
end;

{$IFDEF FPC}constructor TExtDdDragDropManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragDropManager.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDdDragDropManager.HandleWasClicked(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.handleWasClicked(' + VarToJSON([Node, false]) + ');', 'TExtDdDragDropManager');
  Result := Self;
end;

destructor TExtDdDragDropManager.Destroy; begin
  try
    FLocationCache.Free;
    FElementCache.Free;
  except end;
  inherited;
end;

procedure TPerson.SetFStatics(Value : TExtObject); begin
  FStatics := Value;
  Value.DeleteFromGarbage;
  JSCode('statics:' + VarToJSON([Value, false]));
end;

procedure TPerson.SetFInheritableStatics(Value : TExtObject); begin
  FInheritableStatics := Value;
  Value.DeleteFromGarbage;
  JSCode('inheritableStatics:' + VarToJSON([Value, false]));
end;

procedure TPerson.SetFConfig(Value : TExtObject); begin
  FConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('config:' + VarToJSON([Value, false]));
end;

procedure TPerson.SetFMixins(Value : TExtObjectList); begin
  FMixins := Value;
  Value.DeleteFromGarbage;
  JSCode('mixins:' + VarToJSON([Value, false]));
end;

procedure TPerson.SetFMixinsTExtObject(Value : TExtObject); begin
  FMixinsTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('mixins:' + VarToJSON([Value, false]));
end;

function TPerson.JSClassName : string; begin
  Result := 'Person';
end;

procedure TPerson.InitDefaults; begin
  inherited;
  FStatics := TExtObject.CreateInternal(Self, 'statics');
  FInheritableStatics := TExtObject.CreateInternal(Self, 'inheritableStatics');
  FConfig := TExtObject.CreateInternal(Self, 'config');
  FMixins := TExtObjectList.Create(Self, 'mixins');
  FMixinsTExtObject := TExtObject.CreateInternal(Self, 'mixins');
end;

{$IFDEF FPC}constructor TPerson.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TPerson.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TPerson.Destroy; begin
  try
    FStatics.Free;
    FInheritableStatics.Free;
    FConfig.Free;
    FMixins.Free;
    FMixinsTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtDdDragTracker.SetFTrackOver(Value : Boolean); begin
  FTrackOver := Value;
  JSCode('trackOver:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFOverCls(Value : String); begin
  FOverCls := Value;
  JSCode('overCls:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFConstrainTo(Value : TExtUtilRegion); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragTracker.SetFConstrainToTExtElement(Value : TExtElement); begin
  FConstrainToTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragTracker.SetFTolerance(Value : Integer); begin
  FTolerance := Value;
  JSCode('tolerance:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFAutoStart(Value : Boolean); begin
  FAutoStart := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFAutoStartInteger(Value : Integer); begin
  FAutoStartInteger := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFStopEvent(Value : Boolean); begin
  FStopEvent := Value;
  JSCode('stopEvent:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFOnMouseover(Value : TExtDdDragTrackerOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['This', '%0.nm','E', '%1.nm','Target', '%2.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtDdDragTracker.SetFOnMouseout(Value : TExtDdDragTrackerOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtDdDragTracker.SetFOnMousedown(Value : TExtDdDragTrackerOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtDdDragTracker.SetFOnMouseup(Value : TExtDdDragTrackerOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseup := Value;
end;

procedure TExtDdDragTracker.SetFOnMousemove(Value : TExtDdDragTrackerOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMousemove := Value;
end;

procedure TExtDdDragTracker.SetFOnBeforestart(Value : TExtDdDragTrackerOnBeforestart); begin
  if Assigned(FOnBeforestart) then
    JSCode(JSName+'.events ["beforestart"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestart', Ajax('beforestart', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforestart := Value;
end;

procedure TExtDdDragTracker.SetFOnDragstart(Value : TExtDdDragTrackerOnDragstart); begin
  if Assigned(FOnDragstart) then
    JSCode(JSName+'.events ["dragstart"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragstart', Ajax('dragstart', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDragstart := Value;
end;

procedure TExtDdDragTracker.SetFOnDragend(Value : TExtDdDragTrackerOnDragend); begin
  if Assigned(FOnDragend) then
    JSCode(JSName+'.events ["dragend"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragend', Ajax('dragend', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDragend := Value;
end;

procedure TExtDdDragTracker.SetFOnDrag(Value : TExtDdDragTrackerOnDrag); begin
  if Assigned(FOnDrag) then
    JSCode(JSName+'.events ["drag"].listeners=[];');
  if Assigned(Value) then
    AddListener('drag', Ajax('drag', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDrag := Value;
end;

function TExtDdDragTracker.JSClassName : string; begin
  Result := 'Ext.dd.DragTracker';
end;

procedure TExtDdDragTracker.InitDefaults; begin
  inherited;
  FConstrainTo := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FConstrainToTExtElement := TExtElement.CreateInternal(Self, 'constrainTo');
end;

{$IFDEF FPC}constructor TExtDdDragTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragTracker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDdDragTracker.InitEl(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.initEl(' + VarToJSON([El, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.InitEl(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.InitEl(' + VarToJSON([El, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.GetDragTarget : TExtFunction; begin
  JSCode(JSName + '.getDragTarget();', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.GetOffset(Optional : String) : TExtFunction; begin
  JSCode(JSName + '.getOffset(' + VarToJSON([Optional]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

destructor TExtDdDragTracker.Destroy; begin
  try
    FConstrainTo.Free;
    FConstrainToTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtDdDragTracker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')), THTMLElement(ParamAsObject('Target')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'beforestart') and Assigned(FOnBeforestart) then
    FOnBeforestart(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'dragstart') and Assigned(FOnDragstart) then
    FOnDragstart(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'dragend') and Assigned(FOnDragend) then
    FOnDragend(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'drag') and Assigned(FOnDrag) then
    FOnDrag(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')));
end;

procedure TExtDomHelperSingleton.SetFUseDom(Value : Boolean); begin
  FUseDom := Value;
  JSCode(JSName + '.useDom=' + VarToJSON([Value]) + ';');
end;

function TExtDomHelperSingleton.JSClassName : string; begin
  Result := 'Ext.dom.Helper';
end;

{$IFDEF FPC}constructor TExtDomHelperSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomHelperSingleton.CreateDom(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.createDom(' + VarToJSON([O, false]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateDom(O : String) : TExtFunction; begin
  JSCode(JSName + '.CreateDom(' + VarToJSON([O]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateHtml : TExtFunction; begin
  JSCode(JSName + '.createHtml();', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.overwrite(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateTemplate(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.createTemplate(' + VarToJSON([O, false]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

procedure TExtDomElement.SetFAutoBoxAdjust(Value : Boolean); begin
  FAutoBoxAdjust := Value;
  JSCode(JSName + '.autoBoxAdjust=' + VarToJSON([Value]) + ';');
end;

procedure TExtDomElement.SetFOnClick(Value : TExtDomElementOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['E', '%0.nm','T', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtDomElement.SetFOnContextmenu(Value : TExtDomElementOnContextmenu); begin
  if Assigned(FOnContextmenu) then
    JSCode(JSName+'.events ["contextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('contextmenu', Ajax('contextmenu', ['E', '%0.nm','T', '%1.nm'], true));
  FOnContextmenu := Value;
end;

procedure TExtDomElement.SetFOnDblclick(Value : TExtDomElementOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDblclick := Value;
end;

procedure TExtDomElement.SetFOnMousedown(Value : TExtDomElementOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtDomElement.SetFOnMouseup(Value : TExtDomElementOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseup := Value;
end;

procedure TExtDomElement.SetFOnMouseover(Value : TExtDomElementOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtDomElement.SetFOnMousemove(Value : TExtDomElementOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMousemove := Value;
end;

procedure TExtDomElement.SetFOnMouseout(Value : TExtDomElementOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtDomElement.SetFOnMouseenter(Value : TExtDomElementOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseenter := Value;
end;

procedure TExtDomElement.SetFOnMouseleave(Value : TExtDomElementOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseleave := Value;
end;

procedure TExtDomElement.SetFOnKeypress(Value : TExtDomElementOnKeypress); begin
  if Assigned(FOnKeypress) then
    JSCode(JSName+'.events ["keypress"].listeners=[];');
  if Assigned(Value) then
    AddListener('keypress', Ajax('keypress', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeypress := Value;
end;

procedure TExtDomElement.SetFOnKeydown(Value : TExtDomElementOnKeydown); begin
  if Assigned(FOnKeydown) then
    JSCode(JSName+'.events ["keydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('keydown', Ajax('keydown', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeydown := Value;
end;

procedure TExtDomElement.SetFOnKeyup(Value : TExtDomElementOnKeyup); begin
  if Assigned(FOnKeyup) then
    JSCode(JSName+'.events ["keyup"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyup', Ajax('keyup', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeyup := Value;
end;

procedure TExtDomElement.SetFOnLoad(Value : TExtDomElementOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['E', '%0.nm','T', '%1.nm'], true));
  FOnLoad := Value;
end;

procedure TExtDomElement.SetFOnUnload(Value : TExtDomElementOnUnload); begin
  if Assigned(FOnUnload) then
    JSCode(JSName+'.events ["unload"].listeners=[];');
  if Assigned(Value) then
    AddListener('unload', Ajax('unload', ['E', '%0.nm','T', '%1.nm'], true));
  FOnUnload := Value;
end;

procedure TExtDomElement.SetFOnAbort(Value : TExtDomElementOnAbort); begin
  if Assigned(FOnAbort) then
    JSCode(JSName+'.events ["abort"].listeners=[];');
  if Assigned(Value) then
    AddListener('abort', Ajax('abort', ['E', '%0.nm','T', '%1.nm'], true));
  FOnAbort := Value;
end;

procedure TExtDomElement.SetFOnError(Value : TExtDomElementOnError); begin
  if Assigned(FOnError) then
    JSCode(JSName+'.events ["error"].listeners=[];');
  if Assigned(Value) then
    AddListener('error', Ajax('error', ['E', '%0.nm','T', '%1.nm'], true));
  FOnError := Value;
end;

procedure TExtDomElement.SetFOnResize(Value : TExtDomElementOnResize); begin
  if Assigned(FOnResize) then
    JSCode(JSName+'.events ["resize"].listeners=[];');
  if Assigned(Value) then
    AddListener('resize', Ajax('resize', ['E', '%0.nm','T', '%1.nm'], true));
  FOnResize := Value;
end;

procedure TExtDomElement.SetFOnScroll(Value : TExtDomElementOnScroll); begin
  if Assigned(FOnScroll) then
    JSCode(JSName+'.events ["scroll"].listeners=[];');
  if Assigned(Value) then
    AddListener('scroll', Ajax('scroll', ['E', '%0.nm','T', '%1.nm'], true));
  FOnScroll := Value;
end;

procedure TExtDomElement.SetFOnSelect(Value : TExtDomElementOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['E', '%0.nm','T', '%1.nm'], true));
  FOnSelect := Value;
end;

procedure TExtDomElement.SetFOnChange(Value : TExtDomElementOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['E', '%0.nm','T', '%1.nm'], true));
  FOnChange := Value;
end;

procedure TExtDomElement.SetFOnSubmit(Value : TExtDomElementOnSubmit); begin
  if Assigned(FOnSubmit) then
    JSCode(JSName+'.events ["submit"].listeners=[];');
  if Assigned(Value) then
    AddListener('submit', Ajax('submit', ['E', '%0.nm','T', '%1.nm'], true));
  FOnSubmit := Value;
end;

procedure TExtDomElement.SetFOnReset(Value : TExtDomElementOnReset); begin
  if Assigned(FOnReset) then
    JSCode(JSName+'.events ["reset"].listeners=[];');
  if Assigned(Value) then
    AddListener('reset', Ajax('reset', ['E', '%0.nm','T', '%1.nm'], true));
  FOnReset := Value;
end;

procedure TExtDomElement.SetFOnFocus(Value : TExtDomElementOnFocus); begin
  if Assigned(FOnFocus) then
    JSCode(JSName+'.events ["focus"].listeners=[];');
  if Assigned(Value) then
    AddListener('focus', Ajax('focus', ['E', '%0.nm','T', '%1.nm'], true));
  FOnFocus := Value;
end;

procedure TExtDomElement.SetFOnBlur(Value : TExtDomElementOnBlur); begin
  if Assigned(FOnBlur) then
    JSCode(JSName+'.events ["blur"].listeners=[];');
  if Assigned(Value) then
    AddListener('blur', Ajax('blur', ['E', '%0.nm','T', '%1.nm'], true));
  FOnBlur := Value;
end;

procedure TExtDomElement.SetFOnDOMFocusIn(Value : TExtDomElementOnDOMFocusIn); begin
  if Assigned(FOnDOMFocusIn) then
    JSCode(JSName+'.events ["DOMFocusIn"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMFocusIn', Ajax('DOMFocusIn', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMFocusIn := Value;
end;

procedure TExtDomElement.SetFOnDOMFocusOut(Value : TExtDomElementOnDOMFocusOut); begin
  if Assigned(FOnDOMFocusOut) then
    JSCode(JSName+'.events ["DOMFocusOut"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMFocusOut', Ajax('DOMFocusOut', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMFocusOut := Value;
end;

procedure TExtDomElement.SetFOnDOMActivate(Value : TExtDomElementOnDOMActivate); begin
  if Assigned(FOnDOMActivate) then
    JSCode(JSName+'.events ["DOMActivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMActivate', Ajax('DOMActivate', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMActivate := Value;
end;

procedure TExtDomElement.SetFOnDOMSubtreeModified(Value : TExtDomElementOnDOMSubtreeModified); begin
  if Assigned(FOnDOMSubtreeModified) then
    JSCode(JSName+'.events ["DOMSubtreeModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMSubtreeModified', Ajax('DOMSubtreeModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMSubtreeModified := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeInserted(Value : TExtDomElementOnDOMNodeInserted); begin
  if Assigned(FOnDOMNodeInserted) then
    JSCode(JSName+'.events ["DOMNodeInserted"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeInserted', Ajax('DOMNodeInserted', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeInserted := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeRemoved(Value : TExtDomElementOnDOMNodeRemoved); begin
  if Assigned(FOnDOMNodeRemoved) then
    JSCode(JSName+'.events ["DOMNodeRemoved"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeRemoved', Ajax('DOMNodeRemoved', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeRemoved := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeRemovedFromDocument(Value : TExtDomElementOnDOMNodeRemovedFromDocument); begin
  if Assigned(FOnDOMNodeRemovedFromDocument) then
    JSCode(JSName+'.events ["DOMNodeRemovedFromDocument"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeRemovedFromDocument', Ajax('DOMNodeRemovedFromDocument', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeRemovedFromDocument := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeInsertedIntoDocument(Value : TExtDomElementOnDOMNodeInsertedIntoDocument); begin
  if Assigned(FOnDOMNodeInsertedIntoDocument) then
    JSCode(JSName+'.events ["DOMNodeInsertedIntoDocument"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeInsertedIntoDocument', Ajax('DOMNodeInsertedIntoDocument', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeInsertedIntoDocument := Value;
end;

procedure TExtDomElement.SetFOnDOMAttrModified(Value : TExtDomElementOnDOMAttrModified); begin
  if Assigned(FOnDOMAttrModified) then
    JSCode(JSName+'.events ["DOMAttrModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMAttrModified', Ajax('DOMAttrModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMAttrModified := Value;
end;

procedure TExtDomElement.SetFOnDOMCharacterDataModified(Value : TExtDomElementOnDOMCharacterDataModified); begin
  if Assigned(FOnDOMCharacterDataModified) then
    JSCode(JSName+'.events ["DOMCharacterDataModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMCharacterDataModified', Ajax('DOMCharacterDataModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMCharacterDataModified := Value;
end;

function TExtDomElement.JSClassName : string; begin
  Result := 'Ext.dom.Element';
end;

{$IFDEF FPC}constructor TExtDomElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement.On(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.on(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Un(EventName : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.un(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.RemoveAllListeners : TExtFunction; begin
  JSCode(JSName + '.removeAllListeners();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.PurgeAllListeners : TExtFunction; begin
  JSCode(JSName + '.purgeAllListeners();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.MonitorMouseLeave(Delay : Integer; Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.monitorMouseLeave(' + VarToJSON([Delay, Handler, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.SwallowEvent(EventName : String; PreventDefault : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.swallowEvent(' + VarToJSON([EventName, PreventDefault]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.SwallowEvent(EventName : TExtObjectList; PreventDefault : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SwallowEvent(' + VarToJSON(EventName) + ',' + VarToJSON([PreventDefault]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.RelayEvent(EventName : String; Observable : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.relayEvent(' + VarToJSON([EventName, Observable, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Clean(ForceReclean : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.clean(' + VarToJSON([ForceReclean]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Load : TExtFunction; begin
  JSCode(JSName + '.load();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.GetLoader : TExtFunction; begin
  JSCode(JSName + '.getLoader();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Update(Html : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Html, LoadScripts, Callback, true]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : String; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.createProxy(' + VarToJSON([Config, RenderTo, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : TExtObject; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, false, RenderTo, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : TExtObject; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, false, RenderTo, false, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : String; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, RenderTo, false, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.NeedsTabIndex : TExtFunction; begin
  JSCode(JSName + '.needsTabIndex();', 'TExtDomElement');
  Result := Self;
end;

procedure TExtDomElement.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'contextmenu') and Assigned(FOnContextmenu) then
    FOnContextmenu(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keypress') and Assigned(FOnKeypress) then
    FOnKeypress(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keydown') and Assigned(FOnKeydown) then
    FOnKeydown(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keyup') and Assigned(FOnKeyup) then
    FOnKeyup(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'unload') and Assigned(FOnUnload) then
    FOnUnload(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'abort') and Assigned(FOnAbort) then
    FOnAbort(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'error') and Assigned(FOnError) then
    FOnError(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'resize') and Assigned(FOnResize) then
    FOnResize(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'scroll') and Assigned(FOnScroll) then
    FOnScroll(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'submit') and Assigned(FOnSubmit) then
    FOnSubmit(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'reset') and Assigned(FOnReset) then
    FOnReset(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'focus') and Assigned(FOnFocus) then
    FOnFocus(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'blur') and Assigned(FOnBlur) then
    FOnBlur(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMFocusIn') and Assigned(FOnDOMFocusIn) then
    FOnDOMFocusIn(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMFocusOut') and Assigned(FOnDOMFocusOut) then
    FOnDOMFocusOut(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMActivate') and Assigned(FOnDOMActivate) then
    FOnDOMActivate(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMSubtreeModified') and Assigned(FOnDOMSubtreeModified) then
    FOnDOMSubtreeModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeInserted') and Assigned(FOnDOMNodeInserted) then
    FOnDOMNodeInserted(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeRemoved') and Assigned(FOnDOMNodeRemoved) then
    FOnDOMNodeRemoved(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeRemovedFromDocument') and Assigned(FOnDOMNodeRemovedFromDocument) then
    FOnDOMNodeRemovedFromDocument(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeInsertedIntoDocument') and Assigned(FOnDOMNodeInsertedIntoDocument) then
    FOnDOMNodeInsertedIntoDocument(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMAttrModified') and Assigned(FOnDOMAttrModified) then
    FOnDOMAttrModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMCharacterDataModified') and Assigned(FOnDOMCharacterDataModified) then
    FOnDOMCharacterDataModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')));
end;

procedure TExtDrawColor.SetFLightnessFactor(Value : Integer); begin
  FLightnessFactor := Value;
  JSCode('lightnessFactor:' + VarToJSON([Value]));
end;

function TExtDrawColor.JSClassName : string; begin
  Result := 'Ext.draw.Color';
end;

procedure TExtDrawColor.InitDefaults; begin
  inherited;
  FLightnessFactor := 0;
end;

{$IFDEF FPC}constructor TExtDrawColor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawColor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtDrawColor.Create(Red : Integer; Green : Integer; Blue : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([Red, Green, Blue]) + ');');
  InitDefaults;
end;

function TExtDrawColor.GetRed : TExtFunction; begin
  JSCode(JSName + '.getRed();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetGreen : TExtFunction; begin
  JSCode(JSName + '.getGreen();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetBlue : TExtFunction; begin
  JSCode(JSName + '.getBlue();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetRGB : TExtFunction; begin
  JSCode(JSName + '.getRGB();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetHSL : TExtFunction; begin
  JSCode(JSName + '.getHSL();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetLighter(Factor : Integer) : TExtFunction; begin
  JSCode(JSName + '.getLighter(' + VarToJSON([Factor]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetDarker(Factor : Integer) : TExtFunction; begin
  JSCode(JSName + '.getDarker(' + VarToJSON([Factor]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToHex(Color : String) : TExtFunction; begin
  JSCode(JSName + '.toHex(' + VarToJSON([Color]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToHex(Color : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.ToHex(' + VarToJSON(Color) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.FromString(Str : String) : TExtFunction; begin
  JSCode(JSName + '.fromString(' + VarToJSON([Str]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetGrayscale : TExtFunction; begin
  JSCode(JSName + '.getGrayscale();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.FromHSL(H : Integer; S : Integer; L : Integer) : TExtFunction; begin
  JSCode(JSName + '.fromHSL(' + VarToJSON([H, S, L]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawEngineSvgExporterSingleton.JSClassName : string; begin
  Result := 'Ext.draw.engine.SvgExporter';
end;

{$IFDEF FPC}constructor TExtDrawEngineSvgExporterSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineSvgExporterSingleton.Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.generate(' + VarToJSON([Surface, false, Config, false]) + ');', 'TExtDrawEngineSvgExporterSingleton');
  Result := Self;
end;

procedure TExtDrawEngineImageExporter.SetFDefaultUrl(Value : String); begin
  FDefaultUrl := Value;
  JSCode(JSName + '.defaultUrl=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporter.SetFSupportedTypes(Value : TExtObjectList); begin
  FSupportedTypes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.supportedTypes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawEngineImageExporter.SetFWidthParam(Value : String); begin
  FWidthParam := Value;
  JSCode(JSName + '.widthParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporter.SetFHeightParam(Value : String); begin
  FHeightParam := Value;
  JSCode(JSName + '.heightParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporter.SetFTypeParam(Value : String); begin
  FTypeParam := Value;
  JSCode(JSName + '.typeParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporter.SetFSvgParam(Value : String); begin
  FSvgParam := Value;
  JSCode(JSName + '.svgParam=' + VarToJSON([Value]) + ';');
end;

function TExtDrawEngineImageExporter.JSClassName : string; begin
  Result := 'Ext.draw.engine.ImageExporter';
end;

procedure TExtDrawEngineImageExporter.InitDefaults; begin
  inherited;
  FSupportedTypes := TExtObjectList.Create(Self, 'supportedTypes');
end;

{$IFDEF FPC}constructor TExtDrawEngineImageExporter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawEngineImageExporter.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDrawEngineImageExporter.Generate(Surface : TExtDrawSurface; Config : TExtObject = nil; ConfigWidth : Integer = 0; ConfigHeight : Integer = 0; ConfigUrl : String = ''; ConfigType : String = ''; ConfigWidthParam : String = ''; ConfigHeightParam : String = ''; ConfigTypeParam : String = ''; ConfigSvgParam : String = '') : TExtFunction; begin
  JSCode(JSName + '.generate(' + VarToJSON([Surface, false, Config, false, ConfigWidth, ConfigHeight, ConfigUrl, ConfigType, ConfigWidthParam, ConfigHeightParam, ConfigTypeParam, ConfigSvgParam]) + ');', 'TExtDrawEngineImageExporter');
  Result := Self;
end;

destructor TExtDrawEngineImageExporter.Destroy; begin
  try
    FSupportedTypes.Free;
  except end;
  inherited;
end;

procedure TExtDirectPollingProvider.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

procedure TExtDirectPollingProvider.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtDirectPollingProvider.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtDirectPollingProvider.SetFUrlTExtFunction(Value : TExtFunction); begin
  FUrlTExtFunction := Value;
  JSCode('url:' + VarToJSON([Value, true]));
end;

procedure TExtDirectPollingProvider.SetFOnBeforepoll(Value : TExtDirectPollingProviderOnBeforepoll); begin
  if Assigned(FOnBeforepoll) then
    JSCode(JSName+'.events ["beforepoll"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforepoll', Ajax('beforepoll', ['This', '%0.nm'], true));
  FOnBeforepoll := Value;
end;

procedure TExtDirectPollingProvider.SetFOnPoll(Value : TExtDirectPollingProviderOnPoll); begin
  if Assigned(FOnPoll) then
    JSCode(JSName+'.events ["poll"].listeners=[];');
  if Assigned(Value) then
    AddListener('poll', Ajax('poll', ['This', '%0.nm'], true));
  FOnPoll := Value;
end;

function TExtDirectPollingProvider.JSClassName : string; begin
  Result := 'Ext.direct.PollingProvider';
end;

procedure TExtDirectPollingProvider.InitDefaults; begin
  inherited;
  FInterval := 3;
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
end;

{$IFDEF FPC}constructor TExtDirectPollingProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectPollingProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDirectPollingProvider.Connect : TExtFunction; begin
  JSCode(JSName + '.connect();', 'TExtDirectPollingProvider');
  Result := Self;
end;

function TExtDirectPollingProvider.Disconnect : TExtFunction; begin
  JSCode(JSName + '.disconnect();', 'TExtDirectPollingProvider');
  Result := Self;
end;

destructor TExtDirectPollingProvider.Destroy; begin
  try
    FBaseParams.Free;
  except end;
  inherited;
end;

procedure TExtDirectPollingProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforepoll') and Assigned(FOnBeforepoll) then
    FOnBeforepoll(TExtDirectPollingProvider(ParamAsObject('This')))
  else if (AEvtName = 'poll') and Assigned(FOnPoll) then
    FOnPoll(TExtDirectPollingProvider(ParamAsObject('This')));
end;

procedure TExtDirectManagerSingleton.SetFOnEvent(Value : TExtDirectManagerSingletonOnEvent); begin
  if Assigned(FOnEvent) then
    JSCode(JSName+'.events ["event"].listeners=[];');
  if Assigned(Value) then
    AddListener('event', Ajax('event', ['E', '%0.nm','Provider', '%1.nm'], true));
  FOnEvent := Value;
end;

procedure TExtDirectManagerSingleton.SetFOnException(Value : TExtDirectManagerSingletonOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['E', '%0.nm'], true));
  FOnException := Value;
end;

function TExtDirectManagerSingleton.JSClassName : string; begin
  Result := 'Ext.direct.Manager';
end;

{$IFDEF FPC}constructor TExtDirectManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectManagerSingleton.AddProvider(Provider : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.addProvider(' + VarToJSON([Provider, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddProvider(Provider : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddProvider(' + VarToJSON(Provider) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.GetProvider(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getProvider(' + VarToJSON([Id]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.GetProvider(Id : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.GetProvider(' + VarToJSON([Id, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveProvider(Provider : String) : TExtFunction; begin
  JSCode(JSName + '.removeProvider(' + VarToJSON([Provider]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveProvider(Provider : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.RemoveProvider(' + VarToJSON([Provider, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

procedure TExtDirectManagerSingleton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'event') and Assigned(FOnEvent) then
    FOnEvent(TExtDirectEvent(ParamAsObject('E')), TExtDirectProvider(ParamAsObject('Provider')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDirectEvent(ParamAsObject('E')));
end;

procedure TExtDirectRemotingProvider.SetFActions(Value : TExtObject); begin
  FActions := Value;
  Value.DeleteFromGarbage;
  JSCode('actions:' + VarToJSON([Value, false]));
end;

procedure TExtDirectRemotingProvider.SetFNamespace(Value : String); begin
  FNamespace := Value;
  JSCode('namespace:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFNamespaceTExtObject(Value : TExtObject); begin
  FNamespaceTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('namespace:' + VarToJSON([Value, false]));
end;

procedure TExtDirectRemotingProvider.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableUrlEncode(Value : String); begin
  FEnableUrlEncode := Value;
  JSCode('enableUrlEncode:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableBuffer(Value : Integer); begin
  FEnableBuffer := Value;
  JSCode('enableBuffer:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableBufferBoolean(Value : Boolean); begin
  FEnableBufferBoolean := Value;
  JSCode('enableBuffer:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFMaxRetries(Value : Integer); begin
  FMaxRetries := Value;
  JSCode('maxRetries:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFOnBeforecall(Value : TExtDirectRemotingProviderOnBeforecall); begin
  if Assigned(FOnBeforecall) then
    JSCode(JSName+'.events ["beforecall"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecall', Ajax('beforecall', ['Provider', '%0.nm','Transaction', '%1.nm','Meta', '%2.nm'], true));
  FOnBeforecall := Value;
end;

procedure TExtDirectRemotingProvider.SetFOnCall(Value : TExtDirectRemotingProviderOnCall); begin
  if Assigned(FOnCall) then
    JSCode(JSName+'.events ["call"].listeners=[];');
  if Assigned(Value) then
    AddListener('call', Ajax('call', ['Provider', '%0.nm','Transaction', '%1.nm','Meta', '%2.nm'], true));
  FOnCall := Value;
end;

function TExtDirectRemotingProvider.JSClassName : string; begin
  Result := 'Ext.direct.RemotingProvider';
end;

procedure TExtDirectRemotingProvider.InitDefaults; begin
  inherited;
  FActions := TExtObject.CreateInternal(Self, 'actions');
  FNamespaceTExtObject := TExtObject.CreateInternal(Self, 'namespace');
  FEnableUrlEncode := 'data';
end;

{$IFDEF FPC}constructor TExtDirectRemotingProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectRemotingProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDirectRemotingProvider.Destroy; begin
  try
    FActions.Free;
    FNamespaceTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtDirectRemotingProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecall') and Assigned(FOnBeforecall) then
    FOnBeforecall(TExtDirectRemotingProvider(ParamAsObject('Provider')), TExtDirectTransaction(ParamAsObject('Transaction')), TExtObject(ParamAsObject('Meta')))
  else if (AEvtName = 'call') and Assigned(FOnCall) then
    FOnCall(TExtDirectRemotingProvider(ParamAsObject('Provider')), TExtDirectTransaction(ParamAsObject('Transaction')), TExtObject(ParamAsObject('Meta')));
end;

procedure TExtDomCompositeElementLite.SetFElements(Value : TExtObjectList); begin
  FElements := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.elements=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDomCompositeElementLite.SetFIsComposite(Value : Boolean); begin
  FIsComposite := Value;
  JSCode(JSName + '.isComposite=' + VarToJSON([Value]) + ';');
end;

function TExtDomCompositeElementLite.JSClassName : string; begin
  Result := 'Ext.dom.CompositeElementLite';
end;

procedure TExtDomCompositeElementLite.InitDefaults; begin
  inherited;
  FElements := TExtObjectList.Create(Self, 'elements');
end;

{$IFDEF FPC}constructor TExtDomCompositeElementLite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDomCompositeElementLite.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDomCompositeElementLite.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Add(Els : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON(Els) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Add(Els : TExtDomCompositeElement) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON([Els, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Item(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.item(' + VarToJSON([Index]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Each(Fn : TExtFunction; FnEl : TExtDomElement; FnC : TExtDomCompositeElement; FnIndex : Integer; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, FnEl, false, FnC, false, FnIndex, Scope, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Fill(Els : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fill(' + VarToJSON(Els) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Fill(Els : TExtDomCompositeElement) : TExtFunction; begin
  JSCode(JSName + '.Fill(' + VarToJSON([Els, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Filter(Selector : String; SelectorEl : TExtDomElement; SelectorIndex : Integer) : TExtFunction; begin
  JSCode(JSName + '.filter(' + VarToJSON([Selector, SelectorEl, false, SelectorIndex]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Filter(Selector : TExtFunction; SelectorEl : TExtDomElement; SelectorIndex : Integer) : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON([Selector, true, SelectorEl, false, SelectorIndex]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : String) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : Integer) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.replaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.First : TExtFunction; begin
  JSCode(JSName + '.first();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Last : TExtFunction; begin
  JSCode(JSName + '.last();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : String) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : Integer) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

destructor TExtDomCompositeElementLite.Destroy; begin
  try
    FElements.Free;
  except end;
  inherited;
end;

function TExtDirectTransaction.JSClassName : string; begin
  Result := 'Ext.direct.Transaction';
end;

{$IFDEF FPC}constructor TExtDirectTransaction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectTransaction.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtGridFeatureAbstractSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.AbstractSummary';
end;

{$IFDEF FPC}constructor TExtGridFeatureAbstractSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureAbstractSummary.ToggleSummaryRow(Visible : Boolean) : TExtFunction; begin
  JSCode(JSName + '.toggleSummaryRow(' + VarToJSON([Visible]) + ');', 'TExtGridFeatureAbstractSummary');
  Result := Self;
end;

function TExtGridFeatureAbstractSummary.GetColumnValue(Column : TExtGridColumn; Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getColumnValue(' + VarToJSON([Column, false, Data, false]) + ');', 'TExtGridFeatureAbstractSummary');
  Result := Self;
end;

procedure TExtUtilHashMap.SetFKeyFn(Value : TExtFunction); begin
  FKeyFn := Value;
  JSCode('keyFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilHashMap.SetFOnAdd(Value : TExtUtilHashMapOnAdd); begin
  if Assigned(FOnAdd) then
    JSCode(JSName+'.events ["add"].listeners=[];');
  if Assigned(Value) then
    AddListener('add', Ajax('add', ['This', '%0.nm','Key', '%1','Value', '%2.nm'], true));
  FOnAdd := Value;
end;

procedure TExtUtilHashMap.SetFOnClear(Value : TExtUtilHashMapOnClear); begin
  if Assigned(FOnClear) then
    JSCode(JSName+'.events ["clear"].listeners=[];');
  if Assigned(Value) then
    AddListener('clear', Ajax('clear', ['This', '%0.nm'], true));
  FOnClear := Value;
end;

procedure TExtUtilHashMap.SetFOnRemove(Value : TExtUtilHashMapOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['This', '%0.nm','Key', '%1','Value', '%2.nm'], true));
  FOnRemove := Value;
end;

procedure TExtUtilHashMap.SetFOnReplace(Value : TExtUtilHashMapOnReplace); begin
  if Assigned(FOnReplace) then
    JSCode(JSName+'.events ["replace"].listeners=[];');
  if Assigned(Value) then
    AddListener('replace', Ajax('replace', ['This', '%0.nm','Key', '%1','Value', '%2.nm','Old', '%3.nm'], true));
  FOnReplace := Value;
end;

function TExtUtilHashMap.JSClassName : string; begin
  Result := 'Ext.util.HashMap';
end;

{$IFDEF FPC}constructor TExtUtilHashMap.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilHashMap.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetKey(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getKey(' + VarToJSON([O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Add(Key : String; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Key, O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Add(Key : TExtObject; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON([Key, false, O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Replace(Key : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.replace(' + VarToJSON([Key, Value, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Remove(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveAtKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.removeAtKey(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Get(Key : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ContainsKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.containsKey(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Contains(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Value, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetKeys : TExtFunction; begin
  JSCode(JSName + '.getKeys();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Clone : TExtFunction; begin
  JSCode(JSName + '.clone();', 'TExtUtilHashMap');
  Result := Self;
end;

procedure TExtUtilHashMap.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'clear') and Assigned(FOnClear) then
    FOnClear(TExtUtilHashMap(ParamAsObject('This')))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'replace') and Assigned(FOnReplace) then
    FOnReplace(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('Old')));
end;

procedure TExtUtilFloating.SetFFocusOnToFront(Value : Boolean); begin
  FFocusOnToFront := Value;
  JSCode('focusOnToFront:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadowOffset(Value : String); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadowOffsetBoolean(Value : Boolean); begin
  FShadowOffsetBoolean := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

function TExtUtilFloating.JSClassName : string; begin
  Result := 'Ext.util.Floating';
end;

{$IFDEF FPC}constructor TExtUtilFloating.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilFloating.DoConstrain(ConstrainTo : String = '') : TExtFunction; begin
  JSCode(JSName + '.doConstrain(' + VarToJSON([ConstrainTo]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.AlignTo(Element : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.alignTo(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.AlignTo(Element : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, Position, Offsets]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.ToFront(PreventFocus : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toFront(' + VarToJSON([PreventFocus]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.setActive(' + VarToJSON([Active, NewActive, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.ToBack : TExtFunction; begin
  JSCode(JSName + '.toBack();', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.Center : TExtFunction; begin
  JSCode(JSName + '.center();', 'TExtUtilFloating');
  Result := Self;
end;

procedure TExtUtilHistory.SetFOnReady(Value : TExtUtilHistoryOnReady); begin
  if Assigned(FOnReady) then
    JSCode(JSName+'.events ["ready"].listeners=[];');
  if Assigned(Value) then
    AddListener('ready', Ajax('ready', ['The', '%0.nm'], true));
  FOnReady := Value;
end;

procedure TExtUtilHistory.SetFOnChange(Value : TExtUtilHistoryOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['Token', '%0'], true));
  FOnChange := Value;
end;

function TExtUtilHistory.JSClassName : string; begin
  Result := 'Ext.util.History';
end;

{$IFDEF FPC}constructor TExtUtilHistory.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilHistory.Forward : TExtFunction; begin
  JSCode(JSName + '.forward();', 'TExtUtilHistory');
  Result := Self;
end;

function TExtUtilHistory.GetToken : TExtFunction; begin
  JSCode(JSName + '.getToken();', 'TExtUtilHistory');
  Result := Self;
end;

procedure TExtUtilHistory.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'ready') and Assigned(FOnReady) then
    FOnReady(TExtUtilHistory(ParamAsObject('The')))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(ParamAsString('Token'));
end;

procedure TExtUtilKeyMap.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTargetTExtElement(Value : TExtElement); begin
  FTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFBinding(Value : TExtObject); begin
  FBinding := Value;
  Value.DeleteFromGarbage;
  JSCode('binding:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFBindingTExtObjectList(Value : TExtObjectList); begin
  FBindingTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('binding:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFProcessEventScope(Value : TExtObject); begin
  FProcessEventScope := Value;
  Value.DeleteFromGarbage;
  JSCode('processEventScope:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFIgnoreInputFields(Value : Boolean); begin
  FIgnoreInputFields := Value;
  JSCode('ignoreInputFields:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFEventName(Value : String); begin
  FEventName := Value;
  JSCode('eventName:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFProcessEvent(Value : TExtFunction); begin
  FProcessEvent := Value;
  JSCode('processEvent:' + VarToJSON([Value, true]));
end;

function TExtUtilKeyMap.JSClassName : string; begin
  Result := 'Ext.util.KeyMap';
end;

procedure TExtUtilKeyMap.InitDefaults; begin
  inherited;
  FTarget := TExtComponent.CreateInternal(Self, 'target');
  FTargetTExtElement := TExtElement.CreateInternal(Self, 'target');
  FBinding := TExtObject.CreateInternal(Self, 'binding');
  FBindingTExtObjectList := TExtObjectList.Create(Self, 'binding');
  FProcessEventScope := TExtObject.CreateInternal(Self, 'processEventScope');
end;

{$IFDEF FPC}constructor TExtUtilKeyMap.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilKeyMap.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilKeyMap.On(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.on(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.On(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.On(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.On(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.On(' + VarToJSON([Key, false, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.IsEnabled : TExtFunction; begin
  JSCode(JSName + '.isEnabled();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

destructor TExtUtilKeyMap.Destroy; begin
  try
    FTarget.Free;
    FTargetTExtElement.Free;
    FBinding.Free;
    FBindingTExtObjectList.Free;
    FProcessEventScope.Free;
  except end;
  inherited;
end;

function TExtUtilInflector.JSClassName : string; begin
  Result := 'Ext.util.Inflector';
end;

{$IFDEF FPC}constructor TExtUtilInflector.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilInflector.Singular(Matcher : TRegExp; Replacer : String) : TExtFunction; begin
  JSCode(JSName + '.singular(' + VarToJSON([#3 + Matcher, Replacer]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.Plural(Matcher : TRegExp; Replacer : String) : TExtFunction; begin
  JSCode(JSName + '.plural(' + VarToJSON([#3 + Matcher, Replacer]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.ClearSingulars : TExtFunction; begin
  JSCode(JSName + '.clearSingulars();', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.ClearPlurals : TExtFunction; begin
  JSCode(JSName + '.clearPlurals();', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.IsTransnumeral(Word : String) : TExtFunction; begin
  JSCode(JSName + '.isTransnumeral(' + VarToJSON([Word]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.Pluralize(Word : String) : TExtFunction; begin
  JSCode(JSName + '.pluralize(' + VarToJSON([Word]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.Singularize(Word : String) : TExtFunction; begin
  JSCode(JSName + '.singularize(' + VarToJSON([Word]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.Classify(Word : String) : TExtFunction; begin
  JSCode(JSName + '.classify(' + VarToJSON([Word]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

function TExtUtilInflector.Ordinalize(Number : Integer) : TExtFunction; begin
  JSCode(JSName + '.ordinalize(' + VarToJSON([Number]) + ');', 'TExtUtilInflector');
  Result := Self;
end;

procedure TExtUtilClickRepeater.SetFEl(Value : String); begin
  FEl := Value;
  JSCode('el:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFElTHTMLElement(Value : THTMLElement); begin
  FElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('el:' + VarToJSON([Value, false]));
end;

procedure TExtUtilClickRepeater.SetFElTExtElement(Value : TExtElement); begin
  FElTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('el:' + VarToJSON([Value, false]));
end;

procedure TExtUtilClickRepeater.SetFPressedCls(Value : String); begin
  FPressedCls := Value;
  JSCode('pressedCls:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFAccelerate(Value : Boolean); begin
  FAccelerate := Value;
  JSCode('accelerate:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFStopDefault(Value : Boolean); begin
  FStopDefault := Value;
  JSCode('stopDefault:' + VarToJSON([Value]));
end;

function TExtUtilClickRepeater.JSClassName : string; begin
  Result := 'Ext.util.ClickRepeater';
end;

procedure TExtUtilClickRepeater.InitDefaults; begin
  inherited;
  FElTExtElement := TExtElement.CreateInternal(Self, 'el');
end;

{$IFDEF FPC}constructor TExtUtilClickRepeater.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilClickRepeater.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilClickRepeater.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilClickRepeater');
  Result := Self;
end;

function TExtUtilClickRepeater.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilClickRepeater');
  Result := Self;
end;

function TExtUtilClickRepeater.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilClickRepeater');
  Result := Self;
end;

destructor TExtUtilClickRepeater.Destroy; begin
  try
    FElTExtElement.Free;
  except end;
  inherited;
end;

function TExtUtilBindable.JSClassName : string; begin
  Result := 'Ext.util.Bindable';
end;

{$IFDEF FPC}constructor TExtUtilBindable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilBindable.BindStore(Store : TExtDataAbstractStore = nil; Initial : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store, false, Initial]) + ');', 'TExtUtilBindable');
  Result := Self;
end;

function TExtUtilBindable.BindStore(Store : String; Initial : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, Initial]) + ');', 'TExtUtilBindable');
  Result := Self;
end;

function TExtUtilBindable.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtUtilBindable');
  Result := Self;
end;

function TExtUtilCookies.JSClassName : string; begin
  Result := 'Ext.util.Cookies';
end;

{$IFDEF FPC}constructor TExtUtilCookies.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilCookies.SetJS(Name : String; Value : TExtObject; Expires : TExtObject = nil; Path : String = ''; Domain : String = ''; Secure : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false, Expires, false, Path, Domain, Secure]) + ');', 'TExtUtilCookies');
  Result := Self;
end;

function TExtUtilCookies.Get(Name : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name]) + ');', 'TExtUtilCookies');
  Result := Self;
end;

function TExtUtilCookies.Clear(Name : String; Path : String = '') : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name, Path]) + ');', 'TExtUtilCookies');
  Result := Self;
end;

procedure TExtUtilFilter.SetFPropertyJS(Value : String); begin
  FPropertyJS := Value;
  JSCode('propertyJS:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFFilterFn(Value : TExtFunction); begin
  FFilterFn := Value;
  JSCode('filterFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilFilter.SetFAnyMatch(Value : Boolean); begin
  FAnyMatch := Value;
  JSCode('anyMatch:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFExactMatch(Value : Boolean); begin
  FExactMatch := Value;
  JSCode('exactMatch:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFCaseSensitive(Value : Boolean); begin
  FCaseSensitive := Value;
  JSCode('caseSensitive:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

function TExtUtilFilter.JSClassName : string; begin
  Result := 'Ext.util.Filter';
end;

{$IFDEF FPC}constructor TExtUtilFilter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilFilter.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtUtilCSSSingleton.JSClassName : string; begin
  Result := 'Ext.util.CSS';
end;

{$IFDEF FPC}constructor TExtUtilCSSSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilCSSSingleton.CreateStyleSheet(CssText : String; Id : String) : TExtFunction; begin
  JSCode(JSName + '.createStyleSheet(' + VarToJSON([CssText, Id]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RemoveStyleSheet(Id : String) : TExtFunction; begin
  JSCode(JSName + '.removeStyleSheet(' + VarToJSON([Id]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.SwapStyleSheet(Id : String; Url : String) : TExtFunction; begin
  JSCode(JSName + '.swapStyleSheet(' + VarToJSON([Id, Url]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RefreshCache : TExtFunction; begin
  JSCode(JSName + '.refreshCache();', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRules(RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getRules(' + VarToJSON([RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector : String; RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getRule(' + VarToJSON([Selector, RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector : TExtObjectList; RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetRule(' + VarToJSON(Selector) + ',' + VarToJSON([RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector : String; PropertyJS : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.updateRule(' + VarToJSON([Selector, PropertyJS, Value]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector : TExtObjectList; PropertyJS : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.UpdateRule(' + VarToJSON(Selector) + ',' + VarToJSON([PropertyJS, Value]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

procedure TExtUtilSorter.SetFPropertyJS(Value : String); begin
  FPropertyJS := Value;
  JSCode('propertyJS:' + VarToJSON([Value]));
end;

procedure TExtUtilSorter.SetFSorterFn(Value : TExtFunction); begin
  FSorterFn := Value;
  JSCode('sorterFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilSorter.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtUtilSorter.SetFTransform(Value : TExtFunction); begin
  FTransform := Value;
  JSCode('transform:' + VarToJSON([Value, true]));
end;

procedure TExtUtilSorter.SetFDirection(Value : String); begin
  FDirection := Value;
  if not ConfigAvailable(JSName) then
    SetDirection(Value)
  else
    JSCode('direction:' + VarToJSON([Value]));
end;

function TExtUtilSorter.JSClassName : string; begin
  Result := 'Ext.util.Sorter';
end;

{$IFDEF FPC}constructor TExtUtilSorter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilSorter.SetDirection(Direction : String) : TExtFunction; begin
  JSCode(JSName + '.setDirection(' + VarToJSON([Direction]) + ');', 'TExtUtilSorter');
  Result := Self;
end;

function TExtUtilSorter.Toggle : TExtFunction; begin
  JSCode(JSName + '.toggle();', 'TExtUtilSorter');
  Result := Self;
end;

function TExtUtilSorter.UpdateSortFunction(Fn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.updateSortFunction(' + VarToJSON([Fn, true]) + ');', 'TExtUtilSorter');
  Result := Self;
end;

procedure TExtUtilSortable.SetFIsSortable(Value : Boolean); begin
  FIsSortable := Value;
  JSCode(JSName + '.isSortable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilSortable.SetFDefaultSortDirection(Value : String); begin
  FDefaultSortDirection := Value;
  JSCode(JSName + '.defaultSortDirection=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilSortable.SetFSortRoot(Value : String); begin
  FSortRoot := Value;
  JSCode(JSName + '.sortRoot=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilSortable.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.sorters=' + VarToJSON([Value, false]) + ';');
end;

function TExtUtilSortable.JSClassName : string; begin
  Result := 'Ext.util.Sortable';
end;

procedure TExtUtilSortable.InitDefaults; begin
  inherited;
  FSorters := TExtObjectList.Create(Self, 'sorters');
end;

{$IFDEF FPC}constructor TExtUtilSortable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilSortable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilSortable.Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Sorters, Direction]) + ');', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.Sort(' + VarToJSON(Sorters) + ',' + VarToJSON([Direction]) + ');', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.GenerateComparator : TExtFunction; begin
  JSCode(JSName + '.generateComparator();', 'TExtUtilSortable');
  Result := Self;
end;

destructor TExtUtilSortable.Destroy; begin
  try
    FSorters.Free;
  except end;
  inherited;
end;

function TExtUtilTaskRunner.JSClassName : string; begin
  Result := 'Ext.util.TaskRunner';
end;

{$IFDEF FPC}constructor TExtUtilTaskRunner.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilTaskRunner.Stop(Task : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.stop(' + VarToJSON([Task, false]) + ');', 'TExtUtilTaskRunner');
  Result := Self;
end;

function TExtUtilTaskRunner.StopAll : TExtFunction; begin
  JSCode(JSName + '.stopAll();', 'TExtUtilTaskRunner');
  Result := Self;
end;

procedure TExtView.SetFOnBeforeitemmousedown(Value : TExtViewOnBeforeitemmousedown); begin
  if Assigned(FOnBeforeitemmousedown) then
    JSCode(JSName+'.events ["beforeitemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmousedown', Ajax('beforeitemmousedown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmousedown := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseup(Value : TExtViewOnBeforeitemmouseup); begin
  if Assigned(FOnBeforeitemmouseup) then
    JSCode(JSName+'.events ["beforeitemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseup', Ajax('beforeitemmouseup', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseup := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseenter(Value : TExtViewOnBeforeitemmouseenter); begin
  if Assigned(FOnBeforeitemmouseenter) then
    JSCode(JSName+'.events ["beforeitemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseenter', Ajax('beforeitemmouseenter', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseenter := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseleave(Value : TExtViewOnBeforeitemmouseleave); begin
  if Assigned(FOnBeforeitemmouseleave) then
    JSCode(JSName+'.events ["beforeitemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseleave', Ajax('beforeitemmouseleave', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseleave := Value;
end;

procedure TExtView.SetFOnBeforeitemclick(Value : TExtViewOnBeforeitemclick); begin
  if Assigned(FOnBeforeitemclick) then
    JSCode(JSName+'.events ["beforeitemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemclick', Ajax('beforeitemclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemclick := Value;
end;

procedure TExtView.SetFOnBeforeitemdblclick(Value : TExtViewOnBeforeitemdblclick); begin
  if Assigned(FOnBeforeitemdblclick) then
    JSCode(JSName+'.events ["beforeitemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemdblclick', Ajax('beforeitemdblclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemdblclick := Value;
end;

procedure TExtView.SetFOnBeforeitemcontextmenu(Value : TExtViewOnBeforeitemcontextmenu); begin
  if Assigned(FOnBeforeitemcontextmenu) then
    JSCode(JSName+'.events ["beforeitemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcontextmenu', Ajax('beforeitemcontextmenu', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemcontextmenu := Value;
end;

procedure TExtView.SetFOnBeforeitemkeydown(Value : TExtViewOnBeforeitemkeydown); begin
  if Assigned(FOnBeforeitemkeydown) then
    JSCode(JSName+'.events ["beforeitemkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemkeydown', Ajax('beforeitemkeydown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemkeydown := Value;
end;

procedure TExtView.SetFOnItemmousedown(Value : TExtViewOnItemmousedown); begin
  if Assigned(FOnItemmousedown) then
    JSCode(JSName+'.events ["itemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmousedown', Ajax('itemmousedown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmousedown := Value;
end;

procedure TExtView.SetFOnItemmouseup(Value : TExtViewOnItemmouseup); begin
  if Assigned(FOnItemmouseup) then
    JSCode(JSName+'.events ["itemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseup', Ajax('itemmouseup', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseup := Value;
end;

procedure TExtView.SetFOnItemmouseenter(Value : TExtViewOnItemmouseenter); begin
  if Assigned(FOnItemmouseenter) then
    JSCode(JSName+'.events ["itemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseenter', Ajax('itemmouseenter', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseenter := Value;
end;

procedure TExtView.SetFOnItemmouseleave(Value : TExtViewOnItemmouseleave); begin
  if Assigned(FOnItemmouseleave) then
    JSCode(JSName+'.events ["itemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseleave', Ajax('itemmouseleave', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseleave := Value;
end;

procedure TExtView.SetFOnItemclick(Value : TExtViewOnItemclick); begin
  if Assigned(FOnItemclick) then
    JSCode(JSName+'.events ["itemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemclick', Ajax('itemclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemclick := Value;
end;

procedure TExtView.SetFOnItemdblclick(Value : TExtViewOnItemdblclick); begin
  if Assigned(FOnItemdblclick) then
    JSCode(JSName+'.events ["itemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemdblclick', Ajax('itemdblclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemdblclick := Value;
end;

procedure TExtView.SetFOnItemcontextmenu(Value : TExtViewOnItemcontextmenu); begin
  if Assigned(FOnItemcontextmenu) then
    JSCode(JSName+'.events ["itemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcontextmenu', Ajax('itemcontextmenu', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemcontextmenu := Value;
end;

procedure TExtView.SetFOnItemkeydown(Value : TExtViewOnItemkeydown); begin
  if Assigned(FOnItemkeydown) then
    JSCode(JSName+'.events ["itemkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemkeydown', Ajax('itemkeydown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemkeydown := Value;
end;

procedure TExtView.SetFOnBeforecontainermousedown(Value : TExtViewOnBeforecontainermousedown); begin
  if Assigned(FOnBeforecontainermousedown) then
    JSCode(JSName+'.events ["beforecontainermousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermousedown', Ajax('beforecontainermousedown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermousedown := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseup(Value : TExtViewOnBeforecontainermouseup); begin
  if Assigned(FOnBeforecontainermouseup) then
    JSCode(JSName+'.events ["beforecontainermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseup', Ajax('beforecontainermouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseup := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseover(Value : TExtViewOnBeforecontainermouseover); begin
  if Assigned(FOnBeforecontainermouseover) then
    JSCode(JSName+'.events ["beforecontainermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseover', Ajax('beforecontainermouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseover := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseout(Value : TExtViewOnBeforecontainermouseout); begin
  if Assigned(FOnBeforecontainermouseout) then
    JSCode(JSName+'.events ["beforecontainermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseout', Ajax('beforecontainermouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseout := Value;
end;

procedure TExtView.SetFOnBeforecontainerclick(Value : TExtViewOnBeforecontainerclick); begin
  if Assigned(FOnBeforecontainerclick) then
    JSCode(JSName+'.events ["beforecontainerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerclick', Ajax('beforecontainerclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerclick := Value;
end;

procedure TExtView.SetFOnBeforecontainerdblclick(Value : TExtViewOnBeforecontainerdblclick); begin
  if Assigned(FOnBeforecontainerdblclick) then
    JSCode(JSName+'.events ["beforecontainerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerdblclick', Ajax('beforecontainerdblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerdblclick := Value;
end;

procedure TExtView.SetFOnBeforecontainercontextmenu(Value : TExtViewOnBeforecontainercontextmenu); begin
  if Assigned(FOnBeforecontainercontextmenu) then
    JSCode(JSName+'.events ["beforecontainercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainercontextmenu', Ajax('beforecontainercontextmenu', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainercontextmenu := Value;
end;

procedure TExtView.SetFOnBeforecontainerkeydown(Value : TExtViewOnBeforecontainerkeydown); begin
  if Assigned(FOnBeforecontainerkeydown) then
    JSCode(JSName+'.events ["beforecontainerkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerkeydown', Ajax('beforecontainerkeydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerkeydown := Value;
end;

procedure TExtView.SetFOnContainermouseup(Value : TExtViewOnContainermouseup); begin
  if Assigned(FOnContainermouseup) then
    JSCode(JSName+'.events ["containermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseup', Ajax('containermouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseup := Value;
end;

procedure TExtView.SetFOnContainermouseover(Value : TExtViewOnContainermouseover); begin
  if Assigned(FOnContainermouseover) then
    JSCode(JSName+'.events ["containermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseover', Ajax('containermouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseover := Value;
end;

procedure TExtView.SetFOnContainermouseout(Value : TExtViewOnContainermouseout); begin
  if Assigned(FOnContainermouseout) then
    JSCode(JSName+'.events ["containermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseout', Ajax('containermouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseout := Value;
end;

procedure TExtView.SetFOnContainerclick(Value : TExtViewOnContainerclick); begin
  if Assigned(FOnContainerclick) then
    JSCode(JSName+'.events ["containerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerclick', Ajax('containerclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerclick := Value;
end;

procedure TExtView.SetFOnContainerdblclick(Value : TExtViewOnContainerdblclick); begin
  if Assigned(FOnContainerdblclick) then
    JSCode(JSName+'.events ["containerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerdblclick', Ajax('containerdblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerdblclick := Value;
end;

procedure TExtView.SetFOnContainercontextmenu(Value : TExtViewOnContainercontextmenu); begin
  if Assigned(FOnContainercontextmenu) then
    JSCode(JSName+'.events ["containercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('containercontextmenu', Ajax('containercontextmenu', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainercontextmenu := Value;
end;

procedure TExtView.SetFOnContainerkeydown(Value : TExtViewOnContainerkeydown); begin
  if Assigned(FOnContainerkeydown) then
    JSCode(JSName+'.events ["containerkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerkeydown', Ajax('containerkeydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerkeydown := Value;
end;

procedure TExtView.SetFOnHighlightitem(Value : TExtViewOnHighlightitem); begin
  if Assigned(FOnHighlightitem) then
    JSCode(JSName+'.events ["highlightitem"].listeners=[];');
  if Assigned(Value) then
    AddListener('highlightitem', Ajax('highlightitem', ['View', '%0.nm','Node', '%1.nm'], true));
  FOnHighlightitem := Value;
end;

procedure TExtView.SetFOnUnhighlightitem(Value : TExtViewOnUnhighlightitem); begin
  if Assigned(FOnUnhighlightitem) then
    JSCode(JSName+'.events ["unhighlightitem"].listeners=[];');
  if Assigned(Value) then
    AddListener('unhighlightitem', Ajax('unhighlightitem', ['View', '%0.nm','Node', '%1.nm'], true));
  FOnUnhighlightitem := Value;
end;

function TExtView.JSClassName : string; begin
  Result := 'Ext.view.View';
end;

{$IFDEF FPC}constructor TExtView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtView.HighlightItem(Item : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Item, false]) + ');', 'TExtView');
  Result := Self;
end;

function TExtView.ClearHighlight : TExtFunction; begin
  JSCode(JSName + '.clearHighlight();', 'TExtView');
  Result := Self;
end;

procedure TExtView.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeitemmousedown') and Assigned(FOnBeforeitemmousedown) then
    FOnBeforeitemmousedown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseup') and Assigned(FOnBeforeitemmouseup) then
    FOnBeforeitemmouseup(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseenter') and Assigned(FOnBeforeitemmouseenter) then
    FOnBeforeitemmouseenter(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseleave') and Assigned(FOnBeforeitemmouseleave) then
    FOnBeforeitemmouseleave(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemclick') and Assigned(FOnBeforeitemclick) then
    FOnBeforeitemclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemdblclick') and Assigned(FOnBeforeitemdblclick) then
    FOnBeforeitemdblclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemcontextmenu') and Assigned(FOnBeforeitemcontextmenu) then
    FOnBeforeitemcontextmenu(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemkeydown') and Assigned(FOnBeforeitemkeydown) then
    FOnBeforeitemkeydown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmousedown') and Assigned(FOnItemmousedown) then
    FOnItemmousedown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseup') and Assigned(FOnItemmouseup) then
    FOnItemmouseup(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseenter') and Assigned(FOnItemmouseenter) then
    FOnItemmouseenter(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseleave') and Assigned(FOnItemmouseleave) then
    FOnItemmouseleave(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemclick') and Assigned(FOnItemclick) then
    FOnItemclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemdblclick') and Assigned(FOnItemdblclick) then
    FOnItemdblclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemcontextmenu') and Assigned(FOnItemcontextmenu) then
    FOnItemcontextmenu(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemkeydown') and Assigned(FOnItemkeydown) then
    FOnItemkeydown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermousedown') and Assigned(FOnBeforecontainermousedown) then
    FOnBeforecontainermousedown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseup') and Assigned(FOnBeforecontainermouseup) then
    FOnBeforecontainermouseup(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseover') and Assigned(FOnBeforecontainermouseover) then
    FOnBeforecontainermouseover(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseout') and Assigned(FOnBeforecontainermouseout) then
    FOnBeforecontainermouseout(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainerclick') and Assigned(FOnBeforecontainerclick) then
    FOnBeforecontainerclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainerdblclick') and Assigned(FOnBeforecontainerdblclick) then
    FOnBeforecontainerdblclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainercontextmenu') and Assigned(FOnBeforecontainercontextmenu) then
    FOnBeforecontainercontextmenu(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainerkeydown') and Assigned(FOnBeforecontainerkeydown) then
    FOnBeforecontainerkeydown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseup') and Assigned(FOnContainermouseup) then
    FOnContainermouseup(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseover') and Assigned(FOnContainermouseover) then
    FOnContainermouseover(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseout') and Assigned(FOnContainermouseout) then
    FOnContainermouseout(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containerclick') and Assigned(FOnContainerclick) then
    FOnContainerclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containerdblclick') and Assigned(FOnContainerdblclick) then
    FOnContainerdblclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containercontextmenu') and Assigned(FOnContainercontextmenu) then
    FOnContainercontextmenu(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containerkeydown') and Assigned(FOnContainerkeydown) then
    FOnContainerkeydown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'highlightitem') and Assigned(FOnHighlightitem) then
    FOnHighlightitem(TExtView(ParamAsObject('View')), TExtElement(ParamAsObject('Node')))
  else if (AEvtName = 'unhighlightitem') and Assigned(FOnUnhighlightitem) then
    FOnUnhighlightitem(TExtView(ParamAsObject('View')), TExtElement(ParamAsObject('Node')));
end;

function TExtUtilTextMetrics.JSClassName : string; begin
  Result := 'Ext.util.TextMetrics';
end;

{$IFDEF FPC}constructor TExtUtilTextMetrics.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilTextMetrics.Measure(El : String; Text : String; FixedWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.measure(' + VarToJSON([El, Text, FixedWidth]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Measure(El : THTMLElement; Text : String; FixedWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Measure(' + VarToJSON([El, false, Text, FixedWidth]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

constructor TExtUtilTextMetrics.Create(BindTo : String; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, FixedWidth]) + ');');
  InitDefaults;
end;

constructor TExtUtilTextMetrics.Create(BindTo : THTMLElement; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, false, FixedWidth]) + ');');
  InitDefaults;
end;

constructor TExtUtilTextMetrics.Create(BindTo : TExtElement; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, false, FixedWidth]) + ');');
  InitDefaults;
end;

function TExtUtilTextMetrics.GetSize(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getSize(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Bind(El : String) : TExtFunction; begin
  JSCode(JSName + '.bind(' + VarToJSON([El]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Bind(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Bind(' + VarToJSON([El, false]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Bind(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Bind(' + VarToJSON([El, false]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.SetFixedWidth(Width : Integer) : TExtFunction; begin
  JSCode(JSName + '.setFixedWidth(' + VarToJSON([Width]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetWidth(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getWidth(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetHeight(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getHeight(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetTextWidth(Text : String; Min : Integer = 0; Max : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.getTextWidth(' + VarToJSON([Text, Min, Max]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilMemento.JSClassName : string; begin
  Result := 'Ext.util.Memento';
end;

{$IFDEF FPC}constructor TExtUtilMemento.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtUtilKeyNav.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  if not ConfigAvailable(JSName) then
    SetDisabled(Value)
  else
    JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFDefaultEventAction(Value : String); begin
  FDefaultEventAction := Value;
  JSCode('defaultEventAction:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFForceKeyDown(Value : Boolean); begin
  FForceKeyDown := Value;
  JSCode('forceKeyDown:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTargetTExtElement(Value : TExtElement); begin
  FTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFEventName(Value : String); begin
  FEventName := Value;
  JSCode('eventName:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFProcessEvent(Value : TExtFunction); begin
  FProcessEvent := Value;
  JSCode('processEvent:' + VarToJSON([Value, true]));
end;

procedure TExtUtilKeyNav.SetFProcessEventScope(Value : TExtObject); begin
  FProcessEventScope := Value;
  Value.DeleteFromGarbage;
  JSCode('processEventScope:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFIgnoreInputFields(Value : Boolean); begin
  FIgnoreInputFields := Value;
  JSCode('ignoreInputFields:' + VarToJSON([Value]));
end;

function TExtUtilKeyNav.JSClassName : string; begin
  Result := 'Ext.util.KeyNav';
end;

procedure TExtUtilKeyNav.InitDefaults; begin
  inherited;
  FTarget := TExtComponent.CreateInternal(Self, 'target');
  FTargetTExtElement := TExtElement.CreateInternal(Self, 'target');
  FProcessEventScope := TExtObject.CreateInternal(Self, 'processEventScope');
end;

{$IFDEF FPC}constructor TExtUtilKeyNav.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilKeyNav.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilKeyNav.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilKeyNav');
  Result := Self;
end;

function TExtUtilKeyNav.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilKeyNav');
  Result := Self;
end;

function TExtUtilKeyNav.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilKeyNav');
  Result := Self;
end;

destructor TExtUtilKeyNav.Destroy; begin
  try
    FTarget.Free;
    FTargetTExtElement.Free;
    FProcessEventScope.Free;
  except end;
  inherited;
end;

function TExtUtilMixedCollection.JSClassName : string; begin
  Result := 'Ext.util.MixedCollection';
end;

{$IFDEF FPC}constructor TExtUtilMixedCollection.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilMixedCollection.Create(AllowFunctions : Boolean; KeyFn : TExtFunction); begin
  CreateVar(JSClassName + '(' + VarToJSON([AllowFunctions, KeyFn, true]) + ');');
  InitDefaults;
end;

function TExtUtilMixedCollection.SortBy(SorterFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.sortBy(' + VarToJSON([SorterFn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FindInsertionIndex(NewItem : TExtObject; SorterFn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.findInsertionIndex(' + VarToJSON([NewItem, false, SorterFn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Reorder(Mapping : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.reorder(' + VarToJSON([Mapping, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.SortByKey(Direction : String = ''; Fn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.sortByKey(' + VarToJSON([Direction, Fn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilRegion.JSClassName : string; begin
  Result := 'Ext.util.Region';
end;

{$IFDEF FPC}constructor TExtUtilRegion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilRegion.GetRegion(El : String) : TExtFunction; begin
  JSCode(JSName + '.getRegion(' + VarToJSON([El]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetRegion(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetRegion(' + VarToJSON([El, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetRegion(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.GetRegion(' + VarToJSON([El, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.From(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.from(' + VarToJSON([O, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

constructor TExtUtilRegion.Create(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([Top, Right, Bottom, Left]) + ');');
  InitDefaults;
end;

function TExtUtilRegion.Contains(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Intersect(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.intersect(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Union(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.union(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.ConstrainTo(TargetRegion : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.constrainTo(' + VarToJSON([TargetRegion, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Adjust(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer) : TExtFunction; begin
  JSCode(JSName + '.adjust(' + VarToJSON([Top, Right, Bottom, Left]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffset(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffset(' + VarToJSON([Axis, P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffsetX(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffsetX(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffsetY(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffsetY(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBound(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBound(' + VarToJSON([Axis, P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBound(Axis : String; P : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsOutOfBound(' + VarToJSON([Axis, P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBoundX(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBoundX(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBoundY(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBoundY(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Copy : TExtFunction; begin
  JSCode(JSName + '.copy();', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.CopyFrom(P : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.copyFrom(' + VarToJSON([P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.TranslateBy(X : TExtUtilOffset; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.translateBy(' + VarToJSON([X, false, Y]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.TranslateBy(X : TExtObject; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.TranslateBy(' + VarToJSON([X, false, Y]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Round : TExtFunction; begin
  JSCode(JSName + '.round();', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Equals(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.equals(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilProtoElement.JSClassName : string; begin
  Result := 'Ext.util.ProtoElement';
end;

{$IFDEF FPC}constructor TExtUtilProtoElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayout.SetFIsLayout(Value : Boolean); begin
  FIsLayout := Value;
  JSCode(JSName + '.isLayout=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFDone(Value : Boolean); begin
  FDone := Value;
  JSCode(JSName + '.done=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFName(Value : String); begin
  FName := Value;
  JSCode(JSName + '.name=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFAuto(Value : Boolean); begin
  FAuto := Value;
  JSCode(JSName + '.auto=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFCalculated(Value : Boolean); begin
  FCalculated := Value;
  JSCode(JSName + '.calculated=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFConfigured(Value : Boolean); begin
  FConfigured := Value;
  JSCode(JSName + '.configured=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFConstrainedMax(Value : Boolean); begin
  FConstrainedMax := Value;
  JSCode(JSName + '.constrainedMax=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFConstrainedMin(Value : Boolean); begin
  FConstrainedMin := Value;
  JSCode(JSName + '.constrainedMin=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode(JSName + '.fixed=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFNatural(Value : Boolean); begin
  FNatural := Value;
  JSCode(JSName + '.natural=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFShrinkWrap(Value : Boolean); begin
  FShrinkWrap := Value;
  JSCode(JSName + '.shrinkWrap=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFCalculatedFromConfigured(Value : Boolean); begin
  FCalculatedFromConfigured := Value;
  JSCode(JSName + '.calculatedFromConfigured=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFCalculatedFromNatural(Value : Boolean); begin
  FCalculatedFromNatural := Value;
  JSCode(JSName + '.calculatedFromNatural=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFCalculatedFromShrinkWrap(Value : Boolean); begin
  FCalculatedFromShrinkWrap := Value;
  JSCode(JSName + '.calculatedFromShrinkWrap=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFNames(Value : TExtObject); begin
  FNames := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.names=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayout.SetFPairsByHeightOrdinal(Value : TExtObjectList); begin
  FPairsByHeightOrdinal := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.pairsByHeightOrdinal=' + VarToJSON([Value, false]) + ';');
end;

function TExtLayout.JSClassName : string; begin
  Result := 'Ext.layout.Layout';
end;

procedure TExtLayout.InitDefaults; begin
  inherited;
  FNames := TExtObject.CreateInternal(Self, 'names');
  FPairsByHeightOrdinal := TExtObjectList.Create(Self, 'pairsByHeightOrdinal');
end;

{$IFDEF FPC}constructor TExtLayout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayout.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayout.Destroy; begin
  try
    FNames.Free;
    FPairsByHeightOrdinal.Free;
  except end;
  inherited;
end;

procedure TExtLayer.SetFShim(Value : Boolean); begin
  FShim := Value;
  JSCode('shim:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFDh(Value : TExtObject); begin
  FDh := Value;
  Value.DeleteFromGarbage;
  JSCode('dh:' + VarToJSON([Value, false]));
end;

procedure TExtLayer.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFZindex(Value : Integer); begin
  FZindex := Value;
  if not ConfigAvailable(JSName) then
    SetZIndex(Value)
  else
    JSCode('zindex:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFShadowOffset(Value : Integer); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFUseDisplay(Value : Boolean); begin
  FUseDisplay := Value;
  JSCode('useDisplay:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFVisibilityCls(Value : String); begin
  FVisibilityCls := Value;
  JSCode('visibilityCls:' + VarToJSON([Value]));
end;

procedure TExtLayer.SetFHideMode(Value : String); begin
  FHideMode := Value;
  JSCode('hideMode:' + VarToJSON([Value]));
end;

function TExtLayer.JSClassName : string; begin
  Result := 'Ext.Layer';
end;

procedure TExtLayer.InitDefaults; begin
  inherited;
  FDh := TExtObject.CreateInternal(Self, 'dh');
end;

{$IFDEF FPC}constructor TExtLayer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtLayer.Create(Config : TExtObject = nil; ExistingEl : String = ''); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false, ExistingEl]) + ');');
  InitDefaults;
end;

constructor TExtLayer.Create(Config : TExtObject; ExistingEl : THTMLElement); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false, ExistingEl, false]) + ');');
  InitDefaults;
end;

function TExtLayer.SetZIndex(Zindex : Integer) : TExtFunction; begin
  JSCode(JSName + '.setZIndex(' + VarToJSON([Zindex]) + ');', 'TExtLayer');
  Result := Self;
end;

destructor TExtLayer.Destroy; begin
  try
    FDh.Free;
  except end;
  inherited;
end;

function TExtLayoutClassList.JSClassName : string; begin
  Result := 'Ext.layout.ClassList';
end;

{$IFDEF FPC}constructor TExtLayoutClassList.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtMenuManagerSingleton.JSClassName : string; begin
  Result := 'Ext.menu.Manager';
end;

{$IFDEF FPC}constructor TExtMenuManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtMenuManagerSingleton.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtMenuManagerSingleton.Get(Menu : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Menu]) + ');', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtMenuManagerSingleton.Get(Menu : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Menu, false]) + ');', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtViewTableChunker.JSClassName : string; begin
  Result := 'Ext.view.TableChunker';
end;

{$IFDEF FPC}constructor TExtViewTableChunker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridFeatureGrouping.SetFGroupHeaderTpl(Value : String); begin
  FGroupHeaderTpl := Value;
  JSCode('groupHeaderTpl:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplTExtObjectList(Value : TExtObjectList); begin
  FGroupHeaderTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplTExtTemplate(Value : TExtTemplate); begin
  FGroupHeaderTplTExtTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFDepthToIndent(Value : Integer); begin
  FDepthToIndent := Value;
  JSCode('depthToIndent:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFGroupByText(Value : String); begin
  FGroupByText := Value;
  JSCode('groupByText:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFShowGroupsText(Value : String); begin
  FShowGroupsText := Value;
  JSCode('showGroupsText:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFHideGroupedHeader(Value : Boolean); begin
  FHideGroupedHeader := Value;
  JSCode('hideGroupedHeader:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFStartCollapsed(Value : Boolean); begin
  FStartCollapsed := Value;
  JSCode('startCollapsed:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFEnableGroupingMenu(Value : Boolean); begin
  FEnableGroupingMenu := Value;
  JSCode('enableGroupingMenu:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFEnableNoGroups(Value : Boolean); begin
  FEnableNoGroups := Value;
  JSCode('enableNoGroups:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

function TExtGridFeatureGrouping.JSClassName : string; begin
  Result := 'Ext.grid.feature.Grouping';
end;

procedure TExtGridFeatureGrouping.InitDefaults; begin
  inherited;
  FGroupHeaderTplTExtObjectList := TExtObjectList.Create(Self, 'groupHeaderTpl');
  FGroupHeaderTplTExtTemplate := TExtTemplate.CreateInternal(Self, 'groupHeaderTpl');
end;

{$IFDEF FPC}constructor TExtGridFeatureGrouping.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridFeatureGrouping.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridFeatureGrouping.IsExpanded(GroupName : String) : TExtFunction; begin
  JSCode(JSName + '.isExpanded(' + VarToJSON([GroupName]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.Expand(GroupName : String; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([GroupName, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.Expand(GroupName : TExtElement; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Expand(' + VarToJSON([GroupName, false, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.ExpandAll : TExtFunction; begin
  JSCode(JSName + '.expandAll();', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.Collapse(GroupName : String; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([GroupName, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.Collapse(GroupName : TExtElement; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Collapse(' + VarToJSON([GroupName, false, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.CollapseAll : TExtFunction; begin
  JSCode(JSName + '.collapseAll();', 'TExtGridFeatureGrouping');
  Result := Self;
end;

destructor TExtGridFeatureGrouping.Destroy; begin
  try
    FGroupHeaderTplTExtObjectList.Free;
    FGroupHeaderTplTExtTemplate.Free;
  except end;
  inherited;
end;

function TExtGridFeatureChunking.JSClassName : string; begin
  Result := 'Ext.grid.feature.Chunking';
end;

{$IFDEF FPC}constructor TExtGridFeatureChunking.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureRowBody.JSClassName : string; begin
  Result := 'Ext.grid.feature.RowBody';
end;

{$IFDEF FPC}constructor TExtGridFeatureRowBody.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureRowBody.GetAdditionalData(Data : TExtObject; Idx : Integer; RecordJS : TExtDataModel; Orig : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getAdditionalData(' + VarToJSON([Data, false, Idx, RecordJS, false, Orig, false]) + ');', 'TExtGridFeatureRowBody');
  Result := Self;
end;

function TExtGridScroller.JSClassName : string; begin
  Result := 'Ext.grid.Scroller';
end;

{$IFDEF FPC}constructor TExtGridScroller.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPagingScroller.SetFPosition(Value : Integer); begin
  FPosition := Value;
  JSCode(JSName + '.position=' + VarToJSON([Value]) + ';');
end;

function TExtGridPagingScroller.JSClassName : string; begin
  Result := 'Ext.grid.PagingScroller';
end;

{$IFDEF FPC}constructor TExtGridPagingScroller.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtStateStateful.SetFStateful(Value : Boolean); begin
  FStateful := Value;
  JSCode('stateful:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFStateId(Value : String); begin
  FStateId := Value;
  JSCode('stateId:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFStateEvents(Value : TExtObjectList); begin
  FStateEvents := Value;
  Value.DeleteFromGarbage;
  JSCode('stateEvents:' + VarToJSON([Value, false]));
end;

procedure TExtStateStateful.SetFSaveDelay(Value : Integer); begin
  FSaveDelay := Value;
  JSCode('saveDelay:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFOnBeforestaterestore(Value : TExtStateStatefulOnBeforestaterestore); begin
  if Assigned(FOnBeforestaterestore) then
    JSCode(JSName+'.events ["beforestaterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestaterestore', Ajax('beforestaterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestaterestore := Value;
end;

procedure TExtStateStateful.SetFOnStaterestore(Value : TExtStateStatefulOnStaterestore); begin
  if Assigned(FOnStaterestore) then
    JSCode(JSName+'.events ["staterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('staterestore', Ajax('staterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStaterestore := Value;
end;

procedure TExtStateStateful.SetFOnBeforestatesave(Value : TExtStateStatefulOnBeforestatesave); begin
  if Assigned(FOnBeforestatesave) then
    JSCode(JSName+'.events ["beforestatesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestatesave', Ajax('beforestatesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestatesave := Value;
end;

procedure TExtStateStateful.SetFOnStatesave(Value : TExtStateStatefulOnStatesave); begin
  if Assigned(FOnStatesave) then
    JSCode(JSName+'.events ["statesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('statesave', Ajax('statesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStatesave := Value;
end;

function TExtStateStateful.JSClassName : string; begin
  Result := 'Ext.state.Stateful';
end;

procedure TExtStateStateful.InitDefaults; begin
  inherited;
  FStateEvents := TExtObjectList.Create(Self, 'stateEvents');
end;

{$IFDEF FPC}constructor TExtStateStateful.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtStateStateful.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtStateStateful.SaveState : TExtFunction; begin
  JSCode(JSName + '.saveState();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.GetState : TExtFunction; begin
  JSCode(JSName + '.getState();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ApplyState(State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyState(' + VarToJSON([State, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

destructor TExtStateStateful.Destroy; begin
  try
    FStateEvents.Free;
  except end;
  inherited;
end;

procedure TExtStateStateful.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforestaterestore') and Assigned(FOnBeforestaterestore) then
    FOnBeforestaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'staterestore') and Assigned(FOnStaterestore) then
    FOnStaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'beforestatesave') and Assigned(FOnBeforestatesave) then
    FOnBeforestatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'statesave') and Assigned(FOnStatesave) then
    FOnStatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')));
end;

procedure TExtStateProvider.SetFPrefix(Value : String); begin
  FPrefix := Value;
  JSCode('prefix:' + VarToJSON([Value]));
end;

function TExtStateProvider.JSClassName : string; begin
  Result := 'Ext.state.Provider';
end;

procedure TExtStateProvider.InitDefaults; begin
  inherited;
  FPrefix := 'ext-';
end;

{$IFDEF FPC}constructor TExtStateProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtStateProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtStateProvider.Get(Name : String; DefaultValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name, DefaultValue, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.Clear(Name : String) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.SetJS(Name : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.DecodeValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.decodeValue(' + VarToJSON([Value]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.EncodeValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.encodeValue(' + VarToJSON([Value, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

procedure TExtTemplate.SetFCompiled(Value : Boolean); begin
  FCompiled := Value;
  JSCode('compiled:' + VarToJSON([Value]));
end;

procedure TExtTemplate.SetFDisableFormats(Value : Boolean); begin
  FDisableFormats := Value;
  JSCode('disableFormats:' + VarToJSON([Value]));
end;

function TExtTemplate.JSClassName : string; begin
  Result := 'Ext.Template';
end;

{$IFDEF FPC}constructor TExtTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTemplate.Apply(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.apply(' + VarToJSON([Values, false]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Apply(Values : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Apply(' + VarToJSON(Values) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.ApplyOut(Values : TExtObject; OutJS : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.applyOut(' + VarToJSON([Values, false]) + ',' + VarToJSON(OutJS) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.ApplyOut(Values : TExtObjectList; OutJS : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.ApplyOut(' + VarToJSON(Values) + ',' + VarToJSON(OutJS) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Compile : TExtFunction; begin
  JSCode(JSName + '.compile();', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertFirst(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertAfter(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.append(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.overwrite(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtUtilAnimate.JSClassName : string; begin
  Result := 'Ext.util.Animate';
end;

{$IFDEF FPC}constructor TExtUtilAnimate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilAnimate.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.SyncFx : TExtFunction; begin
  JSCode(JSName + '.syncFx();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.SequenceFx : TExtFunction; begin
  JSCode(JSName + '.sequenceFx();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.JSClassName : string; begin
  Result := 'Ext.tip.QuickTipManager';
end;

{$IFDEF FPC}constructor TExtTipQuickTipManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTipQuickTipManagerSingleton.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.IsEnabled : TExtFunction; begin
  JSCode(JSName + '.isEnabled();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.GetQuickTip : TExtFunction; begin
  JSCode(JSName + '.getQuickTip();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Register(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Config, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([El]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Tips : TExtFunction; begin
  JSCode(JSName + '.tips();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

procedure TExtResizer.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFHandles(Value : String); begin
  FHandles := Value;
  JSCode('handles:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFHeightIncrement(Value : Integer); begin
  FHeightIncrement := Value;
  JSCode('heightIncrement:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFWidthIncrement(Value : Integer); begin
  FWidthIncrement := Value;
  JSCode('widthIncrement:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMinHeight(Value : Integer); begin
  FMinHeight := Value;
  JSCode('minHeight:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMaxHeight(Value : Integer); begin
  FMaxHeight := Value;
  JSCode('maxHeight:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFPinned(Value : Boolean); begin
  FPinned := Value;
  JSCode('pinned:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFPreserveRatio(Value : Boolean); begin
  FPreserveRatio := Value;
  JSCode('preserveRatio:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFTransparent(Value : Boolean); begin
  FTransparent := Value;
  JSCode('transparent:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFConstrainTo(Value : TExtElement); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFConstrainToTExtUtilRegion(Value : TExtUtilRegion); begin
  FConstrainToTExtUtilRegion := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFTarget(Value : TExtElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFTargetTExtComponent(Value : TExtComponent); begin
  FTargetTExtComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFEl(Value : TExtElement); begin
  FEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.el=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFOriginalTarget(Value : TExtElement); begin
  FOriginalTarget := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalTarget=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFOriginalTargetTExtComponent(Value : TExtComponent); begin
  FOriginalTargetTExtComponent := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalTarget=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFResizeTracker(Value : TExtResizerResizeTracker); begin
  FResizeTracker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.resizeTracker=' + VarToJSON([Value, false]) + ';');
end;

function TExtResizer.JSClassName : string; begin
  Result := 'Ext.resizer.Resizer';
end;

procedure TExtResizer.InitDefaults; begin
  inherited;
  FHandles := 's e se';
  FConstrainTo := TExtElement.CreateInternal(Self, 'constrainTo');
  FConstrainToTExtUtilRegion := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FTarget := TExtElement.CreateInternal(Self, 'target');
  FTargetTExtComponent := TExtComponent.CreateInternal(Self, 'target');
  FEl := TExtElement.CreateInternal(Self, 'el');
  FOriginalTarget := TExtElement.CreateInternal(Self, 'originalTarget');
  FOriginalTargetTExtComponent := TExtComponent.CreateInternal(Self, 'originalTarget');
  FResizeTracker := TExtResizerResizeTracker.CreateInternal(Self, 'resizeTracker');
end;

{$IFDEF FPC}constructor TExtResizer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtResizer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtResizer.ResizeTo(Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.resizeTo(' + VarToJSON([Width, Height]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtResizer');
  Result := Self;
end;

destructor TExtResizer.Destroy; begin
  try
    FConstrainTo.Free;
    FConstrainToTExtUtilRegion.Free;
    FTarget.Free;
    FTargetTExtComponent.Free;
    FEl.Free;
    FOriginalTarget.Free;
    FOriginalTargetTExtComponent.Free;
    FResizeTracker.Free;
  except end;
  inherited;
end;

procedure TExtPanel.SetFCollapsedCls(Value : String); begin
  FCollapsedCls := Value;
  JSCode('collapsedCls:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFAnimCollapse(Value : Boolean); begin
  FAnimCollapse := Value;
  JSCode('animCollapse:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFMinButtonWidth(Value : Integer); begin
  FMinButtonWidth := Value;
  JSCode('minButtonWidth:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseFirst(Value : Boolean); begin
  FCollapseFirst := Value;
  JSCode('collapseFirst:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHideCollapseTool(Value : Boolean); begin
  FHideCollapseTool := Value;
  JSCode('hideCollapseTool:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTitleCollapse(Value : Boolean); begin
  FTitleCollapse := Value;
  JSCode('titleCollapse:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseMode(Value : String); begin
  FCollapseMode := Value;
  JSCode('collapseMode:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFPlaceholder(Value : TExtComponent); begin
  FPlaceholder := Value;
  Value.DeleteFromGarbage;
  JSCode('placeholder:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFPlaceholderTExtObject(Value : TExtObject); begin
  FPlaceholderTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('placeholder:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFFloatable(Value : Boolean); begin
  FFloatable := Value;
  JSCode('floatable:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFOverlapHeader(Value : Boolean); begin
  FOverlapHeader := Value;
  JSCode('overlapHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseDirection(Value : String); begin
  FCollapseDirection := Value;
  JSCode('collapseDirection:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCloseAction(Value : String); begin
  FCloseAction := Value;
  JSCode('closeAction:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFDockedItems(Value : TExtObject); begin
  FDockedItems := Value;
  Value.DeleteFromGarbage;
  JSCode('dockedItems:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFDockedItemsTExtObjectList(Value : TExtObjectList); begin
  FDockedItemsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('dockedItems:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFPlaceholderCollapseHideMode(Value : Integer); begin
  FPlaceholderCollapseHideMode := Value;
  JSCode('placeholderCollapseHideMode:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFPreventHeader(Value : Boolean); begin
  FPreventHeader := Value;
  JSCode('preventHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHeader(Value : Boolean); begin
  FHeader := Value;
  JSCode('header:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHeaderTExtObject(Value : TExtObject); begin
  FHeaderTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('header:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFHeaderPosition(Value : String); begin
  FHeaderPosition := Value;
  JSCode('headerPosition:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFFrame(Value : Boolean); begin
  FFrame := Value;
  JSCode('frame:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFFrameHeader(Value : Boolean); begin
  FFrameHeader := Value;
  JSCode('frameHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTools(Value : TExtObjectList); begin
  FTools := Value;
  Value.DeleteFromGarbage;
  JSCode('tools:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFToolsTExtObjectList(Value : TExtObjectList); begin
  FToolsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('tools:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTitleAlign(Value : String); begin
  FTitleAlign := Value;
  JSCode('titleAlign:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFManageHeight(Value : Boolean); begin
  FManageHeight := Value;
  JSCode('manageHeight:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFButtonAlign(Value : String); begin
  FButtonAlign := Value;
  JSCode('buttonAlign:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTbar(Value : TExtObject); begin
  FTbar := Value;
  Value.DeleteFromGarbage;
  JSCode('tbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFTbarTExtObjectList(Value : TExtObjectList); begin
  FTbarTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('tbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFBbar(Value : TExtObject); begin
  FBbar := Value;
  Value.DeleteFromGarbage;
  JSCode('bbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFBbarTExtObjectList(Value : TExtObjectList); begin
  FBbarTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('bbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFButtons(Value : TExtObject); begin
  FButtons := Value;
  Value.DeleteFromGarbage;
  JSCode('buttons:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFButtonsTExtObjectList(Value : TExtObjectList); begin
  FButtonsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('buttons:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFFbar(Value : TExtObject); begin
  FFbar := Value;
  Value.DeleteFromGarbage;
  JSCode('fbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFFbarTExtObjectList(Value : TExtObjectList); begin
  FFbarTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('fbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFLbar(Value : TExtObject); begin
  FLbar := Value;
  Value.DeleteFromGarbage;
  JSCode('lbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFLbarTExtObjectList(Value : TExtObjectList); begin
  FLbarTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('lbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFRbar(Value : TExtObject); begin
  FRbar := Value;
  Value.DeleteFromGarbage;
  JSCode('rbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFRbarTExtObjectList(Value : TExtObjectList); begin
  FRbarTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('rbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFDd(Value : TExtDdDragSource); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

function TExtPanel.JSClassName : string; begin
  Result := 'Ext.panel.Panel';
end;

procedure TExtPanel.InitDefaults; begin
  inherited;
  FPlaceholder := TExtComponent.CreateInternal(Self, 'placeholder');
  FPlaceholderTExtObject := TExtObject.CreateInternal(Self, 'placeholder');
  FDockedItems := TExtObject.CreateInternal(Self, 'dockedItems');
  FDockedItemsTExtObjectList := TExtObjectList.Create(Self, 'dockedItems');
  FHeaderTExtObject := TExtObject.CreateInternal(Self, 'header');
  FTools := TExtObjectList.Create(Self, 'tools');
  FToolsTExtObjectList := TExtObjectList.Create(Self, 'tools');
  FTbar := TExtObject.CreateInternal(Self, 'tbar');
  FTbarTExtObjectList := TExtObjectList.Create(Self, 'tbar');
  FBbar := TExtObject.CreateInternal(Self, 'bbar');
  FBbarTExtObjectList := TExtObjectList.Create(Self, 'bbar');
  FButtons := TExtObject.CreateInternal(Self, 'buttons');
  FButtonsTExtObjectList := TExtObjectList.Create(Self, 'buttons');
  FFbar := TExtObject.CreateInternal(Self, 'fbar');
  FFbarTExtObjectList := TExtObjectList.Create(Self, 'fbar');
  FLbar := TExtObject.CreateInternal(Self, 'lbar');
  FLbarTExtObjectList := TExtObjectList.Create(Self, 'lbar');
  FRbar := TExtObject.CreateInternal(Self, 'rbar');
  FRbarTExtObjectList := TExtObjectList.Create(Self, 'rbar');
  FDd := TExtDdDragSource.CreateInternal(Self, 'dd');
end;

{$IFDEF FPC}constructor TExtPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtPanel.Destroy; begin
  try
    FPlaceholder.Free;
    FPlaceholderTExtObject.Free;
    FDockedItems.Free;
    FDockedItemsTExtObjectList.Free;
    FHeaderTExtObject.Free;
    FTools.Free;
    FToolsTExtObjectList.Free;
    FTbar.Free;
    FTbarTExtObjectList.Free;
    FBbar.Free;
    FBbarTExtObjectList.Free;
    FButtons.Free;
    FButtonsTExtObjectList.Free;
    FFbar.Free;
    FFbarTExtObjectList.Free;
    FLbar.Free;
    FLbarTExtObjectList.Free;
    FRbar.Free;
    FRbarTExtObjectList.Free;
    FDd.Free;
  except end;
  inherited;
end;

procedure TExtSelectionModel.SetFMode(Value : String); begin
  FMode := Value;
  JSCode('mode:' + VarToJSON([Value]));
end;

procedure TExtSelectionModel.SetFAllowDeselect(Value : Boolean); begin
  FAllowDeselect := Value;
  JSCode('allowDeselect:' + VarToJSON([Value]));
end;

procedure TExtSelectionModel.SetFPruneRemoved(Value : Boolean); begin
  FPruneRemoved := Value;
  JSCode('pruneRemoved:' + VarToJSON([Value]));
end;

function TExtSelectionModel.JSClassName : string; begin
  Result := 'Ext.selection.Model';
end;

{$IFDEF FPC}constructor TExtSelectionModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionModel.SelectAll(SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.selectAll(' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectAll(SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.deselectAll(' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : TExtDataModel; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectRange(' + VarToJSON([StartRow, false, EndRow, false, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : Integer; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, EndRow, false, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : Integer; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, EndRow, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : TExtDataModel; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, false, EndRow, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Select(Records : TExtObjectList; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON(Records) + ',' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Select(Records : Integer; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Select(' + VarToJSON([Records, KeepExisting, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Deselect(Records : TExtObjectList; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.deselect(' + VarToJSON(Records) + ',' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Deselect(Records : Integer; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Deselect(' + VarToJSON([Records, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetLastFocused(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.setLastFocused(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsFocused(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.isFocused(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetLastSelected : TExtFunction; begin
  JSCode(JSName + '.getLastSelected();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetSelection : TExtFunction; begin
  JSCode(JSName + '.getSelection();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetSelectionMode : TExtFunction; begin
  JSCode(JSName + '.getSelectionMode();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetSelectionMode(SelMode : String) : TExtFunction; begin
  JSCode(JSName + '.setSelectionMode(' + VarToJSON([SelMode]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsLocked : TExtFunction; begin
  JSCode(JSName + '.isLocked();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetLocked(Locked : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setLocked(' + VarToJSON([Locked]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsSelected(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.isSelected(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsSelected(RecordJS : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsSelected(' + VarToJSON([RecordJS]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.HasSelection : TExtFunction; begin
  JSCode(JSName + '.hasSelection();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtStateManagerSingleton.JSClassName : string; begin
  Result := 'Ext.state.Manager';
end;

{$IFDEF FPC}constructor TExtStateManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtStateManagerSingleton.SetProvider(StateProvider : TExtStateProvider) : TExtFunction; begin
  JSCode(JSName + '.setProvider(' + VarToJSON([StateProvider, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.Get(Name : String; DefaultValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name, DefaultValue, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.SetJS(Name : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.Clear(Name : String) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.GetProvider : TExtFunction; begin
  JSCode(JSName + '.getProvider();', 'TExtStateManagerSingleton');
  Result := Self;
end;

procedure TExtShadow.SetFMode(Value : String); begin
  FMode := Value;
  JSCode('mode:' + VarToJSON([Value]));
end;

procedure TExtShadow.SetFOffset(Value : Integer); begin
  FOffset := Value;
  JSCode('offset:' + VarToJSON([Value]));
end;

function TExtShadow.JSClassName : string; begin
  Result := 'Ext.Shadow';
end;

{$IFDEF FPC}constructor TExtShadow.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtShadow.Show(TargetEl : String) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([TargetEl]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Show(TargetEl : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([TargetEl, false]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Show(TargetEl : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([TargetEl, false]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.IsVisible : TExtFunction; begin
  JSCode(JSName + '.isVisible();', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Realign(Left : Integer; Top : Integer; Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.realign(' + VarToJSON([Left, Top, Width, Height]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.SetZIndex(Zindex : Integer) : TExtFunction; begin
  JSCode(JSName + '.setZIndex(' + VarToJSON([Zindex]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.SetOpacity(Opacity : Integer) : TExtFunction; begin
  JSCode(JSName + '.setOpacity(' + VarToJSON([Opacity]) + ');', 'TExtShadow');
  Result := Self;
end;

procedure TExtDataProxy.SetFBatchOrder(Value : String); begin
  FBatchOrder := Value;
  JSCode('batchOrder:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFBatchActions(Value : Boolean); begin
  FBatchActions := Value;
  JSCode('batchActions:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFModel(Value : String); begin
  FModel := Value;
  if not ConfigAvailable(JSName) then
    SetModel(Value, false)
  else
    JSCode('model:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFModelTExtDataModel(Value : TExtDataModel); begin
  FModelTExtDataModel := Value;
  Value.DeleteFromGarbage;
  JSCode('model:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFReader(Value : TExtObject); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFReaderString(Value : String); begin
  FReaderString := Value;
  JSCode('reader:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFReaderTExtDataReader(Value : TExtDataReader); begin
  FReaderTExtDataReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFWriter(Value : TExtObject); begin
  FWriter := Value;
  Value.DeleteFromGarbage;
  JSCode('writer:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFWriterString(Value : String); begin
  FWriterString := Value;
  JSCode('writer:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFWriterTExtDataWriter(Value : TExtDataWriter); begin
  FWriterTExtDataWriter := Value;
  Value.DeleteFromGarbage;
  JSCode('writer:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFIsProxy(Value : Boolean); begin
  FIsProxy := Value;
  JSCode(JSName + '.isProxy=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataProxy.SetFOnMetachange(Value : TExtDataProxyOnMetachange); begin
  if Assigned(FOnMetachange) then
    JSCode(JSName+'.events ["metachange"].listeners=[];');
  if Assigned(Value) then
    AddListener('metachange', Ajax('metachange', ['This', '%0.nm','Meta', '%1.nm'], true));
  FOnMetachange := Value;
end;

function TExtDataProxy.JSClassName : string; begin
  Result := 'Ext.data.proxy.Proxy';
end;

procedure TExtDataProxy.InitDefaults; begin
  inherited;
  FBatchOrder := 'create,update,destroy';
  FBatchActions := true;
  FModelTExtDataModel := TExtDataModel.CreateInternal(Self, 'model');
  FReader := TExtObject.CreateInternal(Self, 'reader');
  FReaderTExtDataReader := TExtDataReader.CreateInternal(Self, 'reader');
  FWriter := TExtObject.CreateInternal(Self, 'writer');
  FWriterTExtDataWriter := TExtDataWriter.CreateInternal(Self, 'writer');
end;

{$IFDEF FPC}constructor TExtDataProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxy.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxy.SetModel(Model : String; SetOnStore : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setModel(' + VarToJSON([Model, SetOnStore]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetModel(Model : TExtDataModel; SetOnStore : Boolean) : TExtFunction; begin
  JSCode(JSName + '.SetModel(' + VarToJSON([Model, false, SetOnStore]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetModel : TExtFunction; begin
  JSCode(JSName + '.getModel();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : String) : TExtFunction; begin
  JSCode(JSName + '.setReader(' + VarToJSON([Reader]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetReader(' + VarToJSON([Reader, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : TExtDataReader) : TExtFunction; begin
  JSCode(JSName + '.SetReader(' + VarToJSON([Reader, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetReader : TExtFunction; begin
  JSCode(JSName + '.getReader();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : String) : TExtFunction; begin
  JSCode(JSName + '.setWriter(' + VarToJSON([Writer]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetWriter(' + VarToJSON([Writer, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : TExtDataWriter) : TExtFunction; begin
  JSCode(JSName + '.SetWriter(' + VarToJSON([Writer, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetWriter : TExtFunction; begin
  JSCode(JSName + '.getWriter();', 'TExtDataProxy');
  Result := Self;
end;

destructor TExtDataProxy.Destroy; begin
  try
    FModelTExtDataModel.Free;
    FReader.Free;
    FReaderTExtDataReader.Free;
    FWriter.Free;
    FWriterTExtDataWriter.Free;
  except end;
  inherited;
end;

procedure TExtDataProxy.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'metachange') and Assigned(FOnMetachange) then
    FOnMetachange(TExtDataProxy(ParamAsObject('This')), TExtObject(ParamAsObject('Meta')));
end;

procedure TExtDataProxyAjax.SetFHeaders(Value : TExtObject); begin
  FHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('headers:' + VarToJSON([Value, false]));
end;

function TExtDataProxyAjax.JSClassName : string; begin
  Result := 'Ext.data.proxy.Ajax';
end;

procedure TExtDataProxyAjax.InitDefaults; begin
  inherited;
  FHeaders := TExtObject.CreateInternal(Self, 'headers');
end;

{$IFDEF FPC}constructor TExtDataProxyAjax.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyAjax.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxyAjax.GetMethod(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.getMethod(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyAjax');
  Result := Self;
end;

destructor TExtDataProxyAjax.Destroy; begin
  try
    FHeaders.Free;
  except end;
  inherited;
end;

procedure TExtDataProxyDirect.SetFParamOrder(Value : String); begin
  FParamOrder := Value;
  JSCode('paramOrder:' + VarToJSON([Value]));
end;

procedure TExtDataProxyDirect.SetFParamOrderTExtObjectList(Value : TExtObjectList); begin
  FParamOrderTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('paramOrder:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyDirect.SetFParamsAsHash(Value : Boolean); begin
  FParamsAsHash := Value;
  JSCode('paramsAsHash:' + VarToJSON([Value]));
end;

procedure TExtDataProxyDirect.SetFDirectFn(Value : TExtFunction); begin
  FDirectFn := Value;
  JSCode('directFn:' + VarToJSON([Value, true]));
end;

procedure TExtDataProxyDirect.SetFDirectFnString(Value : String); begin
  FDirectFnString := Value;
  JSCode('directFn:' + VarToJSON([Value]));
end;

procedure TExtDataProxyDirect.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyDirect.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode('extraParams:' + VarToJSON([Value, false]));
end;

function TExtDataProxyDirect.JSClassName : string; begin
  Result := 'Ext.data.proxy.Direct';
end;

procedure TExtDataProxyDirect.InitDefaults; begin
  inherited;
  FParamOrderTExtObjectList := TExtObjectList.Create(Self, 'paramOrder');
  FApi := TExtObject.CreateInternal(Self, 'api');
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
end;

{$IFDEF FPC}constructor TExtDataProxyDirect.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyDirect.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataProxyDirect.Destroy; begin
  try
    FParamOrderTExtObjectList.Free;
    FApi.Free;
    FExtraParams.Free;
  except end;
  inherited;
end;

procedure TExtDataNodeInterface.SetFParentId(Value : String); begin
  FParentId := Value;
  JSCode('parentId:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIndex(Value : Integer); begin
  FIndex := Value;
  JSCode('index:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFDepth(Value : Integer); begin
  FDepth := Value;
  JSCode('depth:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFExpanded(Value : Boolean); begin
  FExpanded := Value;
  JSCode('expanded:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFExpandable(Value : Boolean); begin
  FExpandable := Value;
  JSCode('expandable:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFLeaf(Value : Boolean); begin
  FLeaf := Value;
  JSCode('leaf:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFRoot(Value : Boolean); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIsLast(Value : Boolean); begin
  FIsLast := Value;
  JSCode('isLast:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIsFirst(Value : Boolean); begin
  FIsFirst := Value;
  JSCode('isFirst:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFAllowDrop(Value : Boolean); begin
  FAllowDrop := Value;
  JSCode('allowDrop:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFAllowDrag(Value : Boolean); begin
  FAllowDrag := Value;
  JSCode('allowDrag:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFLoaded(Value : Boolean); begin
  FLoaded := Value;
  JSCode('loaded:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFLoading(Value : Boolean); begin
  FLoading := Value;
  JSCode('loading:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFHref(Value : String); begin
  FHref := Value;
  JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFQtip(Value : String); begin
  FQtip := Value;
  JSCode('qtip:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFQtitle(Value : String); begin
  FQtitle := Value;
  JSCode('qtitle:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFChildren(Value : TExtObjectList); begin
  FChildren := Value;
  Value.DeleteFromGarbage;
  JSCode('children:' + VarToJSON([Value, false]));
end;

procedure TExtDataNodeInterface.SetFIsNode(Value : Boolean); begin
  FIsNode := Value;
  JSCode(JSName + '.isNode=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataNodeInterface.SetFOnAppend(Value : TExtDataNodeInterfaceOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', ['This', '%0.nm','Node', '%1.nm','Index', '%2'], true));
  FOnAppend := Value;
end;

procedure TExtDataNodeInterface.SetFOnRemove(Value : TExtDataNodeInterfaceOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['This', '%0.nm','Node', '%1.nm','IsMove', '%2'], true));
  FOnRemove := Value;
end;

procedure TExtDataNodeInterface.SetFOnMove(Value : TExtDataNodeInterfaceOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', ['This', '%0.nm','OldParent', '%1.nm','NewParent', '%2.nm','Index', '%3'], true));
  FOnMove := Value;
end;

procedure TExtDataNodeInterface.SetFOnInsert(Value : TExtDataNodeInterfaceOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', ['This', '%0.nm','Node', '%1.nm','RefNode', '%2.nm'], true));
  FOnInsert := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeappend(Value : TExtDataNodeInterfaceOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', ['This', '%0.nm','Node', '%1.nm'], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeremove(Value : TExtDataNodeInterfaceOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', ['This', '%0.nm','Node', '%1.nm','IsMove', '%2'], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforemove(Value : TExtDataNodeInterfaceOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', ['This', '%0.nm','OldParent', '%1.nm','NewParent', '%2.nm','Index', '%3'], true));
  FOnBeforemove := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeinsert(Value : TExtDataNodeInterfaceOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', ['This', '%0.nm','Node', '%1.nm','RefNode', '%2.nm'], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataNodeInterface.SetFOnExpand(Value : TExtDataNodeInterfaceOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['This', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtDataNodeInterface.SetFOnCollapse(Value : TExtDataNodeInterfaceOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['This', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeexpand(Value : TExtDataNodeInterfaceOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', ['This', '%0.nm'], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforecollapse(Value : TExtDataNodeInterfaceOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', ['This', '%0.nm'], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataNodeInterface.SetFOnSort(Value : TExtDataNodeInterfaceOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', ['This', '%0.nm','ChildNodes', '%1.nm'], true));
  FOnSort := Value;
end;

function TExtDataNodeInterface.JSClassName : string; begin
  Result := 'Ext.data.NodeInterface';
end;

procedure TExtDataNodeInterface.InitDefaults; begin
  inherited;
  FChildren := TExtObjectList.Create(Self, 'children');
end;

{$IFDEF FPC}constructor TExtDataNodeInterface.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataNodeInterface.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataNodeInterface.CreateNode : TExtFunction; begin
  JSCode(JSName + '.createNode();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLeaf : TExtFunction; begin
  JSCode(JSName + '.isLeaf();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.UpdateInfo : TExtFunction; begin
  JSCode(JSName + '.updateInfo();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLast_ : TExtFunction; begin
  JSCode(JSName + '.isLast();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsFirst_ : TExtFunction; begin
  JSCode(JSName + '.isFirst();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.HasChildNodes : TExtFunction; begin
  JSCode(JSName + '.hasChildNodes();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsExpandable : TExtFunction; begin
  JSCode(JSName + '.isExpandable();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.AppendChild(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.appendChild(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.AppendChild(Node : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AppendChild(' + VarToJSON(Node) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.RemoveChild(Node : TExtDataNodeInterface; DestroyJS : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeChild(' + VarToJSON([Node, false, DestroyJS]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Copy(Id : String = ''; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.copy(' + VarToJSON([Id, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.InsertBefore(Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([Node, false, RefNode, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.InsertChild(Index : Integer; Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.insertChild(' + VarToJSON([Index, Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Remove(DestroyJS : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([DestroyJS]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.RemoveAll(DestroyJS : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([DestroyJS]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetChildAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getChildAt(' + VarToJSON([Index]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.ReplaceChild(NewChild : TExtDataNodeInterface; OldChild : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.replaceChild(' + VarToJSON([NewChild, false, OldChild, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IndexOf(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IndexOfId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.indexOfId(' + VarToJSON([Id]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetPath(Field : String = ''; Separator : String = '') : TExtFunction; begin
  JSCode(JSName + '.getPath(' + VarToJSON([Field, Separator]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetDepth : TExtFunction; begin
  JSCode(JSName + '.getDepth();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.bubble(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.CascadeBy(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.cascadeBy(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.EachChild(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.eachChild(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.FindChild(Attribute : String; Value : TExtObject; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findChild(' + VarToJSON([Attribute, Value, false, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.FindChildBy(Fn : TExtFunction; Scope : TExtObject = nil; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findChildBy(' + VarToJSON([Fn, true, Scope, false, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Contains(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsAncestor(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.isAncestor(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Sort(Fn : TExtFunction; Recursive : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Fn, true, Recursive, SuppressEvent]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsExpanded : TExtFunction; begin
  JSCode(JSName + '.isExpanded();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLoaded : TExtFunction; begin
  JSCode(JSName + '.isLoaded();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLoading : TExtFunction; begin
  JSCode(JSName + '.isLoading();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsRoot : TExtFunction; begin
  JSCode(JSName + '.isRoot();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsVisible : TExtFunction; begin
  JSCode(JSName + '.isVisible();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Expand(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.ExpandChildren(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandChildren(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Collapse(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.CollapseChildren(Recursive : TExtFunction = nil; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseChildren(' + VarToJSON([Recursive, true, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

destructor TExtDataNodeInterface.Destroy; begin
  try
    FChildren.Free;
  except end;
  inherited;
end;

procedure TExtDataNodeInterface.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('OldParent')), TExtDataNodeInterface(ParamAsObject('NewParent')), ParamAsInteger('Index'))
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtDataNodeInterface(ParamAsObject('RefNode')))
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')))
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('OldParent')), TExtDataNodeInterface(ParamAsObject('NewParent')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtDataNodeInterface(ParamAsObject('RefNode')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort(TExtDataNodeInterface(ParamAsObject('This')), TExtObjectList(ParamAsObject('ChildNodes')));
end;

procedure TExtDataOperation.SetFSynchronous(Value : Boolean); begin
  FSynchronous := Value;
  JSCode('synchronous:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFAction(Value : String); begin
  FAction := Value;
  JSCode('action:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFFilters(Value : TExtObjectList); begin
  FFilters := Value;
  Value.DeleteFromGarbage;
  JSCode('filters:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFGroupers(Value : TExtObjectList); begin
  FGroupers := Value;
  Value.DeleteFromGarbage;
  JSCode('groupers:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFStart(Value : Integer); begin
  FStart := Value;
  JSCode('start:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFLimit(Value : Integer); begin
  FLimit := Value;
  JSCode('limit:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFBatch(Value : TExtDataBatch); begin
  FBatch := Value;
  Value.DeleteFromGarbage;
  JSCode('batch:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtDataOperation.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFActionCommitRecordsRe(Value : TRegExp); begin
  FActionCommitRecordsRe := Value;
  JSCode(JSName + '.actionCommitRecordsRe=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtDataOperation.SetFActionSkipSyncRe(Value : TRegExp); begin
  FActionSkipSyncRe := Value;
  JSCode(JSName + '.actionSkipSyncRe=' + VarToJSON([#3 +Value]) + ';');
end;

function TExtDataOperation.JSClassName : string; begin
  Result := 'Ext.data.Operation';
end;

procedure TExtDataOperation.InitDefaults; begin
  inherited;
  FFilters := TExtObjectList.Create(Self, 'filters');
  FSorters := TExtObjectList.Create(Self, 'sorters');
  FGroupers := TExtObjectList.Create(Self, 'groupers');
  FBatch := TExtDataBatch.CreateInternal(Self, 'batch');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtDataOperation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataOperation.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtDataOperation.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataOperation.SetStarted : TExtFunction; begin
  JSCode(JSName + '.setStarted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetCompleted : TExtFunction; begin
  JSCode(JSName + '.setCompleted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetSuccessful : TExtFunction; begin
  JSCode(JSName + '.setSuccessful();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetException(Error : String = '') : TExtFunction; begin
  JSCode(JSName + '.setException(' + VarToJSON([Error]) + ');', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetException(Error : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetException(' + VarToJSON([Error, false]) + ');', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.HasException : TExtFunction; begin
  JSCode(JSName + '.hasException();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.GetError : TExtFunction; begin
  JSCode(JSName + '.getError();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.GetRecords : TExtFunction; begin
  JSCode(JSName + '.getRecords();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.GetResultSet : TExtFunction; begin
  JSCode(JSName + '.getResultSet();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsStarted : TExtFunction; begin
  JSCode(JSName + '.isStarted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsRunning : TExtFunction; begin
  JSCode(JSName + '.isRunning();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsComplete : TExtFunction; begin
  JSCode(JSName + '.isComplete();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.WasSuccessful : TExtFunction; begin
  JSCode(JSName + '.wasSuccessful();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.AllowWrite : TExtFunction; begin
  JSCode(JSName + '.allowWrite();', 'TExtDataOperation');
  Result := Self;
end;

destructor TExtDataOperation.Destroy; begin
  try
    FFilters.Free;
    FSorters.Free;
    FGroupers.Free;
    FBatch.Free;
    FParams.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtChartSeries.SetFHighlight(Value : Boolean); begin
  FHighlight := Value;
  JSCode('highlight:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFHighlightTExtObject(Value : TExtObject); begin
  FHighlightTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('highlight:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFTips(Value : TExtObject); begin
  FTips := Value;
  Value.DeleteFromGarbage;
  JSCode('tips:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtChartSeries.SetFShadowAttributes(Value : TExtObjectList); begin
  FShadowAttributes := Value;
  Value.DeleteFromGarbage;
  JSCode('shadowAttributes:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFOnTitlechange(Value : TExtChartSeriesOnTitlechange); begin
  if Assigned(FOnTitlechange) then
    JSCode(JSName+'.events ["titlechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('titlechange', Ajax('titlechange', ['Title', '%0','Index', '%1'], true));
  FOnTitlechange := Value;
end;

function TExtChartSeries.JSClassName : string; begin
  Result := 'Ext.chart.series.Series';
end;

procedure TExtChartSeries.InitDefaults; begin
  inherited;
  FHighlightTExtObject := TExtObject.CreateInternal(Self, 'highlight');
  FTips := TExtObject.CreateInternal(Self, 'tips');
  FShadowAttributes := TExtObjectList.Create(Self, 'shadowAttributes');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtChartSeries.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeries.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeries.EachRecord(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.eachRecord(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetRecordCount : TExtFunction; begin
  JSCode(JSName + '.getRecordCount();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.IsExcluded : TExtFunction; begin
  JSCode(JSName + '.isExcluded();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetItemForPoint(X : Integer; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.getItemForPoint(' + VarToJSON([X, Y]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ShowAll : TExtFunction; begin
  JSCode(JSName + '.showAll();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetLegendColor : TExtFunction; begin
  JSCode(JSName + '.getLegendColor();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.SetTitle(Index : Integer; Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Index, Title]) + ');', 'TExtChartSeries');
  Result := Self;
end;

destructor TExtChartSeries.Destroy; begin
  try
    FHighlightTExtObject.Free;
    FTips.Free;
    FShadowAttributes.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtChartSeries.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'titlechange') and Assigned(FOnTitlechange) then
    FOnTitlechange(ParamAsString('Title'), ParamAsInteger('Index'));
end;

function TExtDataProxySessionStorage.JSClassName : string; begin
  Result := 'Ext.data.proxy.SessionStorage';
end;

{$IFDEF FPC}constructor TExtDataProxySessionStorage.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartNavigation.JSClassName : string; begin
  Result := 'Ext.chart.Navigation';
end;

{$IFDEF FPC}constructor TExtChartNavigation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartNavigation.SetZoom : TExtFunction; begin
  JSCode(JSName + '.setZoom();', 'TExtChartNavigation');
  Result := Self;
end;

function TExtChartNavigation.RestoreZoom : TExtFunction; begin
  JSCode(JSName + '.restoreZoom();', 'TExtChartNavigation');
  Result := Self;
end;

procedure TExtChartMask.SetFMask(Value : Boolean); begin
  FMask := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

procedure TExtChartMask.SetFMaskString(Value : String); begin
  FMaskString := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

function TExtChartMask.JSClassName : string; begin
  Result := 'Ext.chart.Mask';
end;

{$IFDEF FPC}constructor TExtChartMask.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartMask.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

procedure TExtDataProxyJsonP.SetFCallbackKey(Value : String); begin
  FCallbackKey := Value;
  JSCode('callbackKey:' + VarToJSON([Value]));
end;

procedure TExtDataProxyJsonP.SetFRecordParam(Value : String); begin
  FRecordParam := Value;
  JSCode('recordParam:' + VarToJSON([Value]));
end;

function TExtDataProxyJsonP.JSClassName : string; begin
  Result := 'Ext.data.proxy.JsonP';
end;

procedure TExtDataProxyJsonP.InitDefaults; begin
  inherited;
  FRecordParam := 'records';
end;

{$IFDEF FPC}constructor TExtDataProxyJsonP.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyJsonP.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxyJsonP.BuildUrl(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.buildUrl(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyJsonP');
  Result := Self;
end;

function TExtDataProxyJsonP.Abort : TExtFunction; begin
  JSCode(JSName + '.abort();', 'TExtDataProxyJsonP');
  Result := Self;
end;

function TExtDataProxyJsonP.EncodeRecords(Records : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.encodeRecords(' + VarToJSON(Records) + ');', 'TExtDataProxyJsonP');
  Result := Self;
end;

function TExtDataProxyLocalStorage.JSClassName : string; begin
  Result := 'Ext.data.proxy.LocalStorage';
end;

{$IFDEF FPC}constructor TExtDataProxyLocalStorage.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataProxyMemory.SetFData(Value : TExtObject); begin
  FData := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

function TExtDataProxyMemory.JSClassName : string; begin
  Result := 'Ext.data.proxy.Memory';
end;

procedure TExtDataProxyMemory.InitDefaults; begin
  inherited;
  FData := TExtObject.CreateInternal(Self, 'data');
end;

{$IFDEF FPC}constructor TExtDataProxyMemory.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyMemory.Create; begin
  CreateVarAlt(JSClassName + '.create({});');
  InitDefaults;
end;

function TExtDataProxyMemory.Update(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');', 'TExtDataProxyMemory');
  Result := Self;
end;

function TExtDataProxyMemory.Read(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.read(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');', 'TExtDataProxyMemory');
  Result := Self;
end;

destructor TExtDataProxyMemory.Destroy; begin
  try
    FData.Free;
  except end;
  inherited;
end;

procedure TExtDataAssociation.SetFOwnerModel(Value : String); begin
  FOwnerModel := Value;
  JSCode('ownerModel:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFAssociatedModel(Value : String); begin
  FAssociatedModel := Value;
  JSCode('associatedModel:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFModel(Value : String); begin
  FModel := Value;
  JSCode('model:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFPrimaryKey(Value : String); begin
  FPrimaryKey := Value;
  JSCode('primaryKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFReader(Value : TExtDataReader); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtDataAssociation.SetFAssociationKey(Value : String); begin
  FAssociationKey := Value;
  JSCode('associationKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFOwnerName(Value : String); begin
  FOwnerName := Value;
  JSCode(JSName + '.ownerName=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAssociation.SetFAssociatedName(Value : String); begin
  FAssociatedName := Value;
  JSCode(JSName + '.associatedName=' + VarToJSON([Value]) + ';');
end;

function TExtDataAssociation.JSClassName : string; begin
  Result := 'Ext.data.association.Association';
end;

procedure TExtDataAssociation.InitDefaults; begin
  inherited;
  FReader := TExtDataReader.CreateInternal(Self, 'reader');
end;

{$IFDEF FPC}constructor TExtDataAssociation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociation.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataAssociation.GetReader : TExtFunction; begin
  JSCode(JSName + '.getReader();', 'TExtDataAssociation');
  Result := Self;
end;

destructor TExtDataAssociation.Destroy; begin
  try
    FReader.Free;
  except end;
  inherited;
end;

procedure TExtDataBatch.SetFAutoStart(Value : Boolean); begin
  FAutoStart := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDataBatch.SetFPauseOnException(Value : Boolean); begin
  FPauseOnException := Value;
  JSCode('pauseOnException:' + VarToJSON([Value]));
end;

procedure TExtDataBatch.SetFCurrent(Value : Integer); begin
  FCurrent := Value;
  JSCode(JSName + '.current=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFTotal(Value : Integer); begin
  FTotal := Value;
  JSCode(JSName + '.total=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFIsRunning(Value : Boolean); begin
  FIsRunning := Value;
  JSCode(JSName + '.isRunning=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFIsComplete(Value : Boolean); begin
  FIsComplete := Value;
  JSCode(JSName + '.isComplete=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFHasException(Value : Boolean); begin
  FHasException := Value;
  JSCode(JSName + '.hasException=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFOperations(Value : TExtObjectList); begin
  FOperations := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.operations=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataBatch.JSClassName : string; begin
  Result := 'Ext.data.Batch';
end;

procedure TExtDataBatch.InitDefaults; begin
  inherited;
  FOperations := TExtObjectList.Create(Self, 'operations');
end;

{$IFDEF FPC}constructor TExtDataBatch.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataBatch.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataBatch.Add(Operation : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Operation, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Start : TExtFunction; begin
  JSCode(JSName + '.start();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Retry : TExtFunction; begin
  JSCode(JSName + '.retry();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Pause : TExtFunction; begin
  JSCode(JSName + '.pause();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RunOperation(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.runOperation(' + VarToJSON([Index]) + ');', 'TExtDataBatch');
  Result := Self;
end;

destructor TExtDataBatch.Destroy; begin
  try
    FOperations.Free;
  except end;
  inherited;
end;

procedure TExtComponent.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFResizableTExtObject(Value : TExtObject); begin
  FResizableTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('resizable:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFResizeHandles(Value : String); begin
  FResizeHandles := Value;
  JSCode('resizeHandles:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFAutoScroll(Value : Boolean); begin
  FAutoScroll := Value;
  if not ConfigAvailable(JSName) then
    SetAutoScroll(Value)
  else
    JSCode('autoScroll:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFOverflowX(Value : String); begin
  FOverflowX := Value;
  JSCode('overflowX:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFOverflowY(Value : String); begin
  FOverflowY := Value;
  JSCode('overflowY:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFFloating(Value : Boolean); begin
  FFloating := Value;
  JSCode('floating:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFToFrontOnShow(Value : Boolean); begin
  FToFrontOnShow := Value;
  JSCode('toFrontOnShow:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFDraggableTExtObject(Value : TExtObject); begin
  FDraggableTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('draggable:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFFormBind(Value : Boolean); begin
  FFormBind := Value;
  JSCode('formBind:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFColumnWidth(Value : Integer); begin
  FColumnWidth := Value;
  JSCode('columnWidth:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFColumnWidthString(Value : String); begin
  FColumnWidthString := Value;
  JSCode('columnWidth:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFRegion(Value : String); begin
  FRegion := Value;
  JSCode('region:' + VarToJSON([Value]));
end;

function TExtComponent.JSClassName : string; begin
  Result := 'Ext.Component';
end;

procedure TExtComponent.InitDefaults; begin
  inherited;
  FResizableTExtObject := TExtObject.CreateInternal(Self, 'resizable');
  FDraggableTExtObject := TExtObject.CreateInternal(Self, 'draggable');
end;

{$IFDEF FPC}constructor TExtComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtComponent.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtComponent.Create(Config : TExtElement); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

constructor TExtComponent.Create(Config : String); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config]) + ');');
  InitDefaults;
end;

constructor TExtComponent.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtComponent.SetAutoScroll(Scroll : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAutoScroll(' + VarToJSON([Scroll]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetOverflowXY(OverflowX : String; OverflowY : String) : TExtFunction; begin
  JSCode(JSName + '.setOverflowXY(' + VarToJSON([OverflowX, OverflowY]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.scrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : Boolean; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setLoading(' + VarToJSON([Load, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : TExtObject; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetLoading(' + VarToJSON([Load, false, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : String; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetLoading(' + VarToJSON([Load, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : Integer; Y : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.showAt(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ShowAt(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : Integer; Y : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setPagePosition(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPagePosition(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.GetBox(Local : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getBox(' + VarToJSON([Local]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.UpdateBox(Box : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.updateBox(' + VarToJSON([Box, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.GetPosition(Local : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getPosition(' + VarToJSON([Local]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Show(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([AnimateTarget, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Show(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([AnimateTarget, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : TExtComponent; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Focus(SelectText : Boolean = false; Delay : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.focus(' + VarToJSON([SelectText, Delay]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Focus(SelectText : Boolean; Delay : Integer) : TExtFunction; begin
  JSCode(JSName + '.Focus(' + VarToJSON([SelectText, Delay]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.CloneConfig(Overrides : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.cloneConfig(' + VarToJSON([Overrides, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.GetXType : TExtFunction; begin
  JSCode(JSName + '.getXType();', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentBy(Fn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.findParentBy(' + VarToJSON([Fn, true]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentByType(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.findParentByType(' + VarToJSON([Xtype]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentByType(Xtype : TExtClass) : TExtFunction; begin
  JSCode(JSName + '.FindParentByType(' + VarToJSON([Xtype, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.bubble(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtComponent');
  Result := Self;
end;

destructor TExtComponent.Destroy; begin
  try
    FResizableTExtObject.Free;
    FDraggableTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtContainerDockingContainer.SetFDefaultDockWeights(Value : TExtObject); begin
  FDefaultDockWeights := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultDockWeights:' + VarToJSON([Value, false]));
end;

function TExtContainerDockingContainer.JSClassName : string; begin
  Result := 'Ext.container.DockingContainer';
end;

procedure TExtContainerDockingContainer.InitDefaults; begin
  inherited;
  FDefaultDockWeights := TExtObject.CreateInternal(Self, 'defaultDockWeights');
end;

{$IFDEF FPC}constructor TExtContainerDockingContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtContainerDockingContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtContainerDockingContainer.AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.addDocked(' + VarToJSON([Component, false, Pos]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.AddDocked(' + VarToJSON(Component) + ',' + VarToJSON([Pos]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.GetDockedComponent(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.getDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.GetDockedComponent(Comp : Integer) : TExtFunction; begin
  JSCode(JSName + '.GetDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getDockedItems(' + VarToJSON([Selector, BeforeBody]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.insertDocked(' + VarToJSON([Pos, Component, false]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.InsertDocked(' + VarToJSON([Pos]) + ',' + VarToJSON(Component) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeDocked(' + VarToJSON([Item, false, AutoDestroy]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

destructor TExtContainerDockingContainer.Destroy; begin
  try
    FDefaultDockWeights.Free;
  except end;
  inherited;
end;

function TExtContainer.JSClassName : string; begin
  Result := 'Ext.container.Container';
end;

{$IFDEF FPC}constructor TExtContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtContainer.GetChildByElement(El : TExtElement; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getChildByElement(' + VarToJSON([El, false, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

function TExtContainer.GetChildByElement(El : THTMLElement; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetChildByElement(' + VarToJSON([El, false, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

function TExtContainer.GetChildByElement(El : String; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetChildByElement(' + VarToJSON([El, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

function TExtComponentQuery.JSClassName : string; begin
  Result := 'Ext.ComponentQuery';
end;

{$IFDEF FPC}constructor TExtComponentQuery.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtComponentQuery.Query(Selector : String; Root : TExtContainer) : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([Selector, Root, false]) + ');', 'TExtComponentQuery');
  Result := Self;
end;

function TExtComponentQuery.IsJS(Component : TExtComponent; Selector : String) : TExtFunction; begin
  JSCode(JSName + '.is(' + VarToJSON([Component, false, Selector]) + ');', 'TExtComponentQuery');
  Result := Self;
end;

procedure TExtDataIdGenerator.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

function TExtDataIdGenerator.JSClassName : string; begin
  Result := 'Ext.data.IdGenerator';
end;

class function TExtDataIdGenerator.All : TExtObject;
const
  lAll : TExtObject = nil;
begin
  if lAll = nil then lAll := TExtObject.CreateSingleton('Ext.data.IdGenerator.All');
  Result := lAll
end;

{$IFDEF FPC}constructor TExtDataIdGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataJsonPSingleton.JSClassName : string; begin
  Result := 'Ext.data.JsonP';
end;

{$IFDEF FPC}constructor TExtDataJsonPSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataJsonPSingleton.Abort(Request : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.abort(' + VarToJSON([Request, false]) + ');', 'TExtDataJsonPSingleton');
  Result := Self;
end;

function TExtDataJsonPSingleton.Abort(Request : String) : TExtFunction; begin
  JSCode(JSName + '.Abort(' + VarToJSON([Request]) + ');', 'TExtDataJsonPSingleton');
  Result := Self;
end;

procedure TExtDataModel.SetFIdgen(Value : String); begin
  FIdgen := Value;
  JSCode('idgen:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFIdgenTExtObject(Value : TExtObject); begin
  FIdgenTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('idgen:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFPersistenceProperty(Value : String); begin
  FPersistenceProperty := Value;
  JSCode('persistenceProperty:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFIdProperty(Value : String); begin
  FIdProperty := Value;
  JSCode('idProperty:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFClientIdProperty(Value : String); begin
  FClientIdProperty := Value;
  JSCode('clientIdProperty:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFDefaultProxyType(Value : String); begin
  FDefaultProxyType := Value;
  JSCode('defaultProxyType:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFFields(Value : TExtObjectList); begin
  FFields := Value;
  Value.DeleteFromGarbage;
  JSCode('fields:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFFieldsTExtObjectList(Value : TExtObjectList); begin
  FFieldsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('fields:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFValidations(Value : TExtObjectList); begin
  FValidations := Value;
  Value.DeleteFromGarbage;
  JSCode('validations:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFAssociations(Value : TExtObjectList); begin
  FAssociations := Value;
  Value.DeleteFromGarbage;
  JSCode('associations:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFHasMany(Value : String); begin
  FHasMany := Value;
  JSCode('hasMany:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFHasManyTExtObject(Value : TExtObject); begin
  FHasManyTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('hasMany:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFHasManyTExtObjectList(Value : TExtObjectList); begin
  FHasManyTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('hasMany:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFBelongsTo(Value : String); begin
  FBelongsTo := Value;
  JSCode('belongsTo:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFBelongsToTExtObject(Value : TExtObject); begin
  FBelongsToTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('belongsTo:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFBelongsToTExtObjectList(Value : TExtObjectList); begin
  FBelongsToTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('belongsTo:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFProxy(Value : String); begin
  FProxy := Value;
  JSCode('proxy:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFProxyTExtObject(Value : TExtObject); begin
  FProxyTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFProxyTExtDataProxy(Value : TExtDataProxy); begin
  FProxyTExtDataProxy := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFInternalId(Value : Integer); begin
  FInternalId := Value;
  JSCode(JSName + '.internalId=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFInternalIdString(Value : String); begin
  FInternalIdString := Value;
  JSCode(JSName + '.internalId=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFRaw(Value : TExtObject); begin
  FRaw := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.raw=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFModified(Value : TExtObject); begin
  FModified := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.modified=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFStores(Value : TExtObjectList); begin
  FStores := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.stores=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.store=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataModel.JSClassName : string; begin
  Result := 'Ext.data.Model';
end;

procedure TExtDataModel.InitDefaults; begin
  inherited;
  FIdgenTExtObject := TExtObject.CreateInternal(Self, 'idgen');
  FPersistenceProperty := 'data';
  FIdProperty := 'id';
  FDefaultProxyType := 'ajax';
  FFields := TExtObjectList.Create(Self, 'fields');
  FFieldsTExtObjectList := TExtObjectList.Create(Self, 'fields');
  FValidations := TExtObjectList.Create(Self, 'validations');
  FAssociations := TExtObjectList.Create(Self, 'associations');
  FHasManyTExtObject := TExtObject.CreateInternal(Self, 'hasMany');
  FHasManyTExtObjectList := TExtObjectList.Create(Self, 'hasMany');
  FBelongsToTExtObject := TExtObject.CreateInternal(Self, 'belongsTo');
  FBelongsToTExtObjectList := TExtObjectList.Create(Self, 'belongsTo');
  FProxyTExtObject := TExtObject.CreateInternal(Self, 'proxy');
  FProxyTExtDataProxy := TExtDataProxy.CreateInternal(Self, 'proxy');
  FRaw := TExtObject.CreateInternal(Self, 'raw');
  FModified := TExtObject.CreateInternal(Self, 'modified');
  FStores := TExtObjectList.Create(Self, 'stores');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtDataModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataModel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataModel.Unjoin(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.unjoin(' + VarToJSON([Store, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetData(IncludeAssociated : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getData(' + VarToJSON([IncludeAssociated]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetAssociatedData : TExtFunction; begin
  JSCode(JSName + '.getAssociatedData();', 'TExtDataModel');
  Result := Self;
end;

destructor TExtDataModel.Destroy; begin
  try
    FIdgenTExtObject.Free;
    FFields.Free;
    FFieldsTExtObjectList.Free;
    FValidations.Free;
    FAssociations.Free;
    FHasManyTExtObject.Free;
    FHasManyTExtObjectList.Free;
    FBelongsToTExtObject.Free;
    FBelongsToTExtObjectList.Free;
    FProxyTExtObject.Free;
    FProxyTExtDataProxy.Free;
    FRaw.Free;
    FModified.Free;
    FStores.Free;
    FStore.Free;
  except end;
  inherited;
end;

function TExtChartTip.JSClassName : string; begin
  Result := 'Ext.chart.Tip';
end;

{$IFDEF FPC}constructor TExtChartTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartTheme.JSClassName : string; begin
  Result := 'Ext.chart.theme.Theme';
end;

{$IFDEF FPC}constructor TExtChartTheme.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataConnection.SetFDisableCaching(Value : Boolean); begin
  FDisableCaching := Value;
  JSCode('disableCaching:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFWithCredentials(Value : Boolean); begin
  FWithCredentials := Value;
  JSCode('withCredentials:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFCors(Value : Boolean); begin
  FCors := Value;
  JSCode('cors:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFDisableCachingParam(Value : String); begin
  FDisableCachingParam := Value;
  JSCode('disableCachingParam:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode('extraParams:' + VarToJSON([Value, false]));
end;

procedure TExtDataConnection.SetFAutoAbort(Value : Boolean); begin
  FAutoAbort := Value;
  JSCode('autoAbort:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFDefaultHeaders(Value : TExtObject); begin
  FDefaultHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultHeaders:' + VarToJSON([Value, false]));
end;

procedure TExtDataConnection.SetFOnBeforerequest(Value : TExtDataConnectionOnBeforerequest); begin
  if Assigned(FOnBeforerequest) then
    JSCode(JSName+'.events ["beforerequest"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerequest', Ajax('beforerequest', ['Conn', '%0.nm','Options', '%1.nm'], true));
  FOnBeforerequest := Value;
end;

procedure TExtDataConnection.SetFOnRequestcomplete(Value : TExtDataConnectionOnRequestcomplete); begin
  if Assigned(FOnRequestcomplete) then
    JSCode(JSName+'.events ["requestcomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('requestcomplete', Ajax('requestcomplete', ['Conn', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnRequestcomplete := Value;
end;

procedure TExtDataConnection.SetFOnRequestexception(Value : TExtDataConnectionOnRequestexception); begin
  if Assigned(FOnRequestexception) then
    JSCode(JSName+'.events ["requestexception"].listeners=[];');
  if Assigned(Value) then
    AddListener('requestexception', Ajax('requestexception', ['Conn', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnRequestexception := Value;
end;

function TExtDataConnection.JSClassName : string; begin
  Result := 'Ext.data.Connection';
end;

procedure TExtDataConnection.InitDefaults; begin
  inherited;
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
  FDefaultHeaders := TExtObject.CreateInternal(Self, 'defaultHeaders');
end;

{$IFDEF FPC}constructor TExtDataConnection.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataConnection.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : TExtFunction; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, true, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : String; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtFunction; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, true, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : THTMLElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : TExtObject; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, false, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : String; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject; OptionsUrl : String; OptionsParams : TExtObject; OptionsMethod : String; OptionsCallback : TExtFunction; OptionsCallbackOptions : TExtObject; OptionsCallbackSuccess : Boolean; OptionsCallbackResponse : TExtObject; OptionsSuccess : TExtFunction; OptionsSuccessResponse : TExtObject; OptionsSuccessOptions : TExtObject; OptionsFailure : TExtFunction; OptionsFailureResponse : TExtObject; OptionsFailureOptions : TExtObject; OptionsScope : TExtObject; OptionsTimeout : Integer; OptionsForm : TExtElement; OptionsIsUpload : Boolean; OptionsHeaders : TExtObject; OptionsXmlData : TExtObject; OptionsJsonData : String; OptionsDisableCaching : Boolean; OptionsWithCredentials : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Request(' + VarToJSON([Options, false, OptionsUrl, OptionsParams, false, OptionsMethod, OptionsCallback, true, OptionsCallbackOptions, false, OptionsCallbackSuccess, OptionsCallbackResponse, false, OptionsSuccess, true, OptionsSuccessResponse, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureResponse, false, OptionsFailureOptions, false, OptionsScope, false, OptionsTimeout, OptionsForm, false, OptionsIsUpload, OptionsHeaders, false, OptionsXmlData, false, OptionsJsonData, OptionsDisableCaching, OptionsWithCredentials]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : String; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.upload(' + VarToJSON([Form, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : THTMLElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Upload(' + VarToJSON([Form, false, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : TExtElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Upload(' + VarToJSON([Form, false, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.SetOptions(Options : TExtObject; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setOptions(' + VarToJSON([Options, false, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.IsLoading(Request : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.isLoading(' + VarToJSON([Request, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Abort(Request : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.abort(' + VarToJSON([Request, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AbortAll : TExtFunction; begin
  JSCode(JSName + '.abortAll();', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ParseStatus(Status : Integer) : TExtFunction; begin
  JSCode(JSName + '.parseStatus(' + VarToJSON([Status]) + ');', 'TExtDataConnection');
  Result := Self;
end;

destructor TExtDataConnection.Destroy; begin
  try
    FExtraParams.Free;
    FDefaultHeaders.Free;
  except end;
  inherited;
end;

procedure TExtDataConnection.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforerequest') and Assigned(FOnBeforerequest) then
    FOnBeforerequest(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'requestcomplete') and Assigned(FOnRequestcomplete) then
    FOnRequestcomplete(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'requestexception') and Assigned(FOnRequestexception) then
    FOnRequestexception(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')));
end;

procedure TExtChartLegend.SetFVisible(Value : Boolean); begin
  FVisible := Value;
  JSCode('visible:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFUpdate(Value : Boolean); begin
  FUpdate := Value;
  JSCode('update:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFLabelColor(Value : String); begin
  FLabelColor := Value;
  JSCode('labelColor:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFLabelFont(Value : String); begin
  FLabelFont := Value;
  JSCode('labelFont:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxStroke(Value : String); begin
  FBoxStroke := Value;
  JSCode('boxStroke:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxStrokeWidth(Value : String); begin
  FBoxStrokeWidth := Value;
  JSCode('boxStrokeWidth:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxFill(Value : String); begin
  FBoxFill := Value;
  JSCode('boxFill:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFItemSpacing(Value : Integer); begin
  FItemSpacing := Value;
  JSCode('itemSpacing:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFPadding(Value : Integer); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxZIndex(Value : Integer); begin
  FBoxZIndex := Value;
  JSCode('boxZIndex:' + VarToJSON([Value]));
end;

function TExtChartLegend.JSClassName : string; begin
  Result := 'Ext.chart.Legend';
end;

procedure TExtChartLegend.InitDefaults; begin
  inherited;
  FBoxZIndex := 100;
end;

{$IFDEF FPC}constructor TExtChartLegend.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartLegend.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtChartLegend.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtChartLegend.Toggle(Whether : Boolean) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([Whether]) + ');', 'TExtChartLegend');
  Result := Self;
end;

procedure TExtAppController.SetFViews(Value : TExtObjectList); begin
  FViews := Value;
  Value.DeleteFromGarbage;
  JSCode('views:' + VarToJSON([Value, false]));
end;

procedure TExtAppController.SetFStores(Value : TExtObjectList); begin
  FStores := Value;
  Value.DeleteFromGarbage;
  JSCode('stores:' + VarToJSON([Value, false]));
end;

procedure TExtAppController.SetFRefs(Value : TExtObjectList); begin
  FRefs := Value;
  Value.DeleteFromGarbage;
  JSCode('refs:' + VarToJSON([Value, false]));
end;

function TExtAppController.JSClassName : string; begin
  Result := 'Ext.app.Controller';
end;

procedure TExtAppController.InitDefaults; begin
  inherited;
  FViews := TExtObjectList.Create(Self, 'views');
  FStores := TExtObjectList.Create(Self, 'stores');
  FRefs := TExtObjectList.Create(Self, 'refs');
end;

{$IFDEF FPC}constructor TExtAppController.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAppController.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtAppController.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtAppController.AddRef(Ref : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addRef(' + VarToJSON([Ref, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.HasRef : TExtFunction; begin
  JSCode(JSName + '.hasRef();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Control(Selectors : String; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.control(' + VarToJSON([Selectors, Listeners, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Control(Selectors : TExtObject; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Control(' + VarToJSON([Selectors, false, Listeners, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetController(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getController(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetStore(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getStore(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetModel(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getModel(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetView(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getView(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

destructor TExtAppController.Destroy; begin
  try
    FViews.Free;
    FStores.Free;
    FRefs.Free;
  except end;
  inherited;
end;

procedure TExtDataTree.SetFOnAppend(Value : TExtDataTreeOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', [], true));
  FOnAppend := Value;
end;

procedure TExtDataTree.SetFOnRemove(Value : TExtDataTreeOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', [], true));
  FOnRemove := Value;
end;

procedure TExtDataTree.SetFOnMove(Value : TExtDataTreeOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', [], true));
  FOnMove := Value;
end;

procedure TExtDataTree.SetFOnInsert(Value : TExtDataTreeOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', [], true));
  FOnInsert := Value;
end;

procedure TExtDataTree.SetFOnBeforeappend(Value : TExtDataTreeOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', [], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataTree.SetFOnBeforeremove(Value : TExtDataTreeOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', [], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataTree.SetFOnBeforemove(Value : TExtDataTreeOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', [], true));
  FOnBeforemove := Value;
end;

procedure TExtDataTree.SetFOnBeforeinsert(Value : TExtDataTreeOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', [], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataTree.SetFOnExpand(Value : TExtDataTreeOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', [], true));
  FOnExpand := Value;
end;

procedure TExtDataTree.SetFOnCollapse(Value : TExtDataTreeOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', [], true));
  FOnCollapse := Value;
end;

procedure TExtDataTree.SetFOnBeforeexpand(Value : TExtDataTreeOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', [], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataTree.SetFOnBeforecollapse(Value : TExtDataTreeOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', [], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataTree.SetFOnSort(Value : TExtDataTreeOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', [], true));
  FOnSort := Value;
end;

procedure TExtDataTree.SetFOnRootchange(Value : TExtDataTreeOnRootchange); begin
  if Assigned(FOnRootchange) then
    JSCode(JSName+'.events ["rootchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('rootchange', Ajax('rootchange', ['Root', '%0.nm'], true));
  FOnRootchange := Value;
end;

function TExtDataTree.JSClassName : string; begin
  Result := 'Ext.data.Tree';
end;

{$IFDEF FPC}constructor TExtDataTree.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataTree.GetNodeById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getNodeById(' + VarToJSON([Id]) + ');', 'TExtDataTree');
  Result := Self;
end;

procedure TExtDataTree.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove()
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove()
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert()
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend()
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove()
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove()
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert()
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand()
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse()
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand()
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse()
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort()
  else if (AEvtName = 'rootchange') and Assigned(FOnRootchange) then
    FOnRootchange(TExtDataModel(ParamAsObject('Root')));
end;

procedure TExtDataTypesSingleton.SetFStripRe(Value : TRegExp); begin
  FStripRe := Value;
  JSCode(JSName + '.stripRe=' + VarToJSON([#3 +Value]) + ';');
end;

function TExtDataTypesSingleton.JSClassName : string; begin
  Result := 'Ext.data.Types';
end;

class function TExtDataTypesSingleton.AUTO : TExtObject;
const
  lAUTO : TExtObject = nil;
begin
  if lAUTO = nil then lAUTO := TExtObject.CreateSingleton('Ext.data.Types.AUTO');
  Result := lAUTO
end;

class function TExtDataTypesSingleton.STRINGJS : TExtObject;
const
  lSTRINGJS : TExtObject = nil;
begin
  if lSTRINGJS = nil then lSTRINGJS := TExtObject.CreateSingleton('Ext.data.Types.STRINGJS');
  Result := lSTRINGJS
end;

class function TExtDataTypesSingleton.INT : TExtObject;
const
  lINT : TExtObject = nil;
begin
  if lINT = nil then lINT := TExtObject.CreateSingleton('Ext.data.Types.INT');
  Result := lINT
end;

class function TExtDataTypesSingleton.FLOAT : TExtObject;
const
  lFLOAT : TExtObject = nil;
begin
  if lFLOAT = nil then lFLOAT := TExtObject.CreateSingleton('Ext.data.Types.FLOAT');
  Result := lFLOAT
end;

class function TExtDataTypesSingleton.BOOL : TExtObject;
const
  lBOOL : TExtObject = nil;
begin
  if lBOOL = nil then lBOOL := TExtObject.CreateSingleton('Ext.data.Types.BOOL');
  Result := lBOOL
end;

class function TExtDataTypesSingleton.DATE : TExtObject;
const
  lDATE : TExtObject = nil;
begin
  if lDATE = nil then lDATE := TExtObject.CreateSingleton('Ext.data.Types.DATE');
  Result := lDATE
end;

class function TExtDataTypesSingleton.BOOLEAN : TExtObject;
const
  lBOOLEAN : TExtObject = nil;
begin
  if lBOOLEAN = nil then lBOOLEAN := TExtObject.CreateSingleton('Ext.data.Types.BOOLEAN');
  Result := lBOOLEAN
end;

class function TExtDataTypesSingleton.INTEGER : TExtObject;
const
  lINTEGER : TExtObject = nil;
begin
  if lINTEGER = nil then lINTEGER := TExtObject.CreateSingleton('Ext.data.Types.INTEGER');
  Result := lINTEGER
end;

class function TExtDataTypesSingleton.NUMBER : TExtObject;
const
  lNUMBER : TExtObject = nil;
begin
  if lNUMBER = nil then lNUMBER := TExtObject.CreateSingleton('Ext.data.Types.NUMBER');
  Result := lNUMBER
end;

{$IFDEF FPC}constructor TExtDataTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataSortTypesSingleton.JSClassName : string; begin
  Result := 'Ext.data.SortTypes';
end;

{$IFDEF FPC}constructor TExtDataSortTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataSortTypesSingleton.None(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.none(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsUCText(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asUCText(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsUCString(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asUCString(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsDate(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asDate(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsFloat(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asFloat(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsInt(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asInt(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

procedure TExtChartAxis.SetFGrid(Value : Boolean); begin
  FGrid := Value;
  JSCode('grid:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFGridTExtObject(Value : TExtObject); begin
  FGridTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('grid:' + VarToJSON([Value, false]));
end;

procedure TExtChartAxis.SetFMajorTickSteps(Value : Integer); begin
  FMajorTickSteps := Value;
  JSCode('majorTickSteps:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFMinorTickSteps(Value : Integer); begin
  FMinorTickSteps := Value;
  JSCode('minorTickSteps:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFDashSize(Value : Integer); begin
  FDashSize := Value;
  JSCode('dashSize:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFLength(Value : Integer); begin
  FLength := Value;
  JSCode('length:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFAdjustEnd(Value : Boolean); begin
  FAdjustEnd := Value;
  JSCode('adjustEnd:' + VarToJSON([Value]));
end;

function TExtChartAxis.JSClassName : string; begin
  Result := 'Ext.chart.axis.Axis';
end;

procedure TExtChartAxis.InitDefaults; begin
  inherited;
  FGridTExtObject := TExtObject.CreateInternal(Self, 'grid');
end;

{$IFDEF FPC}constructor TExtChartAxis.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartAxis.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartAxis.Destroy; begin
  try
    FGridTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtAbstractManager.SetFAll(Value : TExtUtilHashMap); begin
  FAll := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.all=' + VarToJSON([Value, false]) + ';');
end;

function TExtAbstractManager.JSClassName : string; begin
  Result := 'Ext.AbstractManager';
end;

procedure TExtAbstractManager.InitDefaults; begin
  inherited;
  FAll := TExtUtilHashMap.CreateInternal(Self, 'all');
end;

{$IFDEF FPC}constructor TExtAbstractManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAbstractManager.Create; begin
  CreateVarAlt(JSClassName + '.create({});');
  InitDefaults;
end;

function TExtAbstractManager.Get(Id : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Id]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Register(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Item, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Unregister(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Item, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.RegisterType(TypeJS : String; Cls : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.registerType(' + VarToJSON([TypeJS, Cls, true]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.IsRegistered(TypeJS : String) : TExtFunction; begin
  JSCode(JSName + '.isRegistered(' + VarToJSON([TypeJS]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.OnAvailable(Id : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.onAvailable(' + VarToJSON([Id, Fn, true, Scope, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Each(Fn : TExtFunction; FnKey : String; FnValue : Integer; FnLength : Integer; FnReturn : Boolean; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, FnKey, FnValue, FnLength, FnReturn, Scope, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtAbstractManager');
  Result := Self;
end;

destructor TExtAbstractManager.Destroy; begin
  try
    FAll.Free;
  except end;
  inherited;
end;

procedure TExtChartAxisGauge.SetFMinimum(Value : Integer); begin
  FMinimum := Value;
  JSCode('minimum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFMaximum(Value : Integer); begin
  FMaximum := Value;
  JSCode('maximum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFSteps(Value : Integer); begin
  FSteps := Value;
  JSCode('steps:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFMargin(Value : Integer); begin
  FMargin := Value;
  JSCode('margin:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

function TExtChartAxisGauge.JSClassName : string; begin
  Result := 'Ext.chart.axis.Gauge';
end;

{$IFDEF FPC}constructor TExtChartAxisGauge.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartAxisGauge.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtChartAxisGauge');
  Result := Self;
end;

procedure TExtAction.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  if not ConfigAvailable(JSName) then
    SetDisabled(Value)
  else
    JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  if not ConfigAvailable(JSName) then
    SetHidden(Value)
  else
    JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value, nil)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtAction.SetFItemId(Value : String); begin
  FItemId := Value;
  JSCode('itemId:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtAction.SetFIsAction(Value : Boolean); begin
  FIsAction := Value;
  JSCode(JSName + '.isAction=' + VarToJSON([Value]) + ';');
end;

function TExtAction.JSClassName : string; begin
  Result := 'Ext.Action';
end;

procedure TExtAction.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAction.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtAction.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.GetText : TExtFunction; begin
  JSCode(JSName + '.getText();', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.GetIconCls : TExtFunction; begin
  JSCode(JSName + '.getIconCls();', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtAction');
  Result := Self;
end;

function TExtAction.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtAction');
  Result := Self;
end;

function TExtAction.IsDisabled : TExtFunction; begin
  JSCode(JSName + '.isDisabled();', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetHidden(Hidden : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setHidden(' + VarToJSON([Hidden]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Show : TExtFunction; begin
  JSCode(JSName + '.show();', 'TExtAction');
  Result := Self;
end;

function TExtAction.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtAction');
  Result := Self;
end;

function TExtAction.IsHidden : TExtFunction; begin
  JSCode(JSName + '.isHidden();', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetHandler(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Execute(Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.execute(' + VarToJSON(Args) + ');', 'TExtAction');
  Result := Self;
end;

destructor TExtAction.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtChartLabel.SetFLabelJS(Value : TExtObject); begin
  FLabelJS := Value;
  Value.DeleteFromGarbage;
  JSCode('labelJS:' + VarToJSON([Value, false]));
end;

function TExtChartLabel.JSClassName : string; begin
  Result := 'Ext.chart.Label';
end;

procedure TExtChartLabel.InitDefaults; begin
  inherited;
  FLabelJS := TExtObject.CreateInternal(Self, 'labelJS');
end;

{$IFDEF FPC}constructor TExtChartLabel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartLabel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartLabel.Destroy; begin
  try
    FLabelJS.Free;
  except end;
  inherited;
end;

function TExtChartHighlight.JSClassName : string; begin
  Result := 'Ext.chart.Highlight';
end;

{$IFDEF FPC}constructor TExtChartHighlight.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartHighlight.HighlightItem(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Item, false]) + ');', 'TExtChartHighlight');
  Result := Self;
end;

function TExtChartHighlight.UnHighlightItem : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem();', 'TExtChartHighlight');
  Result := Self;
end;

function TExtChartCallout.JSClassName : string; begin
  Result := 'Ext.chart.Callout';
end;

{$IFDEF FPC}constructor TExtChartCallout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataResultSet.SetFLoaded(Value : Boolean); begin
  FLoaded := Value;
  JSCode('loaded:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFCount(Value : Integer); begin
  FCount := Value;
  JSCode('count:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFTotal(Value : Integer); begin
  FTotal := Value;
  JSCode('total:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFSuccess(Value : Boolean); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFRecords(Value : TExtObjectList); begin
  FRecords := Value;
  Value.DeleteFromGarbage;
  JSCode('records:' + VarToJSON([Value, false]));
end;

procedure TExtDataResultSet.SetFTotalRecords(Value : Integer); begin
  FTotalRecords := Value;
  JSCode(JSName + '.totalRecords=' + VarToJSON([Value]) + ';');
end;

function TExtDataResultSet.JSClassName : string; begin
  Result := 'Ext.data.ResultSet';
end;

procedure TExtDataResultSet.InitDefaults; begin
  inherited;
  FRecords := TExtObjectList.Create(Self, 'records');
end;

{$IFDEF FPC}constructor TExtDataResultSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataResultSet.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataResultSet.Destroy; begin
  try
    FRecords.Free;
  except end;
  inherited;
end;

procedure TExtDataRequest.SetFAction(Value : String); begin
  FAction := Value;
  JSCode('action:' + VarToJSON([Value]));
end;

procedure TExtDataRequest.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtDataRequest.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtDataRequest.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

function TExtDataRequest.JSClassName : string; begin
  Result := 'Ext.data.Request';
end;

procedure TExtDataRequest.InitDefaults; begin
  inherited;
  FParams := TExtObject.CreateInternal(Self, 'params');
end;

{$IFDEF FPC}constructor TExtDataRequest.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataRequest.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtDataRequest.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtDataRequest.Destroy; begin
  try
    FParams.Free;
  except end;
  inherited;
end;

procedure TExtAbstractPlugin.SetFPluginId(Value : String); begin
  FPluginId := Value;
  JSCode('pluginId:' + VarToJSON([Value]));
end;

function TExtAbstractPlugin.JSClassName : string; begin
  Result := 'Ext.AbstractPlugin';
end;

{$IFDEF FPC}constructor TExtAbstractPlugin.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAbstractPlugin.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtAbstractPlugin');
  Result := Self;
end;

procedure TExtAjaxSingleton.SetFDisableCaching(Value : Boolean); begin
  FDisableCaching := Value;
  JSCode(JSName + '.disableCaching=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode(JSName + '.url=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.extraParams=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAjaxSingleton.SetFDefaultHeaders(Value : TExtObject); begin
  FDefaultHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.defaultHeaders=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAjaxSingleton.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode(JSName + '.method=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode(JSName + '.timeout=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFAutoAbort(Value : Boolean); begin
  FAutoAbort := Value;
  JSCode(JSName + '.autoAbort=' + VarToJSON([Value]) + ';');
end;

function TExtAjaxSingleton.JSClassName : string; begin
  Result := 'Ext.Ajax';
end;

procedure TExtAjaxSingleton.InitDefaults; begin
  inherited;
  FDisableCaching := true;
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
  FDefaultHeaders := TExtObject.CreateInternal(Self, 'defaultHeaders');
  FTimeout := 30000;
end;

{$IFDEF FPC}constructor TExtAjaxSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

destructor TExtAjaxSingleton.Destroy; begin
  try
    FExtraParams.Free;
    FDefaultHeaders.Free;
  except end;
  inherited;
end;

procedure TExtLayoutContainer.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainer.SetFManageOverflow(Value : Integer); begin
  FManageOverflow := Value;
  JSCode('manageOverflow:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainer.SetFReserveScrollbar(Value : Boolean); begin
  FReserveScrollbar := Value;
  JSCode('reserveScrollbar:' + VarToJSON([Value]));
end;

function TExtLayoutContainer.JSClassName : string; begin
  Result := 'Ext.layout.container.Container';
end;

{$IFDEF FPC}constructor TExtLayoutContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainer.GetLayoutItems : TExtFunction; begin
  JSCode(JSName + '.getLayoutItems();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.GetRenderTarget : TExtFunction; begin
  JSCode(JSName + '.getRenderTarget();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.GetElementTarget : TExtFunction; begin
  JSCode(JSName + '.getElementTarget();', 'TExtLayoutContainer');
  Result := Self;
end;

procedure TExtComponentLoader.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtComponentLoader.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFLoadMask(Value : Boolean); begin
  FLoadMask := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFLoadMaskTExtObject(Value : TExtObject); begin
  FLoadMaskTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('loadMask:' + VarToJSON([Value, false]));
end;

procedure TExtComponentLoader.SetFScripts(Value : Boolean); begin
  FScripts := Value;
  JSCode('scripts:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFRenderer(Value : String); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFRendererTExtFunction(Value : TExtFunction); begin
  FRendererTExtFunction := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

function TExtComponentLoader.JSClassName : string; begin
  Result := 'Ext.ComponentLoader';
end;

procedure TExtComponentLoader.InitDefaults; begin
  inherited;
  FTarget := TExtComponent.CreateInternal(Self, 'target');
  FLoadMaskTExtObject := TExtObject.CreateInternal(Self, 'loadMask');
end;

{$IFDEF FPC}constructor TExtComponentLoader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtComponentLoader.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtComponentLoader.SetTarget(Target : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([Target]) + ');', 'TExtComponentLoader');
  Result := Self;
end;

function TExtComponentLoader.SetTarget(Target : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtComponentLoader');
  Result := Self;
end;

destructor TExtComponentLoader.Destroy; begin
  try
    FTarget.Free;
    FLoadMaskTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtModelManagerSingleton.SetFAssociationStack(Value : TExtObjectList); begin
  FAssociationStack := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.associationStack=' + VarToJSON([Value, false]) + ';');
end;

function TExtModelManagerSingleton.JSClassName : string; begin
  Result := 'Ext.ModelManager';
end;

procedure TExtModelManagerSingleton.InitDefaults; begin
  inherited;
  FAssociationStack := TExtObjectList.Create(Self, 'associationStack');
end;

{$IFDEF FPC}constructor TExtModelManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtModelManagerSingleton.GetModel(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getModel(' + VarToJSON([Id]) + ');', 'TExtModelManagerSingleton');
  Result := Self;
end;

function TExtModelManagerSingleton.GetModel(Id : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.GetModel(' + VarToJSON([Id, false]) + ');', 'TExtModelManagerSingleton');
  Result := Self;
end;

constructor TExtModelManagerSingleton.Create(Data : TExtObject; Name : String; Id : Integer = 0); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Data, false, Name, Id]) + ');');
  InitDefaults;
end;

destructor TExtModelManagerSingleton.Destroy; begin
  try
    FAssociationStack.Free;
  except end;
  inherited;
end;

procedure TExtChartSeriesRadar.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesRadar.JSClassName : string; begin
  Result := 'Ext.chart.series.Radar';
end;

procedure TExtChartSeriesRadar.InitDefaults; begin
  inherited;
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesRadar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesRadar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesRadar.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesRadar');
  Result := Self;
end;

destructor TExtChartSeriesRadar.Destroy; begin
  try
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtPanelHeader.SetFTitleAlign(Value : String); begin
  FTitleAlign := Value;
  JSCode('titleAlign:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFOnClick(Value : TExtPanelHeaderOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtPanelHeader.SetFOnDblclick(Value : TExtPanelHeaderOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDblclick := Value;
end;

function TExtPanelHeader.JSClassName : string; begin
  Result := 'Ext.panel.Header';
end;

{$IFDEF FPC}constructor TExtPanelHeader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPanelHeader.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.AddTool(Tool : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addTool(' + VarToJSON([Tool, false]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

procedure TExtPanelHeader.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtPanelHeader(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick(TExtPanelHeader(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtMenuItem.SetFActiveCls(Value : String); begin
  FActiveCls := Value;
  JSCode('activeCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFCanActivate(Value : Boolean); begin
  FCanActivate := Value;
  JSCode('canActivate:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFClickHideDelay(Value : Integer); begin
  FClickHideDelay := Value;
  JSCode('clickHideDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFDestroyMenu(Value : Boolean); begin
  FDestroyMenu := Value;
  JSCode('destroyMenu:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFDisabledCls(Value : String); begin
  FDisabledCls := Value;
  JSCode('disabledCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHref(Value : String); begin
  FHref := Value;
  JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetMenu(Value)
  else
    JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFMenuTExtObject(Value : TExtObject); begin
  FMenuTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFMenuAlign(Value : String); begin
  FMenuAlign := Value;
  JSCode('menuAlign:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenuExpandDelay(Value : Integer); begin
  FMenuExpandDelay := Value;
  JSCode('menuExpandDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenuHideDelay(Value : Integer); begin
  FMenuHideDelay := Value;
  JSCode('menuHideDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFTooltip(Value : String); begin
  FTooltip := Value;
  if not ConfigAvailable(JSName) then
    SetTooltip(Value)
  else
    JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFTooltipTExtObject(Value : TExtObject); begin
  FTooltipTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtMenuItem.SetFOnActivate(Value : TExtMenuItemOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['Item', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtMenuItem.SetFOnClick(Value : TExtMenuItemOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['Item', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtMenuItem.SetFOnDeactivate(Value : TExtMenuItemOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['Item', '%0.nm'], true));
  FOnDeactivate := Value;
end;

function TExtMenuItem.JSClassName : string; begin
  Result := 'Ext.menu.Item';
end;

procedure TExtMenuItem.InitDefaults; begin
  inherited;
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
  FMenuTExtObject := TExtObject.CreateInternal(Self, 'menu');
  FTooltipTExtObject := TExtObject.CreateInternal(Self, 'tooltip');
end;

{$IFDEF FPC}constructor TExtMenuItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuItem.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenuItem.SetMenu(Menu : TExtMenu; DestroyMenu : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setMenu(' + VarToJSON([Menu, false, DestroyMenu]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetMenu(Menu : TExtObject; DestroyMenu : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetMenu(' + VarToJSON([Menu, false, DestroyMenu]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetHandler(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetIconCls(IconCls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([IconCls]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetTooltip(Tooltip : String) : TExtFunction; begin
  JSCode(JSName + '.setTooltip(' + VarToJSON([Tooltip]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetTooltip(Tooltip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetTooltip(' + VarToJSON([Tooltip, false]) + ');', 'TExtMenuItem');
  Result := Self;
end;

destructor TExtMenuItem.Destroy; begin
  try
    FMenu.Free;
    FMenuTExtObject.Free;
    FTooltipTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtMenuItem.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtMenuItem(ParamAsObject('Item')))
  else if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtMenuItem(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtMenuItem(ParamAsObject('Item')));
end;

procedure TExtAppApplication.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFControllers(Value : TExtObjectList); begin
  FControllers := Value;
  Value.DeleteFromGarbage;
  JSCode('controllers:' + VarToJSON([Value, false]));
end;

procedure TExtAppApplication.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtAppApplication.SetFEnableQuickTips(Value : Boolean); begin
  FEnableQuickTips := Value;
  JSCode('enableQuickTips:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFAppFolder(Value : String); begin
  FAppFolder := Value;
  JSCode('appFolder:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFAutoCreateViewport(Value : Boolean); begin
  FAutoCreateViewport := Value;
  JSCode('autoCreateViewport:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFPaths(Value : TExtObject); begin
  FPaths := Value;
  Value.DeleteFromGarbage;
  JSCode('paths:' + VarToJSON([Value, false]));
end;

function TExtAppApplication.JSClassName : string; begin
  Result := 'Ext.app.Application';
end;

procedure TExtAppApplication.InitDefaults; begin
  inherited;
  FControllers := TExtObjectList.Create(Self, 'controllers');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FPaths := TExtObject.CreateInternal(Self, 'paths');
end;

{$IFDEF FPC}constructor TExtAppApplication.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAppApplication.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtAppApplication.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtAppApplication.Destroy; begin
  try
    FControllers.Free;
    FScope.Free;
    FPaths.Free;
  except end;
  inherited;
end;

procedure TExtLoadMask.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtLoadMask.SetFMsg(Value : String); begin
  FMsg := Value;
  JSCode('msg:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFMsgCls(Value : String); begin
  FMsgCls := Value;
  JSCode('msgCls:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFMaskCls(Value : String); begin
  FMaskCls := Value;
  JSCode('maskCls:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFUseMsg(Value : Boolean); begin
  FUseMsg := Value;
  JSCode('useMsg:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFUseTargetEl(Value : Boolean); begin
  FUseTargetEl := Value;
  JSCode('useTargetEl:' + VarToJSON([Value]));
end;

function TExtLoadMask.JSClassName : string; begin
  Result := 'Ext.LoadMask';
end;

procedure TExtLoadMask.InitDefaults; begin
  inherited;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtLoadMask.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLoadMask.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtLoadMask.Create(Comp : TExtComponent; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Comp, false, Config, false]) + ');');
  InitDefaults;
end;

function TExtLoadMask.BindStore(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

destructor TExtLoadMask.Destroy; begin
  try
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtMenu.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFAllowOtherMenus(Value : Boolean); begin
  FAllowOtherMenus := Value;
  JSCode('allowOtherMenus:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFDefaultAlign(Value : String); begin
  FDefaultAlign := Value;
  JSCode('defaultAlign:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFFloating(Value : Boolean); begin
  FFloating := Value;
  JSCode('floating:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFIgnoreParentClicks(Value : Boolean); begin
  FIgnoreParentClicks := Value;
  JSCode('ignoreParentClicks:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFLayoutTExtObject(Value : TExtObject); begin
  FLayoutTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtMenu.SetFShowSeparator(Value : Boolean); begin
  FShowSeparator := Value;
  JSCode('showSeparator:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFOnClick(Value : TExtMenuOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['Menu', '%0.nm','Item', '%1.nm','E', '%2.nm'], true));
  FOnClick := Value;
end;

procedure TExtMenu.SetFOnMouseenter(Value : TExtMenuOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', ['Menu', '%0.nm','E', '%1.nm'], true));
  FOnMouseenter := Value;
end;

procedure TExtMenu.SetFOnMouseleave(Value : TExtMenuOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', ['Menu', '%0.nm','E', '%1.nm'], true));
  FOnMouseleave := Value;
end;

procedure TExtMenu.SetFOnMouseover(Value : TExtMenuOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['Menu', '%0.nm','Item', '%1.nm','E', '%2.nm'], true));
  FOnMouseover := Value;
end;

function TExtMenu.JSClassName : string; begin
  Result := 'Ext.menu.Menu';
end;

procedure TExtMenu.InitDefaults; begin
  inherited;
  FHidden := true;
  FLayoutTExtObject := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtMenu.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenu.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenu.CanActivateItem : TExtFunction; begin
  JSCode(JSName + '.canActivateItem();', 'TExtMenu');
  Result := Self;
end;

function TExtMenu.DeactivateActiveItem : TExtFunction; begin
  JSCode(JSName + '.deactivateActiveItem();', 'TExtMenu');
  Result := Self;
end;

function TExtMenu.ShowBy(Component : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.showBy(' + VarToJSON([Component, false, Position, Offsets]) + ');', 'TExtMenu');
  Result := Self;
end;

function TExtMenu.ShowBy(Component : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([Component, false, Position, Offsets]) + ');', 'TExtMenu');
  Result := Self;
end;

destructor TExtMenu.Destroy; begin
  try
    FLayoutTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtMenu.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtMenu(ParamAsObject('Menu')), TExtComponent(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter(TExtMenu(ParamAsObject('Menu')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave(TExtMenu(ParamAsObject('Menu')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtMenu(ParamAsObject('Menu')), TExtComponent(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtViewBoundListKeyNav.SetFBoundList(Value : TExtViewBoundList); begin
  FBoundList := Value;
  Value.DeleteFromGarbage;
  JSCode('boundList:' + VarToJSON([Value, false]));
end;

function TExtViewBoundListKeyNav.JSClassName : string; begin
  Result := 'Ext.view.BoundListKeyNav';
end;

procedure TExtViewBoundListKeyNav.InitDefaults; begin
  inherited;
  FBoundList := TExtViewBoundList.CreateInternal(Self, 'boundList');
end;

{$IFDEF FPC}constructor TExtViewBoundListKeyNav.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtViewBoundListKeyNav.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtViewBoundListKeyNav.HighlightAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.highlightAt(' + VarToJSON([Index]) + ');', 'TExtViewBoundListKeyNav');
  Result := Self;
end;

function TExtViewBoundListKeyNav.SelectHighlighted : TExtFunction; begin
  JSCode(JSName + '.selectHighlighted();', 'TExtViewBoundListKeyNav');
  Result := Self;
end;

destructor TExtViewBoundListKeyNav.Destroy; begin
  try
    FBoundList.Free;
  except end;
  inherited;
end;

function TExtGridFeatureSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.Summary';
end;

{$IFDEF FPC}constructor TExtGridFeatureSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridHeaderContainer.SetFWeight(Value : Integer); begin
  FWeight := Value;
  JSCode('weight:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFDefaultWidth(Value : Integer); begin
  FDefaultWidth := Value;
  JSCode('defaultWidth:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFSealed(Value : Boolean); begin
  FSealed := Value;
  JSCode('sealed:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFSortable(Value : Boolean); begin
  FSortable := Value;
  JSCode('sortable:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFOnColumnresize(Value : TExtGridHeaderContainerOnColumnresize); begin
  if Assigned(FOnColumnresize) then
    JSCode(JSName+'.events ["columnresize"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnresize', Ajax('columnresize', ['Ct', '%0.nm','Column', '%1.nm','Width', '%2'], true));
  FOnColumnresize := Value;
end;

procedure TExtGridHeaderContainer.SetFOnHeaderclick(Value : TExtGridHeaderContainerOnHeaderclick); begin
  if Assigned(FOnHeaderclick) then
    JSCode(JSName+'.events ["headerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headerclick', Ajax('headerclick', ['Ct', '%0.nm','Column', '%1.nm','E', '%2.nm','T', '%3.nm'], true));
  FOnHeaderclick := Value;
end;

procedure TExtGridHeaderContainer.SetFOnHeadertriggerclick(Value : TExtGridHeaderContainerOnHeadertriggerclick); begin
  if Assigned(FOnHeadertriggerclick) then
    JSCode(JSName+'.events ["headertriggerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headertriggerclick', Ajax('headertriggerclick', ['Ct', '%0.nm','Column', '%1.nm','E', '%2.nm','T', '%3.nm'], true));
  FOnHeadertriggerclick := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnmove(Value : TExtGridHeaderContainerOnColumnmove); begin
  if Assigned(FOnColumnmove) then
    JSCode(JSName+'.events ["columnmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnmove', Ajax('columnmove', ['Ct', '%0.nm','Column', '%1.nm','FromIdx', '%2','ToIdx', '%3'], true));
  FOnColumnmove := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnhide(Value : TExtGridHeaderContainerOnColumnhide); begin
  if Assigned(FOnColumnhide) then
    JSCode(JSName+'.events ["columnhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnhide', Ajax('columnhide', ['Ct', '%0.nm','Column', '%1.nm'], true));
  FOnColumnhide := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnshow(Value : TExtGridHeaderContainerOnColumnshow); begin
  if Assigned(FOnColumnshow) then
    JSCode(JSName+'.events ["columnshow"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnshow', Ajax('columnshow', ['Ct', '%0.nm','Column', '%1.nm'], true));
  FOnColumnshow := Value;
end;

procedure TExtGridHeaderContainer.SetFOnSortchange(Value : TExtGridHeaderContainerOnSortchange); begin
  if Assigned(FOnSortchange) then
    JSCode(JSName+'.events ["sortchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('sortchange', Ajax('sortchange', ['Ct', '%0.nm','Column', '%1.nm','Direction', '%2'], true));
  FOnSortchange := Value;
end;

procedure TExtGridHeaderContainer.SetFOnMenucreate(Value : TExtGridHeaderContainerOnMenucreate); begin
  if Assigned(FOnMenucreate) then
    JSCode(JSName+'.events ["menucreate"].listeners=[];');
  if Assigned(Value) then
    AddListener('menucreate', Ajax('menucreate', ['Ct', '%0.nm','Menu', '%1.nm'], true));
  FOnMenucreate := Value;
end;

function TExtGridHeaderContainer.JSClassName : string; begin
  Result := 'Ext.grid.header.Container';
end;

{$IFDEF FPC}constructor TExtGridHeaderContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridHeaderContainer.GetMenuItems : TExtFunction; begin
  JSCode(JSName + '.getMenuItems();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetColumnMenu : TExtFunction; begin
  JSCode(JSName + '.getColumnMenu();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetColumnCount : TExtFunction; begin
  JSCode(JSName + '.getColumnCount();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetFullWidth : TExtFunction; begin
  JSCode(JSName + '.getFullWidth();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetVisibleGridColumns(RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getVisibleGridColumns(' + VarToJSON([RefreshCache]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetGridColumns(RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getGridColumns(' + VarToJSON([RefreshCache]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetHeaderIndex(Header : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.getHeaderIndex(' + VarToJSON([Header, false]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetHeaderAtIndex(The : Integer) : TExtFunction; begin
  JSCode(JSName + '.getHeaderAtIndex(' + VarToJSON([The]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetVisibleHeaderClosestToIndex(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getVisibleHeaderClosestToIndex(' + VarToJSON([Index]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.PrepareData : TExtFunction; begin
  JSCode(JSName + '.prepareData();', 'TExtGridHeaderContainer');
  Result := Self;
end;

procedure TExtGridHeaderContainer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'columnresize') and Assigned(FOnColumnresize) then
    FOnColumnresize(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsInteger('Width'))
  else if (AEvtName = 'headerclick') and Assigned(FOnHeaderclick) then
    FOnHeaderclick(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'headertriggerclick') and Assigned(FOnHeadertriggerclick) then
    FOnHeadertriggerclick(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'columnmove') and Assigned(FOnColumnmove) then
    FOnColumnmove(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsInteger('FromIdx'), ParamAsInteger('ToIdx'))
  else if (AEvtName = 'columnhide') and Assigned(FOnColumnhide) then
    FOnColumnhide(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')))
  else if (AEvtName = 'columnshow') and Assigned(FOnColumnshow) then
    FOnColumnshow(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')))
  else if (AEvtName = 'sortchange') and Assigned(FOnSortchange) then
    FOnSortchange(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsString('Direction'))
  else if (AEvtName = 'menucreate') and Assigned(FOnMenucreate) then
    FOnMenucreate(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtMenu(ParamAsObject('Menu')));
end;

procedure TExtGridFeatureGroupingSummary.SetFRemoteRoot(Value : String); begin
  FRemoteRoot := Value;
  JSCode('remoteRoot:' + VarToJSON([Value]));
end;

function TExtGridFeatureGroupingSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.GroupingSummary';
end;

{$IFDEF FPC}constructor TExtGridFeatureGroupingSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtContainerViewport.SetFIsViewport(Value : Boolean); begin
  FIsViewport := Value;
  JSCode(JSName + '.isViewport=' + VarToJSON([Value]) + ';');
end;

function TExtContainerViewport.JSClassName : string; begin
  Result := 'Ext.container.Viewport';
end;

{$IFDEF FPC}constructor TExtContainerViewport.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtViewTable.SetFFirstCls(Value : String); begin
  FFirstCls := Value;
  JSCode('firstCls:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFLastCls(Value : String); begin
  FLastCls := Value;
  JSCode('lastCls:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFStripeRows(Value : Boolean); begin
  FStripeRows := Value;
  JSCode('stripeRows:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFMarkDirty(Value : Boolean); begin
  FMarkDirty := Value;
  JSCode('markDirty:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFEnableTextSelection(Value : Boolean); begin
  FEnableTextSelection := Value;
  JSCode('enableTextSelection:' + VarToJSON([Value]));
end;

function TExtViewTable.JSClassName : string; begin
  Result := 'Ext.view.Table';
end;

{$IFDEF FPC}constructor TExtViewTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewTable.GetFeature(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getFeature(' + VarToJSON([Id]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetTableChunker : TExtFunction; begin
  JSCode(JSName + '.getTableChunker();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : String; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : Integer; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : String; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : Integer; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.focusRow(' + VarToJSON([RowIdx, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : String) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : Integer) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.Refresh : TExtFunction; begin
  JSCode(JSName + '.refresh();', 'TExtViewTable');
  Result := Self;
end;

procedure TExtContainerButtonGroup.SetFColumns(Value : Integer); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFLayout(Value : TExtObject); begin
  FLayout := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtContainerButtonGroup.SetFFrame(Value : Boolean); begin
  FFrame := Value;
  JSCode('frame:' + VarToJSON([Value]));
end;

function TExtContainerButtonGroup.JSClassName : string; begin
  Result := 'Ext.container.ButtonGroup';
end;

procedure TExtContainerButtonGroup.InitDefaults; begin
  inherited;
  FLayout := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtContainerButtonGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtContainerButtonGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtContainerButtonGroup.Destroy; begin
  try
    FLayout.Free;
  except end;
  inherited;
end;

function TExtGridProperty.JSClassName : string; begin
  Result := 'Ext.grid.property.Property';
end;

{$IFDEF FPC}constructor TExtGridProperty.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtComponentManagerSingleton.JSClassName : string; begin
  Result := 'Ext.ComponentManager';
end;

{$IFDEF FPC}constructor TExtComponentManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtComponentManagerSingleton.Create(Config : TExtObject; DefaultType : String = ''); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, DefaultType]) + ');');
  InitDefaults;
end;

procedure TExtImg.SetFSrc(Value : String); begin
  FSrc := Value;
  if not ConfigAvailable(JSName) then
    SetSrc(Value)
  else
    JSCode('src:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFAlt(Value : String); begin
  FAlt := Value;
  JSCode('alt:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFImgCls(Value : String); begin
  FImgCls := Value;
  JSCode('imgCls:' + VarToJSON([Value]));
end;

function TExtImg.JSClassName : string; begin
  Result := 'Ext.Img';
end;

{$IFDEF FPC}constructor TExtImg.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtImg.SetSrc(Src : String) : TExtFunction; begin
  JSCode(JSName + '.setSrc(' + VarToJSON([Src]) + ');', 'TExtImg');
  Result := Self;
end;

procedure TExtGridPluginHeaderResizer.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

function TExtGridPluginHeaderResizer.JSClassName : string; begin
  Result := 'Ext.grid.plugin.HeaderResizer';
end;

{$IFDEF FPC}constructor TExtGridPluginHeaderResizer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtViewBoundList.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFTplTExtXTemplate(Value : TExtXTemplate); begin
  FTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

function TExtViewBoundList.JSClassName : string; begin
  Result := 'Ext.view.BoundList';
end;

procedure TExtViewBoundList.InitDefaults; begin
  inherited;
  FTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtViewBoundList.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtViewBoundList.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtViewBoundList.GetInnerTpl(DisplayField : String) : TExtFunction; begin
  JSCode(JSName + '.getInnerTpl(' + VarToJSON([DisplayField]) + ');', 'TExtViewBoundList');
  Result := Self;
end;

destructor TExtViewBoundList.Destroy; begin
  try
    FTplTExtXTemplate.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginDragDrop.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFDragGroup(Value : String); begin
  FDragGroup := Value;
  JSCode('dragGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFDropGroup(Value : String); begin
  FDropGroup := Value;
  JSCode('dropGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFEnableDrop(Value : Boolean); begin
  FEnableDrop := Value;
  JSCode('enableDrop:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFEnableDrag(Value : Boolean); begin
  FEnableDrag := Value;
  JSCode('enableDrag:' + VarToJSON([Value]));
end;

function TExtGridPluginDragDrop.JSClassName : string; begin
  Result := 'Ext.grid.plugin.DragDrop';
end;

{$IFDEF FPC}constructor TExtGridPluginDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginEditing.SetFClicksToEdit(Value : Integer); begin
  FClicksToEdit := Value;
  JSCode('clicksToEdit:' + VarToJSON([Value]));
end;

procedure TExtGridPluginEditing.SetFTriggerEvent(Value : String); begin
  FTriggerEvent := Value;
  JSCode('triggerEvent:' + VarToJSON([Value]));
end;

procedure TExtGridPluginEditing.SetFOnBeforeedit(Value : TExtGridPluginEditingOnBeforeedit); begin
  if Assigned(FOnBeforeedit) then
    JSCode(JSName+'.events ["beforeedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeedit', Ajax('beforeedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnBeforeedit := Value;
end;

procedure TExtGridPluginEditing.SetFOnEdit(Value : TExtGridPluginEditingOnEdit); begin
  if Assigned(FOnEdit) then
    JSCode(JSName+'.events ["edit"].listeners=[];');
  if Assigned(Value) then
    AddListener('edit', Ajax('edit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnEdit := Value;
end;

procedure TExtGridPluginEditing.SetFOnValidateedit(Value : TExtGridPluginEditingOnValidateedit); begin
  if Assigned(FOnValidateedit) then
    JSCode(JSName+'.events ["validateedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('validateedit', Ajax('validateedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnValidateedit := Value;
end;

procedure TExtGridPluginEditing.SetFOnCanceledit(Value : TExtGridPluginEditingOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnCanceledit := Value;
end;

function TExtGridPluginEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.Editing';
end;

{$IFDEF FPC}constructor TExtGridPluginEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, ColumnHeader, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, ColumnHeader]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, false, ColumnHeader]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.CancelEdit : TExtFunction; begin
  JSCode(JSName + '.cancelEdit();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.CompleteEdit : TExtFunction; begin
  JSCode(JSName + '.completeEdit();', 'TExtGridPluginEditing');
  Result := Self;
end;

procedure TExtGridPluginEditing.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeedit') and Assigned(FOnBeforeedit) then
    FOnBeforeedit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'edit') and Assigned(FOnEdit) then
    FOnEdit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'validateedit') and Assigned(FOnValidateedit) then
    FOnValidateedit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')));
end;

procedure TExtTip.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFShadow(Value : Boolean); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFShadowString(Value : String); begin
  FShadowString := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFDefaultAlign(Value : String); begin
  FDefaultAlign := Value;
  JSCode('defaultAlign:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFConstrainPosition(Value : Boolean); begin
  FConstrainPosition := Value;
  JSCode('constrainPosition:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFCloseAction(Value : String); begin
  FCloseAction := Value;
  JSCode('closeAction:' + VarToJSON([Value]));
end;

function TExtTip.JSClassName : string; begin
  Result := 'Ext.tip.Tip';
end;

{$IFDEF FPC}constructor TExtTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTip.ShowAt(Xy : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.showAt(' + VarToJSON([Xy]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : String; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.showBy(' + VarToJSON([El, Position]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : THTMLElement; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([El, false, Position]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : TExtElement; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([El, false, Position]) + ');', 'TExtTip');
  Result := Self;
end;

procedure TExtChartAxisCategory.SetFCategoryNames(Value : String); begin
  FCategoryNames := Value;
  JSCode(JSName + '.categoryNames=' + VarToJSON([Value]) + ';');
end;

function TExtChartAxisCategory.JSClassName : string; begin
  Result := 'Ext.chart.axis.Category';
end;

{$IFDEF FPC}constructor TExtChartAxisCategory.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtToolbar.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFLayoutTExtObject(Value : TExtObject); begin
  FLayoutTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtToolbar.SetFEnableOverflow(Value : Boolean); begin
  FEnableOverflow := Value;
  JSCode('enableOverflow:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFMenuTriggerCls(Value : String); begin
  FMenuTriggerCls := Value;
  JSCode('menuTriggerCls:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFOnOverflowchange(Value : TExtToolbarOnOverflowchange); begin
  if Assigned(FOnOverflowchange) then
    JSCode(JSName+'.events ["overflowchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('overflowchange', Ajax('overflowchange', ['C', '%0.nm','LastOverflow', '%1'], true));
  FOnOverflowchange := Value;
end;

function TExtToolbar.JSClassName : string; begin
  Result := 'Ext.toolbar.Toolbar';
end;

procedure TExtToolbar.InitDefaults; begin
  inherited;
  FLayoutTExtObject := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtToolbar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtToolbar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtToolbar.PrivateLookupComponent(Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.// private lookupComponent(' + VarToJSON(Args) + ');', 'TExtToolbar');
  Result := Self;
end;

destructor TExtToolbar.Destroy; begin
  try
    FLayoutTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtToolbar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'overflowchange') and Assigned(FOnOverflowchange) then
    FOnOverflowchange(TExtObject(ParamAsObject('C')), ParamAsBoolean('LastOverflow'));
end;

function TExtUtilPoint.JSClassName : string; begin
  Result := 'Ext.util.Point';
end;

{$IFDEF FPC}constructor TExtUtilPoint.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilPoint.FromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.fromEvent(' + VarToJSON([E, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

constructor TExtUtilPoint.Create(X : Integer; Y : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([X, Y]) + ');');
  InitDefaults;
end;

function TExtUtilPoint.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.Equals(The : TExtUtilPoint) : TExtFunction; begin
  JSCode(JSName + '.equals(' + VarToJSON([The, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.Equals(The : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Equals(' + VarToJSON([The, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtUtilPoint; Threshold : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isWithin(' + VarToJSON([P, false, Threshold, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtObject; Threshold : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtObject; Threshold : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtUtilPoint; Threshold : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.RoundedEquals(P : TExtUtilPoint) : TExtFunction; begin
  JSCode(JSName + '.roundedEquals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.RoundedEquals(P : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.RoundedEquals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtStateLocalStorageProvider.JSClassName : string; begin
  Result := 'Ext.state.LocalStorageProvider';
end;

{$IFDEF FPC}constructor TExtStateLocalStorageProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartSeriesCartesian.SetFAxis(Value : String); begin
  FAxis := Value;
  JSCode('axis:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesCartesian.SetFAxisTExtObjectList(Value : TExtObjectList); begin
  FAxisTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('axis:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesCartesian.JSClassName : string; begin
  Result := 'Ext.chart.series.Cartesian';
end;

procedure TExtChartSeriesCartesian.InitDefaults; begin
  inherited;
  FAxisTExtObjectList := TExtObjectList.Create(Self, 'axis');
end;

{$IFDEF FPC}constructor TExtChartSeriesCartesian.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesCartesian.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesCartesian.GetMinMaxXValues : TExtFunction; begin
  JSCode(JSName + '.getMinMaxXValues();', 'TExtChartSeriesCartesian');
  Result := Self;
end;

function TExtChartSeriesCartesian.GetMinMaxYValues : TExtFunction; begin
  JSCode(JSName + '.getMinMaxYValues();', 'TExtChartSeriesCartesian');
  Result := Self;
end;

destructor TExtChartSeriesCartesian.Destroy; begin
  try
    FAxisTExtObjectList.Free;
  except end;
  inherited;
end;

procedure TExtTabPanel.SetFTabPosition(Value : String); begin
  FTabPosition := Value;
  JSCode('tabPosition:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveItem(Value : String); begin
  FActiveItem := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveItemInteger(Value : Integer); begin
  FActiveItemInteger := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveTab(Value : String); begin
  FActiveTab := Value;
  if not ConfigAvailable(JSName) then
    SetActiveTab(Value)
  else
    JSCode('activeTab:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveTabInteger(Value : Integer); begin
  FActiveTabInteger := Value;
  JSCode('activeTab:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveTabTExtComponent(Value : TExtComponent); begin
  FActiveTabTExtComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('activeTab:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFTabBar(Value : TExtObject); begin
  FTabBar := Value;
  Value.DeleteFromGarbage;
  JSCode('tabBar:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFLayout(Value : TExtObject); begin
  FLayout := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFRemovePanelHeader(Value : Boolean); begin
  FRemovePanelHeader := Value;
  JSCode('removePanelHeader:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFMinTabWidth(Value : Integer); begin
  FMinTabWidth := Value;
  JSCode('minTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFMaxTabWidth(Value : Integer); begin
  FMaxTabWidth := Value;
  JSCode('maxTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFDeferredRender(Value : Boolean); begin
  FDeferredRender := Value;
  JSCode('deferredRender:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFTabBar_(Value : TExtTabBar); begin
  FTabBar_ := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.tabBar=' + VarToJSON([Value, false]) + ';');
end;

function TExtTabPanel.JSClassName : string; begin
  Result := 'Ext.tab.Panel';
end;

procedure TExtTabPanel.InitDefaults; begin
  inherited;
  FActiveTabTExtComponent := TExtComponent.CreateInternal(Self, 'activeTab');
  FTabBar := TExtObject.CreateInternal(Self, 'tabBar');
  FLayout := TExtObject.CreateInternal(Self, 'layout');
  FTabBar_ := TExtTabBar.CreateInternal(Self, 'tabBar');
end;

{$IFDEF FPC}constructor TExtTabPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTabPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTabPanel.SetActiveTab(Card : String) : TExtFunction; begin
  JSCode(JSName + '.setActiveTab(' + VarToJSON([Card]) + ');', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.SetActiveTab(Card : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetActiveTab(' + VarToJSON([Card]) + ');', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.SetActiveTab(Card : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.SetActiveTab(' + VarToJSON([Card, false]) + ');', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.GetActiveTab : TExtFunction; begin
  JSCode(JSName + '.getActiveTab();', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.GetTabBar : TExtFunction; begin
  JSCode(JSName + '.getTabBar();', 'TExtTabPanel');
  Result := Self;
end;

destructor TExtTabPanel.Destroy; begin
  try
    FActiveTabTExtComponent.Free;
    FTabBar.Free;
    FLayout.Free;
    FTabBar_.Free;
  except end;
  inherited;
end;

function TExtToolbarSpacer.JSClassName : string; begin
  Result := 'Ext.toolbar.Spacer';
end;

{$IFDEF FPC}constructor TExtToolbarSpacer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTreePluginTreeViewDragDrop.SetFAllowParentInserts(Value : Boolean); begin
  FAllowParentInserts := Value;
  JSCode('allowParentInserts:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFAllowContainerDrops(Value : Boolean); begin
  FAllowContainerDrops := Value;
  JSCode('allowContainerDrops:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFAppendOnly(Value : Boolean); begin
  FAppendOnly := Value;
  JSCode('appendOnly:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDragGroup(Value : String); begin
  FDragGroup := Value;
  JSCode('dragGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDropGroup(Value : String); begin
  FDropGroup := Value;
  JSCode('dropGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFExpandDelay(Value : String); begin
  FExpandDelay := Value;
  JSCode('expandDelay:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFEnableDrop(Value : Boolean); begin
  FEnableDrop := Value;
  JSCode('enableDrop:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFEnableDrag(Value : Boolean); begin
  FEnableDrag := Value;
  JSCode('enableDrag:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightColor(Value : String); begin
  FNodeHighlightColor := Value;
  JSCode('nodeHighlightColor:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightOnDrop(Value : Boolean); begin
  FNodeHighlightOnDrop := Value;
  JSCode('nodeHighlightOnDrop:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightOnRepair(Value : Boolean); begin
  FNodeHighlightOnRepair := Value;
  JSCode('nodeHighlightOnRepair:' + VarToJSON([Value]));
end;

function TExtTreePluginTreeViewDragDrop.JSClassName : string; begin
  Result := 'Ext.tree.plugin.TreeViewDragDrop';
end;

{$IFDEF FPC}constructor TExtTreePluginTreeViewDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtUtilComponentDragger.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtUtilComponentDragger.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

procedure TExtUtilComponentDragger.SetFDelegateTExtElement(Value : TExtElement); begin
  FDelegateTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('delegate:' + VarToJSON([Value, false]));
end;

procedure TExtUtilComponentDragger.SetFConstrainDelegate(Value : Boolean); begin
  FConstrainDelegate := Value;
  JSCode('constrainDelegate:' + VarToJSON([Value]));
end;

function TExtUtilComponentDragger.JSClassName : string; begin
  Result := 'Ext.util.ComponentDragger';
end;

procedure TExtUtilComponentDragger.InitDefaults; begin
  inherited;
  FDelegateTExtElement := TExtElement.CreateInternal(Self, 'delegate');
end;

{$IFDEF FPC}constructor TExtUtilComponentDragger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilComponentDragger.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtUtilComponentDragger.Create(Comp : TExtObject; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Comp, false, Config, false]) + ');');
  InitDefaults;
end;

destructor TExtUtilComponentDragger.Destroy; begin
  try
    FDelegateTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtToolbarItem.SetFOverflowText(Value : String); begin
  FOverflowText := Value;
  JSCode('overflowText:' + VarToJSON([Value]));
end;

function TExtToolbarItem.JSClassName : string; begin
  Result := 'Ext.toolbar.Item';
end;

{$IFDEF FPC}constructor TExtToolbarItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartAxisNumeric.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFDecimals(Value : Integer); begin
  FDecimals := Value;
  JSCode(JSName + '.decimals=' + VarToJSON([Value]) + ';');
end;

procedure TExtChartAxisNumeric.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode(JSName + '.position=' + VarToJSON([Value]) + ';');
end;

procedure TExtChartAxisNumeric.SetFAdjustMinimumByMajorUnit(Value : Boolean); begin
  FAdjustMinimumByMajorUnit := Value;
  JSCode(JSName + '.adjustMinimumByMajorUnit=' + VarToJSON([Value]) + ';');
end;

function TExtChartAxisNumeric.JSClassName : string; begin
  Result := 'Ext.chart.axis.Numeric';
end;

{$IFDEF FPC}constructor TExtChartAxisNumeric.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtToolbarFill.SetFIsFill(Value : Boolean); begin
  FIsFill := Value;
  JSCode(JSName + '.isFill=' + VarToJSON([Value]) + ';');
end;

function TExtToolbarFill.JSClassName : string; begin
  Result := 'Ext.toolbar.Fill';
end;

{$IFDEF FPC}constructor TExtToolbarFill.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilGrouper.JSClassName : string; begin
  Result := 'Ext.util.Grouper';
end;

{$IFDEF FPC}constructor TExtUtilGrouper.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilGrouper.GetGroupString(Instance : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.getGroupString(' + VarToJSON([Instance, false]) + ');', 'TExtUtilGrouper');
  Result := Self;
end;

function TExtPluginManager.JSClassName : string; begin
  Result := 'Ext.PluginManager';
end;

{$IFDEF FPC}constructor TExtPluginManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPluginManager.Create(Config : TExtObject; DefaultType : TExtFunction = nil); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, DefaultType, true]) + ');');
  InitDefaults;
end;

function TExtPluginManager.FindByType(TypeJS : String; DefaultsOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.findByType(' + VarToJSON([TypeJS, DefaultsOnly]) + ');', 'TExtPluginManager');
  Result := Self;
end;

procedure TExtProgressBar.SetFValue(Value : Integer); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFTextEl(Value : String); begin
  FTextEl := Value;
  JSCode('textEl:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFTextElTHTMLElement(Value : THTMLElement); begin
  FTextElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('textEl:' + VarToJSON([Value, false]));
end;

procedure TExtProgressBar.SetFTextElTExtElement(Value : TExtElement); begin
  FTextElTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('textEl:' + VarToJSON([Value, false]));
end;

procedure TExtProgressBar.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFOnUpdate(Value : TExtProgressBarOnUpdate); begin
  if Assigned(FOnUpdate) then
    JSCode(JSName+'.events ["update"].listeners=[];');
  if Assigned(Value) then
    AddListener('update', Ajax('update', ['This', '%0.nm','Value', '%1','Text', '%2'], true));
  FOnUpdate := Value;
end;

function TExtProgressBar.JSClassName : string; begin
  Result := 'Ext.ProgressBar';
end;

procedure TExtProgressBar.InitDefaults; begin
  inherited;
  FTextElTExtElement := TExtElement.CreateInternal(Self, 'textEl');
end;

{$IFDEF FPC}constructor TExtProgressBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtProgressBar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtProgressBar.UpdateProgress(Value : Integer = 0; Text : String = ''; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.updateProgress(' + VarToJSON([Value, Text, Animate]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.UpdateText(Text : String = '') : TExtFunction; begin
  JSCode(JSName + '.updateText(' + VarToJSON([Text]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.Wait(Config : TExtObject = nil; ConfigDuration : Integer = 0; ConfigInterval : Integer = 0; ConfigAnimate : Boolean = false; ConfigIncrement : Integer = 0; ConfigText : String = ''; ConfigFn : TExtFunction = nil; ConfigScope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.wait(' + VarToJSON([Config, false, ConfigDuration, ConfigInterval, ConfigAnimate, ConfigIncrement, ConfigText, ConfigFn, true, ConfigScope, false]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.IsWaiting : TExtFunction; begin
  JSCode(JSName + '.isWaiting();', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.Reset(Hide : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.reset(' + VarToJSON([Hide]) + ');', 'TExtProgressBar');
  Result := Self;
end;

destructor TExtProgressBar.Destroy; begin
  try
    FTextElTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtProgressBar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'update') and Assigned(FOnUpdate) then
    FOnUpdate(TExtProgressBar(ParamAsObject('This')), ParamAsInteger('Value'), ParamAsString('Text'));
end;

procedure TExtChartSeriesPie.SetFHighlightDuration(Value : Integer); begin
  FHighlightDuration := Value;
  JSCode('highlightDuration:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFAngleField(Value : String); begin
  FAngleField := Value;
  JSCode('angleField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFField(Value : String); begin
  FField := Value;
  JSCode('field:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFXField(Value : String); begin
  FXField := Value;
  JSCode('xField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFLengthField(Value : String); begin
  FLengthField := Value;
  JSCode('lengthField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFDonut(Value : Boolean); begin
  FDonut := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFDonutInteger(Value : Integer); begin
  FDonutInteger := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFColorSet(Value : TExtObjectList); begin
  FColorSet := Value;
  Value.DeleteFromGarbage;
  JSCode('colorSet:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesPie.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesPie.JSClassName : string; begin
  Result := 'Ext.chart.series.Pie';
end;

procedure TExtChartSeriesPie.InitDefaults; begin
  inherited;
  FColorSet := TExtObjectList.Create(Self, 'colorSet');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesPie.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesPie.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesPie.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.HighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.UnHighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.GetLegendColor(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

destructor TExtChartSeriesPie.Destroy; begin
  try
    FColorSet.Free;
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtPickerDate.SetFTodayText(Value : String); begin
  FTodayText := Value;
  JSCode('todayText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFAriaTitle(Value : String); begin
  FAriaTitle := Value;
  JSCode('ariaTitle:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFAriaTitleDateFormat(Value : String); begin
  FAriaTitleDateFormat := Value;
  JSCode('ariaTitleDateFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPickerDate.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFTodayTip(Value : String); begin
  FTodayTip := Value;
  JSCode('todayTip:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledDaysText(Value : String); begin
  FDisabledDaysText := Value;
  JSCode('disabledDaysText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledDatesText(Value : String); begin
  FDisabledDatesText := Value;
  JSCode('disabledDatesText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMonthNames(Value : TExtObjectList); begin
  FMonthNames := Value;
  Value.DeleteFromGarbage;
  JSCode('monthNames:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFDayNames(Value : TExtObjectList); begin
  FDayNames := Value;
  Value.DeleteFromGarbage;
  JSCode('dayNames:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFNextText(Value : String); begin
  FNextText := Value;
  JSCode('nextText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFPrevText(Value : String); begin
  FPrevText := Value;
  JSCode('prevText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMonthYearText(Value : String); begin
  FMonthYearText := Value;
  JSCode('monthYearText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMonthYearFormat(Value : String); begin
  FMonthYearFormat := Value;
  JSCode('monthYearFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFStartDay(Value : Integer); begin
  FStartDay := Value;
  JSCode('startDay:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFShowToday(Value : Boolean); begin
  FShowToday := Value;
  JSCode('showToday:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMinDate(Value : TDateTime); begin
  FMinDate := Value;
  if not ConfigAvailable(JSName) then
    SetMinDate(Value)
  else
    JSCode('minDate:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMaxDate(Value : TDateTime); begin
  FMaxDate := Value;
  if not ConfigAvailable(JSName) then
    SetMaxDate(Value)
  else
    JSCode('maxDate:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledDays(Value : TArrayOfInteger); begin
  FDisabledDays := Value;
  if not ConfigAvailable(JSName) then
    SetDisabledDays(Value)
  else
    JSCode('disabledDays:' + ArrayToJSON(Value));
end;

procedure TExtPickerDate.SetFDisabledDatesRE(Value : TRegExp); begin
  FDisabledDatesRE := Value;
  JSCode('disabledDatesRE:' + VarToJSON([#3 +Value]));
end;

procedure TExtPickerDate.SetFDisabledDates(Value : TExtObjectList); begin
  FDisabledDates := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetDisabledDates(Value)
  else
    JSCode('disabledDates:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFDisableAnim(Value : Boolean); begin
  FDisableAnim := Value;
  JSCode('disableAnim:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFSelectedCls(Value : String); begin
  FSelectedCls := Value;
  JSCode('selectedCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledCellCls(Value : String); begin
  FDisabledCellCls := Value;
  JSCode('disabledCellCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFLongDayFormat(Value : String); begin
  FLongDayFormat := Value;
  JSCode('longDayFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFKeyNavConfig(Value : TExtObject); begin
  FKeyNavConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('keyNavConfig:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFFocusOnShow(Value : Boolean); begin
  FFocusOnShow := Value;
  JSCode('focusOnShow:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFOnSelect(Value : TExtPickerDateOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','Date', '%1'], true));
  FOnSelect := Value;
end;

function TExtPickerDate.JSClassName : string; begin
  Result := 'Ext.picker.Date';
end;

procedure TExtPickerDate.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FMonthNames := TExtObjectList.Create(Self, 'monthNames');
  FDayNames := TExtObjectList.Create(Self, 'dayNames');
  FStartDay := 0;
  FDisabledDates := TExtObjectList.Create(Self, 'disabledDates');
  FKeyNavConfig := TExtObject.CreateInternal(Self, 'keyNavConfig');
end;

{$IFDEF FPC}constructor TExtPickerDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerDate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerDate.SetDisabledDates(DisabledDates : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDates(' + VarToJSON(DisabledDates) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetDisabledDates(DisabledDates : TRegExp) : TExtFunction; begin
  JSCode(JSName + '.SetDisabledDates(' + VarToJSON([#3 + DisabledDates]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDays(' + VarToJSON([DisabledDays]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetMinDate(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinDate(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetMaxDate(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxDate(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.GetDayInitial : TExtFunction; begin
  JSCode(JSName + '.getDayInitial();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.HideMonthPicker(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.hideMonthPicker(' + VarToJSON([Animate]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowMonthPicker(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.showMonthPicker(' + VarToJSON([Animate]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowPrevMonth(E : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.showPrevMonth(' + VarToJSON([E, false]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowNextMonth(E : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.showNextMonth(' + VarToJSON([E, false]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowPrevYear : TExtFunction; begin
  JSCode(JSName + '.showPrevYear();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowNextYear : TExtFunction; begin
  JSCode(JSName + '.showNextYear();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SelectToday : TExtFunction; begin
  JSCode(JSName + '.selectToday();', 'TExtPickerDate');
  Result := Self;
end;

destructor TExtPickerDate.Destroy; begin
  try
    FScope.Free;
    FMonthNames.Free;
    FDayNames.Free;
    FDisabledDates.Free;
    FKeyNavConfig.Free;
  except end;
  inherited;
end;

procedure TExtPickerDate.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtPickerDate(ParamAsObject('This')), ParamAsTDateTime('Date'));
end;

procedure TExtPanelTable.SetFViewType(Value : String); begin
  FViewType := Value;
  JSCode('viewType:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFViewConfig(Value : TExtObject); begin
  FViewConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('viewConfig:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFView(Value : TExtViewTable); begin
  FView := Value;
  Value.DeleteFromGarbage;
  JSCode('view:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFSelType(Value : String); begin
  FSelType := Value;
  JSCode('selType:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSelModel(Value : TExtSelectionModel); begin
  FSelModel := Value;
  Value.DeleteFromGarbage;
  JSCode('selModel:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFSelModelTExtObject(Value : TExtObject); begin
  FSelModelTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('selModel:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFMultiSelect(Value : Boolean); begin
  FMultiSelect := Value;
  JSCode('multiSelect:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSimpleSelect(Value : Boolean); begin
  FSimpleSelect := Value;
  JSCode('simpleSelect:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFScroll(Value : String); begin
  FScroll := Value;
  JSCode('scroll:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFScrollBoolean(Value : Boolean); begin
  FScrollBoolean := Value;
  JSCode('scroll:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFColumnsTExtObject(Value : TExtObject); begin
  FColumnsTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFForceFit(Value : Boolean); begin
  FForceFit := Value;
  JSCode('forceFit:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFFeatures(Value : TExtObjectList); begin
  FFeatures := Value;
  Value.DeleteFromGarbage;
  JSCode('features:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFHideHeaders(Value : Boolean); begin
  FHideHeaders := Value;
  JSCode('hideHeaders:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFDeferRowRender(Value : Boolean); begin
  FDeferRowRender := Value;
  JSCode('deferRowRender:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFVerticalScroller(Value : TExtObject); begin
  FVerticalScroller := Value;
  Value.DeleteFromGarbage;
  JSCode('verticalScroller:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFSortableColumns(Value : Boolean); begin
  FSortableColumns := Value;
  JSCode('sortableColumns:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableLocking(Value : Boolean); begin
  FEnableLocking := Value;
  JSCode('enableLocking:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnMove(Value : Boolean); begin
  FEnableColumnMove := Value;
  JSCode('enableColumnMove:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSealedColumns(Value : Boolean); begin
  FSealedColumns := Value;
  JSCode('sealedColumns:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnResize(Value : Boolean); begin
  FEnableColumnResize := Value;
  JSCode('enableColumnResize:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnHide(Value : Boolean); begin
  FEnableColumnHide := Value;
  JSCode('enableColumnHide:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFColumnLines(Value : Boolean); begin
  FColumnLines := Value;
  JSCode('columnLines:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFDisableSelection(Value : Boolean); begin
  FDisableSelection := Value;
  JSCode('disableSelection:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFAllowDeselect(Value : Boolean); begin
  FAllowDeselect := Value;
  JSCode('allowDeselect:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFOptimizedColumnMove(Value : Boolean); begin
  FOptimizedColumnMove := Value;
  JSCode(JSName + '.optimizedColumnMove=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelTable.SetFOnViewready(Value : TExtPanelTableOnViewready); begin
  if Assigned(FOnViewready) then
    JSCode(JSName+'.events ["viewready"].listeners=[];');
  if Assigned(Value) then
    AddListener('viewready', Ajax('viewready', ['This', '%0.nm'], true));
  FOnViewready := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmousedown(Value : TExtPanelTableOnBeforeitemmousedown); begin
  if Assigned(FOnBeforeitemmousedown) then
    JSCode(JSName+'.events ["beforeitemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmousedown', Ajax('beforeitemmousedown', [], true));
  FOnBeforeitemmousedown := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseup(Value : TExtPanelTableOnBeforeitemmouseup); begin
  if Assigned(FOnBeforeitemmouseup) then
    JSCode(JSName+'.events ["beforeitemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseup', Ajax('beforeitemmouseup', [], true));
  FOnBeforeitemmouseup := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseenter(Value : TExtPanelTableOnBeforeitemmouseenter); begin
  if Assigned(FOnBeforeitemmouseenter) then
    JSCode(JSName+'.events ["beforeitemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseenter', Ajax('beforeitemmouseenter', [], true));
  FOnBeforeitemmouseenter := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseleave(Value : TExtPanelTableOnBeforeitemmouseleave); begin
  if Assigned(FOnBeforeitemmouseleave) then
    JSCode(JSName+'.events ["beforeitemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseleave', Ajax('beforeitemmouseleave', [], true));
  FOnBeforeitemmouseleave := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemclick(Value : TExtPanelTableOnBeforeitemclick); begin
  if Assigned(FOnBeforeitemclick) then
    JSCode(JSName+'.events ["beforeitemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemclick', Ajax('beforeitemclick', [], true));
  FOnBeforeitemclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemdblclick(Value : TExtPanelTableOnBeforeitemdblclick); begin
  if Assigned(FOnBeforeitemdblclick) then
    JSCode(JSName+'.events ["beforeitemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemdblclick', Ajax('beforeitemdblclick', [], true));
  FOnBeforeitemdblclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemcontextmenu(Value : TExtPanelTableOnBeforeitemcontextmenu); begin
  if Assigned(FOnBeforeitemcontextmenu) then
    JSCode(JSName+'.events ["beforeitemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcontextmenu', Ajax('beforeitemcontextmenu', [], true));
  FOnBeforeitemcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnItemmousedown(Value : TExtPanelTableOnItemmousedown); begin
  if Assigned(FOnItemmousedown) then
    JSCode(JSName+'.events ["itemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmousedown', Ajax('itemmousedown', [], true));
  FOnItemmousedown := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseup(Value : TExtPanelTableOnItemmouseup); begin
  if Assigned(FOnItemmouseup) then
    JSCode(JSName+'.events ["itemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseup', Ajax('itemmouseup', [], true));
  FOnItemmouseup := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseenter(Value : TExtPanelTableOnItemmouseenter); begin
  if Assigned(FOnItemmouseenter) then
    JSCode(JSName+'.events ["itemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseenter', Ajax('itemmouseenter', [], true));
  FOnItemmouseenter := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseleave(Value : TExtPanelTableOnItemmouseleave); begin
  if Assigned(FOnItemmouseleave) then
    JSCode(JSName+'.events ["itemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseleave', Ajax('itemmouseleave', [], true));
  FOnItemmouseleave := Value;
end;

procedure TExtPanelTable.SetFOnItemclick(Value : TExtPanelTableOnItemclick); begin
  if Assigned(FOnItemclick) then
    JSCode(JSName+'.events ["itemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemclick', Ajax('itemclick', [], true));
  FOnItemclick := Value;
end;

procedure TExtPanelTable.SetFOnItemdblclick(Value : TExtPanelTableOnItemdblclick); begin
  if Assigned(FOnItemdblclick) then
    JSCode(JSName+'.events ["itemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemdblclick', Ajax('itemdblclick', [], true));
  FOnItemdblclick := Value;
end;

procedure TExtPanelTable.SetFOnItemcontextmenu(Value : TExtPanelTableOnItemcontextmenu); begin
  if Assigned(FOnItemcontextmenu) then
    JSCode(JSName+'.events ["itemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcontextmenu', Ajax('itemcontextmenu', [], true));
  FOnItemcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermousedown(Value : TExtPanelTableOnBeforecontainermousedown); begin
  if Assigned(FOnBeforecontainermousedown) then
    JSCode(JSName+'.events ["beforecontainermousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermousedown', Ajax('beforecontainermousedown', [], true));
  FOnBeforecontainermousedown := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseup(Value : TExtPanelTableOnBeforecontainermouseup); begin
  if Assigned(FOnBeforecontainermouseup) then
    JSCode(JSName+'.events ["beforecontainermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseup', Ajax('beforecontainermouseup', [], true));
  FOnBeforecontainermouseup := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseover(Value : TExtPanelTableOnBeforecontainermouseover); begin
  if Assigned(FOnBeforecontainermouseover) then
    JSCode(JSName+'.events ["beforecontainermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseover', Ajax('beforecontainermouseover', [], true));
  FOnBeforecontainermouseover := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseout(Value : TExtPanelTableOnBeforecontainermouseout); begin
  if Assigned(FOnBeforecontainermouseout) then
    JSCode(JSName+'.events ["beforecontainermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseout', Ajax('beforecontainermouseout', [], true));
  FOnBeforecontainermouseout := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainerclick(Value : TExtPanelTableOnBeforecontainerclick); begin
  if Assigned(FOnBeforecontainerclick) then
    JSCode(JSName+'.events ["beforecontainerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerclick', Ajax('beforecontainerclick', [], true));
  FOnBeforecontainerclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainerdblclick(Value : TExtPanelTableOnBeforecontainerdblclick); begin
  if Assigned(FOnBeforecontainerdblclick) then
    JSCode(JSName+'.events ["beforecontainerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerdblclick', Ajax('beforecontainerdblclick', [], true));
  FOnBeforecontainerdblclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainercontextmenu(Value : TExtPanelTableOnBeforecontainercontextmenu); begin
  if Assigned(FOnBeforecontainercontextmenu) then
    JSCode(JSName+'.events ["beforecontainercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainercontextmenu', Ajax('beforecontainercontextmenu', [], true));
  FOnBeforecontainercontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseup(Value : TExtPanelTableOnContainermouseup); begin
  if Assigned(FOnContainermouseup) then
    JSCode(JSName+'.events ["containermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseup', Ajax('containermouseup', [], true));
  FOnContainermouseup := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseover(Value : TExtPanelTableOnContainermouseover); begin
  if Assigned(FOnContainermouseover) then
    JSCode(JSName+'.events ["containermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseover', Ajax('containermouseover', [], true));
  FOnContainermouseover := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseout(Value : TExtPanelTableOnContainermouseout); begin
  if Assigned(FOnContainermouseout) then
    JSCode(JSName+'.events ["containermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseout', Ajax('containermouseout', [], true));
  FOnContainermouseout := Value;
end;

procedure TExtPanelTable.SetFOnContainerclick(Value : TExtPanelTableOnContainerclick); begin
  if Assigned(FOnContainerclick) then
    JSCode(JSName+'.events ["containerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerclick', Ajax('containerclick', [], true));
  FOnContainerclick := Value;
end;

procedure TExtPanelTable.SetFOnContainerdblclick(Value : TExtPanelTableOnContainerdblclick); begin
  if Assigned(FOnContainerdblclick) then
    JSCode(JSName+'.events ["containerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerdblclick', Ajax('containerdblclick', [], true));
  FOnContainerdblclick := Value;
end;

procedure TExtPanelTable.SetFOnContainercontextmenu(Value : TExtPanelTableOnContainercontextmenu); begin
  if Assigned(FOnContainercontextmenu) then
    JSCode(JSName+'.events ["containercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('containercontextmenu', Ajax('containercontextmenu', [], true));
  FOnContainercontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnSelectionchange(Value : TExtPanelTableOnSelectionchange); begin
  if Assigned(FOnSelectionchange) then
    JSCode(JSName+'.events ["selectionchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('selectionchange', Ajax('selectionchange', [], true));
  FOnSelectionchange := Value;
end;

procedure TExtPanelTable.SetFOnBeforeselect(Value : TExtPanelTableOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', [], true));
  FOnBeforeselect := Value;
end;

procedure TExtPanelTable.SetFOnSelect(Value : TExtPanelTableOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

procedure TExtPanelTable.SetFOnBeforedeselect(Value : TExtPanelTableOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', [], true));
  FOnBeforedeselect := Value;
end;

procedure TExtPanelTable.SetFOnDeselect(Value : TExtPanelTableOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', [], true));
  FOnDeselect := Value;
end;

procedure TExtPanelTable.SetFOnColumnresize(Value : TExtPanelTableOnColumnresize); begin
  if Assigned(FOnColumnresize) then
    JSCode(JSName+'.events ["columnresize"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnresize', Ajax('columnresize', [], true));
  FOnColumnresize := Value;
end;

procedure TExtPanelTable.SetFOnColumnmove(Value : TExtPanelTableOnColumnmove); begin
  if Assigned(FOnColumnmove) then
    JSCode(JSName+'.events ["columnmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnmove', Ajax('columnmove', [], true));
  FOnColumnmove := Value;
end;

procedure TExtPanelTable.SetFOnColumnhide(Value : TExtPanelTableOnColumnhide); begin
  if Assigned(FOnColumnhide) then
    JSCode(JSName+'.events ["columnhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnhide', Ajax('columnhide', [], true));
  FOnColumnhide := Value;
end;

procedure TExtPanelTable.SetFOnColumnshow(Value : TExtPanelTableOnColumnshow); begin
  if Assigned(FOnColumnshow) then
    JSCode(JSName+'.events ["columnshow"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnshow', Ajax('columnshow', [], true));
  FOnColumnshow := Value;
end;

procedure TExtPanelTable.SetFOnSortchange(Value : TExtPanelTableOnSortchange); begin
  if Assigned(FOnSortchange) then
    JSCode(JSName+'.events ["sortchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('sortchange', Ajax('sortchange', [], true));
  FOnSortchange := Value;
end;

procedure TExtPanelTable.SetFOnCellclick(Value : TExtPanelTableOnCellclick); begin
  if Assigned(FOnCellclick) then
    JSCode(JSName+'.events ["cellclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellclick', Ajax('cellclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellclick := Value;
end;

procedure TExtPanelTable.SetFOnCelldblclick(Value : TExtPanelTableOnCelldblclick); begin
  if Assigned(FOnCelldblclick) then
    JSCode(JSName+'.events ["celldblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('celldblclick', Ajax('celldblclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCelldblclick := Value;
end;

function TExtPanelTable.JSClassName : string; begin
  Result := 'Ext.panel.Table';
end;

procedure TExtPanelTable.InitDefaults; begin
  inherited;
  FViewConfig := TExtObject.CreateInternal(Self, 'viewConfig');
  FView := TExtViewTable.CreateInternal(Self, 'view');
  FSelType := 'rowmodel';
  FSelModel := TExtSelectionModel.CreateInternal(Self, 'selModel');
  FSelModelTExtObject := TExtObject.CreateInternal(Self, 'selModel');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FColumns := TExtObjectList.Create(Self, 'columns');
  FColumnsTExtObject := TExtObject.CreateInternal(Self, 'columns');
  FFeatures := TExtObjectList.Create(Self, 'features');
  FDeferRowRender := true;
  FVerticalScroller := TExtObject.CreateInternal(Self, 'verticalScroller');
end;

{$IFDEF FPC}constructor TExtPanelTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanelTable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelTable.GetSelectionModel : TExtFunction; begin
  JSCode(JSName + '.getSelectionModel();', 'TExtPanelTable');
  Result := Self;
end;

destructor TExtPanelTable.Destroy; begin
  try
    FViewConfig.Free;
    FView.Free;
    FSelModel.Free;
    FSelModelTExtObject.Free;
    FStore.Free;
    FColumns.Free;
    FColumnsTExtObject.Free;
    FFeatures.Free;
    FVerticalScroller.Free;
  except end;
  inherited;
end;

procedure TExtPanelTable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'viewready') and Assigned(FOnViewready) then
    FOnViewready(TExtPanelTable(ParamAsObject('This')))
  else if (AEvtName = 'beforeitemmousedown') and Assigned(FOnBeforeitemmousedown) then
    FOnBeforeitemmousedown()
  else if (AEvtName = 'beforeitemmouseup') and Assigned(FOnBeforeitemmouseup) then
    FOnBeforeitemmouseup()
  else if (AEvtName = 'beforeitemmouseenter') and Assigned(FOnBeforeitemmouseenter) then
    FOnBeforeitemmouseenter()
  else if (AEvtName = 'beforeitemmouseleave') and Assigned(FOnBeforeitemmouseleave) then
    FOnBeforeitemmouseleave()
  else if (AEvtName = 'beforeitemclick') and Assigned(FOnBeforeitemclick) then
    FOnBeforeitemclick()
  else if (AEvtName = 'beforeitemdblclick') and Assigned(FOnBeforeitemdblclick) then
    FOnBeforeitemdblclick()
  else if (AEvtName = 'beforeitemcontextmenu') and Assigned(FOnBeforeitemcontextmenu) then
    FOnBeforeitemcontextmenu()
  else if (AEvtName = 'itemmousedown') and Assigned(FOnItemmousedown) then
    FOnItemmousedown()
  else if (AEvtName = 'itemmouseup') and Assigned(FOnItemmouseup) then
    FOnItemmouseup()
  else if (AEvtName = 'itemmouseenter') and Assigned(FOnItemmouseenter) then
    FOnItemmouseenter()
  else if (AEvtName = 'itemmouseleave') and Assigned(FOnItemmouseleave) then
    FOnItemmouseleave()
  else if (AEvtName = 'itemclick') and Assigned(FOnItemclick) then
    FOnItemclick()
  else if (AEvtName = 'itemdblclick') and Assigned(FOnItemdblclick) then
    FOnItemdblclick()
  else if (AEvtName = 'itemcontextmenu') and Assigned(FOnItemcontextmenu) then
    FOnItemcontextmenu()
  else if (AEvtName = 'beforecontainermousedown') and Assigned(FOnBeforecontainermousedown) then
    FOnBeforecontainermousedown()
  else if (AEvtName = 'beforecontainermouseup') and Assigned(FOnBeforecontainermouseup) then
    FOnBeforecontainermouseup()
  else if (AEvtName = 'beforecontainermouseover') and Assigned(FOnBeforecontainermouseover) then
    FOnBeforecontainermouseover()
  else if (AEvtName = 'beforecontainermouseout') and Assigned(FOnBeforecontainermouseout) then
    FOnBeforecontainermouseout()
  else if (AEvtName = 'beforecontainerclick') and Assigned(FOnBeforecontainerclick) then
    FOnBeforecontainerclick()
  else if (AEvtName = 'beforecontainerdblclick') and Assigned(FOnBeforecontainerdblclick) then
    FOnBeforecontainerdblclick()
  else if (AEvtName = 'beforecontainercontextmenu') and Assigned(FOnBeforecontainercontextmenu) then
    FOnBeforecontainercontextmenu()
  else if (AEvtName = 'containermouseup') and Assigned(FOnContainermouseup) then
    FOnContainermouseup()
  else if (AEvtName = 'containermouseover') and Assigned(FOnContainermouseover) then
    FOnContainermouseover()
  else if (AEvtName = 'containermouseout') and Assigned(FOnContainermouseout) then
    FOnContainermouseout()
  else if (AEvtName = 'containerclick') and Assigned(FOnContainerclick) then
    FOnContainerclick()
  else if (AEvtName = 'containerdblclick') and Assigned(FOnContainerdblclick) then
    FOnContainerdblclick()
  else if (AEvtName = 'containercontextmenu') and Assigned(FOnContainercontextmenu) then
    FOnContainercontextmenu()
  else if (AEvtName = 'selectionchange') and Assigned(FOnSelectionchange) then
    FOnSelectionchange()
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect()
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect()
  else if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect()
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect()
  else if (AEvtName = 'columnresize') and Assigned(FOnColumnresize) then
    FOnColumnresize()
  else if (AEvtName = 'columnmove') and Assigned(FOnColumnmove) then
    FOnColumnmove()
  else if (AEvtName = 'columnhide') and Assigned(FOnColumnhide) then
    FOnColumnhide()
  else if (AEvtName = 'columnshow') and Assigned(FOnColumnshow) then
    FOnColumnshow()
  else if (AEvtName = 'sortchange') and Assigned(FOnSortchange) then
    FOnSortchange()
  else if (AEvtName = 'cellclick') and Assigned(FOnCellclick) then
    FOnCellclick(TExtPanelTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'celldblclick') and Assigned(FOnCelldblclick) then
    FOnCelldblclick(TExtPanelTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtPanelTool.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPanelTool.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTool.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFTooltipTExtObject(Value : TExtObject); begin
  FTooltipTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTool.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFStopEvent(Value : Boolean); begin
  FStopEvent := Value;
  JSCode('stopEvent:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFOnClick(Value : TExtPanelToolOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

function TExtPanelTool.JSClassName : string; begin
  Result := 'Ext.panel.Tool';
end;

procedure TExtPanelTool.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FTooltipTExtObject := TExtObject.CreateInternal(Self, 'tooltip');
end;

{$IFDEF FPC}constructor TExtPanelTool.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanelTool.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelTool.SetType(TypeJS : String) : TExtFunction; begin
  JSCode(JSName + '.setType(' + VarToJSON([TypeJS]) + ');', 'TExtPanelTool');
  Result := Self;
end;

destructor TExtPanelTool.Destroy; begin
  try
    FScope.Free;
    FTooltipTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtPanelTool.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtPanelTool(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtPickerColor.SetFComponentCls(Value : String); begin
  FComponentCls := Value;
  JSCode('componentCls:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFSelectedCls(Value : String); begin
  FSelectedCls := Value;
  JSCode('selectedCls:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFValue(Value : String); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFClickEvent(Value : String); begin
  FClickEvent := Value;
  JSCode('clickEvent:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFAllowReselect(Value : Boolean); begin
  FAllowReselect := Value;
  JSCode('allowReselect:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPickerColor.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPickerColor.SetFOnSelect(Value : TExtPickerColorOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','Color', '%1'], true));
  FOnSelect := Value;
end;

function TExtPickerColor.JSClassName : string; begin
  Result := 'Ext.picker.Color';
end;

procedure TExtPickerColor.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtPickerColor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerColor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerColor.Select(Color : String; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Color, SuppressEvent]) + ');', 'TExtPickerColor');
  Result := Self;
end;

function TExtPickerColor.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtPickerColor');
  Result := Self;
end;

destructor TExtPickerColor.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtPickerColor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtPickerColor(ParamAsObject('This')), ParamAsString('Color'));
end;

procedure TExtSelectionRowModel.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtSelectionRowModel.SetFIgnoreRightMouseSelection(Value : Boolean); begin
  FIgnoreRightMouseSelection := Value;
  JSCode('ignoreRightMouseSelection:' + VarToJSON([Value]));
end;

procedure TExtSelectionRowModel.SetFOnBeforedeselect(Value : TExtSelectionRowModelOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforedeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnBeforeselect(Value : TExtSelectionRowModelOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnDeselect(Value : TExtSelectionRowModelOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnDeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnSelect(Value : TExtSelectionRowModelOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnSelect := Value;
end;

function TExtSelectionRowModel.JSClassName : string; begin
  Result := 'Ext.selection.RowModel';
end;

{$IFDEF FPC}constructor TExtSelectionRowModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionRowModel.GetCurrentPosition : TExtFunction; begin
  JSCode(JSName + '.getCurrentPosition();', 'TExtSelectionRowModel');
  Result := Self;
end;

function TExtSelectionRowModel.SelectNext(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectNext(' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionRowModel');
  Result := Self;
end;

function TExtSelectionRowModel.SelectPrevious(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectPrevious(' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionRowModel');
  Result := Self;
end;

procedure TExtSelectionRowModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'));
end;

procedure TExtChartSeriesGauge.SetFHighlightDuration(Value : Integer); begin
  FHighlightDuration := Value;
  JSCode('highlightDuration:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFAngleField(Value : String); begin
  FAngleField := Value;
  JSCode('angleField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFNeedle(Value : Boolean); begin
  FNeedle := Value;
  JSCode('needle:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFDonut(Value : Boolean); begin
  FDonut := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFDonutInteger(Value : Integer); begin
  FDonutInteger := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesGauge.JSClassName : string; begin
  Result := 'Ext.chart.series.Gauge';
end;

procedure TExtChartSeriesGauge.InitDefaults; begin
  inherited;
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesGauge.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesGauge.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesGauge.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesGauge');
  Result := Self;
end;

function TExtChartSeriesGauge.GetLegendColor(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesGauge');
  Result := Self;
end;

destructor TExtChartSeriesGauge.Destroy; begin
  try
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtStateCookieProvider.SetFPath(Value : String); begin
  FPath := Value;
  JSCode('path:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFExpires(Value : TDateTime); begin
  FExpires := Value;
  JSCode('expires:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFDomain(Value : String); begin
  FDomain := Value;
  JSCode('domain:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFSecure(Value : Boolean); begin
  FSecure := Value;
  JSCode('secure:' + VarToJSON([Value]));
end;

function TExtStateCookieProvider.JSClassName : string; begin
  Result := 'Ext.state.CookieProvider';
end;

procedure TExtStateCookieProvider.InitDefaults; begin
  inherited;
  FPath := '/';
  FDomain := 'www';
end;

{$IFDEF FPC}constructor TExtStateCookieProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtStateCookieProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

constructor TExtStateCookieProvider.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

procedure TExtSelectionCellModel.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtSelectionCellModel.SetFPreventWrap(Value : Boolean); begin
  FPreventWrap := Value;
  JSCode('preventWrap:' + VarToJSON([Value]));
end;

procedure TExtSelectionCellModel.SetFOnDeselect(Value : TExtSelectionCellModelOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', ['This', '%0.nm','RecordJS', '%1.nm','Row', '%2','Column', '%3'], true));
  FOnDeselect := Value;
end;

procedure TExtSelectionCellModel.SetFOnSelect(Value : TExtSelectionCellModelOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','RecordJS', '%1.nm','Row', '%2','Column', '%3'], true));
  FOnSelect := Value;
end;

function TExtSelectionCellModel.JSClassName : string; begin
  Result := 'Ext.selection.CellModel';
end;

{$IFDEF FPC}constructor TExtSelectionCellModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionCellModel.GetCurrentPosition : TExtFunction; begin
  JSCode(JSName + '.getCurrentPosition();', 'TExtSelectionCellModel');
  Result := Self;
end;

function TExtSelectionCellModel.SetCurrentPosition(Position : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setCurrentPosition(' + VarToJSON([Position, false]) + ');', 'TExtSelectionCellModel');
  Result := Self;
end;

procedure TExtSelectionCellModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect(TExtSelectionCellModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Row'), ParamAsInteger('Column'))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtSelectionCellModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Row'), ParamAsInteger('Column'));
end;

function TExtResizerHandle.JSClassName : string; begin
  Result := 'Ext.resizer.Handle';
end;

{$IFDEF FPC}constructor TExtResizerHandle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtButton.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtButton.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTooltip(Value : String); begin
  FTooltip := Value;
  if not ConfigAvailable(JSName) then
    SetTooltip(Value)
  else
    JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTooltipTExtObject(Value : TExtObject); begin
  FTooltipTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFPressed(Value : Boolean); begin
  FPressed := Value;
  JSCode('pressed:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFToggleGroup(Value : String); begin
  FToggleGroup := Value;
  JSCode('toggleGroup:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFRepeatJS(Value : Boolean); begin
  FRepeatJS := Value;
  JSCode('repeatJS:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFRepeatJSTExtObject(Value : TExtObject); begin
  FRepeatJSTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('repeatJS:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFTabIndex(Value : Integer); begin
  FTabIndex := Value;
  JSCode('tabIndex:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFAllowDepress(Value : Boolean); begin
  FAllowDepress := Value;
  JSCode('allowDepress:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFEnableToggle(Value : Boolean); begin
  FEnableToggle := Value;
  JSCode('enableToggle:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFToggleHandler(Value : TExtFunction); begin
  FToggleHandler := Value;
  JSCode('toggleHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButton.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFMenuString(Value : String); begin
  FMenuString := Value;
  JSCode('menu:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMenuTExtObject(Value : TExtObject); begin
  FMenuTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFMenuAlign(Value : String); begin
  FMenuAlign := Value;
  JSCode('menuAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTextAlign(Value : String); begin
  FTextAlign := Value;
  if not ConfigAvailable(JSName) then
    SetTextAlign(Value)
  else
    JSCode('textAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFOverflowText(Value : String); begin
  FOverflowText := Value;
  JSCode('overflowText:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFClickEvent(Value : String); begin
  FClickEvent := Value;
  JSCode('clickEvent:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHandleMouseEvents(Value : Boolean); begin
  FHandleMouseEvents := Value;
  JSCode('handleMouseEvents:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFPressedCls(Value : String); begin
  FPressedCls := Value;
  JSCode('pressedCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFOverCls(Value : String); begin
  FOverCls := Value;
  JSCode('overCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMenuActiveCls(Value : String); begin
  FMenuActiveCls := Value;
  JSCode('menuActiveCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHref(Value : String); begin
  FHref := Value;
  JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetParams(Value)
  else
    JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFScale(Value : String); begin
  FScale := Value;
  if not ConfigAvailable(JSName) then
    SetScale(Value)
  else
    JSCode('scale:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFIconAlign(Value : String); begin
  FIconAlign := Value;
  JSCode('iconAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFArrowAlign(Value : String); begin
  FArrowAlign := Value;
  JSCode('arrowAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFArrowCls(Value : String); begin
  FArrowCls := Value;
  JSCode('arrowCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMenu_(Value : TExtMenu); begin
  FMenu_ := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.menu=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtButton.SetFOnClick(Value : TExtButtonOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtButton.SetFOnToggle(Value : TExtButtonOnToggle); begin
  if Assigned(FOnToggle) then
    JSCode(JSName+'.events ["toggle"].listeners=[];');
  if Assigned(Value) then
    AddListener('toggle', Ajax('toggle', ['This', '%0.nm','Pressed', '%1'], true));
  FOnToggle := Value;
end;

procedure TExtButton.SetFOnMouseover(Value : TExtButtonOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtButton.SetFOnMouseout(Value : TExtButtonOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtButton.SetFOnMenushow(Value : TExtButtonOnMenushow); begin
  if Assigned(FOnMenushow) then
    JSCode(JSName+'.events ["menushow"].listeners=[];');
  if Assigned(Value) then
    AddListener('menushow', Ajax('menushow', ['This', '%0.nm','Menu', '%1.nm'], true));
  FOnMenushow := Value;
end;

procedure TExtButton.SetFOnMenuhide(Value : TExtButtonOnMenuhide); begin
  if Assigned(FOnMenuhide) then
    JSCode(JSName+'.events ["menuhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('menuhide', Ajax('menuhide', ['This', '%0.nm','Menu', '%1.nm'], true));
  FOnMenuhide := Value;
end;

procedure TExtButton.SetFOnMenutriggerover(Value : TExtButtonOnMenutriggerover); begin
  if Assigned(FOnMenutriggerover) then
    JSCode(JSName+'.events ["menutriggerover"].listeners=[];');
  if Assigned(Value) then
    AddListener('menutriggerover', Ajax('menutriggerover', ['This', '%0.nm','Menu', '%1.nm','E', '%2.nm'], true));
  FOnMenutriggerover := Value;
end;

procedure TExtButton.SetFOnMenutriggerout(Value : TExtButtonOnMenutriggerout); begin
  if Assigned(FOnMenutriggerout) then
    JSCode(JSName+'.events ["menutriggerout"].listeners=[];');
  if Assigned(Value) then
    AddListener('menutriggerout', Ajax('menutriggerout', ['This', '%0.nm','Menu', '%1.nm','E', '%2.nm'], true));
  FOnMenutriggerout := Value;
end;

function TExtButton.JSClassName : string; begin
  Result := 'Ext.button.Button';
end;

procedure TExtButton.InitDefaults; begin
  inherited;
  FTooltipTExtObject := TExtObject.CreateInternal(Self, 'tooltip');
  FRepeatJSTExtObject := TExtObject.CreateInternal(Self, 'repeatJS');
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
  FMenuTExtObject := TExtObject.CreateInternal(Self, 'menu');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FMenu_ := TExtMenu.CreateInternal(Self, 'menu');
end;

{$IFDEF FPC}constructor TExtButton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtButton.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtButton.GetTemplateArgs : TExtFunction; begin
  JSCode(JSName + '.getTemplateArgs();', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetParams(Params : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setParams(' + VarToJSON([Params, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTooltip(Tooltip : String) : TExtFunction; begin
  JSCode(JSName + '.setTooltip(' + VarToJSON([Tooltip]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTooltip(Tooltip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetTooltip(' + VarToJSON([Tooltip, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTextAlign(Align : String) : TExtFunction; begin
  JSCode(JSName + '.setTextAlign(' + VarToJSON([Align]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Handler, true, Scope, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.GetText : TExtFunction; begin
  JSCode(JSName + '.getText();', 'TExtButton');
  Result := Self;
end;

function TExtButton.Toggle(State : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([State, SuppressEvent]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.ShowMenu : TExtFunction; begin
  JSCode(JSName + '.showMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.HideMenu : TExtFunction; begin
  JSCode(JSName + '.hideMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.HasVisibleMenu : TExtFunction; begin
  JSCode(JSName + '.hasVisibleMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetScale(Scale : String) : TExtFunction; begin
  JSCode(JSName + '.setScale(' + VarToJSON([Scale]) + ');', 'TExtButton');
  Result := Self;
end;

destructor TExtButton.Destroy; begin
  try
    FTooltipTExtObject.Free;
    FRepeatJSTExtObject.Free;
    FMenu.Free;
    FMenuTExtObject.Free;
    FBaseParams.Free;
    FParams.Free;
    FScope.Free;
    FMenu_.Free;
  except end;
  inherited;
end;

procedure TExtButton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'toggle') and Assigned(FOnToggle) then
    FOnToggle(TExtButton(ParamAsObject('This')), ParamAsBoolean('Pressed'))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'menushow') and Assigned(FOnMenushow) then
    FOnMenushow(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')))
  else if (AEvtName = 'menuhide') and Assigned(FOnMenuhide) then
    FOnMenuhide(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')))
  else if (AEvtName = 'menutriggerover') and Assigned(FOnMenutriggerover) then
    FOnMenutriggerover(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'menutriggerout') and Assigned(FOnMenutriggerout) then
    FOnMenutriggerout(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')), TExtDirectEvent(ParamAsObject('E')));
end;

procedure TExtResizerSplitter.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFPerformCollapse(Value : Boolean); begin
  FPerformCollapse := Value;
  JSCode('performCollapse:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseOnDblClick(Value : Boolean); begin
  FCollapseOnDblClick := Value;
  JSCode('collapseOnDblClick:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFDefaultSplitMin(Value : Integer); begin
  FDefaultSplitMin := Value;
  JSCode('defaultSplitMin:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFDefaultSplitMax(Value : Integer); begin
  FDefaultSplitMax := Value;
  JSCode('defaultSplitMax:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapsedCls(Value : String); begin
  FCollapsedCls := Value;
  JSCode('collapsedCls:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseTarget(Value : String); begin
  FCollapseTarget := Value;
  JSCode('collapseTarget:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseTargetTExtPanel(Value : TExtPanel); begin
  FCollapseTargetTExtPanel := Value;
  Value.DeleteFromGarbage;
  JSCode('collapseTarget:' + VarToJSON([Value, false]));
end;

procedure TExtResizerSplitter.SetFOrientation(Value : String); begin
  FOrientation := Value;
  JSCode(JSName + '.orientation=' + VarToJSON([Value]) + ';');
end;

function TExtResizerSplitter.JSClassName : string; begin
  Result := 'Ext.resizer.Splitter';
end;

procedure TExtResizerSplitter.InitDefaults; begin
  inherited;
  FCollapseTargetTExtPanel := TExtPanel.CreateInternal(Self, 'collapseTarget');
end;

{$IFDEF FPC}constructor TExtResizerSplitter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtResizerSplitter.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtResizerSplitter.Destroy; begin
  try
    FCollapseTargetTExtPanel.Free;
  except end;
  inherited;
end;

function TExtFormActionLoad.JSClassName : string; begin
  Result := 'Ext.form.action.Load';
end;

{$IFDEF FPC}constructor TExtFormActionLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormActionSubmit.SetFClientValidation(Value : Boolean); begin
  FClientValidation := Value;
  JSCode('clientValidation:' + VarToJSON([Value]));
end;

function TExtFormActionSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.Submit';
end;

{$IFDEF FPC}constructor TExtFormActionSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataField.SetFSerialize(Value : TExtFunction); begin
  FSerialize := Value;
  JSCode('serialize:' + VarToJSON([Value, true]));
end;

procedure TExtDataField.SetFDateFormat(Value : String); begin
  FDateFormat := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFUseNull(Value : Boolean); begin
  FUseNull := Value;
  JSCode('useNull:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFDefaultValue(Value : TExtObject); begin
  FDefaultValue := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultValue:' + VarToJSON([Value, false]));
end;

procedure TExtDataField.SetFMapping(Value : String); begin
  FMapping := Value;
  JSCode('mapping:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFMappingInteger(Value : Integer); begin
  FMappingInteger := Value;
  JSCode('mapping:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFSortType(Value : TExtFunction); begin
  FSortType := Value;
  JSCode('sortType:' + VarToJSON([Value, true]));
end;

procedure TExtDataField.SetFSortDir(Value : String); begin
  FSortDir := Value;
  JSCode('sortDir:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFPersist(Value : Boolean); begin
  FPersist := Value;
  JSCode('persist:' + VarToJSON([Value]));
end;

function TExtDataField.JSClassName : string; begin
  Result := 'Ext.data.Field';
end;

procedure TExtDataField.InitDefaults; begin
  inherited;
  FDefaultValue := TExtObject.CreateInternal(Self, 'defaultValue');
  FSortDir := 'ASC';
  FPersist := true;
end;

{$IFDEF FPC}constructor TExtDataField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataField.Destroy; begin
  try
    FDefaultValue.Free;
  except end;
  inherited;
end;

function TExtDrawEngineVml.JSClassName : string; begin
  Result := 'Ext.draw.engine.Vml';
end;

{$IFDEF FPC}constructor TExtDrawEngineVml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtEditor.SetFField(Value : TExtFormField); begin
  FField := Value;
  Value.DeleteFromGarbage;
  JSCode('field:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFAllowBlur(Value : Boolean); begin
  FAllowBlur := Value;
  JSCode('allowBlur:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFAutoSize(Value : Boolean); begin
  FAutoSize := Value;
  JSCode('autoSize:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFAutoSizeTExtObject(Value : TExtObject); begin
  FAutoSizeTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoSize:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFRevertInvalid(Value : Boolean); begin
  FRevertInvalid := Value;
  JSCode('revertInvalid:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFIgnoreNoChange(Value : Boolean); begin
  FIgnoreNoChange := Value;
  JSCode('ignoreNoChange:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFHideEl(Value : Boolean); begin
  FHideEl := Value;
  JSCode('hideEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFAlignment(Value : String); begin
  FAlignment := Value;
  JSCode('alignment:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFOffsets(Value : TArrayOfInteger); begin
  FOffsets := Value;
  JSCode('offsets:' + ArrayToJSON(Value));
end;

procedure TExtEditor.SetFShadow(Value : Boolean); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFShadowString(Value : String); begin
  FShadowString := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFSwallowKeys(Value : Boolean); begin
  FSwallowKeys := Value;
  JSCode('swallowKeys:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFCompleteOnEnter(Value : Boolean); begin
  FCompleteOnEnter := Value;
  JSCode('completeOnEnter:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFCancelOnEsc(Value : Boolean); begin
  FCancelOnEsc := Value;
  JSCode('cancelOnEsc:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFUpdateEl(Value : Boolean); begin
  FUpdateEl := Value;
  JSCode('updateEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFParentEl(Value : String); begin
  FParentEl := Value;
  JSCode('parentEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFParentElTHTMLElement(Value : THTMLElement); begin
  FParentElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('parentEl:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFParentElTExtElement(Value : TExtElement); begin
  FParentElTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('parentEl:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFOnBeforestartedit(Value : TExtEditorOnBeforestartedit); begin
  if Assigned(FOnBeforestartedit) then
    JSCode(JSName+'.events ["beforestartedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestartedit', Ajax('beforestartedit', ['This', '%0.nm','BoundEl', '%1.nm','Value', '%2.nm'], true));
  FOnBeforestartedit := Value;
end;

procedure TExtEditor.SetFOnStartedit(Value : TExtEditorOnStartedit); begin
  if Assigned(FOnStartedit) then
    JSCode(JSName+'.events ["startedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('startedit', Ajax('startedit', ['This', '%0.nm','BoundEl', '%1.nm','Value', '%2.nm'], true));
  FOnStartedit := Value;
end;

procedure TExtEditor.SetFOnBeforecomplete(Value : TExtEditorOnBeforecomplete); begin
  if Assigned(FOnBeforecomplete) then
    JSCode(JSName+'.events ["beforecomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecomplete', Ajax('beforecomplete', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnBeforecomplete := Value;
end;

procedure TExtEditor.SetFOnComplete(Value : TExtEditorOnComplete); begin
  if Assigned(FOnComplete) then
    JSCode(JSName+'.events ["complete"].listeners=[];');
  if Assigned(Value) then
    AddListener('complete', Ajax('complete', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnComplete := Value;
end;

procedure TExtEditor.SetFOnCanceledit(Value : TExtEditorOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnCanceledit := Value;
end;

procedure TExtEditor.SetFOnSpecialkey(Value : TExtEditorOnSpecialkey); begin
  if Assigned(FOnSpecialkey) then
    JSCode(JSName+'.events ["specialkey"].listeners=[];');
  if Assigned(Value) then
    AddListener('specialkey', Ajax('specialkey', ['This', '%0.nm','Field', '%1.nm','Event', '%2.nm'], true));
  FOnSpecialkey := Value;
end;

function TExtEditor.JSClassName : string; begin
  Result := 'Ext.Editor';
end;

procedure TExtEditor.InitDefaults; begin
  inherited;
  FField := TExtFormField.CreateInternal(Self, 'field');
  FAutoSizeTExtObject := TExtObject.CreateInternal(Self, 'autoSize');
  FValue := TExtObject.CreateInternal(Self, 'value');
  FParentElTExtElement := TExtElement.CreateInternal(Self, 'parentEl');
end;

{$IFDEF FPC}constructor TExtEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtEditor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtEditor.StartEdit(El : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([El, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.StartEdit(El : THTMLElement; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([El, false, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.StartEdit(El : TExtElement; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([El, false, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.Realign(AutoSize : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.realign(' + VarToJSON([AutoSize]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.CompleteEdit(RemainVisible : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.completeEdit(' + VarToJSON([RemainVisible]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.CancelEdit(RemainVisible : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.cancelEdit(' + VarToJSON([RemainVisible]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtEditor');
  Result := Self;
end;

destructor TExtEditor.Destroy; begin
  try
    FField.Free;
    FAutoSizeTExtObject.Free;
    FValue.Free;
    FParentElTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtEditor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforestartedit') and Assigned(FOnBeforestartedit) then
    FOnBeforestartedit(TExtEditor(ParamAsObject('This')), TExtElement(ParamAsObject('BoundEl')), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'startedit') and Assigned(FOnStartedit) then
    FOnStartedit(TExtEditor(ParamAsObject('This')), TExtElement(ParamAsObject('BoundEl')), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'beforecomplete') and Assigned(FOnBeforecomplete) then
    FOnBeforecomplete(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'complete') and Assigned(FOnComplete) then
    FOnComplete(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'specialkey') and Assigned(FOnSpecialkey) then
    FOnSpecialkey(TExtEditor(ParamAsObject('This')), TExtFormField(ParamAsObject('Field')), TExtEventObject(ParamAsObject('Event')));
end;

procedure TExtFlashComponent.SetFFlashVersion(Value : String); begin
  FFlashVersion := Value;
  JSCode('flashVersion:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFBackgroundColor(Value : String); begin
  FBackgroundColor := Value;
  JSCode('backgroundColor:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFWmode(Value : String); begin
  FWmode := Value;
  JSCode('wmode:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFFlashVars(Value : TExtObject); begin
  FFlashVars := Value;
  Value.DeleteFromGarbage;
  JSCode('flashVars:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFFlashParams(Value : TExtObject); begin
  FFlashParams := Value;
  Value.DeleteFromGarbage;
  JSCode('flashParams:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFFlashAttributes(Value : TExtObject); begin
  FFlashAttributes := Value;
  Value.DeleteFromGarbage;
  JSCode('flashAttributes:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfWidth(Value : String); begin
  FSwfWidth := Value;
  JSCode('swfWidth:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfWidthInteger(Value : Integer); begin
  FSwfWidthInteger := Value;
  JSCode('swfWidth:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfHeight(Value : String); begin
  FSwfHeight := Value;
  JSCode('swfHeight:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfHeightInteger(Value : Integer); begin
  FSwfHeightInteger := Value;
  JSCode('swfHeight:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFExpressInstall(Value : Boolean); begin
  FExpressInstall := Value;
  JSCode('expressInstall:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwf(Value : TExtElement); begin
  FSwf := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.swf=' + VarToJSON([Value, false]) + ';');
end;

function TExtFlashComponent.JSClassName : string; begin
  Result := 'Ext.flash.Component';
end;

procedure TExtFlashComponent.InitDefaults; begin
  inherited;
  FFlashVars := TExtObject.CreateInternal(Self, 'flashVars');
  FFlashParams := TExtObject.CreateInternal(Self, 'flashParams');
  FFlashAttributes := TExtObject.CreateInternal(Self, 'flashAttributes');
  FSwfWidth := '100%';
  FSwfHeight := '100%';
  FSwf := TExtElement.CreateInternal(Self, 'swf');
end;

{$IFDEF FPC}constructor TExtFlashComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFlashComponent.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFlashComponent.Destroy; begin
  try
    FFlashVars.Free;
    FFlashParams.Free;
    FFlashAttributes.Free;
    FSwf.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldBase.SetFInputAttrTpl(Value : String); begin
  FInputAttrTpl := Value;
  JSCode('inputAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputAttrTplTExtObjectList(Value : TExtObjectList); begin
  FInputAttrTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('inputAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFInputAttrTplTExtXTemplate(Value : TExtXTemplate); begin
  FInputAttrTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('inputAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputType(Value : String); begin
  FInputType := Value;
  JSCode('inputType:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFTabIndex(Value : Integer); begin
  FTabIndex := Value;
  JSCode('tabIndex:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldStyle(Value : String); begin
  FFieldStyle := Value;
  if not ConfigAvailable(JSName) then
    SetFieldStyle(Value)
  else
    JSCode('fieldStyle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFDirtyCls(Value : String); begin
  FDirtyCls := Value;
  JSCode('dirtyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFCheckChangeEvents(Value : TExtObjectList); begin
  FCheckChangeEvents := Value;
  Value.DeleteFromGarbage;
  JSCode('checkChangeEvents:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFCheckChangeBuffer(Value : Integer); begin
  FCheckChangeBuffer := Value;
  JSCode('checkChangeBuffer:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  if not ConfigAvailable(JSName) then
    SetReadOnly(Value)
  else
    JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFReadOnlyCls(Value : String); begin
  FReadOnlyCls := Value;
  JSCode('readOnlyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputId(Value : String); begin
  FInputId := Value;
  JSCode('inputId:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFValidateOnBlur(Value : Boolean); begin
  FValidateOnBlur := Value;
  JSCode('validateOnBlur:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputEl(Value : TExtElement); begin
  FInputEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.inputEl=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormFieldBase.JSClassName : string; begin
  Result := 'Ext.form.field.Base';
end;

procedure TExtFormFieldBase.InitDefaults; begin
  inherited;
  FInputAttrTplTExtObjectList := TExtObjectList.Create(Self, 'inputAttrTpl');
  FInputAttrTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'inputAttrTpl');
  FCheckChangeEvents := TExtObjectList.Create(Self, 'checkChangeEvents');
  FCheckChangeBuffer := 50;
  FInputEl := TExtElement.CreateInternal(Self, 'inputEl');
end;

{$IFDEF FPC}constructor TExtFormFieldBase.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldBase.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldBase.GetSubTplMarkup : TExtFunction; begin
  JSCode(JSName + '.getSubTplMarkup();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldStyle(' + VarToJSON([Style]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetFieldStyle(' + VarToJSON([Style, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.SetFieldStyle(' + VarToJSON([Style, true]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetRawValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setRawValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ValueToRaw(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.valueToRaw(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.RawToValue(RawValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.rawToValue(' + VarToJSON([RawValue, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ProcessRawValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.processRawValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetReadOnly(ReadOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([ReadOnly]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ValidateValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.validateValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.MarkInvalid(Errors : String) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Errors]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.MarkInvalid(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON(Errors) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormFieldBase');
  Result := Self;
end;

destructor TExtFormFieldBase.Destroy; begin
  try
    FInputAttrTplTExtObjectList.Free;
    FInputAttrTplTExtXTemplate.Free;
    FCheckChangeEvents.Free;
    FInputEl.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTpl(Value : String); begin
  FBeforeTextAreaTpl := Value;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeTextAreaTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeTextAreaTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTpl(Value : String); begin
  FAfterTextAreaTpl := Value;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTplTExtObjectList(Value : TExtObjectList); begin
  FAfterTextAreaTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterTextAreaTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTpl(Value : String); begin
  FBeforeIFrameTpl := Value;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeIFrameTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeIFrameTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTpl(Value : String); begin
  FAfterIFrameTpl := Value;
  JSCode('afterIFrameTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTplTExtObjectList(Value : TExtObjectList); begin
  FAfterIFrameTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterIFrameTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTpl(Value : String); begin
  FIframeAttrTpl := Value;
  JSCode('iframeAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTplTExtObjectList(Value : TExtObjectList); begin
  FIframeAttrTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('iframeAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTplTExtXTemplate(Value : TExtXTemplate); begin
  FIframeAttrTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('iframeAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFormat(Value : Boolean); begin
  FEnableFormat := Value;
  JSCode('enableFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFontSize(Value : Boolean); begin
  FEnableFontSize := Value;
  JSCode('enableFontSize:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableColors(Value : Boolean); begin
  FEnableColors := Value;
  JSCode('enableColors:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableAlignments(Value : Boolean); begin
  FEnableAlignments := Value;
  JSCode('enableAlignments:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableLists(Value : Boolean); begin
  FEnableLists := Value;
  JSCode('enableLists:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableSourceEdit(Value : Boolean); begin
  FEnableSourceEdit := Value;
  JSCode('enableSourceEdit:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableLinks(Value : Boolean); begin
  FEnableLinks := Value;
  JSCode('enableLinks:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFont(Value : Boolean); begin
  FEnableFont := Value;
  JSCode('enableFont:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFCreateLinkText(Value : String); begin
  FCreateLinkText := Value;
  JSCode('createLinkText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFDefaultLinkValue(Value : String); begin
  FDefaultLinkValue := Value;
  JSCode('defaultLinkValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFFontFamilies(Value : TExtObjectList); begin
  FFontFamilies := Value;
  Value.DeleteFromGarbage;
  JSCode('fontFamilies:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFDefaultValue(Value : String); begin
  FDefaultValue := Value;
  JSCode('defaultValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

function TExtFormFieldHtmlEditor.JSClassName : string; begin
  Result := 'Ext.form.field.HtmlEditor';
end;

procedure TExtFormFieldHtmlEditor.InitDefaults; begin
  inherited;
  FBeforeTextAreaTplTExtObjectList := TExtObjectList.Create(Self, 'beforeTextAreaTpl');
  FBeforeTextAreaTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeTextAreaTpl');
  FAfterTextAreaTplTExtObjectList := TExtObjectList.Create(Self, 'afterTextAreaTpl');
  FAfterTextAreaTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterTextAreaTpl');
  FBeforeIFrameTplTExtObjectList := TExtObjectList.Create(Self, 'beforeIFrameTpl');
  FBeforeIFrameTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeIFrameTpl');
  FAfterIFrameTplTExtObjectList := TExtObjectList.Create(Self, 'afterIFrameTpl');
  FAfterIFrameTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterIFrameTpl');
  FIframeAttrTplTExtObjectList := TExtObjectList.Create(Self, 'iframeAttrTpl');
  FIframeAttrTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'iframeAttrTpl');
  FFontFamilies := TExtObjectList.Create(Self, 'fontFamilies');
end;

{$IFDEF FPC}constructor TExtFormFieldHtmlEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldHtmlEditor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldHtmlEditor.Destroy; begin
  try
    FBeforeTextAreaTplTExtObjectList.Free;
    FBeforeTextAreaTplTExtXTemplate.Free;
    FAfterTextAreaTplTExtObjectList.Free;
    FAfterTextAreaTplTExtXTemplate.Free;
    FBeforeIFrameTplTExtObjectList.Free;
    FBeforeIFrameTplTExtXTemplate.Free;
    FAfterIFrameTplTExtObjectList.Free;
    FAfterIFrameTplTExtXTemplate.Free;
    FIframeAttrTplTExtObjectList.Free;
    FIframeAttrTplTExtXTemplate.Free;
    FFontFamilies.Free;
  except end;
  inherited;
end;

procedure TExtXTemplate.SetFCompiled(Value : Boolean); begin
  FCompiled := Value;
  JSCode('compiled:' + VarToJSON([Value]));
end;

procedure TExtXTemplate.SetFDefinitions(Value : String); begin
  FDefinitions := Value;
  JSCode('definitions:' + VarToJSON([Value]));
end;

procedure TExtXTemplate.SetFDefinitionsTExtObjectList(Value : TExtObjectList); begin
  FDefinitionsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('definitions:' + VarToJSON([Value, false]));
end;

function TExtXTemplate.JSClassName : string; begin
  Result := 'Ext.XTemplate';
end;

procedure TExtXTemplate.InitDefaults; begin
  inherited;
  FDefinitionsTExtObjectList := TExtObjectList.Create(Self, 'definitions');
end;

{$IFDEF FPC}constructor TExtXTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtXTemplate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtXTemplate.Compile : TExtFunction; begin
  JSCode(JSName + '.compile();', 'TExtXTemplate');
  Result := Self;
end;

destructor TExtXTemplate.Destroy; begin
  try
    FDefinitionsTExtObjectList.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldSet.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxToggle(Value : Boolean); begin
  FCheckboxToggle := Value;
  JSCode('checkboxToggle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxName(Value : String); begin
  FCheckboxName := Value;
  JSCode('checkboxName:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFToggleOnTitleClick(Value : Boolean); begin
  FToggleOnTitleClick := Value;
  JSCode('toggleOnTitleClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxCmp(Value : TExtFormFieldCheckbox); begin
  FCheckboxCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.checkboxCmp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSet.SetFToggleCmp(Value : TExtPanelTool); begin
  FToggleCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.toggleCmp=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormFieldSet.JSClassName : string; begin
  Result := 'Ext.form.FieldSet';
end;

procedure TExtFormFieldSet.InitDefaults; begin
  inherited;
  FCheckboxCmp := TExtFormFieldCheckbox.CreateInternal(Self, 'checkboxCmp');
  FToggleCmp := TExtPanelTool.CreateInternal(Self, 'toggleCmp');
end;

{$IFDEF FPC}constructor TExtFormFieldSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldSet.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldSet.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtFormFieldSet');
  Result := Self;
end;

function TExtFormFieldSet.Expand : TExtFunction; begin
  JSCode(JSName + '.expand();', 'TExtFormFieldSet');
  Result := Self;
end;

function TExtFormFieldSet.Collapse : TExtFunction; begin
  JSCode(JSName + '.collapse();', 'TExtFormFieldSet');
  Result := Self;
end;

function TExtFormFieldSet.Toggle : TExtFunction; begin
  JSCode(JSName + '.toggle();', 'TExtFormFieldSet');
  Result := Self;
end;

destructor TExtFormFieldSet.Destroy; begin
  try
    FCheckboxCmp.Free;
    FToggleCmp.Free;
  except end;
  inherited;
end;

function TExtDataErrors.JSClassName : string; begin
  Result := 'Ext.data.Errors';
end;

{$IFDEF FPC}constructor TExtDataErrors.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataErrors.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtDataErrors');
  Result := Self;
end;

function TExtDataErrors.GetByField(FieldName : String) : TExtFunction; begin
  JSCode(JSName + '.getByField(' + VarToJSON([FieldName]) + ');', 'TExtDataErrors');
  Result := Self;
end;

procedure TExtFormFieldContainer.SetFCombineLabels(Value : Boolean); begin
  FCombineLabels := Value;
  JSCode('combineLabels:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelConnector(Value : String); begin
  FLabelConnector := Value;
  JSCode('labelConnector:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFCombineErrors(Value : Boolean); begin
  FCombineErrors := Value;
  JSCode('combineErrors:' + VarToJSON([Value]));
end;

function TExtFormFieldContainer.JSClassName : string; begin
  Result := 'Ext.form.FieldContainer';
end;

procedure TExtFormFieldContainer.InitDefaults; begin
  inherited;
  FLabelConnector := ',';
end;

{$IFDEF FPC}constructor TExtFormFieldContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldContainer.GetCombinedErrors(InvalidFields : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.getCombinedErrors(' + VarToJSON(InvalidFields) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

procedure TMyAppCoolPanelSingleton.SetFSingleton(Value : Boolean); begin
  FSingleton := Value;
  JSCode('singleton:' + VarToJSON([Value]));
end;

procedure TMyAppCoolPanelSingleton.SetFAlternateClassName(Value : String); begin
  FAlternateClassName := Value;
  JSCode('alternateClassName:' + VarToJSON([Value]));
end;

procedure TMyAppCoolPanelSingleton.SetFAlternateClassNameTExtObjectList(Value : TExtObjectList); begin
  FAlternateClassNameTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('alternateClassName:' + VarToJSON([Value, false]));
end;

function TMyAppCoolPanelSingleton.JSClassName : string; begin
  Result := 'MyApp.CoolPanel';
end;

procedure TMyAppCoolPanelSingleton.InitDefaults; begin
  inherited;
  FAlternateClassNameTExtObjectList := TExtObjectList.Create(Self, 'alternateClassName');
end;

{$IFDEF FPC}constructor TMyAppCoolPanelSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

destructor TMyAppCoolPanelSingleton.Destroy; begin
  try
    FAlternateClassNameTExtObjectList.Free;
  except end;
  inherited;
end;

function TExtDrawEngineSvg.JSClassName : string; begin
  Result := 'Ext.draw.engine.Svg';
end;

{$IFDEF FPC}constructor TExtDrawEngineSvg.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineSvg.GetRegion : TExtFunction; begin
  JSCode(JSName + '.getRegion();', 'TExtDrawEngineSvg');
  Result := Self;
end;

function TExtDrawEngineSvg.ApplyZIndex(Sprite : TExtDrawSprite) : TExtFunction; begin
  JSCode(JSName + '.applyZIndex(' + VarToJSON([Sprite, false]) + ');', 'TExtDrawEngineSvg');
  Result := Self;
end;

function TExtDrawEngineSvg.HasCls(Sprite : TExtDrawSprite; ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.hasCls(' + VarToJSON([Sprite, false, ClassName]) + ');', 'TExtDrawEngineSvg');
  Result := Self;
end;

function TExtDdDDTarget.JSClassName : string; begin
  Result := 'Ext.dd.DDTarget';
end;

{$IFDEF FPC}constructor TExtDdDDTarget.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDDTarget.Create(Id : String; SGroup : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Id, SGroup, Config, false]) + ');');
  InitDefaults;
end;

function TExtDataStoreManager.JSClassName : string; begin
  Result := 'Ext.data.StoreManager';
end;

{$IFDEF FPC}constructor TExtDataStoreManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataStoreManager.Register(Stores : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Stores, false]) + ');', 'TExtDataStoreManager');
  Result := Self;
end;

function TExtDataStoreManager.Unregister(Stores : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Stores]) + ');', 'TExtDataStoreManager');
  Result := Self;
end;

function TExtDataStoreManager.Unregister(Stores : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON(Stores) + ');', 'TExtDataStoreManager');
  Result := Self;
end;

function TExtDataStoreManager.Lookup(Store : String) : TExtFunction; begin
  JSCode(JSName + '.lookup(' + VarToJSON([Store]) + ');', 'TExtDataStoreManager');
  Result := Self;
end;

function TExtDataStoreManager.Lookup(Store : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Lookup(' + VarToJSON([Store, false]) + ');', 'TExtDataStoreManager');
  Result := Self;
end;

procedure TExtDdStatusProxy.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdStatusProxy.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

function TExtDdStatusProxy.JSClassName : string; begin
  Result := 'Ext.dd.StatusProxy';
end;

{$IFDEF FPC}constructor TExtDdStatusProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdStatusProxy.SetStatus(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.setStatus(' + VarToJSON([CssClass]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Reset(ClearGhost : Boolean) : TExtFunction; begin
  JSCode(JSName + '.reset(' + VarToJSON([ClearGhost]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Update(Html : String) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Html]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Update(Html : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Update(' + VarToJSON([Html, false]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.GetGhost : TExtFunction; begin
  JSCode(JSName + '.getGhost();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Hide(Clear : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Clear]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Stop : TExtFunction; begin
  JSCode(JSName + '.stop();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Sync : TExtFunction; begin
  JSCode(JSName + '.sync();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Repair(Xy : TArrayOfInteger; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.repair(' + VarToJSON([Xy, Callback, true, Scope, false]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

procedure TExtDataUuidGenerator.SetFVersion(Value : Integer); begin
  FVersion := Value;
  JSCode('version:' + VarToJSON([Value]));
end;

function TExtDataUuidGenerator.JSClassName : string; begin
  Result := 'Ext.data.UuidGenerator';
end;

{$IFDEF FPC}constructor TExtDataUuidGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataWriter.SetFIsWriter(Value : Boolean); begin
  FIsWriter := Value;
  JSCode(JSName + '.isWriter=' + VarToJSON([Value]) + ';');
end;

function TExtDataWriter.JSClassName : string; begin
  Result := 'Ext.data.writer.Writer';
end;

{$IFDEF FPC}constructor TExtDataWriter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataWriter.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataWriter.Write(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.write(' + VarToJSON([Request, false]) + ');', 'TExtDataWriter');
  Result := Self;
end;

function TExtDataWriter.GetRecordData(RecordJS : TExtDataModel; Operation : TExtDataOperation = nil) : TExtFunction; begin
  JSCode(JSName + '.getRecordData(' + VarToJSON([RecordJS, false, Operation, false]) + ');', 'TExtDataWriter');
  Result := Self;
end;

procedure TExtDdDD.SetFScroll(Value : Boolean); begin
  FScroll := Value;
  JSCode(JSName + '.scroll=' + VarToJSON([Value]) + ';');
end;

function TExtDdDD.JSClassName : string; begin
  Result := 'Ext.dd.DD';
end;

{$IFDEF FPC}constructor TExtDdDD.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDD.AutoOffset(IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.autoOffset(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.SetDelta(IDeltaX : Integer; IDeltaY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setDelta(' + VarToJSON([IDeltaX, IDeltaY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.SetDragElPos(IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setDragElPos(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.AlignElWithMouse(El : THTMLElement; IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.alignElWithMouse(' + VarToJSON([El, false, IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.CachePosition(IPageX : Integer = 0; IPageY : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.cachePosition(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.ApplyConfig : TExtFunction; begin
  JSCode(JSName + '.applyConfig();', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.B4MouseDown : TExtFunction; begin
  JSCode(JSName + '.b4MouseDown();', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.B4Drag : TExtFunction; begin
  JSCode(JSName + '.b4Drag();', 'TExtDdDD');
  Result := Self;
end;

procedure TExtDataSequentialIdGenerator.SetFPrefix(Value : String); begin
  FPrefix := Value;
  JSCode('prefix:' + VarToJSON([Value]));
end;

procedure TExtDataSequentialIdGenerator.SetFSeed(Value : Integer); begin
  FSeed := Value;
  JSCode('seed:' + VarToJSON([Value]));
end;

function TExtDataSequentialIdGenerator.JSClassName : string; begin
  Result := 'Ext.data.SequentialIdGenerator';
end;

{$IFDEF FPC}constructor TExtDataSequentialIdGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataProxyRest.SetFAppendId(Value : Boolean); begin
  FAppendId := Value;
  JSCode('appendId:' + VarToJSON([Value]));
end;

procedure TExtDataProxyRest.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtDataProxyRest.SetFBatchActions(Value : Boolean); begin
  FBatchActions := Value;
  JSCode('batchActions:' + VarToJSON([Value]));
end;

procedure TExtDataProxyRest.SetFActionMethods(Value : TExtObject); begin
  FActionMethods := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.actionMethods=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataProxyRest.JSClassName : string; begin
  Result := 'Ext.data.proxy.Rest';
end;

procedure TExtDataProxyRest.InitDefaults; begin
  inherited;
  FAppendId := true;
  FActionMethods := TExtObject.CreateInternal(Self, 'actionMethods');
end;

{$IFDEF FPC}constructor TExtDataProxyRest.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyRest.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataProxyRest.Destroy; begin
  try
    FActionMethods.Free;
  except end;
  inherited;
end;

procedure TExtDrawComponent.SetFEnginePriority(Value : TExtObjectList); begin
  FEnginePriority := Value;
  Value.DeleteFromGarbage;
  JSCode('enginePriority:' + VarToJSON([Value, false]));
end;

procedure TExtDrawComponent.SetFViewBox(Value : Boolean); begin
  FViewBox := Value;
  JSCode('viewBox:' + VarToJSON([Value]));
end;

procedure TExtDrawComponent.SetFAutoSize(Value : Boolean); begin
  FAutoSize := Value;
  JSCode('autoSize:' + VarToJSON([Value]));
end;

procedure TExtDrawComponent.SetFGradients(Value : TExtObjectList); begin
  FGradients := Value;
  Value.DeleteFromGarbage;
  JSCode('gradients:' + VarToJSON([Value, false]));
end;

procedure TExtDrawComponent.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtDrawComponent.SetFSurface(Value : TExtDrawSurface); begin
  FSurface := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.surface=' + VarToJSON([Value, false]) + ';');
end;

function TExtDrawComponent.JSClassName : string; begin
  Result := 'Ext.draw.Component';
end;

procedure TExtDrawComponent.InitDefaults; begin
  inherited;
  FEnginePriority := TExtObjectList.Create(Self, 'enginePriority');
  FGradients := TExtObjectList.Create(Self, 'gradients');
  FItems := TExtObjectList.Create(Self, 'items');
  FSurface := TExtDrawSurface.CreateInternal(Self, 'surface');
end;

{$IFDEF FPC}constructor TExtDrawComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawComponent.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDrawComponent.Destroy; begin
  try
    FEnginePriority.Free;
    FGradients.Free;
    FItems.Free;
    FSurface.Free;
  except end;
  inherited;
end;

function TExtDrawCompositeSprite.JSClassName : string; begin
  Result := 'Ext.draw.CompositeSprite';
end;

{$IFDEF FPC}constructor TExtDrawCompositeSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawCompositeSprite.GetBBox : TExtFunction; begin
  JSCode(JSName + '.getBBox();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAttributes(' + VarToJSON([Attrs, false, Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Hide(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Show(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Redraw : TExtFunction; begin
  JSCode(JSName + '.redraw();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SetStyle(Style : String) : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([Style]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.AddCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([Cls]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.RemoveCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([Cls]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDirectRemotingEvent.JSClassName : string; begin
  Result := 'Ext.direct.RemotingEvent';
end;

{$IFDEF FPC}constructor TExtDirectRemotingEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectRemotingEvent.GetTransaction : TExtFunction; begin
  JSCode(JSName + '.getTransaction();', 'TExtDirectRemotingEvent');
  Result := Self;
end;

function TExtDataReader.JSClassName : string; begin
  Result := 'Ext.data.reader.Reader';
end;

{$IFDEF FPC}constructor TExtDataReader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomCompositeElement.JSClassName : string; begin
  Result := 'Ext.dom.CompositeElement';
end;

{$IFDEF FPC}constructor TExtDomCompositeElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtWindow.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFModal(Value : Boolean); begin
  FModal := Value;
  JSCode('modal:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFAnimateTarget(Value : String); begin
  FAnimateTarget := Value;
  JSCode('animateTarget:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFAnimateTargetTExtElement(Value : TExtElement); begin
  FAnimateTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('animateTarget:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFDefaultFocus(Value : String); begin
  FDefaultFocus := Value;
  JSCode('defaultFocus:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFDefaultFocusInteger(Value : Integer); begin
  FDefaultFocusInteger := Value;
  JSCode('defaultFocus:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFDefaultFocusTExtComponent(Value : TExtComponent); begin
  FDefaultFocusTExtComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultFocus:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFOnEsc(Value : TExtFunction); begin
  FOnEsc := Value;
  JSCode('onEsc:' + VarToJSON([Value, true]));
end;

procedure TExtWindow.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFMaximized(Value : Boolean); begin
  FMaximized := Value;
  JSCode('maximized:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFResizableTExtObject(Value : TExtObject); begin
  FResizableTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('resizable:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFConstrainHeader(Value : Boolean); begin
  FConstrainHeader := Value;
  JSCode('constrainHeader:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFConstrainTo(Value : TExtUtilRegion); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFConstrainToTExtElement(Value : TExtElement); begin
  FConstrainToTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFMinimizable(Value : Boolean); begin
  FMinimizable := Value;
  JSCode('minimizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFMaximizable(Value : Boolean); begin
  FMaximizable := Value;
  JSCode('maximizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFExpandOnShow(Value : Boolean); begin
  FExpandOnShow := Value;
  JSCode('expandOnShow:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFIsWindow(Value : Boolean); begin
  FIsWindow := Value;
  JSCode(JSName + '.isWindow=' + VarToJSON([Value]) + ';');
end;

procedure TExtWindow.SetFDd(Value : TExtUtilComponentDragger); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

function TExtWindow.JSClassName : string; begin
  Result := 'Ext.window.Window';
end;

procedure TExtWindow.InitDefaults; begin
  inherited;
  FAnimateTargetTExtElement := TExtElement.CreateInternal(Self, 'animateTarget');
  FDefaultFocusTExtComponent := TExtComponent.CreateInternal(Self, 'defaultFocus');
  FResizableTExtObject := TExtObject.CreateInternal(Self, 'resizable');
  FConstrainTo := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FConstrainToTExtElement := TExtElement.CreateInternal(Self, 'constrainTo');
  FDd := TExtUtilComponentDragger.CreateInternal(Self, 'dd');
end;

{$IFDEF FPC}constructor TExtWindow.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtWindow.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtWindow.GetDefaultFocus : TExtFunction; begin
  JSCode(JSName + '.getDefaultFocus();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Minimize : TExtFunction; begin
  JSCode(JSName + '.minimize();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Maximize : TExtFunction; begin
  JSCode(JSName + '.maximize();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Restore : TExtFunction; begin
  JSCode(JSName + '.restore();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.ToggleMaximize : TExtFunction; begin
  JSCode(JSName + '.toggleMaximize();', 'TExtWindow');
  Result := Self;
end;

destructor TExtWindow.Destroy; begin
  try
    FAnimateTargetTExtElement.Free;
    FDefaultFocusTExtComponent.Free;
    FResizableTExtObject.Free;
    FConstrainTo.Free;
    FConstrainToTExtElement.Free;
    FDd.Free;
  except end;
  inherited;
end;

procedure TExtFxTargetCompositeElement.SetFIsComposite(Value : Boolean); begin
  FIsComposite := Value;
  JSCode(JSName + '.isComposite=' + VarToJSON([Value]) + ';');
end;

function TExtFxTargetCompositeElement.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeElement';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataAssociationHasOne.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFGetterName(Value : String); begin
  FGetterName := Value;
  JSCode('getterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFSetterName(Value : String); begin
  FSetterName := Value;
  JSCode('setterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationHasOne.JSClassName : string; begin
  Result := 'Ext.data.association.HasOne';
end;

procedure TExtDataAssociationHasOne.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FGetterName := 'get';
  FSetterName := 'set';
end;

{$IFDEF FPC}constructor TExtDataAssociationHasOne.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationHasOne.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtDataAssociationBelongsTo.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFGetterName(Value : String); begin
  FGetterName := Value;
  JSCode('getterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFSetterName(Value : String); begin
  FSetterName := Value;
  JSCode('setterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationBelongsTo.JSClassName : string; begin
  Result := 'Ext.data.association.BelongsTo';
end;

procedure TExtDataAssociationBelongsTo.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FGetterName := 'get';
  FSetterName := 'set';
end;

{$IFDEF FPC}constructor TExtDataAssociationBelongsTo.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationBelongsTo.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFxTargetCompositeSprite.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeSprite';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataAbstractStore.SetFFilters(Value : TExtObjectList); begin
  FFilters := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.filters=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataAbstractStore.JSClassName : string; begin
  Result := 'Ext.data.AbstractStore';
end;

procedure TExtDataAbstractStore.InitDefaults; begin
  inherited;
  FFilters := TExtObjectList.Create(Self, 'filters');
end;

{$IFDEF FPC}constructor TExtDataAbstractStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAbstractStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataAbstractStore.SetProxy(Proxy : String) : TExtFunction; begin
  JSCode(JSName + '.setProxy(' + VarToJSON([Proxy]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SetProxy(Proxy : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SetProxy(Proxy : TExtDataProxy) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetNewRecords : TExtFunction; begin
  JSCode(JSName + '.getNewRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetUpdatedRecords : TExtFunction; begin
  JSCode(JSName + '.getUpdatedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetModifiedRecords : TExtFunction; begin
  JSCode(JSName + '.getModifiedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetRemovedRecords : TExtFunction; begin
  JSCode(JSName + '.getRemovedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Sync(Options : TExtObject = nil; OptionsBatch : TExtDataBatch = nil; OptionsCallback : TExtFunction = nil; OptionsCallbackBatch : TExtDataBatch = nil; OptionsCallbackOptions : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessBatch : TExtDataBatch = nil; OptionsSuccessOptions : TExtObject = nil; OptionsFailure : TExtFunction = nil; OptionsFailureBatch : TExtDataBatch = nil; OptionsFailureOptions : TExtObject = nil; OptionsScope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.sync(' + VarToJSON([Options, false, OptionsBatch, false, OptionsCallback, true, OptionsCallbackBatch, false, OptionsCallbackOptions, false, OptionsSuccess, true, OptionsSuccessBatch, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureBatch, false, OptionsFailureOptions, false, OptionsScope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Sync(Options : TExtObject; OptionsBatch : TExtObject; OptionsCallback : TExtFunction = nil; OptionsCallbackBatch : TExtDataBatch = nil; OptionsCallbackOptions : TExtObject = nil; OptionsSuccess : TExtFunction = nil; OptionsSuccessBatch : TExtDataBatch = nil; OptionsSuccessOptions : TExtObject = nil; OptionsFailure : TExtFunction = nil; OptionsFailureBatch : TExtDataBatch = nil; OptionsFailureOptions : TExtObject = nil; OptionsScope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Sync(' + VarToJSON([Options, false, OptionsBatch, false, OptionsCallback, true, OptionsCallbackBatch, false, OptionsCallbackOptions, false, OptionsSuccess, true, OptionsSuccessBatch, false, OptionsSuccessOptions, false, OptionsFailure, true, OptionsFailureBatch, false, OptionsFailureOptions, false, OptionsScope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Save : TExtFunction; begin
  JSCode(JSName + '.save();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Load(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Reload(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.reload(' + VarToJSON([Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SuspendAutoSync : TExtFunction; begin
  JSCode(JSName + '.suspendAutoSync();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ResumeAutoSync : TExtFunction; begin
  JSCode(JSName + '.resumeAutoSync();', 'TExtDataAbstractStore');
  Result := Self;
end;

destructor TExtDataAbstractStore.Destroy; begin
  try
    FFilters.Free;
  except end;
  inherited;
end;

procedure TExtFormLabel.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFForId(Value : String); begin
  FForId := Value;
  JSCode('forId:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFHtml(Value : String); begin
  FHtml := Value;
  JSCode('html:' + VarToJSON([Value]));
end;

function TExtFormLabel.JSClassName : string; begin
  Result := 'Ext.form.Label';
end;

{$IFDEF FPC}constructor TExtFormLabel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormLabel.SetText(Text : String; Encode : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text, Encode]) + ');', 'TExtFormLabel');
  Result := Self;
end;

procedure TExtDataAssociationHasMany.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFStoreConfig(Value : TExtObject); begin
  FStoreConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('storeConfig:' + VarToJSON([Value, false]));
end;

procedure TExtDataAssociationHasMany.SetFFilterProperty(Value : String); begin
  FFilterProperty := Value;
  JSCode('filterProperty:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationHasMany.JSClassName : string; begin
  Result := 'Ext.data.association.HasMany';
end;

procedure TExtDataAssociationHasMany.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FStoreConfig := TExtObject.CreateInternal(Self, 'storeConfig');
end;

{$IFDEF FPC}constructor TExtDataAssociationHasMany.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationHasMany.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataAssociationHasMany.Destroy; begin
  try
    FStoreConfig.Free;
  except end;
  inherited;
end;

function TExtFxTargetElementCSS.JSClassName : string; begin
  Result := 'Ext.fx.target.ElementCSS';
end;

{$IFDEF FPC}constructor TExtFxTargetElementCSS.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormPanel.SetFPollForChanges(Value : Boolean); begin
  FPollForChanges := Value;
  JSCode('pollForChanges:' + VarToJSON([Value]));
end;

procedure TExtFormPanel.SetFPollInterval(Value : Integer); begin
  FPollInterval := Value;
  JSCode('pollInterval:' + VarToJSON([Value]));
end;

procedure TExtFormPanel.SetFLayout(Value : String); begin
  FLayout := Value;
  JSCode('layout:' + VarToJSON([Value]));
end;

procedure TExtFormPanel.SetFOnBeforeaction(Value : TExtFormPanelOnBeforeaction); begin
  if Assigned(FOnBeforeaction) then
    JSCode(JSName+'.events ["beforeaction"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeaction', Ajax('beforeaction', [], true));
  FOnBeforeaction := Value;
end;

procedure TExtFormPanel.SetFOnActionfailed(Value : TExtFormPanelOnActionfailed); begin
  if Assigned(FOnActionfailed) then
    JSCode(JSName+'.events ["actionfailed"].listeners=[];');
  if Assigned(Value) then
    AddListener('actionfailed', Ajax('actionfailed', [], true));
  FOnActionfailed := Value;
end;

procedure TExtFormPanel.SetFOnActioncomplete(Value : TExtFormPanelOnActioncomplete); begin
  if Assigned(FOnActioncomplete) then
    JSCode(JSName+'.events ["actioncomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('actioncomplete', Ajax('actioncomplete', [], true));
  FOnActioncomplete := Value;
end;

procedure TExtFormPanel.SetFOnValiditychange(Value : TExtFormPanelOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', [], true));
  FOnValiditychange := Value;
end;

procedure TExtFormPanel.SetFOnDirtychange(Value : TExtFormPanelOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', [], true));
  FOnDirtychange := Value;
end;

function TExtFormPanel.JSClassName : string; begin
  Result := 'Ext.form.Panel';
end;

procedure TExtFormPanel.InitDefaults; begin
  inherited;
  FPollInterval := 500;
  FLayout := 'anchor';
end;

{$IFDEF FPC}constructor TExtFormPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormPanel.GetForm : TExtFunction; begin
  JSCode(JSName + '.getForm();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.LoadRecord(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.loadRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.GetRecord : TExtFunction; begin
  JSCode(JSName + '.getRecord();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.Submit(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.submit(' + VarToJSON([Options, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.StartPolling(Interval : Integer) : TExtFunction; begin
  JSCode(JSName + '.startPolling(' + VarToJSON([Interval]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.StopPolling : TExtFunction; begin
  JSCode(JSName + '.stopPolling();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormPanel');
  Result := Self;
end;

procedure TExtFormPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeaction') and Assigned(FOnBeforeaction) then
    FOnBeforeaction()
  else if (AEvtName = 'actionfailed') and Assigned(FOnActionfailed) then
    FOnActionfailed()
  else if (AEvtName = 'actioncomplete') and Assigned(FOnActioncomplete) then
    FOnActioncomplete()
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange()
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange();
end;

procedure TExtChartSeriesBar.SetFColumn(Value : Boolean); begin
  FColumn := Value;
  JSCode('column:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFGutter(Value : Integer); begin
  FGutter := Value;
  JSCode('gutter:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFGroupGutter(Value : Integer); begin
  FGroupGutter := Value;
  JSCode('groupGutter:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFXPadding(Value : Integer); begin
  FXPadding := Value;
  JSCode('xPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFYPadding(Value : Integer); begin
  FYPadding := Value;
  JSCode('yPadding:' + VarToJSON([Value]));
end;

function TExtChartSeriesBar.JSClassName : string; begin
  Result := 'Ext.chart.series.Bar';
end;

{$IFDEF FPC}constructor TExtChartSeriesBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartSeriesBar.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesBar');
  Result := Self;
end;

function TExtChartSeriesBar.GetLegendColor : TExtFunction; begin
  JSCode(JSName + '.getLegendColor();', 'TExtChartSeriesBar');
  Result := Self;
end;

procedure TExtTab.SetFActiveCls(Value : String); begin
  FActiveCls := Value;
  JSCode('activeCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFDisabledCls(Value : String); begin
  FDisabledCls := Value;
  JSCode('disabledCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFClosableCls(Value : String); begin
  FClosableCls := Value;
  JSCode('closableCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  if not ConfigAvailable(JSName) then
    SetClosable(Value)
  else
    JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFCloseText(Value : String); begin
  FCloseText := Value;
  JSCode('closeText:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFActive(Value : Boolean); begin
  FActive := Value;
  JSCode(JSName + '.active=' + VarToJSON([Value]) + ';');
end;

procedure TExtTab.SetFClosable_(Value : Boolean); begin
  FClosable_ := Value;
  JSCode(JSName + '.closable=' + VarToJSON([Value]) + ';');
end;

procedure TExtTab.SetFOnActivate(Value : TExtTabOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtTab.SetFOnDeactivate(Value : TExtTabOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['This', '%0.nm'], true));
  FOnDeactivate := Value;
end;

procedure TExtTab.SetFOnBeforeclose(Value : TExtTabOnBeforeclose); begin
  if Assigned(FOnBeforeclose) then
    JSCode(JSName+'.events ["beforeclose"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeclose', Ajax('beforeclose', ['Tab', '%0.nm'], true));
  FOnBeforeclose := Value;
end;

procedure TExtTab.SetFOnClose(Value : TExtTabOnClose); begin
  if Assigned(FOnClose) then
    JSCode(JSName+'.events ["close"].listeners=[];');
  if Assigned(Value) then
    AddListener('close', Ajax('close', ['Tab', '%0.nm'], true));
  FOnClose := Value;
end;

function TExtTab.JSClassName : string; begin
  Result := 'Ext.tab.Tab';
end;

{$IFDEF FPC}constructor TExtTab.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTab.SetClosable(Closable : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setClosable(' + VarToJSON([Closable]) + ');', 'TExtTab');
  Result := Self;
end;

function TExtTab.SetCard(Card : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.setCard(' + VarToJSON([Card, false]) + ');', 'TExtTab');
  Result := Self;
end;

procedure TExtTab.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtTab(ParamAsObject('This')))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtTab(ParamAsObject('This')))
  else if (AEvtName = 'beforeclose') and Assigned(FOnBeforeclose) then
    FOnBeforeclose(TExtTab(ParamAsObject('Tab')))
  else if (AEvtName = 'close') and Assigned(FOnClose) then
    FOnClose(TExtTab(ParamAsObject('Tab')));
end;

procedure TExtChartSeriesArea.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesArea.JSClassName : string; begin
  Result := 'Ext.chart.series.Area';
end;

procedure TExtChartSeriesArea.InitDefaults; begin
  inherited;
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesArea.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesArea.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.HighlightSeries(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightSeries(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.UnHighlightSeries(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightSeries(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.HighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.UnHighlightItem(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.GetLegendColor(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

destructor TExtChartSeriesArea.Destroy; begin
  try
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtDataStore.SetFRemoteGroup(Value : Boolean); begin
  FRemoteGroup := Value;
  JSCode('remoteGroup:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFProxy(Value : String); begin
  FProxy := Value;
  JSCode('proxy:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFProxyTExtDataProxy(Value : TExtDataProxy); begin
  FProxyTExtDataProxy := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFProxyTExtObject(Value : TExtObject); begin
  FProxyTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFData(Value : TExtObjectList); begin
  FData := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFDataTExtObjectList(Value : TExtObjectList); begin
  FDataTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFGroupField(Value : String); begin
  FGroupField := Value;
  JSCode('groupField:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFGroupDir(Value : String); begin
  FGroupDir := Value;
  JSCode('groupDir:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFTrailingBufferZone(Value : Integer); begin
  FTrailingBufferZone := Value;
  JSCode('trailingBufferZone:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFLeadingBufferZone(Value : Integer); begin
  FLeadingBufferZone := Value;
  JSCode('leadingBufferZone:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFClearOnPageLoad(Value : Boolean); begin
  FClearOnPageLoad := Value;
  JSCode('clearOnPageLoad:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFSortOnFilter(Value : Boolean); begin
  FSortOnFilter := Value;
  JSCode('sortOnFilter:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFPurgePageCount(Value : Integer); begin
  FPurgePageCount := Value;
  JSCode('purgePageCount:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFClearRemovedOnLoad(Value : Boolean); begin
  FClearRemovedOnLoad := Value;
  JSCode('clearRemovedOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFData_(Value : TExtObjectList); begin
  FData_ := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.data=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataStore.SetFGroupers(Value : TExtObjectList); begin
  FGroupers := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.groupers=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataStore.SetFSnapshot(Value : TExtObjectList); begin
  FSnapshot := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.snapshot=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataStore.JSClassName : string; begin
  Result := 'Ext.data.Store';
end;

procedure TExtDataStore.InitDefaults; begin
  inherited;
  FProxyTExtDataProxy := TExtDataProxy.CreateInternal(Self, 'proxy');
  FProxyTExtObject := TExtObject.CreateInternal(Self, 'proxy');
  FData := TExtObjectList.Create(Self, 'data');
  FDataTExtObjectList := TExtObjectList.Create(Self, 'data');
  FPageSize := 25;
  FSortOnFilter := true;
  FData_ := TExtObjectList.Create(Self, 'data');
  FGroupers := TExtObjectList.Create(Self, 'groupers');
  FSnapshot := TExtObjectList.Create(Self, 'snapshot');
end;

{$IFDEF FPC}constructor TExtDataStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataStore.ClearFilter(SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.clearFilter(' + VarToJSON([SuppressEvent]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IsFiltered : TExtFunction; begin
  JSCode(JSName + '.isFiltered();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FilterBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.filterBy(' + VarToJSON([Fn, true, FnRecord, false, FnId, false, Scope, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.QueryBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.queryBy(' + VarToJSON([Fn, true, FnRecord, false, FnId, false, Scope, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Query(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([PropertyJS, Value, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Query(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Query(' + VarToJSON([PropertyJS, #3 + Value, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.loadData(' + VarToJSON(Data) + ',' + VarToJSON([Append]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadRawData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.loadRawData(' + VarToJSON(Data) + ',' + VarToJSON([Append]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadRecords(Records : TExtObjectList; Options : TExtObject; OptionsAddRecords : Boolean = false; Param : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.loadRecords(' + VarToJSON(Records) + ',' + VarToJSON([Options, false, OptionsAddRecords, Param]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadPage(Page : Integer; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.loadPage(' + VarToJSON([Page, Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.NextPage(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.nextPage(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PreviousPage(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.previousPage(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Prefetch(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.prefetch(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PrefetchPage(Page : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.prefetchPage(' + VarToJSON([Page, Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetPageFromRecordIndex(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getPageFromRecordIndex(' + VarToJSON([Index]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PrefetchRange : TExtFunction; begin
  JSCode(JSName + '.prefetchRange();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GuaranteeRange : TExtFunction; begin
  JSCode(JSName + '.guaranteeRange();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Find(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.find(' + VarToJSON([FieldName, Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Find(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Find(' + VarToJSON([FieldName, #3 + Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindRecord(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findRecord(' + VarToJSON([FieldName, Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindRecord(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindRecord(' + VarToJSON([FieldName, #3 + Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindExact(FieldName : String; Value : TExtObject; StartIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.findExact(' + VarToJSON([FieldName, Value, false, StartIndex]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindBy(Fn : TExtFunction; FnRecord : TExtDataModel; FnId : TExtObject; Scope : TExtObject = nil; StartIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.findBy(' + VarToJSON([Fn, true, FnRecord, false, FnId, false, Scope, false, StartIndex]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Collect(DataIndex : String; AllowNull : Boolean = false; BypassFilter : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.collect(' + VarToJSON([DataIndex, AllowNull, BypassFilter]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetTotalCount : TExtFunction; begin
  JSCode(JSName + '.getTotalCount();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getAt(' + VarToJSON([Index]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetRange(StartIndex : Integer = 0; EndIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.getRange(' + VarToJSON([StartIndex, EndIndex]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getById(' + VarToJSON([Id]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOf(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([RecordJS, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOfTotal(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.indexOfTotal(' + VarToJSON([RecordJS, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOfId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.indexOfId(' + VarToJSON([Id]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RemoveAll(Silent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([Silent]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.First(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.first(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Last(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.last(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Sum(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.sum(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Count(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.count(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Min(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.min(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Max(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.max(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Average(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.average(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Aggregate(Fn : TExtFunction; Scope : TExtObject = nil; Grouped : Boolean = false; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.aggregate(' + VarToJSON([Fn, true, Scope, false, Grouped]) + ',' + VarToJSON(Args) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.CommitChanges : TExtFunction; begin
  JSCode(JSName + '.commitChanges();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RejectChanges : TExtFunction; begin
  JSCode(JSName + '.rejectChanges();', 'TExtDataStore');
  Result := Self;
end;

destructor TExtDataStore.Destroy; begin
  try
    FProxyTExtDataProxy.Free;
    FProxyTExtObject.Free;
    FData.Free;
    FDataTExtObjectList.Free;
    FData_.Free;
    FGroupers.Free;
    FSnapshot.Free;
  except end;
  inherited;
end;

procedure TExtTabBar.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtTabBar.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtTabBar.SetFMinTabWidth(Value : Integer); begin
  FMinTabWidth := Value;
  JSCode('minTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabBar.SetFMaxTabWidth(Value : Integer); begin
  FMaxTabWidth := Value;
  JSCode('maxTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabBar.SetFOnChange(Value : TExtTabBarOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['TabBar', '%0.nm','Tab', '%1.nm','Card', '%2.nm'], true));
  FOnChange := Value;
end;

function TExtTabBar.JSClassName : string; begin
  Result := 'Ext.tab.Bar';
end;

{$IFDEF FPC}constructor TExtTabBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTabBar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtTabBar(ParamAsObject('TabBar')), TExtTab(ParamAsObject('Tab')), TExtComponent(ParamAsObject('Card')));
end;

function TExtFormActionDirectSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.DirectSubmit';
end;

{$IFDEF FPC}constructor TExtFormActionDirectSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSliderMulti.SetFValue(Value : Integer); begin
  FValue := Value;
  if not ConfigAvailable(JSName) then
    SetValue(Value, 0)
  else
    JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFValues(Value : TArrayOfInteger); begin
  FValues := Value;
  JSCode('values:' + ArrayToJSON(Value));
end;

procedure TExtSliderMulti.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFMinValue(Value : Integer); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFMaxValue(Value : Integer); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFDecimalPrecision(Value : Integer); begin
  FDecimalPrecision := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFDecimalPrecisionBoolean(Value : Boolean); begin
  FDecimalPrecisionBoolean := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFKeyIncrement(Value : Integer); begin
  FKeyIncrement := Value;
  JSCode('keyIncrement:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFZeroBasedSnapping(Value : Boolean); begin
  FZeroBasedSnapping := Value;
  JSCode('zeroBasedSnapping:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFClickToChange(Value : Boolean); begin
  FClickToChange := Value;
  JSCode('clickToChange:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFConstrainThumbs(Value : Boolean); begin
  FConstrainThumbs := Value;
  JSCode('constrainThumbs:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFUseTips(Value : TExtObject); begin
  FUseTips := Value;
  Value.DeleteFromGarbage;
  JSCode('useTips:' + VarToJSON([Value, false]));
end;

procedure TExtSliderMulti.SetFUseTipsBoolean(Value : Boolean); begin
  FUseTipsBoolean := Value;
  JSCode('useTips:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFTipText(Value : TExtFunction); begin
  FTipText := Value;
  JSCode('tipText:' + VarToJSON([Value, true]));
end;

procedure TExtSliderMulti.SetFThumbs(Value : TExtObjectList); begin
  FThumbs := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.thumbs=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtSliderMulti.SetFOnBeforechange(Value : TExtSliderMultiOnBeforechange); begin
  if Assigned(FOnBeforechange) then
    JSCode(JSName+'.events ["beforechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforechange', Ajax('beforechange', ['Slider', '%0.nm','NewValue', '%1','OldValue', '%2'], true));
  FOnBeforechange := Value;
end;

procedure TExtSliderMulti.SetFOnChange(Value : TExtSliderMultiOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['Slider', '%0.nm','NewValue', '%1','Thumb', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtSliderMulti.SetFOnChangecomplete(Value : TExtSliderMultiOnChangecomplete); begin
  if Assigned(FOnChangecomplete) then
    JSCode(JSName+'.events ["changecomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('changecomplete', Ajax('changecomplete', ['Slider', '%0.nm','NewValue', '%1','Thumb', '%2.nm'], true));
  FOnChangecomplete := Value;
end;

procedure TExtSliderMulti.SetFOnDragstart(Value : TExtSliderMultiOnDragstart); begin
  if Assigned(FOnDragstart) then
    JSCode(JSName+'.events ["dragstart"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragstart', Ajax('dragstart', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDragstart := Value;
end;

procedure TExtSliderMulti.SetFOnDrag(Value : TExtSliderMultiOnDrag); begin
  if Assigned(FOnDrag) then
    JSCode(JSName+'.events ["drag"].listeners=[];');
  if Assigned(Value) then
    AddListener('drag', Ajax('drag', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDrag := Value;
end;

procedure TExtSliderMulti.SetFOnDragend(Value : TExtSliderMultiOnDragend); begin
  if Assigned(FOnDragend) then
    JSCode(JSName+'.events ["dragend"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragend', Ajax('dragend', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDragend := Value;
end;

function TExtSliderMulti.JSClassName : string; begin
  Result := 'Ext.slider.Multi';
end;

procedure TExtSliderMulti.InitDefaults; begin
  inherited;
  FUseTips := TExtObject.CreateInternal(Self, 'useTips');
  FThumbs := TExtObjectList.Create(Self, 'thumbs');
end;

{$IFDEF FPC}constructor TExtSliderMulti.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtSliderMulti.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtSliderMulti.AddThumb(Value : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.addThumb(' + VarToJSON([Value]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetMinValue(Val : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Val]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetMaxValue(Val : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Val]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetValue(Index : Integer; Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Index, Value, Animate]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SyncThumbs : TExtFunction; begin
  JSCode(JSName + '.syncThumbs();', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.GetValue(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getValue(' + VarToJSON([Index]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtSliderMulti');
  Result := Self;
end;

destructor TExtSliderMulti.Destroy; begin
  try
    FUseTips.Free;
    FThumbs.Free;
  except end;
  inherited;
end;

procedure TExtSliderMulti.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforechange') and Assigned(FOnBeforechange) then
    FOnBeforechange(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), ParamAsInteger('OldValue'))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), TExtSliderThumb(ParamAsObject('Thumb')))
  else if (AEvtName = 'changecomplete') and Assigned(FOnChangecomplete) then
    FOnChangecomplete(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), TExtSliderThumb(ParamAsObject('Thumb')))
  else if (AEvtName = 'dragstart') and Assigned(FOnDragstart) then
    FOnDragstart(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'drag') and Assigned(FOnDrag) then
    FOnDrag(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dragend') and Assigned(FOnDragend) then
    FOnDragend(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtChartSeriesLine.SetFAxis(Value : String); begin
  FAxis := Value;
  JSCode('axis:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFSelectionTolerance(Value : Integer); begin
  FSelectionTolerance := Value;
  JSCode('selectionTolerance:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFShowMarkers(Value : Boolean); begin
  FShowMarkers := Value;
  JSCode('showMarkers:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFMarkerConfig(Value : TExtObject); begin
  FMarkerConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('markerConfig:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesLine.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesLine.SetFSmooth(Value : Boolean); begin
  FSmooth := Value;
  JSCode('smooth:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFSmoothInteger(Value : Integer); begin
  FSmoothInteger := Value;
  JSCode('smooth:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFFill(Value : Boolean); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

function TExtChartSeriesLine.JSClassName : string; begin
  Result := 'Ext.chart.series.Line';
end;

procedure TExtChartSeriesLine.InitDefaults; begin
  inherited;
  FMarkerConfig := TExtObject.CreateInternal(Self, 'markerConfig');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesLine.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesLine.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesLine.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesLine');
  Result := Self;
end;

destructor TExtChartSeriesLine.Destroy; begin
  try
    FMarkerConfig.Free;
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginRowEditing.SetFAutoCancel(Value : Boolean); begin
  FAutoCancel := Value;
  JSCode('autoCancel:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowEditing.SetFClicksToMoveEditor(Value : Integer); begin
  FClicksToMoveEditor := Value;
  JSCode('clicksToMoveEditor:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowEditing.SetFErrorSummary(Value : Boolean); begin
  FErrorSummary := Value;
  JSCode('errorSummary:' + VarToJSON([Value]));
end;

function TExtGridPluginRowEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.RowEditing';
end;

procedure TExtGridPluginRowEditing.InitDefaults; begin
  inherited;
  FAutoCancel := true;
  FErrorSummary := true;
end;

{$IFDEF FPC}constructor TExtGridPluginRowEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPluginRowEditing.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridPluginRowEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginRowEditing');
  Result := Self;
end;

procedure TExtButtonSplit.SetFArrowHandler(Value : TExtFunction); begin
  FArrowHandler := Value;
  if not ConfigAvailable(JSName) then
    SetArrowHandler(Value)
  else
    JSCode('arrowHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButtonSplit.SetFArrowTooltip(Value : String); begin
  FArrowTooltip := Value;
  JSCode('arrowTooltip:' + VarToJSON([Value]));
end;

procedure TExtButtonSplit.SetFOnArrowclick(Value : TExtButtonSplitOnArrowclick); begin
  if Assigned(FOnArrowclick) then
    JSCode(JSName+'.events ["arrowclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('arrowclick', Ajax('arrowclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnArrowclick := Value;
end;

function TExtButtonSplit.JSClassName : string; begin
  Result := 'Ext.button.Split';
end;

{$IFDEF FPC}constructor TExtButtonSplit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtButtonSplit.SetArrowHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setArrowHandler(' + VarToJSON([Handler, true, Scope, false]) + ');', 'TExtButtonSplit');
  Result := Self;
end;

procedure TExtButtonSplit.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'arrowclick') and Assigned(FOnArrowclick) then
    FOnArrowclick(TExtButtonSplit(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')));
end;

procedure TExtChart.SetFTheme(Value : String); begin
  FTheme := Value;
  JSCode('theme:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFAnimateTExtObject(Value : TExtObject); begin
  FAnimateTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('animate:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFLegend(Value : Boolean); begin
  FLegend := Value;
  JSCode('legend:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFLegendTExtObject(Value : TExtObject); begin
  FLegendTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('legend:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFInsetPadding(Value : Integer); begin
  FInsetPadding := Value;
  JSCode('insetPadding:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFEnginePriority(Value : TExtObjectList); begin
  FEnginePriority := Value;
  Value.DeleteFromGarbage;
  JSCode('enginePriority:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFBackground(Value : TExtObject); begin
  FBackground := Value;
  Value.DeleteFromGarbage;
  JSCode('background:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFBackgroundBoolean(Value : Boolean); begin
  FBackgroundBoolean := Value;
  JSCode('background:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFGradients(Value : TExtObjectList); begin
  FGradients := Value;
  Value.DeleteFromGarbage;
  JSCode('gradients:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFSeries(Value : TExtObjectList); begin
  FSeries := Value;
  Value.DeleteFromGarbage;
  JSCode('series:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFAxes(Value : TExtObjectList); begin
  FAxes := Value;
  Value.DeleteFromGarbage;
  JSCode('axes:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFOnBeforerefresh(Value : TExtChartOnBeforerefresh); begin
  if Assigned(FOnBeforerefresh) then
    JSCode(JSName+'.events ["beforerefresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerefresh', Ajax('beforerefresh', ['This', '%0.nm'], true));
  FOnBeforerefresh := Value;
end;

procedure TExtChart.SetFOnRefresh(Value : TExtChartOnRefresh); begin
  if Assigned(FOnRefresh) then
    JSCode(JSName+'.events ["refresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('refresh', Ajax('refresh', ['This', '%0.nm'], true));
  FOnRefresh := Value;
end;

function TExtChart.JSClassName : string; begin
  Result := 'Ext.chart.Chart';
end;

procedure TExtChart.InitDefaults; begin
  inherited;
  FAnimateTExtObject := TExtObject.CreateInternal(Self, 'animate');
  FLegendTExtObject := TExtObject.CreateInternal(Self, 'legend');
  FInsetPadding := 10;
  FEnginePriority := TExtObjectList.Create(Self, 'enginePriority');
  FBackground := TExtObject.CreateInternal(Self, 'background');
  FGradients := TExtObjectList.Create(Self, 'gradients');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FSeries := TExtObjectList.Create(Self, 'series');
  FAxes := TExtObjectList.Create(Self, 'axes');
end;

{$IFDEF FPC}constructor TExtChart.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChart.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChart.Redraw(Resize : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.redraw(' + VarToJSON([Resize]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.Save(Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.save(' + VarToJSON([Config, false]) + ');', 'TExtChart');
  Result := Self;
end;

destructor TExtChart.Destroy; begin
  try
    FAnimateTExtObject.Free;
    FLegendTExtObject.Free;
    FEnginePriority.Free;
    FBackground.Free;
    FGradients.Free;
    FStore.Free;
    FSeries.Free;
    FAxes.Free;
  except end;
  inherited;
end;

procedure TExtChart.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforerefresh') and Assigned(FOnBeforerefresh) then
    FOnBeforerefresh(TExtChart(ParamAsObject('This')))
  else if (AEvtName = 'refresh') and Assigned(FOnRefresh) then
    FOnRefresh(TExtChart(ParamAsObject('This')));
end;

procedure TExtDdDropTarget.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFOverClass(Value : String); begin
  FOverClass := Value;
  JSCode('overClass:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

function TExtDdDropTarget.JSClassName : string; begin
  Result := 'Ext.dd.DropTarget';
end;

{$IFDEF FPC}constructor TExtDdDropTarget.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSliderTip.SetFOffsets(Value : TExtObjectList); begin
  FOffsets := Value;
  Value.DeleteFromGarbage;
  JSCode('offsets:' + VarToJSON([Value, false]));
end;

procedure TExtSliderTip.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

procedure TExtSliderTip.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

function TExtSliderTip.JSClassName : string; begin
  Result := 'Ext.slider.Tip';
end;

procedure TExtSliderTip.InitDefaults; begin
  inherited;
  FOffsets := TExtObjectList.Create(Self, 'offsets');
end;

{$IFDEF FPC}constructor TExtSliderTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtSliderTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtSliderTip.Destroy; begin
  try
    FOffsets.Free;
  except end;
  inherited;
end;

function TExtFormActionDirectLoad.JSClassName : string; begin
  Result := 'Ext.form.action.DirectLoad';
end;

{$IFDEF FPC}constructor TExtFormActionDirectLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTreeView.SetFRootVisible(Value : Boolean); begin
  FRootVisible := Value;
  JSCode('rootVisible:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFDeferInitialRefresh(Value : Boolean); begin
  FDeferInitialRefresh := Value;
  JSCode('deferInitialRefresh:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFOnAfteritemexpand(Value : TExtTreeViewOnAfteritemexpand); begin
  if Assigned(FOnAfteritemexpand) then
    JSCode(JSName+'.events ["afteritemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemexpand', Ajax('afteritemexpand', ['Node', '%0.nm','Index', '%1','Item', '%2.nm'], true));
  FOnAfteritemexpand := Value;
end;

procedure TExtTreeView.SetFOnAfteritemcollapse(Value : TExtTreeViewOnAfteritemcollapse); begin
  if Assigned(FOnAfteritemcollapse) then
    JSCode(JSName+'.events ["afteritemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemcollapse', Ajax('afteritemcollapse', ['Node', '%0.nm','Index', '%1','Item', '%2.nm'], true));
  FOnAfteritemcollapse := Value;
end;

function TExtTreeView.JSClassName : string; begin
  Result := 'Ext.tree.View';
end;

{$IFDEF FPC}constructor TExtTreeView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTreeView.Expand(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.Collapse(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.Toggle(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.GetTreeStore : TExtFunction; begin
  JSCode(JSName + '.getTreeStore();', 'TExtTreeView');
  Result := Self;
end;

procedure TExtTreeView.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'afteritemexpand') and Assigned(FOnAfteritemexpand) then
    FOnAfteritemexpand(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'), THTMLElement(ParamAsObject('Item')))
  else if (AEvtName = 'afteritemcollapse') and Assigned(FOnAfteritemcollapse) then
    FOnAfteritemcollapse(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'), THTMLElement(ParamAsObject('Item')));
end;

procedure TExtChartAxisTime.SetFDateFormat(Value : String); begin
  FDateFormat := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFDateFormatBoolean(Value : Boolean); begin
  FDateFormatBoolean := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFFromDate(Value : TDateTime); begin
  FFromDate := Value;
  JSCode('fromDate:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFToDate(Value : TDateTime); begin
  FToDate := Value;
  JSCode('toDate:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFStep(Value : TExtObjectList); begin
  FStep := Value;
  Value.DeleteFromGarbage;
  JSCode('step:' + VarToJSON([Value, false]));
end;

procedure TExtChartAxisTime.SetFStepBoolean(Value : Boolean); begin
  FStepBoolean := Value;
  JSCode('step:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

function TExtChartAxisTime.JSClassName : string; begin
  Result := 'Ext.chart.axis.Time';
end;

procedure TExtChartAxisTime.InitDefaults; begin
  inherited;
  FStep := TExtObjectList.Create(Self, 'step');
end;

{$IFDEF FPC}constructor TExtChartAxisTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartAxisTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartAxisTime.Destroy; begin
  try
    FStep.Free;
  except end;
  inherited;
end;

procedure TExtTreePanel.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFLines(Value : Boolean); begin
  FLines := Value;
  JSCode('lines:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFUseArrows(Value : Boolean); begin
  FUseArrows := Value;
  JSCode('useArrows:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFSingleExpand(Value : Boolean); begin
  FSingleExpand := Value;
  JSCode('singleExpand:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFRootVisible(Value : Boolean); begin
  FRootVisible := Value;
  JSCode('rootVisible:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFRoot(Value : TExtDataModel); begin
  FRoot := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFRootTExtDataNodeInterface(Value : TExtDataNodeInterface); begin
  FRootTExtDataNodeInterface := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFRootTExtObject(Value : TExtObject); begin
  FRootTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFHideHeaders(Value : Boolean); begin
  FHideHeaders := Value;
  JSCode('hideHeaders:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFFolderSort(Value : Boolean); begin
  FFolderSort := Value;
  JSCode('folderSort:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFStore(Value : TExtDataTreeStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFOnBeforeload(Value : TExtTreePanelOnBeforeload); begin
  if Assigned(FOnBeforeload) then
    JSCode(JSName+'.events ["beforeload"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeload', Ajax('beforeload', [], true));
  FOnBeforeload := Value;
end;

procedure TExtTreePanel.SetFOnLoad(Value : TExtTreePanelOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', [], true));
  FOnLoad := Value;
end;

procedure TExtTreePanel.SetFOnItemappend(Value : TExtTreePanelOnItemappend); begin
  if Assigned(FOnItemappend) then
    JSCode(JSName+'.events ["itemappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemappend', Ajax('itemappend', [], true));
  FOnItemappend := Value;
end;

procedure TExtTreePanel.SetFOnItemremove(Value : TExtTreePanelOnItemremove); begin
  if Assigned(FOnItemremove) then
    JSCode(JSName+'.events ["itemremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemremove', Ajax('itemremove', [], true));
  FOnItemremove := Value;
end;

procedure TExtTreePanel.SetFOnItemmove(Value : TExtTreePanelOnItemmove); begin
  if Assigned(FOnItemmove) then
    JSCode(JSName+'.events ["itemmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmove', Ajax('itemmove', [], true));
  FOnItemmove := Value;
end;

procedure TExtTreePanel.SetFOnIteminsert(Value : TExtTreePanelOnIteminsert); begin
  if Assigned(FOnIteminsert) then
    JSCode(JSName+'.events ["iteminsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('iteminsert', Ajax('iteminsert', [], true));
  FOnIteminsert := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemappend(Value : TExtTreePanelOnBeforeitemappend); begin
  if Assigned(FOnBeforeitemappend) then
    JSCode(JSName+'.events ["beforeitemappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemappend', Ajax('beforeitemappend', [], true));
  FOnBeforeitemappend := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemremove(Value : TExtTreePanelOnBeforeitemremove); begin
  if Assigned(FOnBeforeitemremove) then
    JSCode(JSName+'.events ["beforeitemremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemremove', Ajax('beforeitemremove', [], true));
  FOnBeforeitemremove := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemmove(Value : TExtTreePanelOnBeforeitemmove); begin
  if Assigned(FOnBeforeitemmove) then
    JSCode(JSName+'.events ["beforeitemmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmove', Ajax('beforeitemmove', [], true));
  FOnBeforeitemmove := Value;
end;

procedure TExtTreePanel.SetFOnBeforeiteminsert(Value : TExtTreePanelOnBeforeiteminsert); begin
  if Assigned(FOnBeforeiteminsert) then
    JSCode(JSName+'.events ["beforeiteminsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeiteminsert', Ajax('beforeiteminsert', [], true));
  FOnBeforeiteminsert := Value;
end;

procedure TExtTreePanel.SetFOnItemexpand(Value : TExtTreePanelOnItemexpand); begin
  if Assigned(FOnItemexpand) then
    JSCode(JSName+'.events ["itemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemexpand', Ajax('itemexpand', [], true));
  FOnItemexpand := Value;
end;

procedure TExtTreePanel.SetFOnItemcollapse(Value : TExtTreePanelOnItemcollapse); begin
  if Assigned(FOnItemcollapse) then
    JSCode(JSName+'.events ["itemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcollapse', Ajax('itemcollapse', [], true));
  FOnItemcollapse := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemexpand(Value : TExtTreePanelOnBeforeitemexpand); begin
  if Assigned(FOnBeforeitemexpand) then
    JSCode(JSName+'.events ["beforeitemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemexpand', Ajax('beforeitemexpand', [], true));
  FOnBeforeitemexpand := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemcollapse(Value : TExtTreePanelOnBeforeitemcollapse); begin
  if Assigned(FOnBeforeitemcollapse) then
    JSCode(JSName+'.events ["beforeitemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcollapse', Ajax('beforeitemcollapse', [], true));
  FOnBeforeitemcollapse := Value;
end;

procedure TExtTreePanel.SetFOnCheckchange(Value : TExtTreePanelOnCheckchange); begin
  if Assigned(FOnCheckchange) then
    JSCode(JSName+'.events ["checkchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('checkchange', Ajax('checkchange', ['Node', '%0.nm','Checked', '%1'], true));
  FOnCheckchange := Value;
end;

procedure TExtTreePanel.SetFOnAfteritemexpand(Value : TExtTreePanelOnAfteritemexpand); begin
  if Assigned(FOnAfteritemexpand) then
    JSCode(JSName+'.events ["afteritemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemexpand', Ajax('afteritemexpand', [], true));
  FOnAfteritemexpand := Value;
end;

procedure TExtTreePanel.SetFOnAfteritemcollapse(Value : TExtTreePanelOnAfteritemcollapse); begin
  if Assigned(FOnAfteritemcollapse) then
    JSCode(JSName+'.events ["afteritemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemcollapse', Ajax('afteritemcollapse', [], true));
  FOnAfteritemcollapse := Value;
end;

function TExtTreePanel.JSClassName : string; begin
  Result := 'Ext.tree.Panel';
end;

procedure TExtTreePanel.InitDefaults; begin
  inherited;
  FRoot := TExtDataModel.CreateInternal(Self, 'root');
  FRootTExtDataNodeInterface := TExtDataNodeInterface.CreateInternal(Self, 'root');
  FRootTExtObject := TExtObject.CreateInternal(Self, 'root');
  FStore := TExtDataTreeStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtTreePanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTreePanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTreePanel.SetRootNode(Root : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.setRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SetRootNode(Root : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.GetRootNode : TExtFunction; begin
  JSCode(JSName + '.getRootNode();', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.GetChecked : TExtFunction; begin
  JSCode(JSName + '.getChecked();', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.ExpandNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandNode(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.CollapseNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseNode(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.ExpandAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandAll(' + VarToJSON([Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.CollapseAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseAll(' + VarToJSON([Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.ExpandPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandPath(' + VarToJSON([Path, Field, Separator, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SelectPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.selectPath(' + VarToJSON([Path, Field, Separator, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

destructor TExtTreePanel.Destroy; begin
  try
    FRoot.Free;
    FRootTExtDataNodeInterface.Free;
    FRootTExtObject.Free;
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtTreePanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeload') and Assigned(FOnBeforeload) then
    FOnBeforeload()
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad()
  else if (AEvtName = 'itemappend') and Assigned(FOnItemappend) then
    FOnItemappend()
  else if (AEvtName = 'itemremove') and Assigned(FOnItemremove) then
    FOnItemremove()
  else if (AEvtName = 'itemmove') and Assigned(FOnItemmove) then
    FOnItemmove()
  else if (AEvtName = 'iteminsert') and Assigned(FOnIteminsert) then
    FOnIteminsert()
  else if (AEvtName = 'beforeitemappend') and Assigned(FOnBeforeitemappend) then
    FOnBeforeitemappend()
  else if (AEvtName = 'beforeitemremove') and Assigned(FOnBeforeitemremove) then
    FOnBeforeitemremove()
  else if (AEvtName = 'beforeitemmove') and Assigned(FOnBeforeitemmove) then
    FOnBeforeitemmove()
  else if (AEvtName = 'beforeiteminsert') and Assigned(FOnBeforeiteminsert) then
    FOnBeforeiteminsert()
  else if (AEvtName = 'itemexpand') and Assigned(FOnItemexpand) then
    FOnItemexpand()
  else if (AEvtName = 'itemcollapse') and Assigned(FOnItemcollapse) then
    FOnItemcollapse()
  else if (AEvtName = 'beforeitemexpand') and Assigned(FOnBeforeitemexpand) then
    FOnBeforeitemexpand()
  else if (AEvtName = 'beforeitemcollapse') and Assigned(FOnBeforeitemcollapse) then
    FOnBeforeitemcollapse()
  else if (AEvtName = 'checkchange') and Assigned(FOnCheckchange) then
    FOnCheckchange(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('Checked'))
  else if (AEvtName = 'afteritemexpand') and Assigned(FOnAfteritemexpand) then
    FOnAfteritemexpand()
  else if (AEvtName = 'afteritemcollapse') and Assigned(FOnAfteritemcollapse) then
    FOnAfteritemcollapse();
end;

function TExtFxTargetCompositeElementCSS.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeElementCSS';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeElementCSS.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataReaderXml.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

procedure TExtDataReaderXml.SetFXmlData(Value : TExtObject); begin
  FXmlData := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.xmlData=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataReaderXml.JSClassName : string; begin
  Result := 'Ext.data.reader.Xml';
end;

procedure TExtDataReaderXml.InitDefaults; begin
  inherited;
  FXmlData := TExtObject.CreateInternal(Self, 'xmlData');
end;

{$IFDEF FPC}constructor TExtDataReaderXml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataReaderXml.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataReaderXml.Destroy; begin
  try
    FXmlData.Free;
  except end;
  inherited;
end;

function TExtDirectExceptionEvent.JSClassName : string; begin
  Result := 'Ext.direct.ExceptionEvent';
end;

{$IFDEF FPC}constructor TExtDirectExceptionEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartLegendItem.JSClassName : string; begin
  Result := 'Ext.chart.LegendItem';
end;

{$IFDEF FPC}constructor TExtChartLegendItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartLegendItem.CreateLegend : TExtFunction; begin
  JSCode(JSName + '.createLegend();', 'TExtChartLegendItem');
  Result := Self;
end;

function TExtChartLegendItem.UpdatePosition(RelativeTo : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.updatePosition(' + VarToJSON([RelativeTo, false]) + ');', 'TExtChartLegendItem');
  Result := Self;
end;

procedure TExtDataReaderJson.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

procedure TExtDataReaderJson.SetFUseSimpleAccessors(Value : Boolean); begin
  FUseSimpleAccessors := Value;
  JSCode('useSimpleAccessors:' + VarToJSON([Value]));
end;

procedure TExtDataReaderJson.SetFJsonData(Value : TExtObject); begin
  FJsonData := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.jsonData=' + VarToJSON([Value, false]) + ';');
end;

function TExtDataReaderJson.JSClassName : string; begin
  Result := 'Ext.data.reader.Json';
end;

procedure TExtDataReaderJson.InitDefaults; begin
  inherited;
  FJsonData := TExtObject.CreateInternal(Self, 'jsonData');
end;

{$IFDEF FPC}constructor TExtDataReaderJson.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataReaderJson.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataReaderJson.Destroy; begin
  try
    FJsonData.Free;
  except end;
  inherited;
end;

procedure TExtTipToolTip.SetFTarget(Value : THTMLElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipToolTip.SetFTargetTExtElement(Value : TExtElement); begin
  FTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipToolTip.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAutoHide(Value : Boolean); begin
  FAutoHide := Value;
  JSCode('autoHide:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFShowDelay(Value : Integer); begin
  FShowDelay := Value;
  JSCode('showDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFHideDelay(Value : Integer); begin
  FHideDelay := Value;
  JSCode('hideDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFDismissDelay(Value : Integer); begin
  FDismissDelay := Value;
  JSCode('dismissDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFMouseOffset(Value : TArrayOfInteger); begin
  FMouseOffset := Value;
  JSCode('mouseOffset:' + ArrayToJSON(Value));
end;

procedure TExtTipToolTip.SetFTrackMouse(Value : Boolean); begin
  FTrackMouse := Value;
  JSCode('trackMouse:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAnchor(Value : String); begin
  FAnchor := Value;
  JSCode('anchor:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAnchorToTarget(Value : Boolean); begin
  FAnchorToTarget := Value;
  JSCode('anchorToTarget:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAnchorOffset(Value : Integer); begin
  FAnchorOffset := Value;
  JSCode('anchorOffset:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

function TExtTipToolTip.JSClassName : string; begin
  Result := 'Ext.tip.ToolTip';
end;

procedure TExtTipToolTip.InitDefaults; begin
  inherited;
  FTargetTExtElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtTipToolTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTipToolTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTipToolTip.SetTarget(T : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([T]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.SetTarget(T : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([T, false]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.SetTarget(T : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([T, false]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.Show : TExtFunction; begin
  JSCode(JSName + '.show();', 'TExtTipToolTip');
  Result := Self;
end;

destructor TExtTipToolTip.Destroy; begin
  try
    FTargetTExtElement.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginCellEditing.SetFOnBeforeedit(Value : TExtGridPluginCellEditingOnBeforeedit); begin
  if Assigned(FOnBeforeedit) then
    JSCode(JSName+'.events ["beforeedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeedit', Ajax('beforeedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnBeforeedit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnEdit(Value : TExtGridPluginCellEditingOnEdit); begin
  if Assigned(FOnEdit) then
    JSCode(JSName+'.events ["edit"].listeners=[];');
  if Assigned(Value) then
    AddListener('edit', Ajax('edit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnEdit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnValidateedit(Value : TExtGridPluginCellEditingOnValidateedit); begin
  if Assigned(FOnValidateedit) then
    JSCode(JSName+'.events ["validateedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('validateedit', Ajax('validateedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnValidateedit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnCanceledit(Value : TExtGridPluginCellEditingOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnCanceledit := Value;
end;

function TExtGridPluginCellEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.CellEditing';
end;

{$IFDEF FPC}constructor TExtGridPluginCellEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginCellEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.CancelEdit : TExtFunction; begin
  JSCode(JSName + '.cancelEdit();', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEditByPosition(Position : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.startEditByPosition(' + VarToJSON([Position, false]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

procedure TExtGridPluginCellEditing.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeedit') and Assigned(FOnBeforeedit) then
    FOnBeforeedit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'edit') and Assigned(FOnEdit) then
    FOnEdit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'validateedit') and Assigned(FOnValidateedit) then
    FOnValidateedit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')));
end;

procedure TExtGridColumn.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFStateId(Value : String); begin
  FStateId := Value;
  JSCode('stateId:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFDataIndex(Value : String); begin
  FDataIndex := Value;
  JSCode('dataIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFHeader(Value : String); begin
  FHeader := Value;
  JSCode('header:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFMenuText(Value : String); begin
  FMenuText := Value;
  JSCode('menuText:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFEmptyCellText(Value : String); begin
  FEmptyCellText := Value;
  JSCode('emptyCellText:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFSortable(Value : Boolean); begin
  FSortable := Value;
  JSCode('sortable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFGroupable(Value : Boolean); begin
  FGroupable := Value;
  JSCode('groupable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode('fixed:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFLocked(Value : Boolean); begin
  FLocked := Value;
  JSCode('locked:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFHideable(Value : Boolean); begin
  FHideable := Value;
  JSCode('hideable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFMenuDisabled(Value : Boolean); begin
  FMenuDisabled := Value;
  JSCode('menuDisabled:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumn.SetFRendererString(Value : String); begin
  FRendererString := Value;
  JSCode('renderer:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFEditRenderer(Value : TExtFunction); begin
  FEditRenderer := Value;
  JSCode('editRenderer:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumn.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTdCls(Value : String); begin
  FTdCls := Value;
  JSCode('tdCls:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFEditor(Value : TExtObject); begin
  FEditor := Value;
  Value.DeleteFromGarbage;
  JSCode('editor:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFEditorString(Value : String); begin
  FEditorString := Value;
  JSCode('editor:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFField(Value : TExtObject); begin
  FField := Value;
  Value.DeleteFromGarbage;
  JSCode('field:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFFieldString(Value : String); begin
  FFieldString := Value;
  JSCode('field:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTriggerEl(Value : TExtElement); begin
  FTriggerEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.triggerEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridColumn.SetFTextEl(Value : TExtElement); begin
  FTextEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.textEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridColumn.SetFIsHeader(Value : Boolean); begin
  FIsHeader := Value;
  JSCode(JSName + '.isHeader=' + VarToJSON([Value]) + ';');
end;

function TExtGridColumn.JSClassName : string; begin
  Result := 'Ext.grid.column.Column';
end;

procedure TExtGridColumn.InitDefaults; begin
  inherited;
  FColumns := TExtObjectList.Create(Self, 'columns');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FEditor := TExtObject.CreateInternal(Self, 'editor');
  FField := TExtObject.CreateInternal(Self, 'field');
  FTriggerEl := TExtElement.CreateInternal(Self, 'triggerEl');
  FTextEl := TExtElement.CreateInternal(Self, 'textEl');
end;

{$IFDEF FPC}constructor TExtGridColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridColumn.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridColumn.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.GetIndex : TExtFunction; begin
  JSCode(JSName + '.getIndex();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.GetVisibleIndex : TExtFunction; begin
  JSCode(JSName + '.getVisibleIndex();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.GetSortParam : TExtFunction; begin
  JSCode(JSName + '.getSortParam();', 'TExtGridColumn');
  Result := Self;
end;

destructor TExtGridColumn.Destroy; begin
  try
    FColumns.Free;
    FScope.Free;
    FEditor.Free;
    FField.Free;
    FTriggerEl.Free;
    FTextEl.Free;
  except end;
  inherited;
end;

procedure TExtDrawText.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtDrawText.SetFStyleSelector(Value : String); begin
  FStyleSelector := Value;
  JSCode('styleSelector:' + VarToJSON([Value]));
end;

procedure TExtDrawText.SetFDegrees(Value : Integer); begin
  FDegrees := Value;
  JSCode('degrees:' + VarToJSON([Value]));
end;

function TExtDrawText.JSClassName : string; begin
  Result := 'Ext.draw.Text';
end;

{$IFDEF FPC}constructor TExtDrawText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawText.SetAngle(Degrees : Integer) : TExtFunction; begin
  JSCode(JSName + '.setAngle(' + VarToJSON([Degrees]) + ');', 'TExtDrawText');
  Result := Self;
end;

function TExtDrawText.SetText(T : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([T]) + ');', 'TExtDrawText');
  Result := Self;
end;

function TExtToolbarSeparator.JSClassName : string; begin
  Result := 'Ext.toolbar.Separator';
end;

{$IFDEF FPC}constructor TExtToolbarSeparator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtToolbarTextItem.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtToolbarTextItem.JSClassName : string; begin
  Result := 'Ext.toolbar.TextItem';
end;

{$IFDEF FPC}constructor TExtToolbarTextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtToolbarTextItem.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtToolbarTextItem');
  Result := Self;
end;

procedure TExtGridPanel.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtGridPanel.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridPanel.SetFColumnsTExtObject(Value : TExtObject); begin
  FColumnsTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridPanel.SetFOnReconfigure(Value : TExtGridPanelOnReconfigure); begin
  if Assigned(FOnReconfigure) then
    JSCode(JSName+'.events ["reconfigure"].listeners=[];');
  if Assigned(Value) then
    AddListener('reconfigure', Ajax('reconfigure', ['This', '%0.nm','Store', '%1.nm','Columns', '%2.nm'], true));
  FOnReconfigure := Value;
end;

function TExtGridPanel.JSClassName : string; begin
  Result := 'Ext.grid.Panel';
end;

procedure TExtGridPanel.InitDefaults; begin
  inherited;
  FColumns := TExtObjectList.Create(Self, 'columns');
  FColumnsTExtObject := TExtObject.CreateInternal(Self, 'columns');
end;

{$IFDEF FPC}constructor TExtGridPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtGridPanel.Destroy; begin
  try
    FColumns.Free;
    FColumnsTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtGridPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'reconfigure') and Assigned(FOnReconfigure) then
    FOnReconfigure(TExtGridPanel(ParamAsObject('This')), TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Columns')));
end;

procedure TExtToolbarPaging.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtToolbarPaging.SetFDisplayInfo(Value : Boolean); begin
  FDisplayInfo := Value;
  JSCode('displayInfo:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFPrependButtons(Value : Boolean); begin
  FPrependButtons := Value;
  JSCode('prependButtons:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFDisplayMsg(Value : String); begin
  FDisplayMsg := Value;
  JSCode('displayMsg:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFEmptyMsg(Value : String); begin
  FEmptyMsg := Value;
  JSCode('emptyMsg:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFBeforePageText(Value : String); begin
  FBeforePageText := Value;
  JSCode('beforePageText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFAfterPageText(Value : String); begin
  FAfterPageText := Value;
  JSCode('afterPageText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFFirstText(Value : String); begin
  FFirstText := Value;
  JSCode('firstText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFPrevText(Value : String); begin
  FPrevText := Value;
  JSCode('prevText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFNextText(Value : String); begin
  FNextText := Value;
  JSCode('nextText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFLastText(Value : String); begin
  FLastText := Value;
  JSCode('lastText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFRefreshText(Value : String); begin
  FRefreshText := Value;
  JSCode('refreshText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFInputItemWidth(Value : Integer); begin
  FInputItemWidth := Value;
  JSCode('inputItemWidth:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFOnChange(Value : TExtToolbarPagingOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','PageData', '%1.nm'], true));
  FOnChange := Value;
end;

procedure TExtToolbarPaging.SetFOnBeforechange(Value : TExtToolbarPagingOnBeforechange); begin
  if Assigned(FOnBeforechange) then
    JSCode(JSName+'.events ["beforechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforechange', Ajax('beforechange', ['This', '%0.nm','Page', '%1'], true));
  FOnBeforechange := Value;
end;

function TExtToolbarPaging.JSClassName : string; begin
  Result := 'Ext.toolbar.Paging';
end;

procedure TExtToolbarPaging.InitDefaults; begin
  inherited;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtToolbarPaging.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtToolbarPaging.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtToolbarPaging.MoveFirst : TExtFunction; begin
  JSCode(JSName + '.moveFirst();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MovePrevious : TExtFunction; begin
  JSCode(JSName + '.movePrevious();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MoveNext : TExtFunction; begin
  JSCode(JSName + '.moveNext();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MoveLast : TExtFunction; begin
  JSCode(JSName + '.moveLast();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.DoRefresh : TExtFunction; begin
  JSCode(JSName + '.doRefresh();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.Unbind(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.unbind(' + VarToJSON([Store, false]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.Bind(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.bind(' + VarToJSON([Store, false]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

destructor TExtToolbarPaging.Destroy; begin
  try
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtToolbarPaging.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtToolbarPaging(ParamAsObject('This')), TExtObject(ParamAsObject('PageData')))
  else if (AEvtName = 'beforechange') and Assigned(FOnBeforechange) then
    FOnBeforechange(TExtToolbarPaging(ParamAsObject('This')), ParamAsInteger('Page'));
end;

procedure TExtDataWriterXml.SetFDocumentRoot(Value : String); begin
  FDocumentRoot := Value;
  JSCode('documentRoot:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFDefaultDocumentRoot(Value : String); begin
  FDefaultDocumentRoot := Value;
  JSCode('defaultDocumentRoot:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFHeader(Value : String); begin
  FHeader := Value;
  JSCode('header:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

function TExtDataWriterXml.JSClassName : string; begin
  Result := 'Ext.data.writer.Xml';
end;

procedure TExtDataWriterXml.InitDefaults; begin
  inherited;
  FDocumentRoot := 'xmlData';
  FRecordJS := 'record';
end;

{$IFDEF FPC}constructor TExtDataWriterXml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataWriterXml.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtLayoutContainerTable.SetFColumns(Value : Integer); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerTable.SetFTableAttrs(Value : TExtObject); begin
  FTableAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('tableAttrs:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerTable.SetFTrAttrs(Value : TExtObject); begin
  FTrAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('trAttrs:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerTable.SetFTdAttrs(Value : TExtObject); begin
  FTdAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('tdAttrs:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerTable.JSClassName : string; begin
  Result := 'Ext.layout.container.Table';
end;

procedure TExtLayoutContainerTable.InitDefaults; begin
  inherited;
  FTableAttrs := TExtObject.CreateInternal(Self, 'tableAttrs');
  FTrAttrs := TExtObject.CreateInternal(Self, 'trAttrs');
  FTdAttrs := TExtObject.CreateInternal(Self, 'tdAttrs');
end;

{$IFDEF FPC}constructor TExtLayoutContainerTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerTable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerTable.Destroy; begin
  try
    FTableAttrs.Free;
    FTrAttrs.Free;
    FTdAttrs.Free;
  except end;
  inherited;
end;

function TExtLayoutContainerColumn.JSClassName : string; begin
  Result := 'Ext.layout.container.Column';
end;

{$IFDEF FPC}constructor TExtLayoutContainerColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerFit.SetFDefaultMargins(Value : TExtObject); begin
  FDefaultMargins := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultMargins:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerFit.JSClassName : string; begin
  Result := 'Ext.layout.container.Fit';
end;

procedure TExtLayoutContainerFit.InitDefaults; begin
  inherited;
  FDefaultMargins := TExtObject.CreateInternal(Self, 'defaultMargins');
end;

{$IFDEF FPC}constructor TExtLayoutContainerFit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerFit.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerFit.Destroy; begin
  try
    FDefaultMargins.Free;
  except end;
  inherited;
end;

procedure TExtMenuColorPicker.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuColorPicker.SetFPickerId(Value : String); begin
  FPickerId := Value;
  JSCode('pickerId:' + VarToJSON([Value]));
end;

procedure TExtMenuColorPicker.SetFPicker(Value : TExtPickerColor); begin
  FPicker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.picker=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenuColorPicker.SetFOnSelect(Value : TExtMenuColorPickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

function TExtMenuColorPicker.JSClassName : string; begin
  Result := 'Ext.menu.ColorPicker';
end;

procedure TExtMenuColorPicker.InitDefaults; begin
  inherited;
  FPicker := TExtPickerColor.CreateInternal(Self, 'picker');
end;

{$IFDEF FPC}constructor TExtMenuColorPicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuColorPicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtMenuColorPicker.Destroy; begin
  try
    FPicker.Free;
  except end;
  inherited;
end;

procedure TExtMenuColorPicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect();
end;

procedure TExtMenuDatePicker.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuDatePicker.SetFPickerId(Value : String); begin
  FPickerId := Value;
  JSCode('pickerId:' + VarToJSON([Value]));
end;

procedure TExtMenuDatePicker.SetFPicker(Value : TExtPickerDate); begin
  FPicker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.picker=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenuDatePicker.SetFOnSelect(Value : TExtMenuDatePickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

function TExtMenuDatePicker.JSClassName : string; begin
  Result := 'Ext.menu.DatePicker';
end;

procedure TExtMenuDatePicker.InitDefaults; begin
  inherited;
  FPicker := TExtPickerDate.CreateInternal(Self, 'picker');
end;

{$IFDEF FPC}constructor TExtMenuDatePicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuDatePicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtMenuDatePicker.Destroy; begin
  try
    FPicker.Free;
  except end;
  inherited;
end;

procedure TExtMenuDatePicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect();
end;

procedure TExtDdDDProxy.SetFResizeFrame(Value : Boolean); begin
  FResizeFrame := Value;
  JSCode(JSName + '.resizeFrame=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDDProxy.SetFCenterFrame(Value : Boolean); begin
  FCenterFrame := Value;
  JSCode(JSName + '.centerFrame=' + VarToJSON([Value]) + ';');
end;

function TExtDdDDProxy.JSClassName : string; begin
  Result := 'Ext.dd.DDProxy';
end;

{$IFDEF FPC}constructor TExtDdDDProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDDProxy.CreateFrame : TExtFunction; begin
  JSCode(JSName + '.createFrame();', 'TExtDdDDProxy');
  Result := Self;
end;

function TExtDdDDProxy.InitFrame : TExtFunction; begin
  JSCode(JSName + '.initFrame();', 'TExtDdDDProxy');
  Result := Self;
end;

procedure TExtMenuCheckItem.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  if not ConfigAvailable(JSName) then
    SetChecked(Value)
  else
    JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFCheckHandler(Value : TExtFunction); begin
  FCheckHandler := Value;
  JSCode('checkHandler:' + VarToJSON([Value, true]));
end;

procedure TExtMenuCheckItem.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtMenuCheckItem.SetFGroup(Value : String); begin
  FGroup := Value;
  JSCode('group:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFCheckedCls(Value : String); begin
  FCheckedCls := Value;
  JSCode('checkedCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFUncheckedCls(Value : String); begin
  FUncheckedCls := Value;
  JSCode('uncheckedCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFGroupCls(Value : String); begin
  FGroupCls := Value;
  JSCode('groupCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFCheckChangeDisabled(Value : Boolean); begin
  FCheckChangeDisabled := Value;
  JSCode('checkChangeDisabled:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFOnBeforecheckchange(Value : TExtMenuCheckItemOnBeforecheckchange); begin
  if Assigned(FOnBeforecheckchange) then
    JSCode(JSName+'.events ["beforecheckchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecheckchange', Ajax('beforecheckchange', ['This', '%0.nm','Checked', '%1'], true));
  FOnBeforecheckchange := Value;
end;

procedure TExtMenuCheckItem.SetFOnCheckchange(Value : TExtMenuCheckItemOnCheckchange); begin
  if Assigned(FOnCheckchange) then
    JSCode(JSName+'.events ["checkchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('checkchange', Ajax('checkchange', ['This', '%0.nm','Checked', '%1'], true));
  FOnCheckchange := Value;
end;

function TExtMenuCheckItem.JSClassName : string; begin
  Result := 'Ext.menu.CheckItem';
end;

procedure TExtMenuCheckItem.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FHideOnClick := true;
end;

{$IFDEF FPC}constructor TExtMenuCheckItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuCheckItem.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenuCheckItem.DisableCheckChange : TExtFunction; begin
  JSCode(JSName + '.disableCheckChange();', 'TExtMenuCheckItem');
  Result := Self;
end;

function TExtMenuCheckItem.EnableCheckChange : TExtFunction; begin
  JSCode(JSName + '.enableCheckChange();', 'TExtMenuCheckItem');
  Result := Self;
end;

function TExtMenuCheckItem.SetChecked(Checked : Boolean; SuppressEvents : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setChecked(' + VarToJSON([Checked, SuppressEvents]) + ');', 'TExtMenuCheckItem');
  Result := Self;
end;

destructor TExtMenuCheckItem.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtMenuCheckItem.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecheckchange') and Assigned(FOnBeforecheckchange) then
    FOnBeforecheckchange(TExtMenuCheckItem(ParamAsObject('This')), ParamAsBoolean('Checked'))
  else if (AEvtName = 'checkchange') and Assigned(FOnCheckchange) then
    FOnCheckchange(TExtMenuCheckItem(ParamAsObject('This')), ParamAsBoolean('Checked'));
end;

procedure TExtLayoutContainerAnchor.SetFAnchor(Value : String); begin
  FAnchor := Value;
  JSCode('anchor:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAnchor.SetFDefaultAnchor(Value : String); begin
  FDefaultAnchor := Value;
  JSCode('defaultAnchor:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAnchor.SetFAnchorSize(Value : Integer); begin
  FAnchorSize := Value;
  JSCode('anchorSize:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAnchor.SetFAnchorSizeTExtObject(Value : TExtObject); begin
  FAnchorSizeTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('anchorSize:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerAnchor.JSClassName : string; begin
  Result := 'Ext.layout.container.Anchor';
end;

procedure TExtLayoutContainerAnchor.InitDefaults; begin
  inherited;
  FAnchorSizeTExtObject := TExtObject.CreateInternal(Self, 'anchorSize');
end;

{$IFDEF FPC}constructor TExtLayoutContainerAnchor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerAnchor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerAnchor.Destroy; begin
  try
    FAnchorSizeTExtObject.Free;
  except end;
  inherited;
end;

function TExtLayoutContainerAuto.JSClassName : string; begin
  Result := 'Ext.layout.container.Auto';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAuto.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldText.SetFVtypeText(Value : String); begin
  FVtypeText := Value;
  JSCode('vtypeText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFStripCharsRe(Value : TRegExp); begin
  FStripCharsRe := Value;
  JSCode('stripCharsRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFSize(Value : Integer); begin
  FSize := Value;
  JSCode('size:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrow(Value : Boolean); begin
  FGrow := Value;
  JSCode('grow:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowAppend(Value : String); begin
  FGrowAppend := Value;
  JSCode('growAppend:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFVtype(Value : String); begin
  FVtype := Value;
  JSCode('vtype:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMaskRe(Value : TRegExp); begin
  FMaskRe := Value;
  JSCode('maskRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFDisableKeyFilter(Value : Boolean); begin
  FDisableKeyFilter := Value;
  JSCode('disableKeyFilter:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMinLength(Value : Integer); begin
  FMinLength := Value;
  JSCode('minLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMaxLength(Value : Integer); begin
  FMaxLength := Value;
  JSCode('maxLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEnforceMaxLength(Value : Boolean); begin
  FEnforceMaxLength := Value;
  JSCode('enforceMaxLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMaxLengthText(Value : String); begin
  FMaxLengthText := Value;
  JSCode('maxLengthText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFValidator(Value : TExtFunction); begin
  FValidator := Value;
  JSCode('validator:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldText.SetFRegex(Value : TRegExp); begin
  FRegex := Value;
  JSCode('regex:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFRegexText(Value : String); begin
  FRegexText := Value;
  JSCode('regexText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEmptyCls(Value : String); begin
  FEmptyCls := Value;
  JSCode('emptyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFRequiredCls(Value : String); begin
  FRequiredCls := Value;
  JSCode('requiredCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEnableKeyEvents(Value : Boolean); begin
  FEnableKeyEvents := Value;
  JSCode('enableKeyEvents:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFOnAutosize(Value : TExtFormFieldTextOnAutosize); begin
  if Assigned(FOnAutosize) then
    JSCode(JSName+'.events ["autosize"].listeners=[];');
  if Assigned(Value) then
    AddListener('autosize', Ajax('autosize', ['This', '%0.nm','Width', '%1'], true));
  FOnAutosize := Value;
end;

procedure TExtFormFieldText.SetFOnKeydown(Value : TExtFormFieldTextOnKeydown); begin
  if Assigned(FOnKeydown) then
    JSCode(JSName+'.events ["keydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('keydown', Ajax('keydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeydown := Value;
end;

procedure TExtFormFieldText.SetFOnKeyup(Value : TExtFormFieldTextOnKeyup); begin
  if Assigned(FOnKeyup) then
    JSCode(JSName+'.events ["keyup"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyup', Ajax('keyup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeyup := Value;
end;

procedure TExtFormFieldText.SetFOnKeypress(Value : TExtFormFieldTextOnKeypress); begin
  if Assigned(FOnKeypress) then
    JSCode(JSName+'.events ["keypress"].listeners=[];');
  if Assigned(Value) then
    AddListener('keypress', Ajax('keypress', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeypress := Value;
end;

function TExtFormFieldText.JSClassName : string; begin
  Result := 'Ext.form.field.Text';
end;

procedure TExtFormFieldText.InitDefaults; begin
  inherited;
  FSize := 20;
  FGrowAppend := 'W';
end;

{$IFDEF FPC}constructor TExtFormFieldText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldText.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldText.ProcessRawValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.processRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.selectText(' + VarToJSON([Start, EndJS]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.AutoSize : TExtFunction; begin
  JSCode(JSName + '.autoSize();', 'TExtFormFieldText');
  Result := Self;
end;

procedure TExtFormFieldText.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'autosize') and Assigned(FOnAutosize) then
    FOnAutosize(TExtFormFieldText(ParamAsObject('This')), ParamAsInteger('Width'))
  else if (AEvtName = 'keydown') and Assigned(FOnKeydown) then
    FOnKeydown(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'keyup') and Assigned(FOnKeyup) then
    FOnKeyup(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'keypress') and Assigned(FOnKeypress) then
    FOnKeypress(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

function TExtWindowMessageBox.JSClassName : string; begin
  Result := 'Ext.window.MessageBox';
end;

{$IFDEF FPC}constructor TExtWindowMessageBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtWindowMessageBox.Show(Config : TExtObject; ConfigAnimateTarget : String; ConfigButtons : Integer = 0; ConfigClosable : Boolean = false; ConfigCls : String = ''; ConfigDefaultTextHeight : Integer = 0; ConfigFn : TExtFunction = nil; ConfigFnButtonId : String = ''; ConfigFnText : String = ''; ConfigFnOpt : TExtObject = nil; ConfigButtonText : TExtObject = nil; ConfigScope : TExtObject = nil; ConfigIcon : String = ''; ConfigIconCls : String = ''; ConfigMaxWidth : Integer = 0; ConfigMinWidth : Integer = 0; ConfigModal : Boolean = false; ConfigMsg : String = ''; ConfigMultiline : Boolean = false; ConfigProgress : Boolean = false; ConfigProgressText : String = ''; ConfigPrompt : Boolean = false; ConfigProxyDrag : Boolean = false; ConfigTitle : String = ''; ConfigValue : String = ''; ConfigWait : Boolean = false; ConfigWaitConfig : TExtObject = nil; ConfigWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Config, false, ConfigAnimateTarget, ConfigButtons, ConfigClosable, ConfigCls, ConfigDefaultTextHeight, ConfigFn, true, ConfigFnButtonId, ConfigFnText, ConfigFnOpt, false, ConfigButtonText, false, ConfigScope, false, ConfigIcon, ConfigIconCls, ConfigMaxWidth, ConfigMinWidth, ConfigModal, ConfigMsg, ConfigMultiline, ConfigProgress, ConfigProgressText, ConfigPrompt, ConfigProxyDrag, ConfigTitle, ConfigValue, ConfigWait, ConfigWaitConfig, false, ConfigWidth]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Show(Config : TExtObject; ConfigAnimateTarget : TExtDomElement; ConfigButtons : Integer = 0; ConfigClosable : Boolean = false; ConfigCls : String = ''; ConfigDefaultTextHeight : Integer = 0; ConfigFn : TExtFunction = nil; ConfigFnButtonId : String = ''; ConfigFnText : String = ''; ConfigFnOpt : TExtObject = nil; ConfigButtonText : TExtObject = nil; ConfigScope : TExtObject = nil; ConfigIcon : String = ''; ConfigIconCls : String = ''; ConfigMaxWidth : Integer = 0; ConfigMinWidth : Integer = 0; ConfigModal : Boolean = false; ConfigMsg : String = ''; ConfigMultiline : Boolean = false; ConfigProgress : Boolean = false; ConfigProgressText : String = ''; ConfigPrompt : Boolean = false; ConfigProxyDrag : Boolean = false; ConfigTitle : String = ''; ConfigValue : String = ''; ConfigWait : Boolean = false; ConfigWaitConfig : TExtObject = nil; ConfigWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([Config, false, ConfigAnimateTarget, false, ConfigButtons, ConfigClosable, ConfigCls, ConfigDefaultTextHeight, ConfigFn, true, ConfigFnButtonId, ConfigFnText, ConfigFnOpt, false, ConfigButtonText, false, ConfigScope, false, ConfigIcon, ConfigIconCls, ConfigMaxWidth, ConfigMinWidth, ConfigModal, ConfigMsg, ConfigMultiline, ConfigProgress, ConfigProgressText, ConfigPrompt, ConfigProxyDrag, ConfigTitle, ConfigValue, ConfigWait, ConfigWaitConfig, false, ConfigWidth]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.UpdateProgress(Value : Integer = 0; ProgressText : String = ''; Msg : String = '') : TExtFunction; begin
  JSCode(JSName + '.updateProgress(' + VarToJSON([Value, ProgressText, Msg]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Confirm(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.confirm(' + VarToJSON([Title, Msg, Fn, true, Scope, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Prompt(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Multiline : Boolean = false; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.prompt(' + VarToJSON([Title, Msg, Fn, true, Scope, false, Multiline, Value]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Prompt(Title : String; Msg : String; Fn : TExtFunction; Scope : TExtObject; Multiline : Integer; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.Prompt(' + VarToJSON([Title, Msg, Fn, true, Scope, false, Multiline, Value]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Wait(Msg : String; Title : String = ''; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.wait(' + VarToJSON([Msg, Title, Config, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Alert(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.alert(' + VarToJSON([Title, Msg, Fn, true, Scope, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Progress(Title : String; Msg : String; ProgressText : String = '') : TExtFunction; begin
  JSCode(JSName + '.progress(' + VarToJSON([Title, Msg, ProgressText]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

procedure TExtDataWriterJson.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtDataWriterJson.SetFEncode(Value : Boolean); begin
  FEncode := Value;
  JSCode('encode:' + VarToJSON([Value]));
end;

procedure TExtDataWriterJson.SetFAllowSingle(Value : Boolean); begin
  FAllowSingle := Value;
  JSCode('allowSingle:' + VarToJSON([Value]));
end;

function TExtDataWriterJson.JSClassName : string; begin
  Result := 'Ext.data.writer.Json';
end;

procedure TExtDataWriterJson.InitDefaults; begin
  inherited;
  FAllowSingle := true;
end;

{$IFDEF FPC}constructor TExtDataWriterJson.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataWriterJson.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtLayoutContainerCheckboxGroup.SetFAutoFlex(Value : Boolean); begin
  FAutoFlex := Value;
  JSCode('autoFlex:' + VarToJSON([Value]));
end;

function TExtLayoutContainerCheckboxGroup.JSClassName : string; begin
  Result := 'Ext.layout.container.CheckboxGroup';
end;

{$IFDEF FPC}constructor TExtLayoutContainerCheckboxGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerBorder.SetFSplit(Value : Boolean); begin
  FSplit := Value;
  JSCode('split:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFSplitterResize(Value : Boolean); begin
  FSplitterResize := Value;
  JSCode('splitterResize:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFPadding(Value : Integer); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFPaddingString(Value : String); begin
  FPaddingString := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFPaddingTExtObject(Value : TExtObject); begin
  FPaddingTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('padding:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBorder.SetFRegionWeights(Value : TExtObject); begin
  FRegionWeights := Value;
  Value.DeleteFromGarbage;
  JSCode('regionWeights:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerBorder.JSClassName : string; begin
  Result := 'Ext.layout.container.Border';
end;

procedure TExtLayoutContainerBorder.InitDefaults; begin
  inherited;
  FPaddingTExtObject := TExtObject.CreateInternal(Self, 'padding');
  FRegionWeights := TExtObject.CreateInternal(Self, 'regionWeights');
end;

{$IFDEF FPC}constructor TExtLayoutContainerBorder.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerBorder.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerBorder.Destroy; begin
  try
    FPaddingTExtObject.Free;
    FRegionWeights.Free;
  except end;
  inherited;
end;

procedure TExtLayoutContainerBox.SetFDefaultMargins(Value : TExtObject); begin
  FDefaultMargins := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultMargins:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBox.SetFPadding(Value : String); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFPack(Value : String); begin
  FPack := Value;
  JSCode('pack:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFFlex(Value : Integer); begin
  FFlex := Value;
  JSCode('flex:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFStretchMaxPartner(Value : String); begin
  FStretchMaxPartner := Value;
  JSCode('stretchMaxPartner:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFStretchMaxPartnerTExtComponent(Value : TExtComponent); begin
  FStretchMaxPartnerTExtComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('stretchMaxPartner:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerBox.JSClassName : string; begin
  Result := 'Ext.layout.container.Box';
end;

procedure TExtLayoutContainerBox.InitDefaults; begin
  inherited;
  FDefaultMargins := TExtObject.CreateInternal(Self, 'defaultMargins');
  FStretchMaxPartnerTExtComponent := TExtComponent.CreateInternal(Self, 'stretchMaxPartner');
end;

{$IFDEF FPC}constructor TExtLayoutContainerBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerBox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerBox.Destroy; begin
  try
    FDefaultMargins.Free;
    FStretchMaxPartnerTExtComponent.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldDisplay.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDisplay.SetFHtmlEncode(Value : Boolean); begin
  FHtmlEncode := Value;
  JSCode('htmlEncode:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDisplay.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldDisplay.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

function TExtFormFieldDisplay.JSClassName : string; begin
  Result := 'Ext.form.field.Display';
end;

procedure TExtFormFieldDisplay.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtFormFieldDisplay.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldDisplay.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldDisplay.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTpl(Value : String); begin
  FBeforeBoxLabelTpl := Value;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeBoxLabelTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeBoxLabelTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTpl(Value : String); begin
  FAfterBoxLabelTpl := Value;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTplTExtObjectList(Value : TExtObjectList); begin
  FAfterBoxLabelTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterBoxLabelTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTpl(Value : String); begin
  FBeforeBoxLabelTextTpl := Value;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTplTExtObjectList(Value : TExtObjectList); begin
  FBeforeBoxLabelTextTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTplTExtXTemplate(Value : TExtXTemplate); begin
  FBeforeBoxLabelTextTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTpl(Value : String); begin
  FAfterBoxLabelTextTpl := Value;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTplTExtObjectList(Value : TExtObjectList); begin
  FAfterBoxLabelTextTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTplTExtXTemplate(Value : TExtXTemplate); begin
  FAfterBoxLabelTextTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTpl(Value : String); begin
  FBoxLabelAttrTpl := Value;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTplTExtObjectList(Value : TExtObjectList); begin
  FBoxLabelAttrTplTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTplTExtXTemplate(Value : TExtXTemplate); begin
  FBoxLabelAttrTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFCheckedCls(Value : String); begin
  FCheckedCls := Value;
  JSCode('checkedCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabel(Value : String); begin
  FBoxLabel := Value;
  JSCode('boxLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelCls(Value : String); begin
  FBoxLabelCls := Value;
  JSCode('boxLabelCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAlign(Value : String); begin
  FBoxLabelAlign := Value;
  JSCode('boxLabelAlign:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFInputValue(Value : String); begin
  FInputValue := Value;
  JSCode('inputValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFUncheckedValue(Value : String); begin
  FUncheckedValue := Value;
  JSCode('uncheckedValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldCheckbox.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormFieldCheckbox.JSClassName : string; begin
  Result := 'Ext.form.field.Checkbox';
end;

procedure TExtFormFieldCheckbox.InitDefaults; begin
  inherited;
  FBeforeBoxLabelTplTExtObjectList := TExtObjectList.Create(Self, 'beforeBoxLabelTpl');
  FBeforeBoxLabelTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBoxLabelTpl');
  FAfterBoxLabelTplTExtObjectList := TExtObjectList.Create(Self, 'afterBoxLabelTpl');
  FAfterBoxLabelTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterBoxLabelTpl');
  FBeforeBoxLabelTextTplTExtObjectList := TExtObjectList.Create(Self, 'beforeBoxLabelTextTpl');
  FBeforeBoxLabelTextTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBoxLabelTextTpl');
  FAfterBoxLabelTextTplTExtObjectList := TExtObjectList.Create(Self, 'afterBoxLabelTextTpl');
  FAfterBoxLabelTextTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'afterBoxLabelTextTpl');
  FBoxLabelAttrTplTExtObjectList := TExtObjectList.Create(Self, 'boxLabelAttrTpl');
  FBoxLabelAttrTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'boxLabelAttrTpl');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
end;

{$IFDEF FPC}constructor TExtFormFieldCheckbox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldCheckbox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldCheckbox.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetValue(Checked : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Checked]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetValue(Checked : String) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Checked]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

destructor TExtFormFieldCheckbox.Destroy; begin
  try
    FBeforeBoxLabelTplTExtObjectList.Free;
    FBeforeBoxLabelTplTExtXTemplate.Free;
    FAfterBoxLabelTplTExtObjectList.Free;
    FAfterBoxLabelTplTExtXTemplate.Free;
    FBeforeBoxLabelTextTplTExtObjectList.Free;
    FBeforeBoxLabelTextTplTExtXTemplate.Free;
    FAfterBoxLabelTextTplTExtObjectList.Free;
    FAfterBoxLabelTextTplTExtXTemplate.Free;
    FBoxLabelAttrTplTExtObjectList.Free;
    FBoxLabelAttrTplTExtXTemplate.Free;
    FScope.Free;
    FOriginalValue.Free;
  except end;
  inherited;
end;

procedure TExtDataTreeStore.SetFRoot(Value : TExtDataModel); begin
  FRoot := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFRootTExtDataNodeInterface(Value : TExtDataNodeInterface); begin
  FRootTExtDataNodeInterface := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFRootTExtObject(Value : TExtObject); begin
  FRootTExtObject := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFClearOnLoad(Value : Boolean); begin
  FClearOnLoad := Value;
  JSCode('clearOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFClearRemovedOnLoad(Value : Boolean); begin
  FClearRemovedOnLoad := Value;
  JSCode('clearRemovedOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFNodeParam(Value : String); begin
  FNodeParam := Value;
  JSCode('nodeParam:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFDefaultRootId(Value : String); begin
  FDefaultRootId := Value;
  JSCode('defaultRootId:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFDefaultRootProperty(Value : String); begin
  FDefaultRootProperty := Value;
  JSCode('defaultRootProperty:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFFolderSort(Value : Boolean); begin
  FFolderSort := Value;
  JSCode('folderSort:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFOnAppend(Value : TExtDataTreeStoreOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', [], true));
  FOnAppend := Value;
end;

procedure TExtDataTreeStore.SetFOnRemove(Value : TExtDataTreeStoreOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', [], true));
  FOnRemove := Value;
end;

procedure TExtDataTreeStore.SetFOnMove(Value : TExtDataTreeStoreOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', [], true));
  FOnMove := Value;
end;

procedure TExtDataTreeStore.SetFOnInsert(Value : TExtDataTreeStoreOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', [], true));
  FOnInsert := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeappend(Value : TExtDataTreeStoreOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', [], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeremove(Value : TExtDataTreeStoreOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', [], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforemove(Value : TExtDataTreeStoreOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', [], true));
  FOnBeforemove := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeinsert(Value : TExtDataTreeStoreOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', [], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataTreeStore.SetFOnExpand(Value : TExtDataTreeStoreOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', [], true));
  FOnExpand := Value;
end;

procedure TExtDataTreeStore.SetFOnCollapse(Value : TExtDataTreeStoreOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', [], true));
  FOnCollapse := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeexpand(Value : TExtDataTreeStoreOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', [], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforecollapse(Value : TExtDataTreeStoreOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', [], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataTreeStore.SetFOnSort(Value : TExtDataTreeStoreOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', [], true));
  FOnSort := Value;
end;

procedure TExtDataTreeStore.SetFOnRootchange(Value : TExtDataTreeStoreOnRootchange); begin
  if Assigned(FOnRootchange) then
    JSCode(JSName+'.events ["rootchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('rootchange', Ajax('rootchange', [], true));
  FOnRootchange := Value;
end;

procedure TExtDataTreeStore.SetFOnLoad(Value : TExtDataTreeStoreOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['This', '%0.nm','Node', '%1.nm','Records', '%2.nm','Successful', '%3'], true));
  FOnLoad := Value;
end;

function TExtDataTreeStore.JSClassName : string; begin
  Result := 'Ext.data.TreeStore';
end;

procedure TExtDataTreeStore.InitDefaults; begin
  inherited;
  FRoot := TExtDataModel.CreateInternal(Self, 'root');
  FRootTExtDataNodeInterface := TExtDataNodeInterface.CreateInternal(Self, 'root');
  FRootTExtObject := TExtObject.CreateInternal(Self, 'root');
end;

{$IFDEF FPC}constructor TExtDataTreeStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataTreeStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataTreeStore.Destroy; begin
  try
    FRoot.Free;
    FRootTExtDataNodeInterface.Free;
    FRootTExtObject.Free;
  except end;
  inherited;
end;

procedure TExtDataTreeStore.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove()
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove()
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert()
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend()
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove()
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove()
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert()
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand()
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse()
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand()
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse()
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort()
  else if (AEvtName = 'rootchange') and Assigned(FOnRootchange) then
    FOnRootchange()
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtDataTreeStore(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtObjectList(ParamAsObject('Records')), ParamAsBoolean('Successful'));
end;

procedure TExtPickerTime.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtPickerTime.JSClassName : string; begin
  Result := 'Ext.picker.Time';
end;

procedure TExtPickerTime.InitDefaults; begin
  inherited;
  FFormat := 'g:i A';
end;

{$IFDEF FPC}constructor TExtPickerTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerTime.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtPickerTime');
  Result := Self;
end;

function TExtPickerTime.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtPickerTime');
  Result := Self;
end;

function TExtPickerTime.UpdateList : TExtFunction; begin
  JSCode(JSName + '.updateList();', 'TExtPickerTime');
  Result := Self;
end;

procedure TExtFormCheckboxGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFItemsTExtObjectList(Value : TExtObjectList); begin
  FItemsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFColumns(Value : String); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsInteger(Value : Integer); begin
  FColumnsInteger := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsTArrayOfInteger(Value : TArrayOfInteger); begin
  FColumnsTArrayOfInteger := Value;
  JSCode('columns:' + ArrayToJSON(Value));
end;

procedure TExtFormCheckboxGroup.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

function TExtFormCheckboxGroup.JSClassName : string; begin
  Result := 'Ext.form.CheckboxGroup';
end;

procedure TExtFormCheckboxGroup.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
  FItemsTExtObjectList := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormCheckboxGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormCheckboxGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormCheckboxGroup.GetErrors : TExtFunction; begin
  JSCode(JSName + '.getErrors();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetChecked : TExtFunction; begin
  JSCode(JSName + '.getChecked();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

destructor TExtFormCheckboxGroup.Destroy; begin
  try
    FItems.Free;
    FItemsTExtObjectList.Free;
  except end;
  inherited;
end;

procedure TExtFormActionStandardSubmit.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

function TExtFormActionStandardSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.StandardSubmit';
end;

{$IFDEF FPC}constructor TExtFormActionStandardSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridView.JSClassName : string; begin
  Result := 'Ext.grid.View';
end;

{$IFDEF FPC}constructor TExtGridView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtMenuSeparator.SetFSeparatorCls(Value : String); begin
  FSeparatorCls := Value;
  JSCode('separatorCls:' + VarToJSON([Value]));
end;

function TExtMenuSeparator.JSClassName : string; begin
  Result := 'Ext.menu.Separator';
end;

{$IFDEF FPC}constructor TExtMenuSeparator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartSeriesScatter.SetFMarkerConfig(Value : TExtObject); begin
  FMarkerConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('markerConfig:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesScatter.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesScatter.SetFAxis(Value : String); begin
  FAxis := Value;
  JSCode('axis:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesScatter.SetFAxisTExtObjectList(Value : TExtObjectList); begin
  FAxisTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('axis:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesScatter.JSClassName : string; begin
  Result := 'Ext.chart.series.Scatter';
end;

procedure TExtChartSeriesScatter.InitDefaults; begin
  inherited;
  FMarkerConfig := TExtObject.CreateInternal(Self, 'markerConfig');
  FStyle := TExtObject.CreateInternal(Self, 'style');
  FAxisTExtObjectList := TExtObjectList.Create(Self, 'axis');
end;

{$IFDEF FPC}constructor TExtChartSeriesScatter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesScatter.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesScatter.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesScatter');
  Result := Self;
end;

destructor TExtChartSeriesScatter.Destroy; begin
  try
    FMarkerConfig.Free;
    FStyle.Free;
    FAxisTExtObjectList.Free;
  except end;
  inherited;
end;

procedure TExtSelectionCheckboxModel.SetFMode(Value : String); begin
  FMode := Value;
  JSCode('mode:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFInjectCheckbox(Value : Integer); begin
  FInjectCheckbox := Value;
  JSCode('injectCheckbox:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFInjectCheckboxString(Value : String); begin
  FInjectCheckboxString := Value;
  JSCode('injectCheckbox:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFCheckOnly(Value : Boolean); begin
  FCheckOnly := Value;
  JSCode('checkOnly:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFShowHeaderCheckbox(Value : Boolean); begin
  FShowHeaderCheckbox := Value;
  JSCode('showHeaderCheckbox:' + VarToJSON([Value]));
end;

function TExtSelectionCheckboxModel.JSClassName : string; begin
  Result := 'Ext.selection.CheckboxModel';
end;

{$IFDEF FPC}constructor TExtSelectionCheckboxModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionCheckboxModel.OnHeaderClick : TExtFunction; begin
  JSCode(JSName + '.onHeaderClick();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

function TExtSelectionCheckboxModel.GetHeaderConfig : TExtFunction; begin
  JSCode(JSName + '.getHeaderConfig();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

function TExtSelectionCheckboxModel.Renderer : TExtFunction; begin
  JSCode(JSName + '.renderer();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

function TExtFormFieldHidden.JSClassName : string; begin
  Result := 'Ext.form.field.Hidden';
end;

{$IFDEF FPC}constructor TExtFormFieldHidden.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPropertyHeaderContainer.JSClassName : string; begin
  Result := 'Ext.grid.property.HeaderContainer';
end;

{$IFDEF FPC}constructor TExtGridPropertyHeaderContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyHeaderContainer.Create(Grid : TExtGridPropertyGrid; Source : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Grid, false, Source, false]) + ');');
  InitDefaults;
end;

procedure TExtGridColumnBoolean.SetFTrueText(Value : String); begin
  FTrueText := Value;
  JSCode('trueText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnBoolean.SetFFalseText(Value : String); begin
  FFalseText := Value;
  JSCode('falseText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnBoolean.SetFUndefinedText(Value : String); begin
  FUndefinedText := Value;
  JSCode('undefinedText:' + VarToJSON([Value]));
end;

function TExtGridColumnBoolean.JSClassName : string; begin
  Result := 'Ext.grid.column.Boolean';
end;

{$IFDEF FPC}constructor TExtGridColumnBoolean.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridColumnDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtGridColumnDate.JSClassName : string; begin
  Result := 'Ext.grid.column.Date';
end;

{$IFDEF FPC}constructor TExtGridColumnDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtButtonCycle.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtButtonCycle.SetFShowText(Value : Boolean); begin
  FShowText := Value;
  JSCode('showText:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFPrependText(Value : String); begin
  FPrependText := Value;
  JSCode('prependText:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFChangeHandler(Value : TExtFunction); begin
  FChangeHandler := Value;
  JSCode('changeHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButtonCycle.SetFForceIcon(Value : String); begin
  FForceIcon := Value;
  JSCode('forceIcon:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.menu=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtButtonCycle.SetFOnChange(Value : TExtButtonCycleOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','Item', '%1.nm'], true));
  FOnChange := Value;
end;

function TExtButtonCycle.JSClassName : string; begin
  Result := 'Ext.button.Cycle';
end;

procedure TExtButtonCycle.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
end;

{$IFDEF FPC}constructor TExtButtonCycle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtButtonCycle.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtButtonCycle.ToggleSelected : TExtFunction; begin
  JSCode(JSName + '.toggleSelected();', 'TExtButtonCycle');
  Result := Self;
end;

destructor TExtButtonCycle.Destroy; begin
  try
    FItems.Free;
    FMenu.Free;
  except end;
  inherited;
end;

procedure TExtButtonCycle.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtButtonCycle(ParamAsObject('This')), TExtMenuCheckItem(ParamAsObject('Item')));
end;

function TExtDataXmlStore.JSClassName : string; begin
  Result := 'Ext.data.XmlStore';
end;

{$IFDEF FPC}constructor TExtDataXmlStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridColumnNumber.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtGridColumnNumber.JSClassName : string; begin
  Result := 'Ext.grid.column.Number';
end;

{$IFDEF FPC}constructor TExtGridColumnNumber.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridColumnTemplate.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtGridColumnTemplate.SetFTplTExtXTemplate(Value : TExtXTemplate); begin
  FTplTExtXTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

function TExtGridColumnTemplate.JSClassName : string; begin
  Result := 'Ext.grid.column.Template';
end;

procedure TExtGridColumnTemplate.InitDefaults; begin
  inherited;
  FTplTExtXTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtGridColumnTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridColumnTemplate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtGridColumnTemplate.Destroy; begin
  try
    FTplTExtXTemplate.Free;
  except end;
  inherited;
end;

procedure TExtGridColumnAction.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFStopSelection(Value : Boolean); begin
  FStopSelection := Value;
  JSCode('stopSelection:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClass(Value : TExtFunction); begin
  FGetClass := Value;
  JSCode('getClass:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFAltText(Value : String); begin
  FAltText := Value;
  JSCode('altText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFMenuText(Value : String); begin
  FMenuText := Value;
  JSCode('menuText:' + VarToJSON([Value]));
end;

function TExtGridColumnAction.JSClassName : string; begin
  Result := 'Ext.grid.column.Action';
end;

procedure TExtGridColumnAction.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FItems := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtGridColumnAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridColumnAction.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridColumnAction.EnableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.enableAction(' + VarToJSON([Index, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.EnableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.EnableAction(' + VarToJSON([Index, false, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.DisableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.disableAction(' + VarToJSON([Index, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.DisableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.DisableAction(' + VarToJSON([Index, false, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

destructor TExtGridColumnAction.Destroy; begin
  try
    FScope.Free;
    FItems.Free;
  except end;
  inherited;
end;

procedure TExtDdDragSource.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFAnimRepair(Value : Boolean); begin
  FAnimRepair := Value;
  JSCode('animRepair:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFRepairHighlightColor(Value : String); begin
  FRepairHighlightColor := Value;
  JSCode('repairHighlightColor:' + VarToJSON([Value]));
end;

function TExtDdDragSource.JSClassName : string; begin
  Result := 'Ext.dd.DragSource';
end;

{$IFDEF FPC}constructor TExtDdDragSource.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragSource.Create(El : String; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragSource.Create(El : THTMLElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragSource.Create(El : TExtElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

function TExtDdDragSource.GetDragData : TExtFunction; begin
  JSCode(JSName + '.getDragData();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtDdDragSource.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtDdDragSource.HideProxy : TExtFunction; begin
  JSCode(JSName + '.hideProxy();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtDdDropZone.JSClassName : string; begin
  Result := 'Ext.dd.DropZone';
end;

{$IFDEF FPC}constructor TExtDdDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDropZone.GetTargetFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getTargetFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdDropZone');
  Result := Self;
end;

function TExtDdDropZone.OnNodeEnter(NodeData : TExtObject; Source : TExtDdDragSource; E : TEvent; Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.onNodeEnter(' + VarToJSON([NodeData, false, Source, false, E, false, Data, false]) + ');', 'TExtDdDropZone');
  Result := Self;
end;

procedure TExtFormFieldTrigger.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFHideTrigger(Value : Boolean); begin
  FHideTrigger := Value;
  JSCode('hideTrigger:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFEditable(Value : Boolean); begin
  FEditable := Value;
  JSCode('editable:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFRepeatTriggerClick(Value : Boolean); begin
  FRepeatTriggerClick := Value;
  JSCode('repeatTriggerClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFGrow(Value : Boolean); begin
  FGrow := Value;
  JSCode('grow:' + VarToJSON([Value]));
end;

function TExtFormFieldTrigger.JSClassName : string; begin
  Result := 'Ext.form.field.Trigger';
end;

{$IFDEF FPC}constructor TExtFormFieldTrigger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerVBox.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

function TExtLayoutContainerVBox.JSClassName : string; begin
  Result := 'Ext.layout.container.VBox';
end;

{$IFDEF FPC}constructor TExtLayoutContainerVBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldRadio.SetFUncheckedValue(Value : String); begin
  FUncheckedValue := Value;
  JSCode('uncheckedValue:' + VarToJSON([Value]));
end;

function TExtFormFieldRadio.JSClassName : string; begin
  Result := 'Ext.form.field.Radio';
end;

{$IFDEF FPC}constructor TExtFormFieldRadio.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldRadio.GetGroupValue : TExtFunction; begin
  JSCode(JSName + '.getGroupValue();', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.SetValue(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldRadio');
  Result := Self;
end;

procedure TExtGridRowNumberer.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtGridRowNumberer.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtGridRowNumberer.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

function TExtGridRowNumberer.JSClassName : string; begin
  Result := 'Ext.grid.RowNumberer';
end;

{$IFDEF FPC}constructor TExtGridRowNumberer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataDirectStore.JSClassName : string; begin
  Result := 'Ext.data.DirectStore';
end;

{$IFDEF FPC}constructor TExtDataDirectStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerAbsolute.SetFIgnoreOnContentChange(Value : Boolean); begin
  FIgnoreOnContentChange := Value;
  JSCode('ignoreOnContentChange:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAbsolute.JSClassName : string; begin
  Result := 'Ext.layout.container.Absolute';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAbsolute.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldTextArea.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFGrowAppend(Value : String); begin
  FGrowAppend := Value;
  JSCode('growAppend:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFCols(Value : Integer); begin
  FCols := Value;
  JSCode('cols:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFRows(Value : Integer); begin
  FRows := Value;
  JSCode('rows:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFEnterIsSpecial(Value : Boolean); begin
  FEnterIsSpecial := Value;
  JSCode('enterIsSpecial:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFPreventScrollbars(Value : Boolean); begin
  FPreventScrollbars := Value;
  JSCode('preventScrollbars:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFOnAutosize(Value : TExtFormFieldTextAreaOnAutosize); begin
  if Assigned(FOnAutosize) then
    JSCode(JSName+'.events ["autosize"].listeners=[];');
  if Assigned(Value) then
    AddListener('autosize', Ajax('autosize', ['This', '%0.nm','Height', '%1'], true));
  FOnAutosize := Value;
end;

function TExtFormFieldTextArea.JSClassName : string; begin
  Result := 'Ext.form.field.TextArea';
end;

procedure TExtFormFieldTextArea.InitDefaults; begin
  inherited;
  FRows := 4;
end;

{$IFDEF FPC}constructor TExtFormFieldTextArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldTextArea.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtFormFieldTextArea.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'autosize') and Assigned(FOnAutosize) then
    FOnAutosize(TExtFormFieldTextArea(ParamAsObject('This')), ParamAsInteger('Height'));
end;

procedure TExtLayoutContainerCard.SetFDeferredRender(Value : Boolean); begin
  FDeferredRender := Value;
  JSCode('deferredRender:' + VarToJSON([Value]));
end;

function TExtLayoutContainerCard.JSClassName : string; begin
  Result := 'Ext.layout.container.Card';
end;

{$IFDEF FPC}constructor TExtLayoutContainerCard.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainerCard.GetActiveItem : TExtFunction; begin
  JSCode(JSName + '.getActiveItem();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.GetNext : TExtFunction; begin
  JSCode(JSName + '.getNext();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.Next : TExtFunction; begin
  JSCode(JSName + '.next();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.GetPrev : TExtFunction; begin
  JSCode(JSName + '.getPrev();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.Prev : TExtFunction; begin
  JSCode(JSName + '.prev();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.setActiveItem(' + VarToJSON([NewCard, false]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetActiveItem(' + VarToJSON([NewCard]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : String) : TExtFunction; begin
  JSCode(JSName + '.SetActiveItem(' + VarToJSON([NewCard]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

procedure TExtLayoutContainerHBox.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

function TExtLayoutContainerHBox.JSClassName : string; begin
  Result := 'Ext.layout.container.HBox';
end;

{$IFDEF FPC}constructor TExtLayoutContainerHBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainerForm.JSClassName : string; begin
  Result := 'Ext.layout.container.Form';
end;

{$IFDEF FPC}constructor TExtLayoutContainerForm.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormRadioGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormRadioGroup.SetFItemsTExtObjectList(Value : TExtObjectList); begin
  FItemsTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormRadioGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormRadioGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

function TExtFormRadioGroup.JSClassName : string; begin
  Result := 'Ext.form.RadioGroup';
end;

procedure TExtFormRadioGroup.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
  FItemsTExtObjectList := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormRadioGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormRadioGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormRadioGroup.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormRadioGroup');
  Result := Self;
end;

destructor TExtFormRadioGroup.Destroy; begin
  try
    FItems.Free;
    FItemsTExtObjectList.Free;
  except end;
  inherited;
end;

function TExtDataJsonStore.JSClassName : string; begin
  Result := 'Ext.data.JsonStore';
end;

{$IFDEF FPC}constructor TExtDataJsonStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTipQuickTip.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtTipQuickTip.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipQuickTip.SetFTargetTExtElement(Value : TExtElement); begin
  FTargetTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipQuickTip.SetFInterceptTitles(Value : Boolean); begin
  FInterceptTitles := Value;
  JSCode('interceptTitles:' + VarToJSON([Value]));
end;

function TExtTipQuickTip.JSClassName : string; begin
  Result := 'Ext.tip.QuickTip';
end;

procedure TExtTipQuickTip.InitDefaults; begin
  inherited;
  FTargetTExtElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtTipQuickTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTipQuickTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTipQuickTip.Register(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Config, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([El]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.CancelShow(El : String) : TExtFunction; begin
  JSCode(JSName + '.cancelShow(' + VarToJSON([El]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.CancelShow(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.CancelShow(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.CancelShow(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.CancelShow(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

destructor TExtTipQuickTip.Destroy; begin
  try
    FTargetTExtElement.Free;
  except end;
  inherited;
end;

function TExtDataReaderArray.JSClassName : string; begin
  Result := 'Ext.data.reader.Array';
end;

{$IFDEF FPC}constructor TExtDataReaderArray.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataArrayStore.JSClassName : string; begin
  Result := 'Ext.data.ArrayStore';
end;

{$IFDEF FPC}constructor TExtDataArrayStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPropertyGrid.SetFPropertyNames(Value : TExtObject); begin
  FPropertyNames := Value;
  Value.DeleteFromGarbage;
  JSCode('propertyNames:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFSource(Value : TExtObject); begin
  FSource := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetSource(Value)
  else
    JSCode('source:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFCustomEditors(Value : TExtObject); begin
  FCustomEditors := Value;
  Value.DeleteFromGarbage;
  JSCode('customEditors:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFCustomRenderers(Value : TExtObject); begin
  FCustomRenderers := Value;
  Value.DeleteFromGarbage;
  JSCode('customRenderers:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFValueField(Value : String); begin
  FValueField := Value;
  JSCode('valueField:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFNameField(Value : String); begin
  FNameField := Value;
  JSCode('nameField:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFNameColumnWidth(Value : Integer); begin
  FNameColumnWidth := Value;
  JSCode('nameColumnWidth:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFOnBeforepropertychange(Value : TExtGridPropertyGridOnBeforepropertychange); begin
  if Assigned(FOnBeforepropertychange) then
    JSCode(JSName+'.events ["beforepropertychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforepropertychange', Ajax('beforepropertychange', ['Source', '%0.nm','RecordId', '%1','Value', '%2.nm','OldValue', '%3.nm'], true));
  FOnBeforepropertychange := Value;
end;

procedure TExtGridPropertyGrid.SetFOnPropertychange(Value : TExtGridPropertyGridOnPropertychange); begin
  if Assigned(FOnPropertychange) then
    JSCode(JSName+'.events ["propertychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('propertychange', Ajax('propertychange', ['Source', '%0.nm','RecordId', '%1','Value', '%2.nm','OldValue', '%3.nm'], true));
  FOnPropertychange := Value;
end;

function TExtGridPropertyGrid.JSClassName : string; begin
  Result := 'Ext.grid.property.Grid';
end;

procedure TExtGridPropertyGrid.InitDefaults; begin
  inherited;
  FPropertyNames := TExtObject.CreateInternal(Self, 'propertyNames');
  FSource := TExtObject.CreateInternal(Self, 'source');
  FCustomEditors := TExtObject.CreateInternal(Self, 'customEditors');
  FCustomRenderers := TExtObject.CreateInternal(Self, 'customRenderers');
end;

{$IFDEF FPC}constructor TExtGridPropertyGrid.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyGrid.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridPropertyGrid.SetSource(Source : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setSource(' + VarToJSON([Source, false]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.GetSource : TExtFunction; begin
  JSCode(JSName + '.getSource();', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.SetProperty(Prop : String; Value : TExtObject; Create : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setProperty(' + VarToJSON([Prop, Value, false, Create]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.RemoveProperty(Prop : String) : TExtFunction; begin
  JSCode(JSName + '.removeProperty(' + VarToJSON([Prop]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

destructor TExtGridPropertyGrid.Destroy; begin
  try
    FPropertyNames.Free;
    FSource.Free;
    FCustomEditors.Free;
    FCustomRenderers.Free;
  except end;
  inherited;
end;

procedure TExtGridPropertyGrid.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforepropertychange') and Assigned(FOnBeforepropertychange) then
    FOnBeforepropertychange(TExtObject(ParamAsObject('Source')), ParamAsString('RecordId'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'propertychange') and Assigned(FOnPropertychange) then
    FOnPropertychange(TExtObject(ParamAsObject('Source')), ParamAsString('RecordId'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('OldValue')));
end;

function TExtGridPropertyStore.JSClassName : string; begin
  Result := 'Ext.grid.property.Store';
end;

{$IFDEF FPC}constructor TExtGridPropertyStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyStore.Create(Grid : TExtGridPanel; Source : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Grid, false, Source, false]) + ');');
  InitDefaults;
end;

function TExtSliderSingle.JSClassName : string; begin
  Result := 'Ext.slider.Single';
end;

{$IFDEF FPC}constructor TExtSliderSingle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSliderSingle.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtSliderSingle');
  Result := Self;
end;

function TExtSliderSingle.SetValue(Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, Animate]) + ');', 'TExtSliderSingle');
  Result := Self;
end;

procedure TExtChartSeriesColumn.SetFXPadding(Value : Integer); begin
  FXPadding := Value;
  JSCode('xPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesColumn.SetFYPadding(Value : Integer); begin
  FYPadding := Value;
  JSCode('yPadding:' + VarToJSON([Value]));
end;

function TExtChartSeriesColumn.JSClassName : string; begin
  Result := 'Ext.chart.series.Column';
end;

{$IFDEF FPC}constructor TExtChartSeriesColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataJsonPStore.JSClassName : string; begin
  Result := 'Ext.data.JsonPStore';
end;

{$IFDEF FPC}constructor TExtDataJsonPStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldPicker.SetFMatchFieldWidth(Value : Boolean); begin
  FMatchFieldWidth := Value;
  JSCode('matchFieldWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFPickerAlign(Value : String); begin
  FPickerAlign := Value;
  JSCode('pickerAlign:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFOpenCls(Value : String); begin
  FOpenCls := Value;
  JSCode('openCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFEditable(Value : Boolean); begin
  FEditable := Value;
  JSCode('editable:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFOnExpand(Value : TExtFormFieldPickerOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['Field', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtFormFieldPicker.SetFOnCollapse(Value : TExtFormFieldPickerOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['Field', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtFormFieldPicker.SetFOnSelect(Value : TExtFormFieldPickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['Field', '%0.nm','Value', '%1.nm'], true));
  FOnSelect := Value;
end;

function TExtFormFieldPicker.JSClassName : string; begin
  Result := 'Ext.form.field.Picker';
end;

procedure TExtFormFieldPicker.InitDefaults; begin
  inherited;
  FMatchFieldWidth := true;
  FPickerAlign := 'tl-bl?';
end;

{$IFDEF FPC}constructor TExtFormFieldPicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldPicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldPicker.Expand : TExtFunction; begin
  JSCode(JSName + '.expand();', 'TExtFormFieldPicker');
  Result := Self;
end;

function TExtFormFieldPicker.Collapse : TExtFunction; begin
  JSCode(JSName + '.collapse();', 'TExtFormFieldPicker');
  Result := Self;
end;

function TExtFormFieldPicker.GetPicker : TExtFunction; begin
  JSCode(JSName + '.getPicker();', 'TExtFormFieldPicker');
  Result := Self;
end;

procedure TExtFormFieldPicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtFormFieldPicker(ParamAsObject('Field')))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtFormFieldPicker(ParamAsObject('Field')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormFieldPicker(ParamAsObject('Field')), TExtObject(ParamAsObject('Value')));
end;

procedure TExtFormFieldFile.SetFButtonText(Value : String); begin
  FButtonText := Value;
  JSCode('buttonText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFButtonOnly(Value : Boolean); begin
  FButtonOnly := Value;
  JSCode('buttonOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFButtonMargin(Value : Integer); begin
  FButtonMargin := Value;
  JSCode('buttonMargin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFButtonConfig(Value : TExtObject); begin
  FButtonConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('buttonConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldFile.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  JSCode('readOnly:' + VarToJSON([Value]));
end;

function TExtFormFieldFile.JSClassName : string; begin
  Result := 'Ext.form.field.File';
end;

procedure TExtFormFieldFile.InitDefaults; begin
  inherited;
  FButtonConfig := TExtObject.CreateInternal(Self, 'buttonConfig');
end;

{$IFDEF FPC}constructor TExtFormFieldFile.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldFile.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldFile.GetTriggerMarkup : TExtFunction; begin
  JSCode(JSName + '.getTriggerMarkup();', 'TExtFormFieldFile');
  Result := Self;
end;

function TExtFormFieldFile.SetValueExtEmptyFnReset : TExtFunction; begin
  JSCode(JSName + '.setValue: Ext.emptyFn, reset();', 'TExtFormFieldFile');
  Result := Self;
end;

destructor TExtFormFieldFile.Destroy; begin
  try
    FButtonConfig.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldSpinner.SetFSpinUpEnabled(Value : Boolean); begin
  FSpinUpEnabled := Value;
  if not ConfigAvailable(JSName) then
    SetSpinUpEnabled(Value)
  else
    JSCode('spinUpEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFSpinDownEnabled(Value : Boolean); begin
  FSpinDownEnabled := Value;
  if not ConfigAvailable(JSName) then
    SetSpinDownEnabled(Value)
  else
    JSCode('spinDownEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFKeyNavEnabled(Value : Boolean); begin
  FKeyNavEnabled := Value;
  JSCode('keyNavEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFMouseWheelEnabled(Value : Boolean); begin
  FMouseWheelEnabled := Value;
  JSCode('mouseWheelEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFRepeatTriggerClick(Value : Boolean); begin
  FRepeatTriggerClick := Value;
  JSCode('repeatTriggerClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFSpinUpEl(Value : TExtElement); begin
  FSpinUpEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.spinUpEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSpinner.SetFSpinDownEl(Value : TExtElement); begin
  FSpinDownEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.spinDownEl=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormFieldSpinner.JSClassName : string; begin
  Result := 'Ext.form.field.Spinner';
end;

procedure TExtFormFieldSpinner.InitDefaults; begin
  inherited;
  FSpinUpEnabled := true;
  FSpinDownEnabled := true;
  FKeyNavEnabled := true;
  FMouseWheelEnabled := true;
  FRepeatTriggerClick := true;
  FSpinUpEl := TExtElement.CreateInternal(Self, 'spinUpEl');
  FSpinDownEl := TExtElement.CreateInternal(Self, 'spinDownEl');
end;

{$IFDEF FPC}constructor TExtFormFieldSpinner.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldSpinner.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldSpinner.GetTriggerWidth : TExtFunction; begin
  JSCode(JSName + '.getTriggerWidth();', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SpinUp : TExtFunction; begin
  JSCode(JSName + '.spinUp();', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SpinDown : TExtFunction; begin
  JSCode(JSName + '.spinDown();', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SetSpinUpEnabled(Enabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setSpinUpEnabled(' + VarToJSON([Enabled]) + ');', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SetSpinDownEnabled(Enabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setSpinDownEnabled(' + VarToJSON([Enabled]) + ');', 'TExtFormFieldSpinner');
  Result := Self;
end;

destructor TExtFormFieldSpinner.Destroy; begin
  try
    FSpinUpEl.Free;
    FSpinDownEl.Free;
  except end;
  inherited;
end;

procedure TExtLayoutContainerAccordion.SetFFill(Value : Boolean); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFAutoWidth(Value : Boolean); begin
  FAutoWidth := Value;
  JSCode('autoWidth:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFTitleCollapse(Value : Boolean); begin
  FTitleCollapse := Value;
  JSCode('titleCollapse:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFHideCollapseTool(Value : Boolean); begin
  FHideCollapseTool := Value;
  JSCode('hideCollapseTool:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFCollapseFirst(Value : Boolean); begin
  FCollapseFirst := Value;
  JSCode('collapseFirst:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFActiveOnTop(Value : Boolean); begin
  FActiveOnTop := Value;
  JSCode('activeOnTop:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFMulti(Value : Boolean); begin
  FMulti := Value;
  JSCode('multi:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAccordion.JSClassName : string; begin
  Result := 'Ext.layout.container.Accordion';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAccordion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdDragZone.SetFContainerScroll(Value : Boolean); begin
  FContainerScroll := Value;
  JSCode('containerScroll:' + VarToJSON([Value]));
end;

function TExtDdDragZone.JSClassName : string; begin
  Result := 'Ext.dd.DragZone';
end;

{$IFDEF FPC}constructor TExtDdDragZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDragZone.GetDragData(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getDragData(' + VarToJSON([E, false]) + ');', 'TExtDdDragZone');
  Result := Self;
end;

procedure TExtFormFieldComboBox.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFHiddenName(Value : String); begin
  FHiddenName := Value;
  JSCode('hiddenName:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFStoreTExtObjectList(Value : TExtObjectList); begin
  FStoreTExtObjectList := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFMultiSelect(Value : Boolean); begin
  FMultiSelect := Value;
  JSCode('multiSelect:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFDelimiter(Value : String); begin
  FDelimiter := Value;
  JSCode('delimiter:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFValueField(Value : String); begin
  FValueField := Value;
  JSCode('valueField:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTriggerAction(Value : String); begin
  FTriggerAction := Value;
  JSCode('triggerAction:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFAllQuery(Value : String); begin
  FAllQuery := Value;
  JSCode('allQuery:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryParam(Value : String); begin
  FQueryParam := Value;
  JSCode('queryParam:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryMode(Value : String); begin
  FQueryMode := Value;
  JSCode('queryMode:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryCaching(Value : Boolean); begin
  FQueryCaching := Value;
  JSCode('queryCaching:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryDelay(Value : Integer); begin
  FQueryDelay := Value;
  JSCode('queryDelay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFAutoSelect(Value : Boolean); begin
  FAutoSelect := Value;
  JSCode('autoSelect:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTypeAhead(Value : Boolean); begin
  FTypeAhead := Value;
  JSCode('typeAhead:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTypeAheadDelay(Value : Integer); begin
  FTypeAheadDelay := Value;
  JSCode('typeAheadDelay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFSelectOnTab(Value : Boolean); begin
  FSelectOnTab := Value;
  JSCode('selectOnTab:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFForceSelection(Value : Boolean); begin
  FForceSelection := Value;
  JSCode('forceSelection:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFGrowToLongestValue(Value : Boolean); begin
  FGrowToLongestValue := Value;
  JSCode('growToLongestValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFValueNotFoundText(Value : String); begin
  FValueNotFoundText := Value;
  JSCode('valueNotFoundText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFDefaultListConfig(Value : TExtObject); begin
  FDefaultListConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultListConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFTransform(Value : String); begin
  FTransform := Value;
  JSCode('transform:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTransformTHTMLElement(Value : THTMLElement); begin
  FTransformTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('transform:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFTransformTExtElement(Value : TExtElement); begin
  FTransformTExtElement := Value;
  Value.DeleteFromGarbage;
  JSCode('transform:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFListConfig(Value : TExtObject); begin
  FListConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('listConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFOnBeforequery(Value : TExtFormFieldComboBoxOnBeforequery); begin
  if Assigned(FOnBeforequery) then
    JSCode(JSName+'.events ["beforequery"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforequery', Ajax('beforequery', ['QueryEvent', '%0.nm'], true));
  FOnBeforequery := Value;
end;

procedure TExtFormFieldComboBox.SetFOnSelect(Value : TExtFormFieldComboBoxOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['Combo', '%0.nm','Records', '%1.nm'], true));
  FOnSelect := Value;
end;

procedure TExtFormFieldComboBox.SetFOnBeforeselect(Value : TExtFormFieldComboBoxOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforeselect := Value;
end;

procedure TExtFormFieldComboBox.SetFOnBeforedeselect(Value : TExtFormFieldComboBoxOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforedeselect := Value;
end;

function TExtFormFieldComboBox.JSClassName : string; begin
  Result := 'Ext.form.field.ComboBox';
end;

procedure TExtFormFieldComboBox.InitDefaults; begin
  inherited;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FStoreTExtObjectList := TExtObjectList.Create(Self, 'store');
  FQueryDelay := 500;
  FDefaultListConfig := TExtObject.CreateInternal(Self, 'defaultListConfig');
  FTransformTExtElement := TExtElement.CreateInternal(Self, 'transform');
  FListConfig := TExtObject.CreateInternal(Self, 'listConfig');
end;

{$IFDEF FPC}constructor TExtFormFieldComboBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldComboBox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldComboBox.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.DoQuery(QueryString : String; ForceAll : Boolean = false; RawQuery : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.doQuery(' + VarToJSON([QueryString, ForceAll, RawQuery]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.Select(R : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([R, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecord(Field : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecord(' + VarToJSON([Field, Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecordByValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecordByValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecordByDisplay(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecordByDisplay(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.SetValue(Value : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON(Value) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.ClearValue : TExtFunction; begin
  JSCode(JSName + '.clearValue();', 'TExtFormFieldComboBox');
  Result := Self;
end;

destructor TExtFormFieldComboBox.Destroy; begin
  try
    FStore.Free;
    FStoreTExtObjectList.Free;
    FDefaultListConfig.Free;
    FTransformTExtElement.Free;
    FListConfig.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldComboBox.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforequery') and Assigned(FOnBeforequery) then
    FOnBeforequery(TExtObject(ParamAsObject('QueryEvent')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtObjectList(ParamAsObject('Records')))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'));
end;

procedure TExtFormFieldDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFDisabledDaysText(Value : String); begin
  FDisabledDaysText := Value;
  JSCode('disabledDaysText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFDisabledDatesText(Value : String); begin
  FDisabledDatesText := Value;
  JSCode('disabledDatesText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFShowToday(Value : Boolean); begin
  FShowToday := Value;
  JSCode('showToday:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFDisabledDays(Value : TArrayOfInteger); begin
  FDisabledDays := Value;
  JSCode('disabledDays:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldDate.SetFDisabledDates(Value : TExtObjectList); begin
  FDisabledDates := Value;
  Value.DeleteFromGarbage;
  JSCode('disabledDates:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldDate.SetFSubmitFormat(Value : String); begin
  FSubmitFormat := Value;
  JSCode('submitFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFUseStrict(Value : Boolean); begin
  FUseStrict := Value;
  JSCode('useStrict:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFStartDay(Value : Integer); begin
  FStartDay := Value;
  JSCode('startDay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFGrow(Value : Boolean); begin
  FGrow := Value;
  JSCode('grow:' + VarToJSON([Value]));
end;

function TExtFormFieldDate.JSClassName : string; begin
  Result := 'Ext.form.field.Date';
end;

procedure TExtFormFieldDate.InitDefaults; begin
  inherited;
  FDisabledDates := TExtObjectList.Create(Self, 'disabledDates');
  FStartDay := 0;
end;

{$IFDEF FPC}constructor TExtFormFieldDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldDate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldDate.Destroy; begin
  try
    FDisabledDates.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldNumber.SetFAllowDecimals(Value : Boolean); begin
  FAllowDecimals := Value;
  JSCode('allowDecimals:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFDecimalSeparator(Value : String); begin
  FDecimalSeparator := Value;
  JSCode('decimalSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFSubmitLocaleSeparator(Value : Boolean); begin
  FSubmitLocaleSeparator := Value;
  JSCode('submitLocaleSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFDecimalPrecision(Value : Integer); begin
  FDecimalPrecision := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMinValue(Value : Integer); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMaxValue(Value : Integer); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFStep(Value : Integer); begin
  FStep := Value;
  JSCode('step:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFNanText(Value : String); begin
  FNanText := Value;
  JSCode('nanText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFNegativeText(Value : String); begin
  FNegativeText := Value;
  JSCode('negativeText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFBaseChars(Value : String); begin
  FBaseChars := Value;
  JSCode('baseChars:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFAutoStripChars(Value : Boolean); begin
  FAutoStripChars := Value;
  JSCode('autoStripChars:' + VarToJSON([Value]));
end;

function TExtFormFieldNumber.JSClassName : string; begin
  Result := 'Ext.form.field.Number';
end;

{$IFDEF FPC}constructor TExtFormFieldNumber.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldNumber.GetErrors(Value : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

function TExtFormFieldNumber.SetMinValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

function TExtFormFieldNumber.SetMaxValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

procedure TExtFormFieldTime.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSubmitFormat(Value : String); begin
  FSubmitFormat := Value;
  JSCode('submitFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFPickerMaxHeight(Value : Integer); begin
  FPickerMaxHeight := Value;
  JSCode('pickerMaxHeight:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSelectOnTab(Value : Boolean); begin
  FSelectOnTab := Value;
  JSCode('selectOnTab:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSnapToIncrement(Value : Boolean); begin
  FSnapToIncrement := Value;
  JSCode('snapToIncrement:' + VarToJSON([Value]));
end;

function TExtFormFieldTime.JSClassName : string; begin
  Result := 'Ext.form.field.Time';
end;

procedure TExtFormFieldTime.InitDefaults; begin
  inherited;
  FFormat := 'g:i A';
end;

{$IFDEF FPC}constructor TExtFormFieldTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldTime.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMinValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMaxValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.GetErrors(Value : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

initialization
  ExtEventObjectImpl := TExtEventObjectImplSingleton.CreateSingleton;
  Mother := TMotherSingleton.CreateSingleton;
  ExtFormFieldVTypes := TExtFormFieldVTypesSingleton.CreateSingleton;
  ExtDomHelper := TExtDomHelperSingleton.CreateSingleton;
  ExtDrawEngineSvgExporter := TExtDrawEngineSvgExporterSingleton.CreateSingleton;
  ExtDirectManager := TExtDirectManagerSingleton.CreateSingleton;
  ExtUtilCSS := TExtUtilCSSSingleton.CreateSingleton;
  ExtMenuManager := TExtMenuManagerSingleton.CreateSingleton;
  ExtTipQuickTipManager := TExtTipQuickTipManagerSingleton.CreateSingleton;
  ExtStateManager := TExtStateManagerSingleton.CreateSingleton;
  ExtDataJsonP := TExtDataJsonPSingleton.CreateSingleton;
  ExtDataTypes := TExtDataTypesSingleton.CreateSingleton;
  ExtDataSortTypes := TExtDataSortTypesSingleton.CreateSingleton;
  ExtAjax := TExtAjaxSingleton.CreateSingleton;
  ExtModelManager := TExtModelManagerSingleton.CreateSingleton;
  ExtComponentManager := TExtComponentManagerSingleton.CreateSingleton;
  MyAppCoolPanel := TMyAppCoolPanelSingleton.CreateSingleton;

finalization
  MyAppCoolPanel.Destroy;
  ExtComponentManager.Destroy;
  ExtModelManager.Destroy;
  ExtAjax.Destroy;
  ExtDataSortTypes.Destroy;
  ExtDataTypes.Destroy;
  ExtDataJsonP.Destroy;
  ExtStateManager.Destroy;
  ExtTipQuickTipManager.Destroy;
  ExtMenuManager.Destroy;
  ExtUtilCSS.Destroy;
  ExtDirectManager.Destroy;
  ExtDrawEngineSvgExporter.Destroy;
  ExtDomHelper.Destroy;
  ExtFormFieldVTypes.Destroy;
  Mother.Destroy;
  ExtEventObjectImpl.Destroy;
end.