unit Ext;

// Generated by JSToPascal v.0.9.9, at 03/04/2013 18:55:22
// from "\extpascal\ext-4.2.0\src

interface

uses
  StrUtils, ExtPascal, ExtPascalUtils;

const
  SourcePath = '/src';

type
  TExtAbstractComponent = class;
  TExtAbstractManager = class;
  TExtAbstractPlugin = class;
  TExtAction = class;
  TExtAjaxSingleton = class;
  TExtAppApplication = class;
  TExtAppController = class;
  TExtAppDomainComponentSingleton = class;
  TExtAppDomainControllerSingleton = class;
  TExtAppDomainDirectSingleton = class;
  TExtAppDomainGlobalSingleton = class;
  TExtAppDomainStoreSingleton = class;
  TExtAppEventBusSingleton = class;
  TExtAppEventDomain = class;
  TExtButton = class;
  TExtButtonCycle = class;
  TExtButtonManagerSingleton = class;
  TExtButtonSplit = class;
  TExtChart = class;
  TExtChartAxis = class;
  TExtChartAxisAbstract = class;
  TExtChartAxisCategory = class;
  TExtChartAxisGauge = class;
  TExtChartAxisNumeric = class;
  TExtChartAxisRadial = class;
  TExtChartAxisTime = class;
  TExtChartCallout = class;
  TExtChartHighlight = class;
  TExtChartLabel = class;
  TExtChartLegend = class;
  TExtChartLegendItem = class;
  TExtChartMask = class;
  TExtChartMaskLayer = class;
  TExtChartNavigation = class;
  TExtChartSeries = class;
  TExtChartSeriesArea = class;
  TExtChartSeriesBar = class;
  TExtChartSeriesCartesian = class;
  TExtChartSeriesColumn = class;
  TExtChartSeriesGauge = class;
  TExtChartSeriesLine = class;
  TExtChartSeriesPie = class;
  TExtChartSeriesRadar = class;
  TExtChartSeriesScatter = class;
  TExtChartShapeSingleton = class;
  TExtChartTheme = class;
  TExtChartThemeBase = class;
  TExtChartTip = class;
  TExtChartTipSurface = class;
  TExtComponent = class;
  TExtComponentLoader = class;
  TExtComponentManagerSingleton = class;
  TExtComponentQuerySingleton = class;
  TExtContainer = class;
  TExtContainerAbstractContainer = class;
  TExtContainerButtonGroup = class;
  TExtContainerDockingContainer = class;
  TExtContainerMonitor = class;
  TExtContainerViewport = class;
  TExtDataAbstractStore = class;
  TExtDataArrayStore = class;
  TExtDataAssociation = class;
  TExtDataAssociationBelongsTo = class;
  TExtDataAssociationHasMany = class;
  TExtDataAssociationHasOne = class;
  TExtDataBatch = class;
  TExtDataBufferStore = class;
  TExtDataConnection = class;
  TExtDataDirectStore = class;
  TExtDataErrors = class;
  TExtDataField = class;
  TExtDataFlashBinaryXhr = class;
  TExtDataGroup = class;
  TExtDataIdGenerator = class;
  TExtDataJsonPSingleton = class;
  TExtDataJsonPStore = class;
  TExtDataJsonStore = class;
  TExtDataModel = class;
  TExtDataNodeInterface = class;
  TExtDataNodeStore = class;
  TExtDataOperation = class;
  TExtDataProxy = class;
  TExtDataProxyAjax = class;
  TExtDataProxyClient = class;
  TExtDataProxyDirect = class;
  TExtDataProxyJsonP = class;
  TExtDataProxyLocalStorage = class;
  TExtDataProxyMemory = class;
  TExtDataProxyRest = class;
  TExtDataProxyServer = class;
  TExtDataProxySessionStorage = class;
  TExtDataProxyWebStorage = class;
  TExtDataReader = class;
  TExtDataReaderArray = class;
  TExtDataReaderJson = class;
  TExtDataReaderXml = class;
  TExtDataRequest = class;
  TExtDataResultSet = class;
  TExtDataSequentialIdGenerator = class;
  TExtDataSortTypesSingleton = class;
  TExtDataStore = class;
  TExtDataStoreManagerSingleton = class;
  TExtDataTree = class;
  TExtDataTreeModel = class;
  TExtDataTreeStore = class;
  TExtDataTypesSingleton = class;
  TExtDataUuidGenerator = class;
  TExtDataValidationsSingleton = class;
  TExtDataWriter = class;
  TExtDataWriterJson = class;
  TExtDataWriterXml = class;
  TExtDataXmlStore = class;
  TExtDdDD = class;
  TExtDdDDProxy = class;
  TExtDdDDTarget = class;
  TExtDdDragDrop = class;
  TExtDdDragDropManagerSingleton = class;
  TExtDdDragSource = class;
  TExtDdDragTracker = class;
  TExtDdDragZone = class;
  TExtDdDropTarget = class;
  TExtDdDropZone = class;
  TExtDdRegistrySingleton = class;
  TExtDdScrollManagerSingleton = class;
  TExtDdStatusProxy = class;
  TExtDiagLayoutContext = class;
  TExtDiagLayoutContextItem = class;
  TExtDirectEvent = class;
  TExtDirectExceptionEvent = class;
  TExtDirectJsonProvider = class;
  TExtDirectManagerSingleton = class;
  TExtDirectPollingProvider = class;
  TExtDirectProvider = class;
  TExtDirectRemotingEvent = class;
  TExtDirectRemotingMethod = class;
  TExtDirectRemotingProvider = class;
  TExtDirectTransaction = class;
  TExtDomAbstractElement = class;
  TExtDomAbstractElement_insertion = class;
  TExtDomAbstractElement_static = class;
  TExtDomAbstractElement_style = class;
  TExtDomAbstractElement_traversal = class;
  TExtDomAbstractHelper = class;
  TExtDomAbstractQuery = class;
  TExtDomCompositeElement = class;
  TExtDomCompositeElementLite = class;
  TExtDomElement = class;
  TExtDomElement_anim = class;
  TExtDomElement_dd = class;
  TExtDomElement_fx = class;
  TExtDomElement_position = class;
  TExtDomElement_scroll = class;
  TExtDomElement_style = class;
  TExtDomHelperSingleton = class;
  TExtDomLayer = class;
  TExtDrawColor = class;
  TExtDrawComponent = class;
  TExtDrawCompositeSprite = class;
  TExtDrawEngineImageExporterSingleton = class;
  TExtDrawEngineSvg = class;
  TExtDrawEngineSvgExporterSingleton = class;
  TExtDrawEngineVml = class;
  TExtDrawMatrix = class;
  TExtDrawSingleton = class;
  TExtDrawSprite = class;
  TExtDrawSpriteDD = class;
  TExtDrawSurface = class;
  TExtDrawText = class;
  TExtEditor = class;
  TExtElementLoader = class;
  TExtEventObjectImplSingleton = class;
  TExtFlashComponent = class;
  TExtFocusManagerSingleton = class;
  TExtFoo = class;
  TExtFormAction = class;
  TExtFormActionDirectLoad = class;
  TExtFormActionDirectSubmit = class;
  TExtFormActionLoad = class;
  TExtFormActionStandardSubmit = class;
  TExtFormActionSubmit = class;
  TExtFormBasic = class;
  TExtFormCheckboxGroup = class;
  TExtFormCheckboxManagerSingleton = class;
  TExtFormField = class;
  TExtFormFieldAncestor = class;
  TExtFormFieldBase = class;
  TExtFormFieldCheckbox = class;
  TExtFormFieldComboBox = class;
  TExtFormFieldContainer = class;
  TExtFormFieldDate = class;
  TExtFormFieldDisplay = class;
  TExtFormFieldFile = class;
  TExtFormFieldFileButton = class;
  TExtFormFieldHidden = class;
  TExtFormFieldHtmlEditor = class;
  TExtFormFieldNumber = class;
  TExtFormFieldPicker = class;
  TExtFormFieldRadio = class;
  TExtFormFieldSet = class;
  TExtFormFieldSpinner = class;
  TExtFormFieldText = class;
  TExtFormFieldTextArea = class;
  TExtFormFieldTime = class;
  TExtFormFieldTrigger = class;
  TExtFormFieldVTypesSingleton = class;
  TExtFormLabel = class;
  TExtFormLabelable = class;
  TExtFormPanel = class;
  TExtFormRadioGroup = class;
  TExtFormRadioManagerSingleton = class;
  TExtFxAnim = class;
  TExtFxAnimator = class;
  TExtFxCubicBezierSingleton = class;
  TExtFxEasingSingleton = class;
  TExtFxManagerSingleton = class;
  TExtFxPropertyHandler = class;
  TExtFxQueue = class;
  TExtFxTarget = class;
  TExtFxTargetComponent = class;
  TExtFxTargetCompositeElement = class;
  TExtFxTargetCompositeElementCSS = class;
  TExtFxTargetCompositeSprite = class;
  TExtFxTargetElement = class;
  TExtFxTargetElementCSS = class;
  TExtFxTargetSprite = class;
  TExtGridCellEditor = class;
  TExtGridColumn = class;
  TExtGridColumnAction = class;
  TExtGridColumnBoolean = class;
  TExtGridColumnCheckColumn = class;
  TExtGridColumnComponentLayout = class;
  TExtGridColumnDate = class;
  TExtGridColumnLayout = class;
  TExtGridColumnNumber = class;
  TExtGridColumnTemplate = class;
  TExtGridFeature = class;
  TExtGridFeatureAbstractSummary = class;
  TExtGridFeatureGrouping = class;
  TExtGridFeatureGroupingSummary = class;
  TExtGridFeatureGroupStore = class;
  TExtGridFeatureRowBody = class;
  TExtGridFeatureRowWrap = class;
  TExtGridFeatureSummary = class;
  TExtGridHeaderContainer = class;
  TExtGridHeaderDragZone = class;
  TExtGridHeaderDropZone = class;
  TExtGridLockingHeaderContainer = class;
  TExtGridLockingLockable = class;
  TExtGridLockingView = class;
  TExtGridPanel = class;
  TExtGridPluginBufferedRenderer = class;
  TExtGridPluginBufferedRendererTableView = class;
  TExtGridPluginBufferedRendererTreeView = class;
  TExtGridPluginCellEditing = class;
  TExtGridPluginDivRenderer = class;
  TExtGridPluginDragDrop = class;
  TExtGridPluginEditing = class;
  TExtGridPluginHeaderReorderer = class;
  TExtGridPluginHeaderResizer = class;
  TExtGridPluginRowEditing = class;
  TExtGridPluginRowExpander = class;
  TExtGridProperty = class;
  TExtGridPropertyGrid = class;
  TExtGridPropertyHeaderContainer = class;
  TExtGridPropertyStore = class;
  TExtGridRowEditor = class;
  TExtGridRowEditorButtons = class;
  TExtGridRowNumberer = class;
  TExtGridScroller = class;
  TExtGridView = class;
  TExtGridViewDropZone = class;
  TExtImg = class;
  TExtLayout = class;
  TExtLayoutClassList = class;
  TExtLayoutComponent = class;
  TExtLayoutComponentAuto = class;
  TExtLayoutComponentBody = class;
  TExtLayoutComponentBoundList = class;
  TExtLayoutComponentButton = class;
  TExtLayoutComponentDock = class;
  TExtLayoutComponentDraw = class;
  TExtLayoutComponentField = class;
  TExtLayoutComponentFieldComboBox = class;
  TExtLayoutComponentFieldFieldContainer = class;
  TExtLayoutComponentFieldHtmlEditor = class;
  TExtLayoutComponentFieldSet = class;
  TExtLayoutComponentFieldSlider = class;
  TExtLayoutComponentFieldText = class;
  TExtLayoutComponentFieldTextArea = class;
  TExtLayoutComponentFieldTrigger = class;
  TExtLayoutComponentProgressBar = class;
  TExtLayoutContainer = class;
  TExtLayoutContainerAbsolute = class;
  TExtLayoutContainerAccordion = class;
  TExtLayoutContainerAnchor = class;
  TExtLayoutContainerAuto = class;
  TExtLayoutContainerBorder = class;
  TExtLayoutContainerBox = class;
  TExtLayoutContainerBoxOverflowMenu = class;
  TExtLayoutContainerBoxOverflowNone = class;
  TExtLayoutContainerBoxOverflowScroller = class;
  TExtLayoutContainerCard = class;
  TExtLayoutContainerCheckboxGroup = class;
  TExtLayoutContainerColumn = class;
  TExtLayoutContainerEditor = class;
  TExtLayoutContainerFit = class;
  TExtLayoutContainerForm = class;
  TExtLayoutContainerHBox = class;
  TExtLayoutContainerTable = class;
  TExtLayoutContainerVBox = class;
  TExtLayoutContextItem = class;
  TExtLayoutSizeModel = class;
  TExtLoadMask = class;
  TExtMenu = class;
  TExtMenuCheckItem = class;
  TExtMenuColorPicker = class;
  TExtMenuDatePicker = class;
  TExtMenuItem = class;
  TExtMenuKeyNav = class;
  TExtMenuManagerSingleton = class;
  TExtMenuSeparator = class;
  TExtMessageBoxSingleton = class;
  TExtModelManagerSingleton = class;
  TExtPanel = class;
  TExtPanelAbstractPanel = class;
  TExtPanelDD = class;
  TExtPanelHeader = class;
  TExtPanelProxy = class;
  TExtPanelTable = class;
  TExtPanelTool = class;
  TExtPerfAccumulator = class;
  TExtPerfMonitorSingleton = class;
  TExtPickerColor = class;
  TExtPickerDate = class;
  TExtPickerMonth = class;
  TExtPickerTime = class;
  TExtPluginManagerSingleton = class;
  TExtProgressBar = class;
  TExtProgressWaitConfig = class;
  TExtResizer = class;
  TExtResizerBorderSplitter = class;
  TExtResizerBorderSplitterTracker = class;
  TExtResizerHandle = class;
  TExtResizerResizeTracker = class;
  TExtResizerSplitter = class;
  TExtResizerSplitterTracker = class;
  TExtRtlAbstractComponent = class;
  TExtRtlButton = class;
  TExtRtlDdDD = class;
  TExtRtlDomElement_anim = class;
  TExtRtlDomElement_insertion = class;
  TExtRtlDomElement_position = class;
  TExtRtlDomElement_scroll = class;
  TExtRtlDomElement_static = class;
  TExtRtlDomLayer = class;
  TExtRtlEventObjectImpl = class;
  TExtRtlFormFieldSpinner = class;
  TExtRtlFormFieldTrigger = class;
  TExtRtlGridColumn = class;
  TExtRtlGridPluginHeaderResizer = class;
  TExtRtlGridPluginRowEditing = class;
  TExtRtlGridRowEditor = class;
  TExtRtlLayoutComponentDock = class;
  TExtRtlLayoutComponentFieldText = class;
  TExtRtlLayoutComponentFieldTrigger = class;
  TExtRtlLayoutContainerAbsolute = class;
  TExtRtlLayoutContainerBox = class;
  TExtRtlLayoutContainerBoxOverflowScroller = class;
  TExtRtlLayoutContainerColumn = class;
  TExtRtlLayoutContainerHBox = class;
  TExtRtlLayoutContainerVBox = class;
  TExtRtlLayoutContextItem = class;
  TExtRtlPanel = class;
  TExtRtlPanelHeader = class;
  TExtRtlResizerBorderSplitterTracker = class;
  TExtRtlResizerResizeTracker = class;
  TExtRtlResizerSplitterTracker = class;
  TExtRtlSliderMulti = class;
  TExtRtlTabBar = class;
  TExtRtlTreeColumn = class;
  TExtRtlUtilFloating = class;
  TExtRtlUtilRenderable = class;
  TExtRtlViewTable = class;
  TExtSelectionCellModel = class;
  TExtSelectionCheckboxModel = class;
  TExtSelectionDataViewModel = class;
  TExtSelectionModel = class;
  TExtSelectionRowModel = class;
  TExtSelectionTreeModel = class;
  TExtShadow = class;
  TExtShadowPoolSingleton = class;
  TExtShowConfig = class;
  TExtSliderMulti = class;
  TExtSliderSingle = class;
  TExtSliderThumb = class;
  TExtSliderTip = class;
  TExtStateCookieProvider = class;
  TExtStateLocalStorageProvider = class;
  TExtStateManagerSingleton = class;
  TExtStateProvider = class;
  TExtStateStateful = class;
  TExtTab = class;
  TExtTabBar = class;
  TExtTabPanel = class;
  TExtTemplate = class;
  TExtTip = class;
  TExtTipQuickTip = class;
  TExtTipQuickTipManagerSingleton = class;
  TExtTipToolTip = class;
  TExtToolbar = class;
  TExtToolbarFill = class;
  TExtToolbarItem = class;
  TExtToolbarPaging = class;
  TExtToolbarSeparator = class;
  TExtToolbarSpacer = class;
  TExtToolbarTextItem = class;
  TExtTreeColumn = class;
  TExtTreePanel = class;
  TExtTreePluginTreeViewDragDrop = class;
  TExtTreeView = class;
  TExtTreeViewDragZone = class;
  TExtTreeViewDropZone = class;
  TExtUtilAbstractMixedCollection = class;
  TExtUtilAnimate = class;
  TExtUtilBindable = class;
  TExtUtilClickRepeater = class;
  TExtUtilComponentDragger = class;
  TExtUtilCookiesSingleton = class;
  TExtUtilCSSSingleton = class;
  TExtUtilElementContainer = class;
  TExtUtilEvent = class;
  TExtUtilFilter = class;
  TExtUtilFloating = class;
  TExtUtilGrouper = class;
  TExtUtilHashMap = class;
  TExtUtilHistorySingleton = class;
  TExtUtilInflectorSingleton = class;
  TExtUtilKeyMap = class;
  TExtUtilKeyNav = class;
  TExtUtilLruCache = class;
  TExtUtilMemento = class;
  TExtUtilMixedCollection = class;
  TExtUtilObservable = class;
  TExtUtilOffset = class;
  TExtUtilPoint = class;
  TExtUtilPositionable = class;
  TExtUtilProtoElement = class;
  TExtUtilQueue = class;
  TExtUtilRegion = class;
  TExtUtilRenderable = class;
  TExtUtilSortable = class;
  TExtUtilSorter = class;
  TExtUtilTaskManagerSingleton = class;
  TExtUtilTaskRunner = class;
  TExtUtilTextMetrics = class;
  TExtView = class;
  TExtViewAbstractView = class;
  TExtViewBoundList = class;
  TExtViewBoundListKeyNav = class;
  TExtViewDragZone = class;
  TExtViewDropZone = class;
  TExtViewNodeCache = class;
  TExtViewTable = class;
  TExtViewTableLayout = class;
  TExtWindow = class;
  TExtWindowMessageBox = class;
  TExtXTemplate = class;
  TExtXTemplateCompiler = class;
  TExtXTemplateParser = class;
  TExtZIndexManager = class;

  TExtClass = class(TExtObject);
  TExtCompositeElement = class(TExtObject);
  TExtDataRecord = TExtDataModel;
  TExtElement = class(TExtObject);
  TExtEnumsLayout = (laAbsolute, laAccordion, laAnchor, laAutocomponent, laAutocontainer, laBorder, laBox, laCard, laCheckboxgroup, laColumn, laContainer, laFit, laForm, laHbox, laTable, laVbox);
  TExtEnumsWidget = String;
  TExtError = class(TExtObject);
  TExtEventObject = class(TExtObject);
  TExtFocusManager = class(TExtObject);
  TExtSliderMultiSlider = class(TExtObject);
  TExtUtilHistory = class(TExtObject);

  TExtShowConfig = class(TExtFunction)
  private
    FAnimTarget : String;
    FButtons : Integer;
    FClosable : Boolean; // true
    FCls : String;
    FDefaultFocus : String;
    FDefaultTextHeight : Integer; // 75
    FFn : TExtFunction;
    FIcon : String;
    FIconCls : String;
    FMaxWidth : Integer; // 600
    FMinWidth : Integer; // 100
    FModal : Boolean; // true
    FMsg : String;
    FMultiline : Boolean;
    FProgress : Boolean;
    FProgressText : String;
    FPrompt : Boolean;
    FProxyDrag : Boolean;
    FScope : TExtObject;
    FTitle : String;
    FValue : String;
    FWait : Boolean;
    FWaitConfig : TExtProgressWaitConfig;
    FWidth : Integer;
    procedure SetFAnimTarget(Value : String);
    procedure SetFButtons(Value : Integer);
    procedure SetFClosable(Value : Boolean);
    procedure SetFCls(Value : String);
    procedure SetFDefaultFocus(Value : String);
    procedure SetFDefaultTextHeight(Value : Integer);
    procedure SetFFn(Value : TExtFunction);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFModal(Value : Boolean);
    procedure SetFMsg(Value : String);
    procedure SetFMultiline(Value : Boolean);
    procedure SetFProgress(Value : Boolean);
    procedure SetFProgressText(Value : String);
    procedure SetFPrompt(Value : Boolean);
    procedure SetFProxyDrag(Value : Boolean);
    procedure SetFScope(Value : TExtObject);
    procedure SetFTitle(Value : String);
    procedure SetFValue(Value : String);
    procedure SetFWait(Value : Boolean);
    procedure SetFWaitConfig(Value : TExtProgressWaitConfig);
    procedure SetFWidth(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AnimTarget : String read FAnimTarget write SetFAnimTarget;
    property Buttons : Integer read FButtons write SetFButtons;
    property Closable : Boolean read FClosable write SetFClosable;
    property Cls : String read FCls write SetFCls;
    property DefaultFocus : String read FDefaultFocus write SetFDefaultFocus;
    property DefaultTextHeight : Integer read FDefaultTextHeight write SetFDefaultTextHeight;
    property Fn : TExtFunction read FFn write SetFFn;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property Modal : Boolean read FModal write SetFModal;
    property Msg : String read FMsg write SetFMsg;
    property Multiline : Boolean read FMultiline write SetFMultiline;
    property Progress : Boolean read FProgress write SetFProgress;
    property ProgressText : String read FProgressText write SetFProgressText;
    property Prompt : Boolean read FPrompt write SetFPrompt;
    property ProxyDrag : Boolean read FProxyDrag write SetFProxyDrag;
    property Scope : TExtObject read FScope write SetFScope;
    property Title : String read FTitle write SetFTitle;
    property Value : String read FValue write SetFValue;
    property Wait : Boolean read FWait write SetFWait;
    property WaitConfig : TExtProgressWaitConfig read FWaitConfig write SetFWaitConfig;
    property Width : Integer read FWidth write SetFWidth;
  end;

  TExtProgressWaitConfig = class(TExtFunction)
  private
    FAnimate : Boolean;
    FDuration : Integer;
    FFn : TExtFunction;
    FIncrement : Integer; // 10
    FInterval : Integer; // 1000
    FScope : TExtObject;
    FText : String;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFDuration(Value : Integer);
    procedure SetFFn(Value : TExtFunction);
    procedure SetFIncrement(Value : Integer);
    procedure SetFInterval(Value : Integer);
    procedure SetFScope(Value : TExtObject);
    procedure SetFText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Animate : Boolean read FAnimate write SetFAnimate;
    property Duration : Integer read FDuration write SetFDuration;
    property Fn : TExtFunction read FFn write SetFFn;
    property Increment : Integer read FIncrement write SetFIncrement;
    property Interval : Integer read FInterval write SetFInterval;
    property Scope : TExtObject read FScope write SetFScope;
    property Text : String read FText write SetFText;
  end;

  // Procedural types for events TExtAbstractComponent
  TExtAbstractComponentOnActivate = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnAdded = procedure(This : TExtAbstractComponent; Container : TExtContainer; Pos : Integer) of object;
  TExtAbstractComponentOnAfterrender = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforeactivate = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforedeactivate = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforedestroy = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforehide = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforerender = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforeshow = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnBeforestaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtAbstractComponentOnBeforestatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtAbstractComponentOnBlur = procedure(This : TExtAbstractComponent; The : TExtEventObject) of object;
  TExtAbstractComponentOnBoxready = procedure(This : TExtAbstractComponent; Width : Integer; Height : Integer) of object;
  TExtAbstractComponentOnDeactivate = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnDestroy = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnDisable = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnEnable = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnFocus = procedure(This : TExtAbstractComponent; The : TExtEventObject) of object;
  TExtAbstractComponentOnHide = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnMove = procedure(This : TExtAbstractComponent; X : Integer; Y : Integer) of object;
  TExtAbstractComponentOnRemoved = procedure(This : TExtAbstractComponent; OwnerCt : TExtContainer) of object;
  TExtAbstractComponentOnRender = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnResize = procedure(This : TExtAbstractComponent; Width : Integer; Height : Integer; OldWidth : Integer; OldHeight : Integer) of object;
  TExtAbstractComponentOnShow = procedure(This : TExtAbstractComponent) of object;
  TExtAbstractComponentOnStaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtAbstractComponentOnStatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;

  TExtAbstractComponent = class(TExtFunction)
  private
    FAutoEl : String;
    FAutoElObject : TExtObject;
    FAutoRender : Boolean;
    FAutoRenderElement : TExtElement;
    FAutoRenderString : String;
    FAutoRenderTHTMLElement : THTMLElement;
    FAutoShow : Boolean;
    FBaseCls : String;
    FBorder : Integer;
    FBorderBoolean : Boolean;
    FBorderString : String;
    FChildEls : TExtObjectList;
    FCls : String;
    FComponentCls : String;
    FComponentLayout : String;
    FComponentLayoutObject : TExtObject;
    FContentEl : String;
    FContentPaddingProperty : String;
    FData : TExtObject;
    FDisabled : Boolean;
    FDisabledCls : String;
    FDraggable : Boolean;
    FFloating : Boolean;
    FFrame : Boolean;
    FFrameSize : TExtObject;
    FFrameSizeBottom : Integer;
    FFrameSizeHeight : Integer;
    FFrameSizeLeft : Integer;
    FFrameSizeRight : Integer;
    FFrameSizeTop : Integer;
    FFrameSizeWidth : Integer;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FHeight : Integer;
    FHidden : Boolean;
    FHideMode : String;
    FHtml : String;
    FHtmlObject : TExtObject;
    FId : String;
    FIsComponent : Boolean;
    FIsObservable : Boolean;
    FItemId : String;
    FListeners : TExtObject;
    FLoader : TExtComponentLoader;
    FLoaderObject : TExtObject;
    FMargin : Integer;
    FMarginString : String;
    FMaskOnDisable : Boolean;
    FMaxHeight : Integer;
    FMaxWidth : Integer;
    FMinHeight : Integer;
    FMinWidth : Integer;
    FOverCls : String;
    FOwnerCt : TExtContainer;
    FPadding : Integer;
    FPaddingString : String;
    FPlugins : TExtObjectList;
    FPluginsList : TExtObjectList;
    FPluginsObject : TExtObject;
    FPluginsPlugin : TExtAbstractPlugin;
    FRenderData : TExtObject;
    FRendered : Boolean;
    FRenderSelectors : TExtObject;
    FRenderTo : String;
    FRenderToElement : TExtElement;
    FRenderToTHTMLElement : THTMLElement;
    FSaveDelay : Integer;
    FScrollFlags : TExtObject;
    FScrollFlagsBoth : Boolean;
    FScrollFlagsOverflowX : String;
    FScrollFlagsOverflowY : String;
    FScrollFlagsX : Boolean;
    FScrollFlagsY : Boolean;
    FShrinkWrap : Boolean;
    FShrinkWrapInteger : Integer;
    FStateEvents : TArrayOfString;
    FStateful : Boolean;
    FStateId : String;
    FStyle : String;
    FStyleObject : TExtObject;
    FTpl : TExtXTemplate;
    FTplString : String;
    FTplTArrayOfString : TArrayOfString;
    FTplTemplate : TExtTemplate;
    FTplWriteMode : String;
    FUi : String;
    FWidth : Integer;
    FXtype : TExtEnumsWidget;
    FOnActivate : TExtAbstractComponentOnActivate;
    FOnAdded : TExtAbstractComponentOnAdded;
    FOnAfterrender : TExtAbstractComponentOnAfterrender;
    FOnBeforeactivate : TExtAbstractComponentOnBeforeactivate;
    FOnBeforedeactivate : TExtAbstractComponentOnBeforedeactivate;
    FOnBeforedestroy : TExtAbstractComponentOnBeforedestroy;
    FOnBeforehide : TExtAbstractComponentOnBeforehide;
    FOnBeforerender : TExtAbstractComponentOnBeforerender;
    FOnBeforeshow : TExtAbstractComponentOnBeforeshow;
    FOnBeforestaterestore : TExtAbstractComponentOnBeforestaterestore;
    FOnBeforestatesave : TExtAbstractComponentOnBeforestatesave;
    FOnBlur : TExtAbstractComponentOnBlur;
    FOnBoxready : TExtAbstractComponentOnBoxready;
    FOnDeactivate : TExtAbstractComponentOnDeactivate;
    FOnDestroy : TExtAbstractComponentOnDestroy;
    FOnDisable : TExtAbstractComponentOnDisable;
    FOnEnable : TExtAbstractComponentOnEnable;
    FOnFocus : TExtAbstractComponentOnFocus;
    FOnHide : TExtAbstractComponentOnHide;
    FOnMove : TExtAbstractComponentOnMove;
    FOnRemoved : TExtAbstractComponentOnRemoved;
    FOnRender : TExtAbstractComponentOnRender;
    FOnResize : TExtAbstractComponentOnResize;
    FOnShow : TExtAbstractComponentOnShow;
    FOnStaterestore : TExtAbstractComponentOnStaterestore;
    FOnStatesave : TExtAbstractComponentOnStatesave;
    procedure SetFAutoEl(Value : String);
    procedure SetFAutoElObject(Value : TExtObject);
    procedure SetFAutoRender(Value : Boolean);
    procedure SetFAutoRenderElement(Value : TExtElement);
    procedure SetFAutoRenderString(Value : String);
    procedure SetFAutoRenderTHTMLElement(Value : THTMLElement);
    procedure SetFAutoShow(Value : Boolean);
    procedure SetFBaseCls(Value : String);
    procedure SetFBorder(Value : Integer);
    procedure SetFBorderBoolean(Value : Boolean);
    procedure SetFBorderString(Value : String);
    procedure SetFChildEls(Value : TExtObjectList);
    procedure SetFCls(Value : String);
    procedure SetFComponentCls(Value : String);
    procedure SetFComponentLayout(Value : String);
    procedure SetFComponentLayoutObject(Value : TExtObject);
    procedure SetFContentEl(Value : String);
    procedure SetFContentPaddingProperty(Value : String);
    procedure SetFData(Value : TExtObject);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFDisabledCls(Value : String);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFFloating(Value : Boolean);
    procedure SetFFrame(Value : Boolean);
    procedure SetFFrameSize(Value : TExtObject);
    procedure SetFFrameSizeBottom(Value : Integer);
    procedure SetFFrameSizeHeight(Value : Integer);
    procedure SetFFrameSizeLeft(Value : Integer);
    procedure SetFFrameSizeRight(Value : Integer);
    procedure SetFFrameSizeTop(Value : Integer);
    procedure SetFFrameSizeWidth(Value : Integer);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHeight(Value : Integer);
    procedure SetFHidden(Value : Boolean);
    procedure SetFHideMode(Value : String);
    procedure SetFHtml(Value : String);
    procedure SetFHtmlObject(Value : TExtObject);
    procedure SetFId(Value : String);
    procedure SetFIsComponent(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFItemId(Value : String);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFLoader(Value : TExtComponentLoader);
    procedure SetFLoaderObject(Value : TExtObject);
    procedure SetFMargin(Value : Integer);
    procedure SetFMarginString(Value : String);
    procedure SetFMaskOnDisable(Value : Boolean);
    procedure SetFMaxHeight(Value : Integer);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFMinHeight(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFOverCls(Value : String);
    procedure SetFOwnerCt(Value : TExtContainer);
    procedure SetFPadding(Value : Integer);
    procedure SetFPaddingString(Value : String);
    procedure SetFPlugins(Value : TExtObjectList);
    procedure SetFPluginsList(Value : TExtObjectList);
    procedure SetFPluginsObject(Value : TExtObject);
    procedure SetFPluginsPlugin(Value : TExtAbstractPlugin);
    procedure SetFRenderData(Value : TExtObject);
    procedure SetFRendered(Value : Boolean);
    procedure SetFRenderSelectors(Value : TExtObject);
    procedure SetFRenderTo(Value : String);
    procedure SetFRenderToElement(Value : TExtElement);
    procedure SetFRenderToTHTMLElement(Value : THTMLElement);
    procedure SetFSaveDelay(Value : Integer);
    procedure SetFScrollFlags(Value : TExtObject);
    procedure SetFScrollFlagsBoth(Value : Boolean);
    procedure SetFScrollFlagsOverflowX(Value : String);
    procedure SetFScrollFlagsOverflowY(Value : String);
    procedure SetFScrollFlagsX(Value : Boolean);
    procedure SetFScrollFlagsY(Value : Boolean);
    procedure SetFShrinkWrap(Value : Boolean);
    procedure SetFShrinkWrapInteger(Value : Integer);
    procedure SetFStateEvents(Value : TArrayOfString);
    procedure SetFStateful(Value : Boolean);
    procedure SetFStateId(Value : String);
    procedure SetFStyle(Value : String);
    procedure SetFStyleObject(Value : TExtObject);
    procedure SetFTpl(Value : TExtXTemplate);
    procedure SetFTplString(Value : String);
    procedure SetFTplTArrayOfString(Value : TArrayOfString);
    procedure SetFTplTemplate(Value : TExtTemplate);
    procedure SetFTplWriteMode(Value : String);
    procedure SetFUi(Value : String);
    procedure SetFWidth(Value : Integer);
    procedure SetFXtype(Value : TExtEnumsWidget);
    procedure SetFOnActivate(Value : TExtAbstractComponentOnActivate);
    procedure SetFOnAdded(Value : TExtAbstractComponentOnAdded);
    procedure SetFOnAfterrender(Value : TExtAbstractComponentOnAfterrender);
    procedure SetFOnBeforeactivate(Value : TExtAbstractComponentOnBeforeactivate);
    procedure SetFOnBeforedeactivate(Value : TExtAbstractComponentOnBeforedeactivate);
    procedure SetFOnBeforedestroy(Value : TExtAbstractComponentOnBeforedestroy);
    procedure SetFOnBeforehide(Value : TExtAbstractComponentOnBeforehide);
    procedure SetFOnBeforerender(Value : TExtAbstractComponentOnBeforerender);
    procedure SetFOnBeforeshow(Value : TExtAbstractComponentOnBeforeshow);
    procedure SetFOnBeforestaterestore(Value : TExtAbstractComponentOnBeforestaterestore);
    procedure SetFOnBeforestatesave(Value : TExtAbstractComponentOnBeforestatesave);
    procedure SetFOnBlur(Value : TExtAbstractComponentOnBlur);
    procedure SetFOnBoxready(Value : TExtAbstractComponentOnBoxready);
    procedure SetFOnDeactivate(Value : TExtAbstractComponentOnDeactivate);
    procedure SetFOnDestroy(Value : TExtAbstractComponentOnDestroy);
    procedure SetFOnDisable(Value : TExtAbstractComponentOnDisable);
    procedure SetFOnEnable(Value : TExtAbstractComponentOnEnable);
    procedure SetFOnFocus(Value : TExtAbstractComponentOnFocus);
    procedure SetFOnHide(Value : TExtAbstractComponentOnHide);
    procedure SetFOnMove(Value : TExtAbstractComponentOnMove);
    procedure SetFOnRemoved(Value : TExtAbstractComponentOnRemoved);
    procedure SetFOnRender(Value : TExtAbstractComponentOnRender);
    procedure SetFOnResize(Value : TExtAbstractComponentOnResize);
    procedure SetFOnShow(Value : TExtAbstractComponentOnShow);
    procedure SetFOnStaterestore(Value : TExtAbstractComponentOnStaterestore);
    procedure SetFOnStatesave(Value : TExtAbstractComponentOnStatesave);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddChildEls : TExtFunction;
    function AddCls(Cls : TArrayOfString) : TExtFunction; overload;
    function AddCls(Cls : String) : TExtFunction; overload;
    function AddClsWithUI(Classes : TArrayOfString; Skip : TExtObject) : TExtFunction; overload;
    function AddClsWithUI(Classes : String; Skip : TExtObject) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddStateEvents(Events : String) : TExtFunction; overload;
    function AddStateEvents(Events : TArrayOfString) : TExtFunction; overload;
    function AddUIClsToElement(Ui : String) : TExtFunction;
    function AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AlignTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AlignTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AlignTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AlignTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function Animate(Config : TExtObject) : TExtFunction;
    function ApplyState(State : TExtObject) : TExtFunction;
    function CalculateConstrainedPosition(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : TExtElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CancelLayout(Comp : TExtComponent) : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Config : TExtObject);
    function Disable(Silent : Boolean = false) : TExtFunction;
    function DoAutoRender : TExtFunction;
    function DoComponentLayout : TExtFunction;
    function Enable(Silent : Boolean = false) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EnsureAttachedToBody(RunLayout : Boolean = false) : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FlushLayouts : TExtFunction;
    function GetActiveAnimation : TExtFunction;
    function GetAlignToXY(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAlignToXY(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAlignToXY(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAnchorXY(Anchor : String = ''; Local : Boolean = false; Size : TExtObject = nil) : TExtFunction;
    function GetBox(ContentBox : Boolean = false; Local : Boolean = false) : TExtFunction;
    function GetBubbleTarget : TExtFunction;
    function GetConstrainVector(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : TExtUtilPositionable; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetEl : TExtFunction;
    function GetHeight : TExtFunction;
    function GetId : TExtFunction;
    function GetInsertPosition(Position : Integer) : TExtFunction; overload;
    function GetInsertPosition(Position : String) : TExtFunction; overload;
    function GetInsertPosition(Position : TExtDomElement) : TExtFunction; overload;
    function GetInsertPosition(Position : THTMLElement) : TExtFunction; overload;
    function GetItemId : TExtFunction;
    function GetLoader : TExtFunction;
    function GetLocalX : TExtFunction;
    function GetLocalXY : TExtFunction;
    function GetLocalY : TExtFunction;
    function GetOffsetsTo(OffsetsTo : String) : TExtFunction; overload;
    function GetOffsetsTo(OffsetsTo : TExtUtilPositionable) : TExtFunction; overload;
    function GetOffsetsTo(OffsetsTo : THTMLElement) : TExtFunction; overload;
    function GetPlugin(PluginId : String) : TExtFunction;
    function GetRegion : TExtFunction;
    function GetSize : TExtFunction;
    function GetSizeModel : TExtFunction;
    function GetState : TExtFunction;
    function GetViewRegion : TExtFunction;
    function GetWidth : TExtFunction;
    function GetX : TExtFunction;
    function GetXTypes : TExtFunction;
    function GetXY : TExtFunction;
    function GetY : TExtFunction;
    function HasCls(ClassName : String) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function HasUICls(Cls : String) : TExtFunction;
    function IsDescendantOf(Container : TExtContainer) : TExtFunction;
    function IsDisabled : TExtFunction;
    function IsDraggable : TExtFunction;
    function IsDroppable : TExtFunction;
    function IsFloating : TExtFunction;
    function IsHidden : TExtFunction;
    function IsJS(Selector : String) : TExtFunction;
    function IsLayoutSuspended : TExtFunction;
    function IsVisible(Deep : Boolean = false) : TExtFunction;
    function IsXType(Xtype : String; Shallow : Boolean = false) : TExtFunction;
    function Move(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function Move(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; overload;
    function NextNode(Selector : String = '') : TExtFunction;
    function NextSibling(Selector : String = '') : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function PreviousNode(Selector : String = '') : TExtFunction;
    function PreviousSibling(Selector : String = '') : TExtFunction;
    function RegisterFloatingItem : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveAnchor : TExtFunction;
    function RemoveChildEls(TestFn : TExtFunction) : TExtFunction;
    function RemoveCls(Cls : TArrayOfString) : TExtFunction; overload;
    function RemoveCls(Cls : String) : TExtFunction; overload;
    function RemoveClsWithUI(Cls : TArrayOfString) : TExtFunction; overload;
    function RemoveClsWithUI(Cls : String) : TExtFunction; overload;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveUIClsFromElement(Ui : String) : TExtFunction;
    function Render(Container : String = ''; Position : Integer = 0) : TExtFunction; overload;
    function Render(Container : TExtElement; Position : Integer = 0) : TExtFunction; overload;
    function Render(Container : TExtElement; Position : String) : TExtFunction; overload;
    function Render(Container : THTMLElement; Position : Integer = 0) : TExtFunction; overload;
    function Render(Container : THTMLElement; Position : String) : TExtFunction; overload;
    function Render(Container : String; Position : String) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function ResumeLayouts(Flush : Boolean = false) : TExtFunction;
    function SavePropsToState(PropNames : String; State : TExtObject) : TExtFunction; overload;
    function SavePropsToState(PropNames : TArrayOfString; State : TExtObject) : TExtFunction; overload;
    function SavePropToState(PropName : String; State : TExtObject; StateName : String = '') : TExtFunction;
    function SaveState : TExtFunction;
    function SequenceFx : TExtFunction;
    function SetBorder(Border : String) : TExtFunction; overload;
    function SetBorder(Border : Integer) : TExtFunction; overload;
    function SetBox(Box : TExtObject; Animate : Boolean = false) : TExtFunction; overload;
    function SetBox(Box : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    function SetDocked(Dock : TExtObject; LayoutParent : Boolean = false) : TExtFunction;
    function SetHeight(Height : Integer) : TExtFunction;
    function SetLocalX(X : Integer) : TExtFunction;
    function SetLocalXY(X : Integer; Y : Integer = 0) : TExtFunction; overload;
    function SetLocalXY(X : TExtObjectList; Y : Integer = 0) : TExtFunction; overload;
    function SetLocalY(Y : Integer) : TExtFunction;
    function SetMargin(Margin : String) : TExtFunction; overload;
    function SetMargin(Margin : Integer) : TExtFunction; overload;
    function SetPosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPosition(X : TExtObject; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPosition(X : TExtObject; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function SetPosition(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPosition(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function SetPosition(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function SetRegion(Region : TExtUtilRegion; Animate : Boolean = false) : TExtFunction; overload;
    function SetRegion(Region : TExtUtilRegion; Animate : TExtObject) : TExtFunction; overload;
    function SetSize(Width : Integer; Height : String) : TExtFunction; overload;
    function SetSize(Width : TExtObject; Height : String) : TExtFunction; overload;
    function SetSize(Width : TExtObject; Height : Integer) : TExtFunction; overload;
    function SetSize(Width : String; Height : String) : TExtFunction; overload;
    function SetSize(Width : String; Height : Integer) : TExtFunction; overload;
    function SetSize(Width : Integer; Height : Integer) : TExtFunction; overload;
    function SetUI(Ui : String) : TExtFunction;
    function SetVisible(Visible : Boolean) : TExtFunction;
    function SetWidth(Width : Integer) : TExtFunction;
    function SetX(The : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetX(The : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetXY(Pos : TArrayOfInteger; Animate : Boolean = false) : TExtFunction; overload;
    function SetXY(Pos : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function SetY(The : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetY(The : Integer; Animate : TExtObject) : TExtFunction; overload;
    function StopAnimation : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function SuspendLayouts : TExtFunction;
    function SyncFx : TExtFunction;
    function TranslatePoints(X : Integer; Y : Integer = 0) : TExtFunction; overload;
    function TranslatePoints(X : TExtObjectList; Y : Integer = 0) : TExtFunction; overload;
    function Up(Selector : TExtComponent) : TExtFunction; overload;
    function Up(Selector : String = '') : TExtFunction; overload;
    function Update(HtmlOrData : TExtObject; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function Update(HtmlOrData : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function UpdateLayout(Comp : TExtComponent; Defer : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property AutoEl : String read FAutoEl write SetFAutoEl;
    property AutoElObject : TExtObject read FAutoElObject write SetFAutoElObject;
    property AutoRender : Boolean read FAutoRender write SetFAutoRender;
    property AutoRenderElement : TExtElement read FAutoRenderElement write SetFAutoRenderElement;
    property AutoRenderString : String read FAutoRenderString write SetFAutoRenderString;
    property AutoRenderTHTMLElement : THTMLElement read FAutoRenderTHTMLElement write SetFAutoRenderTHTMLElement;
    property AutoShow : Boolean read FAutoShow write SetFAutoShow;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Border : Integer read FBorder write SetFBorder;
    property BorderBoolean : Boolean read FBorderBoolean write SetFBorderBoolean;
    property BorderString : String read FBorderString write SetFBorderString;
    property ChildEls : TExtObjectList read FChildEls write SetFChildEls;
    property Cls : String read FCls write SetFCls;
    property ComponentCls : String read FComponentCls write SetFComponentCls;
    property ComponentLayout : String read FComponentLayout write SetFComponentLayout;
    property ComponentLayoutObject : TExtObject read FComponentLayoutObject write SetFComponentLayoutObject;
    property ContentEl : String read FContentEl write SetFContentEl;
    property ContentPaddingProperty : String read FContentPaddingProperty write SetFContentPaddingProperty;
    property Data : TExtObject read FData write SetFData;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property DisabledCls : String read FDisabledCls write SetFDisabledCls;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Floating : Boolean read FFloating write SetFFloating;
    property Frame : Boolean read FFrame write SetFFrame;
    property FrameSize : TExtObject read FFrameSize write SetFFrameSize;
    property FrameSizeBottom : Integer read FFrameSizeBottom write SetFFrameSizeBottom;
    property FrameSizeHeight : Integer read FFrameSizeHeight write SetFFrameSizeHeight;
    property FrameSizeLeft : Integer read FFrameSizeLeft write SetFFrameSizeLeft;
    property FrameSizeRight : Integer read FFrameSizeRight write SetFFrameSizeRight;
    property FrameSizeTop : Integer read FFrameSizeTop write SetFFrameSizeTop;
    property FrameSizeWidth : Integer read FFrameSizeWidth write SetFFrameSizeWidth;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Height : Integer read FHeight write SetFHeight;
    property Hidden : Boolean read FHidden write SetFHidden;
    property HideMode : String read FHideMode write SetFHideMode;
    property Html : String read FHtml write SetFHtml;
    property HtmlObject : TExtObject read FHtmlObject write SetFHtmlObject;
    property Id : String read FId write SetFId;
    property IsComponent : Boolean read FIsComponent write SetFIsComponent;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property ItemId : String read FItemId write SetFItemId;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Loader : TExtComponentLoader read FLoader write SetFLoader;
    property LoaderObject : TExtObject read FLoaderObject write SetFLoaderObject;
    property Margin : Integer read FMargin write SetFMargin;
    property MarginString : String read FMarginString write SetFMarginString;
    property MaskOnDisable : Boolean read FMaskOnDisable write SetFMaskOnDisable;
    property MaxHeight : Integer read FMaxHeight write SetFMaxHeight;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property MinHeight : Integer read FMinHeight write SetFMinHeight;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property OverCls : String read FOverCls write SetFOverCls;
    property OwnerCt : TExtContainer read FOwnerCt write SetFOwnerCt;
    property Padding : Integer read FPadding write SetFPadding;
    property PaddingString : String read FPaddingString write SetFPaddingString;
    property Plugins : TExtObjectList read FPlugins write SetFPlugins;
    property PluginsList : TExtObjectList read FPluginsList write SetFPluginsList;
    property PluginsObject : TExtObject read FPluginsObject write SetFPluginsObject;
    property PluginsPlugin : TExtAbstractPlugin read FPluginsPlugin write SetFPluginsPlugin;
    property RenderData : TExtObject read FRenderData write SetFRenderData;
    property Rendered : Boolean read FRendered write SetFRendered;
    property RenderSelectors : TExtObject read FRenderSelectors write SetFRenderSelectors;
    property RenderTo : String read FRenderTo write SetFRenderTo;
    property RenderToElement : TExtElement read FRenderToElement write SetFRenderToElement;
    property RenderToTHTMLElement : THTMLElement read FRenderToTHTMLElement write SetFRenderToTHTMLElement;
    property SaveDelay : Integer read FSaveDelay write SetFSaveDelay;
    property ScrollFlags : TExtObject read FScrollFlags write SetFScrollFlags;
    property ScrollFlagsBoth : Boolean read FScrollFlagsBoth write SetFScrollFlagsBoth;
    property ScrollFlagsOverflowX : String read FScrollFlagsOverflowX write SetFScrollFlagsOverflowX;
    property ScrollFlagsOverflowY : String read FScrollFlagsOverflowY write SetFScrollFlagsOverflowY;
    property ScrollFlagsX : Boolean read FScrollFlagsX write SetFScrollFlagsX;
    property ScrollFlagsY : Boolean read FScrollFlagsY write SetFScrollFlagsY;
    property ShrinkWrap : Boolean read FShrinkWrap write SetFShrinkWrap;
    property ShrinkWrapInteger : Integer read FShrinkWrapInteger write SetFShrinkWrapInteger;
    property StateEvents : TArrayOfString read FStateEvents write SetFStateEvents;
    property Stateful : Boolean read FStateful write SetFStateful;
    property StateId : String read FStateId write SetFStateId;
    property Style : String read FStyle write SetFStyle;
    property StyleObject : TExtObject read FStyleObject write SetFStyleObject;
    property Tpl : TExtXTemplate read FTpl write SetFTpl;
    property TplString : String read FTplString write SetFTplString;
    property TplTArrayOfString : TArrayOfString read FTplTArrayOfString write SetFTplTArrayOfString;
    property TplTemplate : TExtTemplate read FTplTemplate write SetFTplTemplate;
    property TplWriteMode : String read FTplWriteMode write SetFTplWriteMode;
    property Ui : String read FUi write SetFUi;
    property Width : Integer read FWidth write SetFWidth;
    property Xtype : TExtEnumsWidget read FXtype write SetFXtype;
    property OnActivate : TExtAbstractComponentOnActivate read FOnActivate write SetFOnActivate;
    property OnAdded : TExtAbstractComponentOnAdded read FOnAdded write SetFOnAdded;
    property OnAfterrender : TExtAbstractComponentOnAfterrender read FOnAfterrender write SetFOnAfterrender;
    property OnBeforeactivate : TExtAbstractComponentOnBeforeactivate read FOnBeforeactivate write SetFOnBeforeactivate;
    property OnBeforedeactivate : TExtAbstractComponentOnBeforedeactivate read FOnBeforedeactivate write SetFOnBeforedeactivate;
    property OnBeforedestroy : TExtAbstractComponentOnBeforedestroy read FOnBeforedestroy write SetFOnBeforedestroy;
    property OnBeforehide : TExtAbstractComponentOnBeforehide read FOnBeforehide write SetFOnBeforehide;
    property OnBeforerender : TExtAbstractComponentOnBeforerender read FOnBeforerender write SetFOnBeforerender;
    property OnBeforeshow : TExtAbstractComponentOnBeforeshow read FOnBeforeshow write SetFOnBeforeshow;
    property OnBeforestaterestore : TExtAbstractComponentOnBeforestaterestore read FOnBeforestaterestore write SetFOnBeforestaterestore;
    property OnBeforestatesave : TExtAbstractComponentOnBeforestatesave read FOnBeforestatesave write SetFOnBeforestatesave;
    property OnBlur : TExtAbstractComponentOnBlur read FOnBlur write SetFOnBlur;
    property OnBoxready : TExtAbstractComponentOnBoxready read FOnBoxready write SetFOnBoxready;
    property OnDeactivate : TExtAbstractComponentOnDeactivate read FOnDeactivate write SetFOnDeactivate;
    property OnDestroy : TExtAbstractComponentOnDestroy read FOnDestroy write SetFOnDestroy;
    property OnDisable : TExtAbstractComponentOnDisable read FOnDisable write SetFOnDisable;
    property OnEnable : TExtAbstractComponentOnEnable read FOnEnable write SetFOnEnable;
    property OnFocus : TExtAbstractComponentOnFocus read FOnFocus write SetFOnFocus;
    property OnHide : TExtAbstractComponentOnHide read FOnHide write SetFOnHide;
    property OnMove : TExtAbstractComponentOnMove read FOnMove write SetFOnMove;
    property OnRemoved : TExtAbstractComponentOnRemoved read FOnRemoved write SetFOnRemoved;
    property OnRender : TExtAbstractComponentOnRender read FOnRender write SetFOnRender;
    property OnResize : TExtAbstractComponentOnResize read FOnResize write SetFOnResize;
    property OnShow : TExtAbstractComponentOnShow read FOnShow write SetFOnShow;
    property OnStaterestore : TExtAbstractComponentOnStaterestore read FOnStaterestore write SetFOnStaterestore;
    property OnStatesave : TExtAbstractComponentOnStatesave read FOnStatesave write SetFOnStatesave;
  end;

  TExtViewNodeCache = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear(RemoveDom : Boolean = false) : TExtFunction;
    function Fill(Els : TExtObjectList) : TExtFunction;
    function IndexOf(El : THTMLElement) : TExtFunction; overload;
    function IndexOf(El : TExtElement) : TExtFunction; overload;
    function IndexOf(El : String) : TExtFunction; overload;
    function IndexOf(El : Integer) : TExtFunction; overload;
    function RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function Scroll(NewRecords : TExtObjectList; Direction : Integer; RemoveCount : Integer) : TExtFunction;
  end;

  TExtFxTarget = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Target : TExtElement); overload;
    constructor Create(Target : TExtDrawSprite); overload;
    constructor Create(Target : TExtComponent); overload;
  end;

  TExtFxQueue = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridLockingLockable
  TExtGridLockingLockableOnFilterchange = procedure of object;
  TExtGridLockingLockableOnLockcolumn = procedure(This : TExtGridLockingLockable; Column : TExtGridColumn) of object;
  TExtGridLockingLockableOnProcesscolumns = procedure(LockedColumns : TExtObjectList; NormalColumns : TExtObjectList) of object;
  TExtGridLockingLockableOnUnlockcolumn = procedure(This : TExtGridLockingLockable; Column : TExtGridColumn) of object;

  TExtGridLockingLockable = class(TExtAbstractComponent)
  private
    FLockedGridConfig : TExtObject;
    FLockedViewConfig : TExtObject;
    FNormalGridConfig : TExtObject;
    FNormalViewConfig : TExtObject;
    FScrollDelta : Integer;
    FSubGridXType : String;
    FSyncRowHeight : Boolean;
    FOnFilterchange : TExtGridLockingLockableOnFilterchange;
    FOnLockcolumn : TExtGridLockingLockableOnLockcolumn;
    FOnProcesscolumns : TExtGridLockingLockableOnProcesscolumns;
    FOnUnlockcolumn : TExtGridLockingLockableOnUnlockcolumn;
    procedure SetFLockedGridConfig(Value : TExtObject);
    procedure SetFLockedViewConfig(Value : TExtObject);
    procedure SetFNormalGridConfig(Value : TExtObject);
    procedure SetFNormalViewConfig(Value : TExtObject);
    procedure SetFScrollDelta(Value : Integer);
    procedure SetFSubGridXType(Value : String);
    procedure SetFSyncRowHeight(Value : Boolean);
    procedure SetFOnFilterchange(Value : TExtGridLockingLockableOnFilterchange);
    procedure SetFOnLockcolumn(Value : TExtGridLockingLockableOnLockcolumn);
    procedure SetFOnProcesscolumns(Value : TExtGridLockingLockableOnProcesscolumns);
    procedure SetFOnUnlockcolumn(Value : TExtGridLockingLockableOnUnlockcolumn);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SyncRowHeights : TExtFunction;
    destructor Destroy; override;
    property LockedGridConfig : TExtObject read FLockedGridConfig write SetFLockedGridConfig;
    property LockedViewConfig : TExtObject read FLockedViewConfig write SetFLockedViewConfig;
    property NormalGridConfig : TExtObject read FNormalGridConfig write SetFNormalGridConfig;
    property NormalViewConfig : TExtObject read FNormalViewConfig write SetFNormalViewConfig;
    property ScrollDelta : Integer read FScrollDelta write SetFScrollDelta;
    property SubGridXType : String read FSubGridXType write SetFSubGridXType;
    property SyncRowHeight : Boolean read FSyncRowHeight write SetFSyncRowHeight;
    property OnFilterchange : TExtGridLockingLockableOnFilterchange read FOnFilterchange write SetFOnFilterchange;
    property OnLockcolumn : TExtGridLockingLockableOnLockcolumn read FOnLockcolumn write SetFOnLockcolumn;
    property OnProcesscolumns : TExtGridLockingLockableOnProcesscolumns read FOnProcesscolumns write SetFOnProcesscolumns;
    property OnUnlockcolumn : TExtGridLockingLockableOnUnlockcolumn read FOnUnlockcolumn write SetFOnUnlockcolumn;
  end;

  TExtGridLockingView = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsLockingView : Boolean;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsLockingView(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsLockingView : Boolean read FIsLockingView write SetFIsLockingView;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
  end;

  TExtGridPluginBufferedRendererTableView = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilTextMetrics = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Bind(El : THTMLElement) : TExtFunction; overload;
    function Bind(El : TExtElement) : TExtFunction; overload;
    function Bind(El : String) : TExtFunction; overload;
    constructor Create(BindTo : THTMLElement; FixedWidth : Integer = 0); overload;
    constructor Create(BindTo : TExtElement; FixedWidth : Integer = 0); overload;
    constructor Create(BindTo : String; FixedWidth : Integer = 0); overload;
    function GetHeight(Text : String) : TExtFunction;
    function GetSize(Text : String) : TExtFunction;
    function GetTextWidth(Text : String; Min : Integer = 0; Max : Integer = 0) : TExtFunction;
    function GetWidth(Text : String) : TExtFunction;
    function Measure(El : THTMLElement; Text : String; FixedWidth : Integer = 0) : TExtFunction; overload;
    function Measure(El : String; Text : String; FixedWidth : Integer = 0) : TExtFunction; overload;
    function SetFixedWidth(Width : Integer) : TExtFunction;
  end;

  // Procedural types for events TExtFxAnim
  TExtFxAnimOnAfteranimate = procedure(This : TExtFxAnim; StartTime : TDateTime) of object;
  TExtFxAnimOnBeforeanimate = procedure(This : TExtFxAnim) of object;
  TExtFxAnimOnLastframe = procedure(This : TExtFxAnim; StartTime : TDateTime) of object;

  TExtFxAnim = class(TExtAbstractComponent)
  private
    FAlternate : Boolean;
    FCallback : TExtFunction;
    FDelay : Integer;
    FDuration : Integer;
    FDynamic : Boolean;
    FEasing : String;
    FFrom : TExtObject;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsAnimation : Boolean;
    FIsObservable : Boolean;
    FIterations : Integer;
    FKeyframes : TExtObject;
    FListeners : TExtObject;
    FReverse : Boolean;
    FScope : TExtFunction;
    FTarget : String;
    FTargetObject : TExtObject;
    FToJS : TExtObject;
    FOnAfteranimate : TExtFxAnimOnAfteranimate;
    FOnBeforeanimate : TExtFxAnimOnBeforeanimate;
    FOnLastframe : TExtFxAnimOnLastframe;
    procedure SetFAlternate(Value : Boolean);
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFDelay(Value : Integer);
    procedure SetFDuration(Value : Integer);
    procedure SetFDynamic(Value : Boolean);
    procedure SetFEasing(Value : String);
    procedure SetFFrom(Value : TExtObject);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsAnimation(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIterations(Value : Integer);
    procedure SetFKeyframes(Value : TExtObject);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFReverse(Value : Boolean);
    procedure SetFScope(Value : TExtFunction);
    procedure SetFTarget(Value : String);
    procedure SetFTargetObject(Value : TExtObject);
    procedure SetFToJS(Value : TExtObject);
    procedure SetFOnAfteranimate(Value : TExtFxAnimOnAfteranimate);
    procedure SetFOnBeforeanimate(Value : TExtFxAnimOnBeforeanimate);
    procedure SetFOnLastframe(Value : TExtFxAnimOnLastframe);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EndJS : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Alternate : Boolean read FAlternate write SetFAlternate;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property Delay : Integer read FDelay write SetFDelay;
    property Duration : Integer read FDuration write SetFDuration;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property Easing : String read FEasing write SetFEasing;
    property From : TExtObject read FFrom write SetFFrom;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsAnimation : Boolean read FIsAnimation write SetFIsAnimation;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Iterations : Integer read FIterations write SetFIterations;
    property Keyframes : TExtObject read FKeyframes write SetFKeyframes;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Reverse : Boolean read FReverse write SetFReverse;
    property Scope : TExtFunction read FScope write SetFScope;
    property Target : String read FTarget write SetFTarget;
    property TargetObject : TExtObject read FTargetObject write SetFTargetObject;
    property ToJS : TExtObject read FToJS write SetFToJS;
    property OnAfteranimate : TExtFxAnimOnAfteranimate read FOnAfteranimate write SetFOnAfteranimate;
    property OnBeforeanimate : TExtFxAnimOnBeforeanimate read FOnBeforeanimate write SetFOnBeforeanimate;
    property OnLastframe : TExtFxAnimOnLastframe read FOnLastframe write SetFOnLastframe;
  end;

  // Procedural types for events TExtFxAnimator
  TExtFxAnimatorOnAfteranimate = procedure(This : TExtFxAnimator; StartTime : TDateTime) of object;
  TExtFxAnimatorOnBeforeanimate = procedure(This : TExtFxAnimator) of object;
  TExtFxAnimatorOnKeyframe = procedure(This : TExtFxAnimator; Keyframe : Integer) of object;

  TExtFxAnimator = class(TExtAbstractComponent)
  private
    FDelay : Integer; // 0
    FDuration : Integer; // 250
    FDynamic : Boolean;
    FEasing : String;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsAnimator : Boolean;
    FIsObservable : Boolean;
    FIterations : Integer; // 1
    FKeyframes : TExtObject;
    FListeners : TExtObject;
    FTarget : TExtFxTarget;
    FOnAfteranimate : TExtFxAnimatorOnAfteranimate;
    FOnBeforeanimate : TExtFxAnimatorOnBeforeanimate;
    FOnKeyframe : TExtFxAnimatorOnKeyframe;
    procedure SetFDelay(Value : Integer);
    procedure SetFDuration(Value : Integer);
    procedure SetFDynamic(Value : Boolean);
    procedure SetFEasing(Value : String);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsAnimator(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIterations(Value : Integer);
    procedure SetFKeyframes(Value : TExtObject);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFTarget(Value : TExtFxTarget);
    procedure SetFOnAfteranimate(Value : TExtFxAnimatorOnAfteranimate);
    procedure SetFOnBeforeanimate(Value : TExtFxAnimatorOnBeforeanimate);
    procedure SetFOnKeyframe(Value : TExtFxAnimatorOnKeyframe);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EndJS : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Delay : Integer read FDelay write SetFDelay;
    property Duration : Integer read FDuration write SetFDuration;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property Easing : String read FEasing write SetFEasing;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsAnimator : Boolean read FIsAnimator write SetFIsAnimator;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Iterations : Integer read FIterations write SetFIterations;
    property Keyframes : TExtObject read FKeyframes write SetFKeyframes;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Target : TExtFxTarget read FTarget write SetFTarget;
    property OnAfteranimate : TExtFxAnimatorOnAfteranimate read FOnAfteranimate write SetFOnAfteranimate;
    property OnBeforeanimate : TExtFxAnimatorOnBeforeanimate read FOnBeforeanimate write SetFOnBeforeanimate;
    property OnKeyframe : TExtFxAnimatorOnKeyframe read FOnKeyframe write SetFOnKeyframe;
  end;

  TExtFormFieldVTypesSingleton = class(TExtAbstractComponent)
  private
    FAlphanumText : String; // 'This field should only contain letters, numbers and _'
    FAlphaText : String; // 'This field should only contain letters and _'
    FEmailMask : TRegExp;
    FEmailText : String; // 'This field should be an e-mail address in the format'
    FUrlText : String; // 'This field should be a URL in the format'
    procedure SetFAlphanumText(Value : String);
    procedure SetFAlphaText(Value : String);
    procedure SetFEmailMask(Value : TRegExp);
    procedure SetFEmailText(Value : String);
    procedure SetFUrlText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Alpha(Value : String) : TExtFunction;
    function Alphanum(Value : String) : TExtFunction;
    function Email(Value : String) : TExtFunction;
    function Url(Value : String) : TExtFunction;
    property AlphanumText : String read FAlphanumText write SetFAlphanumText;
    property AlphaText : String read FAlphaText write SetFAlphaText;
    property EmailMask : TRegExp read FEmailMask write SetFEmailMask;
    property EmailText : String read FEmailText write SetFEmailText;
    property UrlText : String read FUrlText write SetFUrlText;
  end;

  // Procedural types for events TExtFormLabelable
  TExtFormLabelableOnErrorchange = procedure(This : TExtFormLabelable; Error : String) of object;

  // Enumerated types for properties
  TLabelAlignEnum = (laLeft, laTop, laRight);

  TExtFormLabelable = class(TExtAbstractComponent)
  private
    FActiveError : String;
    FActiveErrorsTpl : String;
    FActiveErrorsTplTArrayOfString : TArrayOfString;
    FActiveErrorsTplTemplate : TExtXTemplate;
    FAfterBodyEl : String;
    FAfterBodyElList : TExtObjectList;
    FAfterBodyElTemplate : TExtXTemplate;
    FAfterLabelTextTpl : String;
    FAfterLabelTextTplList : TExtObjectList;
    FAfterLabelTextTplTemplate : TExtXTemplate;
    FAfterLabelTpl : String;
    FAfterLabelTplList : TExtObjectList;
    FAfterLabelTplTemplate : TExtXTemplate;
    FAfterSubTpl : String;
    FAfterSubTplList : TExtObjectList;
    FAfterSubTplTemplate : TExtXTemplate;
    FAutoFitErrors : Boolean;
    FBaseBodyCls : String;
    FBeforeBodyEl : String;
    FBeforeBodyElList : TExtObjectList;
    FBeforeBodyElTemplate : TExtXTemplate;
    FBeforeLabelTextTpl : String;
    FBeforeLabelTextTplList : TExtObjectList;
    FBeforeLabelTextTplTemplate : TExtXTemplate;
    FBeforeLabelTpl : String;
    FBeforeLabelTplList : TExtObjectList;
    FBeforeLabelTplTemplate : TExtXTemplate;
    FBeforeSubTpl : String;
    FBeforeSubTplList : TExtObjectList;
    FBeforeSubTplTemplate : TExtXTemplate;
    FBodyEl : TExtElement;
    FClearCls : String;
    FErrorEl : TExtElement;
    FErrorMsgCls : String;
    FFieldBodyCls : String;
    FFieldLabel : String;
    FFormItemCls : String;
    FHideEmptyLabel : Boolean;
    FHideLabel : Boolean;
    FInvalidCls : String;
    FIsFieldLabelable : Boolean;
    FLabelAlign : TLabelAlignEnum;
    FLabelAttrTpl : String;
    FLabelAttrTplList : TExtObjectList;
    FLabelAttrTplTemplate : TExtXTemplate;
    FLabelCell : TExtElement;
    FLabelCls : String;
    FLabelClsExtra : String;
    FLabelEl : TExtElement;
    FLabelPad : Integer;
    FLabelSeparator : String;
    FLabelStyle : String;
    FLabelWidth : Integer;
    FMsgTarget : String;
    FPreventMark : Boolean;
    FOnErrorchange : TExtFormLabelableOnErrorchange;
    procedure SetFActiveError(Value : String);
    procedure SetFActiveErrorsTpl(Value : String);
    procedure SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString);
    procedure SetFActiveErrorsTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterBodyEl(Value : String);
    procedure SetFAfterBodyElList(Value : TExtObjectList);
    procedure SetFAfterBodyElTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTextTpl(Value : String);
    procedure SetFAfterLabelTextTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTpl(Value : String);
    procedure SetFAfterLabelTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterSubTpl(Value : String);
    procedure SetFAfterSubTplList(Value : TExtObjectList);
    procedure SetFAfterSubTplTemplate(Value : TExtXTemplate);
    procedure SetFAutoFitErrors(Value : Boolean);
    procedure SetFBaseBodyCls(Value : String);
    procedure SetFBeforeBodyEl(Value : String);
    procedure SetFBeforeBodyElList(Value : TExtObjectList);
    procedure SetFBeforeBodyElTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTextTpl(Value : String);
    procedure SetFBeforeLabelTextTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTpl(Value : String);
    procedure SetFBeforeLabelTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeSubTpl(Value : String);
    procedure SetFBeforeSubTplList(Value : TExtObjectList);
    procedure SetFBeforeSubTplTemplate(Value : TExtXTemplate);
    procedure SetFBodyEl(Value : TExtElement);
    procedure SetFClearCls(Value : String);
    procedure SetFErrorEl(Value : TExtElement);
    procedure SetFErrorMsgCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFFieldLabel(Value : String);
    procedure SetFFormItemCls(Value : String);
    procedure SetFHideEmptyLabel(Value : Boolean);
    procedure SetFHideLabel(Value : Boolean);
    procedure SetFInvalidCls(Value : String);
    procedure SetFIsFieldLabelable(Value : Boolean);
    procedure SetFLabelAlign(Value : TLabelAlignEnum);
    procedure SetFLabelAttrTpl(Value : String);
    procedure SetFLabelAttrTplList(Value : TExtObjectList);
    procedure SetFLabelAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFLabelCell(Value : TExtElement);
    procedure SetFLabelCls(Value : String);
    procedure SetFLabelClsExtra(Value : String);
    procedure SetFLabelEl(Value : TExtElement);
    procedure SetFLabelPad(Value : Integer);
    procedure SetFLabelSeparator(Value : String);
    procedure SetFLabelStyle(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFMsgTarget(Value : String);
    procedure SetFPreventMark(Value : Boolean);
    procedure SetFOnErrorchange(Value : TExtFormLabelableOnErrorchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetActiveError : TExtFunction;
    function GetActiveErrors : TExtFunction;
    function GetInputId : TExtFunction;
    function GetLabelWidth : TExtFunction;
    function HasActiveError : TExtFunction;
    function HasVisibleLabel : TExtFunction;
    function InitLabelable : TExtFunction;
    function SetActiveError(Msg : String) : TExtFunction;
    function SetActiveErrors(Errors : TArrayOfString) : TExtFunction;
    function SetFieldDefaults(Defaults : TExtObject) : TExtFunction;
    function SetFieldLabel(LabelJS : String) : TExtFunction;
    function TrimLabelSeparator : TExtFunction;
    function UnsetActiveError : TExtFunction;
    destructor Destroy; override;
    property ActiveError : String read FActiveError write SetFActiveError;
    property ActiveErrorsTpl : String read FActiveErrorsTpl write SetFActiveErrorsTpl;
    property ActiveErrorsTplTArrayOfString : TArrayOfString read FActiveErrorsTplTArrayOfString write SetFActiveErrorsTplTArrayOfString;
    property ActiveErrorsTplTemplate : TExtXTemplate read FActiveErrorsTplTemplate write SetFActiveErrorsTplTemplate;
    property AfterBodyEl : String read FAfterBodyEl write SetFAfterBodyEl;
    property AfterBodyElList : TExtObjectList read FAfterBodyElList write SetFAfterBodyElList;
    property AfterBodyElTemplate : TExtXTemplate read FAfterBodyElTemplate write SetFAfterBodyElTemplate;
    property AfterLabelTextTpl : String read FAfterLabelTextTpl write SetFAfterLabelTextTpl;
    property AfterLabelTextTplList : TExtObjectList read FAfterLabelTextTplList write SetFAfterLabelTextTplList;
    property AfterLabelTextTplTemplate : TExtXTemplate read FAfterLabelTextTplTemplate write SetFAfterLabelTextTplTemplate;
    property AfterLabelTpl : String read FAfterLabelTpl write SetFAfterLabelTpl;
    property AfterLabelTplList : TExtObjectList read FAfterLabelTplList write SetFAfterLabelTplList;
    property AfterLabelTplTemplate : TExtXTemplate read FAfterLabelTplTemplate write SetFAfterLabelTplTemplate;
    property AfterSubTpl : String read FAfterSubTpl write SetFAfterSubTpl;
    property AfterSubTplList : TExtObjectList read FAfterSubTplList write SetFAfterSubTplList;
    property AfterSubTplTemplate : TExtXTemplate read FAfterSubTplTemplate write SetFAfterSubTplTemplate;
    property AutoFitErrors : Boolean read FAutoFitErrors write SetFAutoFitErrors;
    property BaseBodyCls : String read FBaseBodyCls write SetFBaseBodyCls;
    property BeforeBodyEl : String read FBeforeBodyEl write SetFBeforeBodyEl;
    property BeforeBodyElList : TExtObjectList read FBeforeBodyElList write SetFBeforeBodyElList;
    property BeforeBodyElTemplate : TExtXTemplate read FBeforeBodyElTemplate write SetFBeforeBodyElTemplate;
    property BeforeLabelTextTpl : String read FBeforeLabelTextTpl write SetFBeforeLabelTextTpl;
    property BeforeLabelTextTplList : TExtObjectList read FBeforeLabelTextTplList write SetFBeforeLabelTextTplList;
    property BeforeLabelTextTplTemplate : TExtXTemplate read FBeforeLabelTextTplTemplate write SetFBeforeLabelTextTplTemplate;
    property BeforeLabelTpl : String read FBeforeLabelTpl write SetFBeforeLabelTpl;
    property BeforeLabelTplList : TExtObjectList read FBeforeLabelTplList write SetFBeforeLabelTplList;
    property BeforeLabelTplTemplate : TExtXTemplate read FBeforeLabelTplTemplate write SetFBeforeLabelTplTemplate;
    property BeforeSubTpl : String read FBeforeSubTpl write SetFBeforeSubTpl;
    property BeforeSubTplList : TExtObjectList read FBeforeSubTplList write SetFBeforeSubTplList;
    property BeforeSubTplTemplate : TExtXTemplate read FBeforeSubTplTemplate write SetFBeforeSubTplTemplate;
    property BodyEl : TExtElement read FBodyEl write SetFBodyEl;
    property ClearCls : String read FClearCls write SetFClearCls;
    property ErrorEl : TExtElement read FErrorEl write SetFErrorEl;
    property ErrorMsgCls : String read FErrorMsgCls write SetFErrorMsgCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property FieldLabel : String read FFieldLabel write SetFFieldLabel;
    property FormItemCls : String read FFormItemCls write SetFFormItemCls;
    property HideEmptyLabel : Boolean read FHideEmptyLabel write SetFHideEmptyLabel;
    property HideLabel : Boolean read FHideLabel write SetFHideLabel;
    property InvalidCls : String read FInvalidCls write SetFInvalidCls;
    property IsFieldLabelable : Boolean read FIsFieldLabelable write SetFIsFieldLabelable;
    property LabelAlign : TLabelAlignEnum read FLabelAlign write SetFLabelAlign;
    property LabelAttrTpl : String read FLabelAttrTpl write SetFLabelAttrTpl;
    property LabelAttrTplList : TExtObjectList read FLabelAttrTplList write SetFLabelAttrTplList;
    property LabelAttrTplTemplate : TExtXTemplate read FLabelAttrTplTemplate write SetFLabelAttrTplTemplate;
    property LabelCell : TExtElement read FLabelCell write SetFLabelCell;
    property LabelCls : String read FLabelCls write SetFLabelCls;
    property LabelClsExtra : String read FLabelClsExtra write SetFLabelClsExtra;
    property LabelEl : TExtElement read FLabelEl write SetFLabelEl;
    property LabelPad : Integer read FLabelPad write SetFLabelPad;
    property LabelSeparator : String read FLabelSeparator write SetFLabelSeparator;
    property LabelStyle : String read FLabelStyle write SetFLabelStyle;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property MsgTarget : String read FMsgTarget write SetFMsgTarget;
    property PreventMark : Boolean read FPreventMark write SetFPreventMark;
    property OnErrorchange : TExtFormLabelableOnErrorchange read FOnErrorchange write SetFOnErrorchange;
  end;

  TExtFxManagerSingleton = class(TExtAbstractComponent)
  private
    FInterval : Integer; // 16
    procedure SetFInterval(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddAnim(Anim : TExtFxAnim) : TExtFunction;
    function RemoveAnim(Anim : TExtFxAnim) : TExtFunction;
    property Interval : Integer read FInterval write SetFInterval;
  end;

  TExtFxPropertyHandler = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxCubicBezierSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxEasingSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPluginBufferedRendererTreeView = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContextItem = class(TExtAbstractComponent)
  private
    FState : TExtObject;
    FWrapsComponent : Boolean;
    procedure SetFState(Value : TExtObject);
    procedure SetFWrapsComponent(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddCls : TExtFunction;
    function Block(Layout : TExtLayout; PropName : String) : TExtFunction;
    function ClearMarginCache : TExtFunction;
    constructor Create;
    function DomBlock(Layout : TExtLayout; PropName : String) : TExtFunction;
    function Flush : TExtFunction;
    function GetBorderInfo : TExtFunction;
    function GetClassList : TExtFunction;
    function GetDomProp(PropName : String) : TExtFunction;
    function GetEl(NameOrEl : String; Owner : TExtLayoutContainer) : TExtFunction; overload;
    function GetEl(NameOrEl : TExtDomElement; Owner : TExtLayoutContainer) : TExtFunction; overload;
    function GetEl(NameOrEl : TExtDomElement; Owner : TExtComponent = nil) : TExtFunction; overload;
    function GetEl(NameOrEl : String; Owner : TExtComponent = nil) : TExtFunction; overload;
    function GetFrameInfo : TExtFunction;
    function GetMarginInfo : TExtFunction;
    function GetPaddingInfo : TExtFunction;
    function GetProp(PropName : String) : TExtFunction;
    function GetStyle(StyleName : String) : TExtFunction;
    function GetStyles(StyleNames : TArrayOfString; AltNames : TArrayOfString = nil) : TExtFunction;
    function HasDomProp(PropName : String) : TExtFunction;
    function HasProp(PropName : String) : TExtFunction;
    function Invalidate(Options : TExtObject) : TExtFunction;
    function RecoverProp(PropName : String; OldProps : TExtObject; OldDirty : TExtObject) : TExtFunction;
    function RemoveCls : TExtFunction;
    function RemoveEl(NameOrEl : String; Owner : TExtLayoutContainer) : TExtFunction; overload;
    function RemoveEl(NameOrEl : TExtDomElement; Owner : TExtLayoutContainer) : TExtFunction; overload;
    function RemoveEl(NameOrEl : TExtDomElement; Owner : TExtComponent = nil) : TExtFunction; overload;
    function RemoveEl(NameOrEl : String; Owner : TExtComponent = nil) : TExtFunction; overload;
    function SetAttribute : TExtFunction;
    function SetContentHeight : TExtFunction;
    function SetContentSize : TExtFunction;
    function SetContentWidth : TExtFunction;
    function SetHeight(Height : Integer; Dirty : Boolean = false) : TExtFunction;
    function SetProp(PropName : String; Value : TExtObject; Dirty : Boolean) : TExtFunction;
    function SetWidth(Width : Integer; Dirty : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property State : TExtObject read FState write SetFState;
    property WrapsComponent : Boolean read FWrapsComponent write SetFWrapsComponent;
  end;

  TExtLayoutSizeModel = class(TExtAbstractComponent)
  private
    FAuto : Boolean;
    FCalculated : Boolean;
    FCalculatedFromConfigured : Boolean;
    FCalculatedFromNatural : Boolean;
    FCalculatedFromShrinkWrap : Boolean;
    FConfigured : Boolean;
    FConstrainedMax : Boolean;
    FConstrainedMin : Boolean;
    FFixed : Boolean;
    FName : String;
    FNames : TExtObject;
    FNamesHeight : String;
    FNamesWidth : String;
    FNatural : Boolean;
    FOrdinal : Integer;
    FPairsByHeightOrdinal : TExtObjectList;
    FPairsByHeightOrdinalHeight : TExtLayoutSizeModel;
    FPairsByHeightOrdinalWidth : TExtLayoutSizeModel;
    FShrinkWrap : Boolean;
    procedure SetFAuto(Value : Boolean);
    procedure SetFCalculated(Value : Boolean);
    procedure SetFCalculatedFromConfigured(Value : Boolean);
    procedure SetFCalculatedFromNatural(Value : Boolean);
    procedure SetFCalculatedFromShrinkWrap(Value : Boolean);
    procedure SetFConfigured(Value : Boolean);
    procedure SetFConstrainedMax(Value : Boolean);
    procedure SetFConstrainedMin(Value : Boolean);
    procedure SetFFixed(Value : Boolean);
    procedure SetFName(Value : String);
    procedure SetFNames(Value : TExtObject);
    procedure SetFNamesHeight(Value : String);
    procedure SetFNamesWidth(Value : String);
    procedure SetFNatural(Value : Boolean);
    procedure SetFOrdinal(Value : Integer);
    procedure SetFPairsByHeightOrdinal(Value : TExtObjectList);
    procedure SetFPairsByHeightOrdinalHeight(Value : TExtLayoutSizeModel);
    procedure SetFPairsByHeightOrdinalWidth(Value : TExtLayoutSizeModel);
    procedure SetFShrinkWrap(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Auto : Boolean read FAuto write SetFAuto;
    property Calculated : Boolean read FCalculated write SetFCalculated;
    property CalculatedFromConfigured : Boolean read FCalculatedFromConfigured write SetFCalculatedFromConfigured;
    property CalculatedFromNatural : Boolean read FCalculatedFromNatural write SetFCalculatedFromNatural;
    property CalculatedFromShrinkWrap : Boolean read FCalculatedFromShrinkWrap write SetFCalculatedFromShrinkWrap;
    property Configured : Boolean read FConfigured write SetFConfigured;
    property ConstrainedMax : Boolean read FConstrainedMax write SetFConstrainedMax;
    property ConstrainedMin : Boolean read FConstrainedMin write SetFConstrainedMin;
    property Fixed : Boolean read FFixed write SetFFixed;
    property Name : String read FName write SetFName;
    property Names : TExtObject read FNames write SetFNames;
    property NamesHeight : String read FNamesHeight write SetFNamesHeight;
    property NamesWidth : String read FNamesWidth write SetFNamesWidth;
    property Natural : Boolean read FNatural write SetFNatural;
    property Ordinal : Integer read FOrdinal write SetFOrdinal;
    property PairsByHeightOrdinal : TExtObjectList read FPairsByHeightOrdinal write SetFPairsByHeightOrdinal;
    property PairsByHeightOrdinalHeight : TExtLayoutSizeModel read FPairsByHeightOrdinalHeight write SetFPairsByHeightOrdinalHeight;
    property PairsByHeightOrdinalWidth : TExtLayoutSizeModel read FPairsByHeightOrdinalWidth write SetFPairsByHeightOrdinalWidth;
    property ShrinkWrap : Boolean read FShrinkWrap write SetFShrinkWrap;
  end;

  TExtUtilQueue = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear : TExtFunction;
    function GetCount : TExtFunction;
    function Remove(Obj : TExtObject) : TExtFunction;
  end;

  TExtLayoutContainerBoxOverflowNone = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtMenuManagerSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Get(Menu : TExtObject) : TExtFunction; overload;
    function Get(Menu : String) : TExtFunction; overload;
    function HideAll : TExtFunction;
  end;

  TExtUtilOffset = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilProtoElement = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddCls(Cls : String) : TExtFunction;
    function Flush : TExtFunction;
    function HasCls(Cls : String) : TExtFunction;
    function RemoveCls(Cls : String) : TExtFunction;
    function SetStyle(Prop : TExtObject; Value : String = '') : TExtFunction; overload;
    function SetStyle(Prop : String; Value : String = '') : TExtFunction; overload;
    function WriteTo(ToJS : TExtObject) : TExtFunction;
  end;

  TExtUtilPositionable = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AlignTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AlignTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AlignTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function AlignTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function AnchorTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : TExtElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function CalculateConstrainedPosition(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAlignToXY(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAlignToXY(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAlignToXY(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetAnchorXY(Anchor : String = ''; Local : Boolean = false; Size : TExtObject = nil) : TExtFunction;
    function GetBox(ContentBox : Boolean = false; Local : Boolean = false) : TExtFunction;
    function GetConstrainVector(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : TExtUtilPositionable; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetConstrainVector(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; overload;
    function GetLocalX : TExtFunction;
    function GetLocalXY : TExtFunction;
    function GetLocalY : TExtFunction;
    function GetOffsetsTo(OffsetsTo : THTMLElement) : TExtFunction; overload;
    function GetOffsetsTo(OffsetsTo : TExtUtilPositionable) : TExtFunction; overload;
    function GetOffsetsTo(OffsetsTo : String) : TExtFunction; overload;
    function GetRegion : TExtFunction;
    function GetViewRegion : TExtFunction;
    function GetX : TExtFunction;
    function GetXY : TExtFunction;
    function GetY : TExtFunction;
    function Move(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; overload;
    function Move(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function RemoveAnchor : TExtFunction;
    function SetBox(Box : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function SetBox(Box : TExtObject; Animate : Boolean = false) : TExtFunction; overload;
    function SetLocalX(X : Integer) : TExtFunction;
    function SetLocalXY(X : TExtObjectList; Y : Integer = 0) : TExtFunction; overload;
    function SetLocalXY(X : Integer; Y : Integer = 0) : TExtFunction; overload;
    function SetLocalY(Y : Integer) : TExtFunction;
    function SetRegion(Region : TExtUtilRegion; Animate : TExtObject) : TExtFunction; overload;
    function SetRegion(Region : TExtUtilRegion; Animate : Boolean = false) : TExtFunction; overload;
    function SetX(The : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetX(The : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetXY(Pos : TArrayOfInteger; Animate : TExtObject) : TExtFunction; overload;
    function SetXY(Pos : TArrayOfInteger; Animate : Boolean = false) : TExtFunction; overload;
    function SetY(The : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetY(The : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function TranslatePoints(X : TExtObjectList; Y : Integer = 0) : TExtFunction; overload;
    function TranslatePoints(X : Integer; Y : Integer = 0) : TExtFunction; overload;
  end;

  TExtGridScroller = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilSortable = class(TExtAbstractComponent)
  private
    FDefaultSortDirection : String;
    FIsSortable : Boolean;
    FSorters : TExtObjectList;
    FSortersList : TExtObjectList;
    FSortRoot : String;
    procedure SetFDefaultSortDirection(Value : String);
    procedure SetFIsSortable(Value : Boolean);
    procedure SetFSorters(Value : TExtObjectList);
    procedure SetFSortersList(Value : TExtObjectList);
    procedure SetFSortRoot(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function CreateComparator(Sorters : TExtObjectList) : TExtFunction;
    function GenerateComparator : TExtFunction;
    function InitSortable : TExtFunction;
    function Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; overload;
    function Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; overload;
    destructor Destroy; override;
    property DefaultSortDirection : String read FDefaultSortDirection write SetFDefaultSortDirection;
    property IsSortable : Boolean read FIsSortable write SetFIsSortable;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
    property SortersList : TExtObjectList read FSortersList write SetFSortersList;
    property SortRoot : String read FSortRoot write SetFSortRoot;
  end;

  TExtUtilTaskRunner = class(TExtAbstractComponent)
  private
    FFireIdleEvent : Boolean;
    procedure SetFFireIdleEvent(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function NewTask(Config : TExtObject) : TExtFunction;
    function Restart(Interval : Integer = 0) : TExtFunction;
    function Start(Task : TExtObject) : TExtFunction;
    function Stop(Task : TExtObject) : TExtFunction;
    function StopAll : TExtFunction;
    property FireIdleEvent : Boolean read FFireIdleEvent write SetFFireIdleEvent;
  end;

  TExtUtilSorter = class(TExtAbstractComponent)
  private
    FDirection : String;
    FPropertyJS : String;
    FRoot : String;
    FSorterFn : TExtFunction;
    FTransform : TExtFunction;
    procedure SetFDirection(Value : String);
    procedure SetFPropertyJS(Value : String);
    procedure SetFRoot(Value : String);
    procedure SetFSorterFn(Value : TExtFunction);
    procedure SetFTransform(Value : TExtFunction);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetDirection(Direction : String) : TExtFunction;
    function Toggle : TExtFunction;
    function UpdateSortFunction(Fn : TExtFunction = nil) : TExtFunction;
    property Direction : String read FDirection write SetFDirection;
    property PropertyJS : String read FPropertyJS write SetFPropertyJS;
    property Root : String read FRoot write SetFRoot;
    property SorterFn : TExtFunction read FSorterFn write SetFSorterFn;
    property Transform : TExtFunction read FTransform write SetFTransform;
  end;

  TExtUtilRenderable = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function DoAutoRender : TExtFunction;
    function EnsureAttachedToBody(RunLayout : Boolean = false) : TExtFunction;
    function GetInsertPosition(Position : THTMLElement) : TExtFunction; overload;
    function GetInsertPosition(Position : TExtDomElement) : TExtFunction; overload;
    function GetInsertPosition(Position : String) : TExtFunction; overload;
    function GetInsertPosition(Position : Integer) : TExtFunction; overload;
    function Render(Container : String; Position : String) : TExtFunction; overload;
    function Render(Container : THTMLElement; Position : String) : TExtFunction; overload;
    function Render(Container : THTMLElement; Position : Integer = 0) : TExtFunction; overload;
    function Render(Container : TExtElement; Position : String) : TExtFunction; overload;
    function Render(Container : TExtElement; Position : Integer = 0) : TExtFunction; overload;
    function Render(Container : String = ''; Position : Integer = 0) : TExtFunction; overload;
  end;

  TExtUtilRegion = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Adjust(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer) : TExtFunction;
    function ConstrainTo(TargetRegion : TExtUtilRegion) : TExtFunction;
    function Contains(Region : TExtUtilRegion) : TExtFunction;
    function Copy : TExtFunction;
    function CopyFrom(P : TExtUtilRegion) : TExtFunction;
    constructor Create(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer);
    function Equals(Region : TExtUtilRegion) : TExtFunction;
    function From(O : TExtObject) : TExtFunction;
    function GetOutOfBoundOffset(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction;
    function GetOutOfBoundOffsetX(P : Integer) : TExtFunction;
    function GetOutOfBoundOffsetY(P : Integer) : TExtFunction;
    function GetRegion(El : THTMLElement) : TExtFunction; overload;
    function GetRegion(El : TExtElement) : TExtFunction; overload;
    function GetRegion(El : String) : TExtFunction; overload;
    function Intersect(Region : TExtUtilRegion) : TExtFunction;
    function IsOutOfBound(Axis : String; P : TExtUtilPoint) : TExtFunction; overload;
    function IsOutOfBound(Axis : String = ''; P : Integer = 0) : TExtFunction; overload;
    function IsOutOfBoundX(P : Integer) : TExtFunction;
    function IsOutOfBoundY(P : Integer) : TExtFunction;
    function Round : TExtFunction;
    function TranslateBy(X : TExtUtilOffset; Y : Integer) : TExtFunction; overload;
    function TranslateBy(X : TExtObject; Y : Integer) : TExtFunction; overload;
    function Union(Region : TExtUtilRegion) : TExtFunction;
  end;

  TExtLayout = class(TExtAbstractComponent)
  private
    FDone : Boolean;
    FIsLayout : Boolean;
    procedure SetFDone(Value : Boolean);
    procedure SetFIsLayout(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function OnContentChange(Child : TExtComponent) : TExtFunction;
    property Done : Boolean read FDone write SetFDone;
    property IsLayout : Boolean read FIsLayout write SetFIsLayout;
  end;

  TExtLayoutClassList = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add : TExtFunction;
    function AddMany : TExtFunction;
    function Remove : TExtFunction;
    function RemoveMany : TExtFunction;
  end;

  TExtDomElement_anim = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Animate(Config : TExtObject) : TExtFunction;
    function FadeIn(Options : TExtObject = nil) : TExtFunction;
    function FadeOut(Options : TExtObject = nil) : TExtFunction;
    function Frame(Color : String = ''; Count : Integer = 0; Options : TExtObject = nil) : TExtFunction;
    function Ghost(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction;
    function Highlight(Color : String = ''; Options : TExtObject = nil) : TExtFunction;
    function Puff(Options : TExtObject = nil) : TExtFunction;
    function SlideIn(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction;
    function SlideOut(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction;
    function SwitchOff(Options : TExtObject = nil) : TExtFunction;
  end;

  TExtDomElement_dd = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function InitDD(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction;
    function InitDDProxy(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction;
    function InitDDTarget(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction;
  end;

  TExtDomAbstractQuery = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function IsJS(El : THTMLElement; Selector : String) : TExtFunction; overload;
    function IsJS(El : TExtObjectList; Selector : String) : TExtFunction; overload;
    function IsJS(El : String; Selector : String) : TExtFunction; overload;
    function Select(Selector : String; Root : THTMLElement) : TExtFunction; overload;
    function Select(Selector : String; Root : String = '') : TExtFunction; overload;
    function SelectNode(Selector : String; Root : THTMLElement) : TExtFunction; overload;
    function SelectNode(Selector : String; Root : String = '') : TExtFunction; overload;
  end;

  TExtDomCompositeElementLite = class(TExtAbstractComponent)
  private
    FElements : TExtObjectList;
    FIsComposite : Boolean;
    procedure SetFElements(Value : TExtObjectList);
    procedure SetFIsComposite(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Els : TExtObjectList) : TExtFunction; overload;
    function Add(Els : TExtDomCompositeElement) : TExtFunction; overload;
    function Clear(RemoveDom : Boolean = false) : TExtFunction;
    function Contains(El : THTMLElement) : TExtFunction; overload;
    function Contains(El : TExtElement) : TExtFunction; overload;
    function Contains(El : String) : TExtFunction; overload;
    function Contains(El : Integer) : TExtFunction; overload;
    constructor Create;
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Fill(Els : TExtObjectList) : TExtFunction; overload;
    function Fill(Els : TExtDomCompositeElement) : TExtFunction; overload;
    function Filter(Selector : TExtFunction) : TExtFunction; overload;
    function Filter(Selector : String) : TExtFunction; overload;
    function First : TExtFunction;
    function GetCount : TExtFunction;
    function IndexOf(El : THTMLElement) : TExtFunction; overload;
    function IndexOf(El : TExtElement) : TExtFunction; overload;
    function IndexOf(El : String) : TExtFunction; overload;
    function IndexOf(El : Integer) : TExtFunction; overload;
    function Item(Index : Integer) : TExtFunction;
    function Last : TExtFunction;
    function RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; overload;
    function RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; overload;
    function Slice(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    destructor Destroy; override;
    property Elements : TExtObjectList read FElements write SetFElements;
    property IsComposite : Boolean read FIsComposite write SetFIsComposite;
  end;

  TExtDomElement_scroll = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetScroll : TExtFunction;
    function GetScrollLeft : TExtFunction;
    function GetScrollTop : TExtFunction;
    function IsScrollable : TExtFunction;
    function Scroll(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; overload;
    function Scroll(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollIntoView(Hscroll : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollIntoView(Hscroll : Boolean = false; Animate : Boolean = false) : TExtFunction; overload;
    function ScrollTo(Side : String; Value : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollTo(Side : String; Value : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetScrollLeft(Left : Integer) : TExtFunction;
    function SetScrollTop(Top : Integer) : TExtFunction;
  end;

  TExtDomElement_style = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddClsOnClick(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function AddClsOnFocus(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function AddClsOnOver(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function BoxWrap(ClassJS : String = '') : TExtFunction;
    function ClearOpacity : TExtFunction;
    function Clip : TExtFunction;
    function GetColor(Attr : String; DefaultValue : String; Prefix : String = '') : TExtFunction;
    function GetComputedHeight : TExtFunction;
    function GetComputedWidth : TExtFunction;
    function GetFrameWidth(Sides : String) : TExtFunction;
    function GetStyleSize : TExtFunction;
    function Selectable : TExtFunction;
    function SetOpacity(Opacity : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetOpacity(Opacity : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function Unclip : TExtFunction;
    function Unselectable : TExtFunction;
  end;

  TExtDomElement_fx = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Hide(Animate : TExtObject) : TExtFunction; overload;
    function Hide(Animate : Boolean = false) : TExtFunction; overload;
    function SetDisplayed(Value : String) : TExtFunction; overload;
    function SetDisplayed(Value : Boolean) : TExtFunction; overload;
    function Show(Animate : TExtObject) : TExtFunction; overload;
    function Show(Animate : Boolean = false) : TExtFunction; overload;
    function Toggle(Animate : TExtObject) : TExtFunction; overload;
    function Toggle(Animate : Boolean = false) : TExtFunction; overload;
  end;

  TExtDomElement_position = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Center(CenterIn : THTMLElement) : TExtFunction; overload;
    function Center(CenterIn : TExtDomElement) : TExtFunction; overload;
    function Center(CenterIn : String) : TExtFunction; overload;
    function ClearPositioning(Value : String = '') : TExtFunction;
    function GetLocalX : TExtFunction;
    function GetLocalXY : TExtFunction;
    function GetLocalY : TExtFunction;
    function GetPositioning(AutoPx : Boolean = false) : TExtFunction;
    function GetX : TExtFunction;
    function GetXY : TExtFunction;
    function GetY : TExtFunction;
    function Position(Pos : String = ''; ZIndex : Integer = 0; X : Integer = 0; Y : Integer = 0) : TExtFunction;
    function SetPositioning(PosCfg : TExtObject) : TExtFunction;
  end;

  TExtDomAbstractElement = class(TExtAbstractComponent)
  private
    FDefaultUnit : String;
    FDom : THTMLElement;
    FId : String;
    FIsFly : Boolean;
    procedure SetFDefaultUnit(Value : String);
    procedure SetFDom(Value : THTMLElement);
    procedure SetFId(Value : String);
    procedure SetFIsFly(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Contains(El : THTMLElement) : TExtFunction; overload;
    function Contains(El : String) : TExtFunction; overload;
    function Fly(Dom : THTMLElement; Named : String = '') : TExtFunction; overload;
    function Fly(Dom : String; Named : String = '') : TExtFunction; overload;
    function Get(El : THTMLElement) : TExtFunction; overload;
    function Get(El : TExtElement) : TExtFunction; overload;
    function Get(El : String) : TExtFunction; overload;
    function GetAttribute(Name : String; Namespace : String = '') : TExtFunction;
    function GetHTML : TExtFunction;
    function GetValue(AsNumber : Boolean) : TExtFunction;
    function Hide(Animate : TExtObject) : TExtFunction; overload;
    function Hide(Animate : Boolean = false) : TExtFunction; overload;
    function IsJS(Selector : String) : TExtFunction;
    function MergeClsList(ClsList1 : String; ClsList2 : String) : TExtFunction;
    function Remove : TExtFunction;
    function RemoveCls(ExistingClsList : String; RemoveClsList : String) : TExtFunction;
    function SetHTML(Html : String) : TExtFunction;
    function SetJS(O : TExtObject; UseSet : Boolean = false) : TExtFunction;
    function SetVisibilityMode : TExtFunction;
    function SetVisible(Visible : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function SetVisible(Visible : Boolean; Animate : Boolean = false) : TExtFunction; overload;
    function Show(Animate : TExtObject) : TExtFunction; overload;
    function Show(Animate : Boolean = false) : TExtFunction; overload;
    function Update(Html : String) : TExtFunction;
    property DefaultUnit : String read FDefaultUnit write SetFDefaultUnit;
    property Dom : THTMLElement read FDom write SetFDom;
    property Id : String read FId write SetFId;
    property IsFly : Boolean read FIsFly write SetFIsFly;
  end;

  TExtDomAbstractElement_insertion = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AppendChild(El : THTMLElement; ReturnDom : Boolean = false) : TExtFunction; overload;
    function AppendChild(El : TExtObject; ReturnDom : Boolean = false) : TExtFunction; overload;
    function AppendChild(El : TExtDomAbstractElement; ReturnDom : Boolean = false) : TExtFunction; overload;
    function AppendChild(El : String; ReturnDom : Boolean = false) : TExtFunction; overload;
    function AppendTo(El : THTMLElement) : TExtFunction; overload;
    function AppendTo(El : TExtDomAbstractElement) : TExtFunction; overload;
    function AppendTo(El : String) : TExtFunction; overload;
    function CreateChild(Config : TExtObject; InsertBefore : THTMLElement = nil; ReturnDom : Boolean = false) : TExtFunction;
    function InsertAfter(El : THTMLElement) : TExtFunction; overload;
    function InsertAfter(El : TExtDomAbstractElement) : TExtFunction; overload;
    function InsertAfter(El : String) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement) : TExtFunction; overload;
    function InsertBefore(El : TExtDomAbstractElement) : TExtFunction; overload;
    function InsertBefore(El : String) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement) : TExtFunction; overload;
    function InsertFirst(El : TExtObject) : TExtFunction; overload;
    function InsertFirst(El : TExtDomAbstractElement) : TExtFunction; overload;
    function InsertFirst(El : String) : TExtFunction; overload;
    function InsertHtml(Where : String; Html : String; ReturnEl : Boolean = false) : TExtFunction;
    function InsertSibling(El : THTMLElement; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; overload;
    function InsertSibling(El : TExtObjectList; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; overload;
    function InsertSibling(El : TExtObject; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; overload;
    function InsertSibling(El : TExtDomAbstractElement; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; overload;
    function InsertSibling(El : String; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; overload;
    function Replace(El : THTMLElement) : TExtFunction; overload;
    function Replace(El : TExtDomAbstractElement) : TExtFunction; overload;
    function Replace(El : String) : TExtFunction; overload;
    function ReplaceWith(El : THTMLElement) : TExtFunction; overload;
    function ReplaceWith(El : TExtObject) : TExtFunction; overload;
    function ReplaceWith(El : TExtDomAbstractElement) : TExtFunction; overload;
    function ReplaceWith(El : String) : TExtFunction; overload;
    function Wrap(Config : TExtObject = nil; ReturnDom : Boolean = false; Selector : String = '') : TExtFunction;
  end;

  TExtDirectRemotingMethod = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCallData(Args : TExtObjectList) : TExtFunction;
  end;

  TExtDirectTransaction = class(TExtAbstractComponent)
  private
    FProvider : TExtDirectProvider;
    procedure SetFProvider(Value : TExtDirectProvider);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property Provider : TExtDirectProvider read FProvider write SetFProvider;
  end;

  TExtDomAbstractElement_traversal = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Child(Selector : String; ReturnDom : Boolean = false) : TExtFunction;
    function Down(Selector : String; ReturnDom : Boolean = false) : TExtFunction;
    function FindParent(Selector : String; Limit : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParent(Selector : String; Limit : TExtElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParent(Selector : String; Limit : String; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParent(Selector : String; Limit : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParentNode(Selector : String; Limit : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParentNode(Selector : String; Limit : TExtElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParentNode(Selector : String; Limit : String; ReturnEl : Boolean = false) : TExtFunction; overload;
    function FindParentNode(Selector : String; Limit : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function First(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction;
    function Last(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction;
    function Next(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction;
    function Parent(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction;
    function Prev(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction;
    function Query(Selector : String) : TExtFunction;
    function Select(Selector : String; Unique : Boolean = false) : TExtFunction;
    function Up(Selector : String; Limit : THTMLElement; ReturnDom : Boolean = false) : TExtFunction; overload;
    function Up(Selector : String; Limit : TExtElement; ReturnDom : Boolean = false) : TExtFunction; overload;
    function Up(Selector : String; Limit : String; ReturnDom : Boolean = false) : TExtFunction; overload;
    function Up(Selector : String; Limit : Integer = 0; ReturnDom : Boolean = false) : TExtFunction; overload;
  end;

  TExtDomAbstractHelper = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Append(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function ApplyStyles(El : String; Styles : TExtObject) : TExtFunction; overload;
    function ApplyStyles(El : String; Styles : TExtFunction) : TExtFunction; overload;
    function ApplyStyles(El : THTMLElement; Styles : TExtObject) : TExtFunction; overload;
    function ApplyStyles(El : THTMLElement; Styles : TExtFunction) : TExtFunction; overload;
    function ApplyStyles(El : THTMLElement; Styles : String) : TExtFunction; overload;
    function ApplyStyles(El : String; Styles : String) : TExtFunction; overload;
    function GenerateStyles(Styles : TExtObject; Buffer : TArrayOfString = nil) : TExtFunction;
    function InsertAfter(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertHtml(Where : String; El : TTextNode; Html : String) : TExtFunction; overload;
    function InsertHtml(Where : String; El : THTMLElement; Html : String) : TExtFunction; overload;
    function Markup(Spec : TExtObject) : TExtFunction;
    function Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
  end;

  TExtDomAbstractElement_static = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function FromPoint(X : Integer; Y : Integer) : TExtFunction;
    function GetActiveElement : TExtFunction;
    function GetDocumentHeight : TExtFunction;
    function GetDocumentWidth : TExtFunction;
    function GetOrientation : TExtFunction;
    function GetViewportHeight : TExtFunction;
    function GetViewportWidth : TExtFunction;
    function GetViewSize : TExtFunction;
    function Normalize(Prop : String) : TExtFunction;
    function ParseBox(Box : String) : TExtFunction; overload;
    function ParseBox(Box : Integer) : TExtFunction; overload;
    function ParseStyles(Styles : String) : TExtFunction;
    function SerializeForm(Form : TExtObject) : TExtFunction;
    function UnitizeBox(Box : TExtObject; Units : String) : TExtFunction; overload;
    function UnitizeBox(Box : String; Units : String) : TExtFunction; overload;
    function UnitizeBox(Box : Integer; Units : String) : TExtFunction; overload;
  end;

  TExtDomAbstractElement_style = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ApplyStyles(Styles : TExtObject) : TExtFunction; overload;
    function ApplyStyles(Styles : TExtFunction) : TExtFunction; overload;
    function ApplyStyles(Styles : String) : TExtFunction; overload;
    function GetBorderWidth(Side : String) : TExtFunction;
    function GetHeight(ContentHeight : Boolean = false) : TExtFunction;
    function GetMargin(Sides : String = '') : TExtFunction;
    function GetPadding(Side : String) : TExtFunction;
    function GetSize(ContentSize : Boolean = false) : TExtFunction;
    function GetStyle(PropertyJS : TArrayOfString; InlineJS : Boolean = false) : TExtFunction; overload;
    function GetStyle(PropertyJS : String; InlineJS : Boolean = false) : TExtFunction; overload;
    function GetViewSize : TExtFunction;
    function GetWidth(ContentWidth : Boolean = false) : TExtFunction;
    function IsStyle(Style : String; Value : String) : TExtFunction;
    function IsTransparent(Prop : String) : TExtFunction;
    function Mask(Msg : String = ''; MsgCls : String = '') : TExtFunction;
    function RadioCls(ClassName : TArrayOfString) : TExtFunction; overload;
    function RadioCls(ClassName : String) : TExtFunction; overload;
    function Repaint : TExtFunction;
    function SetHeight(Height : String) : TExtFunction; overload;
    function SetHeight(Height : Integer) : TExtFunction; overload;
    function SetSize(Width : Integer; Height : String) : TExtFunction; overload;
    function SetSize(Width : String; Height : String) : TExtFunction; overload;
    function SetSize(Width : String; Height : Integer) : TExtFunction; overload;
    function SetSize(Width : Integer; Height : Integer) : TExtFunction; overload;
    function SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; overload;
    function SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; overload;
    function SetWidth(Width : String) : TExtFunction; overload;
    function SetWidth(Width : Integer) : TExtFunction; overload;
    function Unmask : TExtFunction;
  end;

  TExtDomHelperSingleton = class(TExtAbstractComponent)
  private
    FUseDom : Boolean;
    procedure SetFUseDom(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateDom(O : TExtObject) : TExtFunction; overload;
    function CreateDom(O : String) : TExtFunction; overload;
    function CreateHtml : TExtFunction;
    function CreateTemplate(O : TExtObject) : TExtFunction;
    function Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; overload;
    property UseDom : Boolean read FUseDom write SetFUseDom;
  end;

  // Procedural types for events TExtFocusManagerSingleton
  TExtFocusManagerSingletonOnBeforecomponentfocus = procedure(Fm : TExtFocusManager; Cmp : TExtComponent; PreviousCmp : TExtComponent) of object;
  TExtFocusManagerSingletonOnComponentfocus = procedure(Fm : TExtFocusManager; Cmp : TExtComponent; PreviousCmp : TExtComponent) of object;
  TExtFocusManagerSingletonOnDisable = procedure(Fm : TExtFocusManager) of object;
  TExtFocusManagerSingletonOnEnable = procedure(Fm : TExtFocusManager) of object;

  TExtFocusManagerSingleton = class(TExtAbstractComponent)
  private
    FEnabled : Boolean;
    FFocusedCmp : TExtComponent;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FWhitelist : TArrayOfString;
    FOnBeforecomponentfocus : TExtFocusManagerSingletonOnBeforecomponentfocus;
    FOnComponentfocus : TExtFocusManagerSingletonOnComponentfocus;
    FOnDisable : TExtFocusManagerSingletonOnDisable;
    FOnEnable : TExtFocusManagerSingletonOnEnable;
    procedure SetFEnabled(Value : Boolean);
    procedure SetFFocusedCmp(Value : TExtComponent);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFWhitelist(Value : TArrayOfString);
    procedure SetFOnBeforecomponentfocus(Value : TExtFocusManagerSingletonOnBeforecomponentfocus);
    procedure SetFOnComponentfocus(Value : TExtFocusManagerSingletonOnComponentfocus);
    procedure SetFOnDisable(Value : TExtFocusManagerSingletonOnDisable);
    procedure SetFOnEnable(Value : TExtFocusManagerSingletonOnEnable);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddXTypeToWhitelist(Xtype : TArrayOfString) : TExtFunction; overload;
    function AddXTypeToWhitelist(Xtype : String) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function Disable : TExtFunction;
    function Enable(Options : TExtObject) : TExtFunction; overload;
    function Enable(Options : Boolean) : TExtFunction; overload;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveXTypeFromWhitelist(Xtype : TArrayOfString) : TExtFunction; overload;
    function RemoveXTypeFromWhitelist(Xtype : String) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Enabled : Boolean read FEnabled write SetFEnabled;
    property FocusedCmp : TExtComponent read FFocusedCmp write SetFFocusedCmp;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Whitelist : TArrayOfString read FWhitelist write SetFWhitelist;
    property OnBeforecomponentfocus : TExtFocusManagerSingletonOnBeforecomponentfocus read FOnBeforecomponentfocus write SetFOnBeforecomponentfocus;
    property OnComponentfocus : TExtFocusManagerSingletonOnComponentfocus read FOnComponentfocus write SetFOnComponentfocus;
    property OnDisable : TExtFocusManagerSingletonOnDisable read FOnDisable write SetFOnDisable;
    property OnEnable : TExtFocusManagerSingletonOnEnable read FOnEnable write SetFOnEnable;
  end;

  TExtFoo = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject); overload;
    constructor Create(Config : String); overload;
    function Handle(Err : TExtError) : TExtFunction;
    function ToString : TExtFunction;
  end;

  // Procedural types for events TExtElementLoader
  TExtElementLoaderOnBeforeload = procedure(This : TExtElementLoader; Options : TExtObject) of object;
  TExtElementLoaderOnException = procedure(This : TExtElementLoader; Response : TExtObject; Options : TExtObject) of object;
  TExtElementLoaderOnLoad = procedure(This : TExtElementLoader; Response : TExtObject; Options : TExtObject) of object;

  TExtElementLoader = class(TExtAbstractComponent)
  private
    FAjaxOptions : TExtObject;
    FAutoLoad : Boolean;
    FAutoLoadObject : TExtObject;
    FBaseParams : TExtObject;
    FCallback : TExtFunction;
    FFailure : TExtFunction;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsLoader : Boolean;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FLoadMask : Boolean;
    FLoadMaskString : String;
    FParams : TExtObject;
    FRenderer : TExtFunction;
    FScope : TExtObject;
    FScripts : Boolean;
    FSuccess : TExtFunction;
    FTarget : THTMLElement;
    FTargetElement : TExtElement;
    FTargetString : String;
    FUrl : String;
    FOnBeforeload : TExtElementLoaderOnBeforeload;
    FOnException : TExtElementLoaderOnException;
    FOnLoad : TExtElementLoaderOnLoad;
    procedure SetFAjaxOptions(Value : TExtObject);
    procedure SetFAutoLoad(Value : Boolean);
    procedure SetFAutoLoadObject(Value : TExtObject);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFFailure(Value : TExtFunction);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsLoader(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFLoadMask(Value : Boolean);
    procedure SetFLoadMaskString(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
    procedure SetFScripts(Value : Boolean);
    procedure SetFSuccess(Value : TExtFunction);
    procedure SetFTarget(Value : THTMLElement);
    procedure SetFTargetElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFUrl(Value : String);
    procedure SetFOnBeforeload(Value : TExtElementLoaderOnBeforeload);
    procedure SetFOnException(Value : TExtElementLoaderOnException);
    procedure SetFOnLoad(Value : TExtElementLoaderOnLoad);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort : TExtFunction;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetTarget : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function IsAutoRefreshing : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetTarget(Target : THTMLElement) : TExtFunction; overload;
    function SetTarget(Target : TExtElement) : TExtFunction; overload;
    function SetTarget(Target : String) : TExtFunction; overload;
    function StartAutoRefresh(Interval : Integer; Options : TExtObject = nil) : TExtFunction;
    function StopAutoRefresh : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property AjaxOptions : TExtObject read FAjaxOptions write SetFAjaxOptions;
    property AutoLoad : Boolean read FAutoLoad write SetFAutoLoad;
    property AutoLoadObject : TExtObject read FAutoLoadObject write SetFAutoLoadObject;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property Failure : TExtFunction read FFailure write SetFFailure;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsLoader : Boolean read FIsLoader write SetFIsLoader;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property LoadMask : Boolean read FLoadMask write SetFLoadMask;
    property LoadMaskString : String read FLoadMaskString write SetFLoadMaskString;
    property Params : TExtObject read FParams write SetFParams;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property Scope : TExtObject read FScope write SetFScope;
    property Scripts : Boolean read FScripts write SetFScripts;
    property Success : TExtFunction read FSuccess write SetFSuccess;
    property Target : THTMLElement read FTarget write SetFTarget;
    property TargetElement : TExtElement read FTargetElement write SetFTargetElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property Url : String read FUrl write SetFUrl;
    property OnBeforeload : TExtElementLoaderOnBeforeload read FOnBeforeload write SetFOnBeforeload;
    property OnException : TExtElementLoaderOnException read FOnException write SetFOnException;
    property OnLoad : TExtElementLoaderOnLoad read FOnLoad write SetFOnLoad;
  end;

  TExtEventObjectImplSingleton = class(TExtAbstractComponent)
  private
    FAltKey : Boolean;
    FCtrlKey : Boolean;
    FShiftKey : Boolean;
    procedure SetFAltKey(Value : Boolean);
    procedure SetFCtrlKey(Value : Boolean);
    procedure SetFShiftKey(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CorrectWheelDelta(Delta : Integer) : TExtFunction;
    function GetCharCode : TExtFunction;
    function GetKey : TExtFunction;
    function GetPoint : TExtFunction;
    function GetRelatedTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetRelatedTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; overload;
    function GetWheelDelta : TExtFunction;
    function GetWheelDeltas : TExtFunction;
    function GetX : TExtFunction;
    function GetXY : TExtFunction;
    function GetY : TExtFunction;
    function HasModifier : TExtFunction;
    function IsNavKeyPress : TExtFunction;
    function IsSpecialKey : TExtFunction;
    function PreventDefault : TExtFunction;
    function StopEvent : TExtFunction;
    function StopPropagation : TExtFunction;
    function Within(El : THTMLElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    function Within(El : TExtElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    function Within(El : String; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; overload;
    property AltKey : Boolean read FAltKey write SetFAltKey;
    property CtrlKey : Boolean read FCtrlKey write SetFCtrlKey;
    property ShiftKey : Boolean read FShiftKey write SetFShiftKey;
  end;

  // Procedural types for events TExtFormFieldAncestor
  TExtFormFieldAncestorOnFielderrorchange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; Error : String) of object;
  TExtFormFieldAncestorOnFieldvaliditychange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; IsValid : String) of object;

  TExtFormFieldAncestor = class(TExtAbstractComponent)
  private
    FFieldDefaults : TExtObject;
    FOnFielderrorchange : TExtFormFieldAncestorOnFielderrorchange;
    FOnFieldvaliditychange : TExtFormFieldAncestorOnFieldvaliditychange;
    procedure SetFFieldDefaults(Value : TExtObject);
    procedure SetFOnFielderrorchange(Value : TExtFormFieldAncestorOnFielderrorchange);
    procedure SetFOnFieldvaliditychange(Value : TExtFormFieldAncestorOnFieldvaliditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FieldDefaults : TExtObject read FFieldDefaults write SetFFieldDefaults;
    property OnFielderrorchange : TExtFormFieldAncestorOnFielderrorchange read FOnFielderrorchange write SetFOnFielderrorchange;
    property OnFieldvaliditychange : TExtFormFieldAncestorOnFieldvaliditychange read FOnFieldvaliditychange write SetFOnFieldvaliditychange;
  end;

  TExtXTemplateParser = class(TExtAbstractComponent)
  private
    FLevel : Integer;
    procedure SetFLevel(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function DoCase(Action : String; Actions : TExtObject) : TExtFunction;
    function DoDefault : TExtFunction;
    function DoElse : TExtFunction;
    function DoElseIf(Action : String; Actions : TExtObject) : TExtFunction;
    function DoEnd(TypeJS : String; Actions : TExtObject) : TExtFunction;
    function DoEval(Text : String) : TExtFunction;
    function DoExec(Action : String; Actions : TExtObject) : TExtFunction;
    function DoExpr(Expr : String) : TExtFunction;
    function DoFor(Action : String; Actions : TExtObject) : TExtFunction;
    function DoForEach(Action : String; Actions : TExtObject) : TExtFunction;
    function DoIf(Action : String; Actions : TExtObject) : TExtFunction;
    function DoSwitch(Action : String; Actions : TExtObject) : TExtFunction;
    function DoTag : TExtFunction;
    function DoText(Text : String) : TExtFunction;
    function DoTplExtEmptyFnParse : TExtFunction;
    property Level : Integer read FLevel write SetFLevel;
  end;

  TExtFormAction = class(TExtAbstractComponent)
  private
    FFailure : TExtFunction;
    FFailureAction : TExtFormAction;
    FFailureForm : TExtFormBasic;
    FFailureType : String;
    FForm : TExtFormBasic;
    FHeaders : TExtObject;
    FMethod : String;
    FParams : TExtObject;
    FParamsString : String;
    FReset : Boolean;
    FResponse : TExtObject;
    FResultJS : TExtObject;
    FScope : TExtObject;
    FSubmitEmptyText : Boolean;
    FSuccess : TExtFunction;
    FSuccessAction : TExtFormAction;
    FSuccessForm : TExtFormBasic;
    FTimeout : Integer;
    FTypeJS : String;
    FUrl : String;
    FWaitMsg : String;
    FWaitTitle : String;
    procedure SetFFailure(Value : TExtFunction);
    procedure SetFFailureAction(Value : TExtFormAction);
    procedure SetFFailureForm(Value : TExtFormBasic);
    procedure SetFFailureType(Value : String);
    procedure SetFForm(Value : TExtFormBasic);
    procedure SetFHeaders(Value : TExtObject);
    procedure SetFMethod(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFParamsString(Value : String);
    procedure SetFReset(Value : Boolean);
    procedure SetFResponse(Value : TExtObject);
    procedure SetFResultJS(Value : TExtObject);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSubmitEmptyText(Value : Boolean);
    procedure SetFSuccess(Value : TExtFunction);
    procedure SetFSuccessAction(Value : TExtFormAction);
    procedure SetFSuccessForm(Value : TExtFormBasic);
    procedure SetFTimeout(Value : Integer);
    procedure SetFTypeJS(Value : String);
    procedure SetFUrl(Value : String);
    procedure SetFWaitMsg(Value : String);
    procedure SetFWaitTitle(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property Failure : TExtFunction read FFailure write SetFFailure;
    property FailureAction : TExtFormAction read FFailureAction write SetFFailureAction;
    property FailureForm : TExtFormBasic read FFailureForm write SetFFailureForm;
    property FailureType : String read FFailureType write SetFFailureType;
    property Form : TExtFormBasic read FForm write SetFForm;
    property Headers : TExtObject read FHeaders write SetFHeaders;
    property Method : String read FMethod write SetFMethod;
    property Params : TExtObject read FParams write SetFParams;
    property ParamsString : String read FParamsString write SetFParamsString;
    property Reset : Boolean read FReset write SetFReset;
    property Response : TExtObject read FResponse write SetFResponse;
    property ResultJS : TExtObject read FResultJS write SetFResultJS;
    property Scope : TExtObject read FScope write SetFScope;
    property SubmitEmptyText : Boolean read FSubmitEmptyText write SetFSubmitEmptyText;
    property Success : TExtFunction read FSuccess write SetFSuccess;
    property SuccessAction : TExtFormAction read FSuccessAction write SetFSuccessAction;
    property SuccessForm : TExtFormBasic read FSuccessForm write SetFSuccessForm;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property Url : String read FUrl write SetFUrl;
    property WaitMsg : String read FWaitMsg write SetFWaitMsg;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
  end;

  // Procedural types for events TExtFormField
  TExtFormFieldOnChange = procedure(This : TExtFormField; NewValue : TExtObject; OldValue : TExtObject) of object;
  TExtFormFieldOnDirtychange = procedure(This : TExtFormField; IsDirty : Boolean) of object;
  TExtFormFieldOnValiditychange = procedure(This : TExtFormField; IsValid : Boolean) of object;

  TExtFormField = class(TExtAbstractComponent)
  private
    FDisabled : Boolean;
    FIsFormField : Boolean;
    FName : String;
    FOriginalValue : TExtObject;
    FSubmitValue : Boolean;
    FValidateOnChange : Boolean;
    FValue : TExtObject;
    FOnChange : TExtFormFieldOnChange;
    FOnDirtychange : TExtFormFieldOnDirtychange;
    FOnValiditychange : TExtFormFieldOnValiditychange;
    procedure SetFDisabled(Value : Boolean);
    procedure SetFIsFormField(Value : Boolean);
    procedure SetFName(Value : String);
    procedure SetFOriginalValue(Value : TExtObject);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFValidateOnChange(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFOnChange(Value : TExtFormFieldOnChange);
    procedure SetFOnDirtychange(Value : TExtFormFieldOnDirtychange);
    procedure SetFOnValiditychange(Value : TExtFormFieldOnValiditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BatchChanges(Fn : TExtObject) : TExtFunction;
    function CheckChange : TExtFunction;
    function CheckDirty : TExtFunction;
    constructor Create;
    function ExtractFileInput : TExtFunction;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function GetModelData : TExtFunction;
    function GetName : TExtFunction;
    function GetSubmitData : TExtFunction;
    function GetValue : TExtFunction;
    function InitField : TExtFunction;
    function InitValue : TExtFunction;
    function IsDirty : TExtFunction;
    function IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction;
    function IsFileUpload : TExtFunction;
    function IsValid : TExtFunction;
    function Reset : TExtFunction;
    function ResetOriginalValue : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function Validate : TExtFunction;
    destructor Destroy; override;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property IsFormField : Boolean read FIsFormField write SetFIsFormField;
    property Name : String read FName write SetFName;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property ValidateOnChange : Boolean read FValidateOnChange write SetFValidateOnChange;
    property Value : TExtObject read FValue write SetFValue;
    property OnChange : TExtFormFieldOnChange read FOnChange write SetFOnChange;
    property OnDirtychange : TExtFormFieldOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnValiditychange : TExtFormFieldOnValiditychange read FOnValiditychange write SetFOnValiditychange;
  end;

  TExtDrawEngineImageExporterSingleton = class(TExtAbstractComponent)
  private
    FDefaultUrl : String;
    FHeightParam : String;
    FSupportedTypes : TExtObjectList;
    FSvgParam : String;
    FTypeParam : String;
    FWidthParam : String;
    procedure SetFDefaultUrl(Value : String);
    procedure SetFHeightParam(Value : String);
    procedure SetFSupportedTypes(Value : TExtObjectList);
    procedure SetFSvgParam(Value : String);
    procedure SetFTypeParam(Value : String);
    procedure SetFWidthParam(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property DefaultUrl : String read FDefaultUrl write SetFDefaultUrl;
    property HeightParam : String read FHeightParam write SetFHeightParam;
    property SupportedTypes : TExtObjectList read FSupportedTypes write SetFSupportedTypes;
    property SvgParam : String read FSvgParam write SetFSvgParam;
    property TypeParam : String read FTypeParam write SetFTypeParam;
    property WidthParam : String read FWidthParam write SetFWidthParam;
  end;

  TExtDrawEngineSvgExporterSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction;
  end;

  TExtDomLayer = class(TExtAbstractComponent)
  private
    FCls : String;
    FConstrain : Boolean;
    FDh : TExtObject;
    FHideMode : String;
    FShadow : String;
    FShadowBoolean : Boolean;
    FShadowOffset : Integer;
    FShim : Boolean;
    FUseDisplay : Boolean;
    FVisibilityCls : String;
    FZindex : Integer;
    procedure SetFCls(Value : String);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFDh(Value : TExtObject);
    procedure SetFHideMode(Value : String);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFShadowOffset(Value : Integer);
    procedure SetFShim(Value : Boolean);
    procedure SetFUseDisplay(Value : Boolean);
    procedure SetFVisibilityCls(Value : String);
    procedure SetFZindex(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; ExistingEl : THTMLElement); overload;
    constructor Create(Config : TExtObject = nil; ExistingEl : String = ''); overload;
    function SetZIndex(Zindex : Integer) : TExtFunction;
    destructor Destroy; override;
    property Cls : String read FCls write SetFCls;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Dh : TExtObject read FDh write SetFDh;
    property HideMode : String read FHideMode write SetFHideMode;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property ShadowOffset : Integer read FShadowOffset write SetFShadowOffset;
    property Shim : Boolean read FShim write SetFShim;
    property UseDisplay : Boolean read FUseDisplay write SetFUseDisplay;
    property VisibilityCls : String read FVisibilityCls write SetFVisibilityCls;
    property Zindex : Integer read FZindex write SetFZindex;
  end;

  TExtDrawColor = class(TExtAbstractComponent)
  private
    FLightnessFactor : Integer; // 0
    procedure SetFLightnessFactor(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Red : Integer; Green : Integer; Blue : Integer); overload;
    constructor Create; overload;
    function FromHSL(H : Integer; S : Integer; L : Integer) : TExtFunction;
    function FromString(Str : String) : TExtFunction;
    function GetBlue : TExtFunction;
    function GetDarker(Factor : Integer) : TExtFunction;
    function GetGrayscale : TExtFunction;
    function GetGreen : TExtFunction;
    function GetHSL : TExtFunction;
    function GetLighter(Factor : Integer) : TExtFunction;
    function GetRed : TExtFunction;
    function GetRGB : TExtFunction;
    function ToHex(Color : TArrayOfString) : TExtFunction; overload;
    function ToHex(Color : String) : TExtFunction; overload;
    function ToString : TExtFunction;
    property LightnessFactor : Integer read FLightnessFactor write SetFLightnessFactor;
  end;

  // Procedural types for events TExtDrawSprite
  TExtDrawSpriteOnBeforedestroy = procedure(This : TExtDrawSprite) of object;
  TExtDrawSpriteOnClick = procedure of object;
  TExtDrawSpriteOnDestroy = procedure(This : TExtDrawSprite) of object;
  TExtDrawSpriteOnMousedown = procedure of object;
  TExtDrawSpriteOnMousemove = procedure of object;
  TExtDrawSpriteOnMouseout = procedure of object;
  TExtDrawSpriteOnMouseover = procedure of object;
  TExtDrawSpriteOnMouseup = procedure of object;
  TExtDrawSpriteOnRender = procedure(This : TExtDrawSprite) of object;

  TExtDrawSprite = class(TExtAbstractComponent)
  private
    FDd : TExtDdDragSource;
    FDraggable : Boolean;
    FFill : String;
    FFont : String;
    FGlobalEvents : TExtUtilObservable;
    FGroup : String;
    FGroupTArrayOfString : TArrayOfString;
    FHasListeners : TExtObject;
    FHeight : Integer;
    FIsObservable : Boolean;
    FIsSprite : Boolean;
    FListeners : TExtObject;
    FOpacity : Integer;
    FPath : String;
    FRadius : Integer;
    FRadiusX : Integer;
    FRadiusY : Integer;
    FSrc : String;
    FStroke : String;
    FStrokeWidth : Integer;
    FText : String;
    FTypeJS : String;
    FWidth : Integer;
    FX : Integer;
    FY : Integer;
    FOnBeforedestroy : TExtDrawSpriteOnBeforedestroy;
    FOnClick : TExtDrawSpriteOnClick;
    FOnDestroy : TExtDrawSpriteOnDestroy;
    FOnMousedown : TExtDrawSpriteOnMousedown;
    FOnMousemove : TExtDrawSpriteOnMousemove;
    FOnMouseout : TExtDrawSpriteOnMouseout;
    FOnMouseover : TExtDrawSpriteOnMouseover;
    FOnMouseup : TExtDrawSpriteOnMouseup;
    FOnRender : TExtDrawSpriteOnRender;
    procedure SetFDd(Value : TExtDdDragSource);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFFill(Value : String);
    procedure SetFFont(Value : String);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFGroup(Value : String);
    procedure SetFGroupTArrayOfString(Value : TArrayOfString);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHeight(Value : Integer);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIsSprite(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOpacity(Value : Integer);
    procedure SetFPath(Value : String);
    procedure SetFRadius(Value : Integer);
    procedure SetFRadiusX(Value : Integer);
    procedure SetFRadiusY(Value : Integer);
    procedure SetFSrc(Value : String);
    procedure SetFStroke(Value : String);
    procedure SetFStrokeWidth(Value : Integer);
    procedure SetFText(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFWidth(Value : Integer);
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
    procedure SetFOnBeforedestroy(Value : TExtDrawSpriteOnBeforedestroy);
    procedure SetFOnClick(Value : TExtDrawSpriteOnClick);
    procedure SetFOnDestroy(Value : TExtDrawSpriteOnDestroy);
    procedure SetFOnMousedown(Value : TExtDrawSpriteOnMousedown);
    procedure SetFOnMousemove(Value : TExtDrawSpriteOnMousemove);
    procedure SetFOnMouseout(Value : TExtDrawSpriteOnMouseout);
    procedure SetFOnMouseover(Value : TExtDrawSpriteOnMouseover);
    procedure SetFOnMouseup(Value : TExtDrawSpriteOnMouseup);
    procedure SetFOnRender(Value : TExtDrawSpriteOnRender);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddCls(ClassName : TArrayOfString) : TExtFunction; overload;
    function AddCls(ClassName : String) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Animate(Config : TExtObject) : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetActiveAnimation : TExtFunction;
    function GetBBox : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Hide(Redraw : Boolean) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function Redraw : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function Remove : TExtFunction;
    function RemoveCls(ClassName : TArrayOfString) : TExtFunction; overload;
    function RemoveCls(ClassName : String) : TExtFunction; overload;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SequenceFx : TExtFunction;
    function SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction;
    function SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; overload;
    function SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; overload;
    function Show(Redraw : Boolean) : TExtFunction;
    function StopAnimation : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function SyncFx : TExtFunction;
    destructor Destroy; override;
    property Dd : TExtDdDragSource read FDd write SetFDd;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Fill : String read FFill write SetFFill;
    property Font : String read FFont write SetFFont;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property Group : String read FGroup write SetFGroup;
    property GroupTArrayOfString : TArrayOfString read FGroupTArrayOfString write SetFGroupTArrayOfString;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Height : Integer read FHeight write SetFHeight;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property IsSprite : Boolean read FIsSprite write SetFIsSprite;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Opacity : Integer read FOpacity write SetFOpacity;
    property Path : String read FPath write SetFPath;
    property Radius : Integer read FRadius write SetFRadius;
    property RadiusX : Integer read FRadiusX write SetFRadiusX;
    property RadiusY : Integer read FRadiusY write SetFRadiusY;
    property Src : String read FSrc write SetFSrc;
    property Stroke : String read FStroke write SetFStroke;
    property StrokeWidth : Integer read FStrokeWidth write SetFStrokeWidth;
    property Text : String read FText write SetFText;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property Width : Integer read FWidth write SetFWidth;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
    property OnBeforedestroy : TExtDrawSpriteOnBeforedestroy read FOnBeforedestroy write SetFOnBeforedestroy;
    property OnClick : TExtDrawSpriteOnClick read FOnClick write SetFOnClick;
    property OnDestroy : TExtDrawSpriteOnDestroy read FOnDestroy write SetFOnDestroy;
    property OnMousedown : TExtDrawSpriteOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMousemove : TExtDrawSpriteOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseout : TExtDrawSpriteOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtDrawSpriteOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseup : TExtDrawSpriteOnMouseup read FOnMouseup write SetFOnMouseup;
    property OnRender : TExtDrawSpriteOnRender read FOnRender write SetFOnRender;
  end;

  // Procedural types for events TExtDrawSurface
  TExtDrawSurfaceOnClick = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnDblclick = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMousedown = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMouseenter = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMouseleave = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMousemove = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMouseout = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMouseover = procedure(E : TExtEventObject) of object;
  TExtDrawSurfaceOnMouseup = procedure(E : TExtEventObject) of object;

  TExtDrawSurface = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FHeight : Integer;
    FIsObservable : Boolean;
    FItems : TExtObjectList;
    FListeners : TExtObject;
    FWidth : Integer;
    FOnClick : TExtDrawSurfaceOnClick;
    FOnDblclick : TExtDrawSurfaceOnDblclick;
    FOnMousedown : TExtDrawSurfaceOnMousedown;
    FOnMouseenter : TExtDrawSurfaceOnMouseenter;
    FOnMouseleave : TExtDrawSurfaceOnMouseleave;
    FOnMousemove : TExtDrawSurfaceOnMousemove;
    FOnMouseout : TExtDrawSurfaceOnMouseout;
    FOnMouseover : TExtDrawSurfaceOnMouseover;
    FOnMouseup : TExtDrawSurfaceOnMouseup;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHeight(Value : Integer);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFWidth(Value : Integer);
    procedure SetFOnClick(Value : TExtDrawSurfaceOnClick);
    procedure SetFOnDblclick(Value : TExtDrawSurfaceOnDblclick);
    procedure SetFOnMousedown(Value : TExtDrawSurfaceOnMousedown);
    procedure SetFOnMouseenter(Value : TExtDrawSurfaceOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtDrawSurfaceOnMouseleave);
    procedure SetFOnMousemove(Value : TExtDrawSurfaceOnMousemove);
    procedure SetFOnMouseout(Value : TExtDrawSurfaceOnMouseout);
    procedure SetFOnMouseover(Value : TExtDrawSurfaceOnMouseover);
    procedure SetFOnMouseup(Value : TExtDrawSurfaceOnMouseup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Config : TExtObject; EnginePriority : TArrayOfString = nil);
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetGroup(Id : String) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function Remove(Sprite : TExtDrawSprite; DestroySprite : Boolean) : TExtFunction;
    function RemoveAll(DestroySprites : Boolean) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function Save(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction;
    function SetSize(W : Integer; H : Integer) : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Height : Integer read FHeight write SetFHeight;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Items : TExtObjectList read FItems write SetFItems;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Width : Integer read FWidth write SetFWidth;
    property OnClick : TExtDrawSurfaceOnClick read FOnClick write SetFOnClick;
    property OnDblclick : TExtDrawSurfaceOnDblclick read FOnDblclick write SetFOnDblclick;
    property OnMousedown : TExtDrawSurfaceOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseenter : TExtDrawSurfaceOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtDrawSurfaceOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnMousemove : TExtDrawSurfaceOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseout : TExtDrawSurfaceOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtDrawSurfaceOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseup : TExtDrawSurfaceOnMouseup read FOnMouseup write SetFOnMouseup;
  end;

  TExtDrawMatrix = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDrawSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SnapEndsByDate(From : TDateTime; ToJS : TDateTime; StepsMax : Integer; LockEnds : Boolean) : TExtFunction;
    function SnapEndsByDateAndStep(From : TDateTime; ToJS : TDateTime; Step : TExtObjectList; LockEnds : Boolean) : TExtFunction;
  end;

  TExtShadowPoolSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtSliderThumb = class(TExtAbstractComponent)
  private
    FConstrain : Boolean;
    FSlider : TExtSliderMultiSlider;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFSlider(Value : TExtSliderMultiSlider);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    function InitEvents : TExtFunction;
    function Render : TExtFunction;
    destructor Destroy; override;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Slider : TExtSliderMultiSlider read FSlider write SetFSlider;
  end;

  TExtRtlViewTable = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtShadow = class(TExtAbstractComponent)
  private
    FMode : String;
    FOffset : Integer;
    procedure SetFMode(Value : String);
    procedure SetFOffset(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function Hide : TExtFunction;
    function IsVisible : TExtFunction;
    function Realign(Left : Integer; Top : Integer; Width : Integer; Height : Integer) : TExtFunction;
    function SetOpacity(Opacity : Integer) : TExtFunction;
    function SetZIndex(Zindex : Integer) : TExtFunction;
    function Show(TargetEl : THTMLElement) : TExtFunction; overload;
    function Show(TargetEl : TExtElement) : TExtFunction; overload;
    function Show(TargetEl : String) : TExtFunction; overload;
    property Mode : String read FMode write SetFMode;
    property Offset : Integer read FOffset write SetFOffset;
  end;

  // Procedural types for events TExtStateStateful
  TExtStateStatefulOnBeforestaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnBeforestatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnStaterestore = procedure(This : TExtStateStateful; State : TExtObject) of object;
  TExtStateStatefulOnStatesave = procedure(This : TExtStateStateful; State : TExtObject) of object;

  TExtStateStateful = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FSaveDelay : Integer;
    FStateEvents : TArrayOfString;
    FStateful : Boolean;
    FStateId : String;
    FOnBeforestaterestore : TExtStateStatefulOnBeforestaterestore;
    FOnBeforestatesave : TExtStateStatefulOnBeforestatesave;
    FOnStaterestore : TExtStateStatefulOnStaterestore;
    FOnStatesave : TExtStateStatefulOnStatesave;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFSaveDelay(Value : Integer);
    procedure SetFStateEvents(Value : TArrayOfString);
    procedure SetFStateful(Value : Boolean);
    procedure SetFStateId(Value : String);
    procedure SetFOnBeforestaterestore(Value : TExtStateStatefulOnBeforestaterestore);
    procedure SetFOnBeforestatesave(Value : TExtStateStatefulOnBeforestatesave);
    procedure SetFOnStaterestore(Value : TExtStateStatefulOnStaterestore);
    procedure SetFOnStatesave(Value : TExtStateStatefulOnStatesave);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddStateEvents(Events : TArrayOfString) : TExtFunction; overload;
    function AddStateEvents(Events : String) : TExtFunction; overload;
    function ApplyState(State : TExtObject) : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetState : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SavePropsToState(PropNames : TArrayOfString; State : TExtObject) : TExtFunction; overload;
    function SavePropsToState(PropNames : String; State : TExtObject) : TExtFunction; overload;
    function SavePropToState(PropName : String; State : TExtObject; StateName : String = '') : TExtFunction;
    function SaveState : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property SaveDelay : Integer read FSaveDelay write SetFSaveDelay;
    property StateEvents : TArrayOfString read FStateEvents write SetFStateEvents;
    property Stateful : Boolean read FStateful write SetFStateful;
    property StateId : String read FStateId write SetFStateId;
    property OnBeforestaterestore : TExtStateStatefulOnBeforestaterestore read FOnBeforestaterestore write SetFOnBeforestaterestore;
    property OnBeforestatesave : TExtStateStatefulOnBeforestatesave read FOnBeforestatesave write SetFOnBeforestatesave;
    property OnStaterestore : TExtStateStatefulOnStaterestore read FOnStaterestore write SetFOnStaterestore;
    property OnStatesave : TExtStateStatefulOnStatesave read FOnStatesave write SetFOnStatesave;
  end;

  TExtUtilMemento = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Capture(Props : TArrayOfString; Target : TExtObject) : TExtFunction; overload;
    function Capture(Props : String; Target : TExtObject) : TExtFunction; overload;
    constructor Create(Target : TExtObject; Props : TArrayOfString); overload;
    constructor Create(Target : TExtObject; Props : String); overload;
    function Remove(Props : TArrayOfString) : TExtFunction; overload;
    function Remove(Props : String) : TExtFunction; overload;
    function Restore(Props : TArrayOfString; Clear : Boolean; Target : TExtObject) : TExtFunction; overload;
    function Restore(Props : String; Clear : Boolean; Target : TExtObject) : TExtFunction; overload;
    function RestoreAll(Clear : Boolean; Target : TExtObject) : TExtFunction;
  end;

  TExtStateManagerSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear(Name : String) : TExtFunction;
    function Get(Name : String; DefaultValue : TExtObject) : TExtFunction;
    function GetProvider : TExtFunction;
    function SetJS(Name : String; Value : TExtObject) : TExtFunction;
    function SetProvider(StateProvider : TExtStateProvider) : TExtFunction;
  end;

  // Procedural types for events TExtStateProvider
  TExtStateProviderOnStatechange = procedure(This : TExtStateProvider; Key : String; Value : String) of object;

  TExtStateProvider = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FPrefix : String; // 'ext-'
    FOnStatechange : TExtStateProviderOnStatechange;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFPrefix(Value : String);
    procedure SetFOnStatechange(Value : TExtStateProviderOnStatechange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Clear(Name : String) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function DecodeValue(Value : String) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EncodeValue(Value : TExtObject) : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function Get(Name : String; DefaultValue : TExtObject) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetJS(Name : String; Value : TExtObject) : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Prefix : String read FPrefix write SetFPrefix;
    property OnStatechange : TExtStateProviderOnStatechange read FOnStatechange write SetFOnStatechange;
  end;

  TExtRtlResizerSplitterTracker = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlSliderMulti = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlResizerBorderSplitterTracker = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlResizerResizeTracker = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlUtilFloating = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlUtilRenderable = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlTabBar = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlTreeColumn = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilCookiesSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear(Name : String; Path : String = '') : TExtFunction;
    function Get(Name : String) : TExtFunction;
    function SetJS(Name : String; Value : TExtObject; Expires : TExtObject = nil; Path : String = ''; Domain : String = ''; Secure : Boolean = false) : TExtFunction;
  end;

  TExtUtilCSSSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateRule(StyleSheet : TCSSStyleSheet; Selector : String; PropertyJS : String) : TExtFunction;
    function CreateStyleSheet(CssText : String; Id : String) : TExtFunction;
    function GetRule(Selector : TArrayOfString; RefreshCache : Boolean) : TExtFunction; overload;
    function GetRule(Selector : String; RefreshCache : Boolean) : TExtFunction; overload;
    function GetRules(RefreshCache : Boolean) : TExtFunction;
    function RefreshCache : TExtFunction;
    function RemoveStyleSheet(Id : String) : TExtFunction;
    function SwapStyleSheet(Id : String; Url : String) : TExtFunction;
    function UpdateRule(Selector : TArrayOfString; PropertyJS : String; Value : String) : TExtFunction; overload;
    function UpdateRule(Selector : String; PropertyJS : String; Value : String) : TExtFunction; overload;
  end;

  TExtUtilAnimate = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Animate(Config : TExtObject) : TExtFunction;
    function GetActiveAnimation : TExtFunction;
    function SequenceFx : TExtFunction;
    function StopAnimation : TExtFunction;
    function SyncFx : TExtFunction;
  end;

  TExtUtilBindable = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    function BindStore(Store : String = '') : TExtFunction; overload;
    function GetStore : TExtFunction;
  end;

  TExtUtilFilter = class(TExtAbstractComponent)
  private
    FAnyMatch : Boolean;
    FCaseSensitive : Boolean;
    FDisabled : Boolean;
    FExactMatch : Boolean;
    FFilterFn : TExtFunction;
    FId : String;
    FOperator : String;
    FPropertyJS : String;
    FRoot : String;
    FValue : String;
    procedure SetFAnyMatch(Value : Boolean);
    procedure SetFCaseSensitive(Value : Boolean);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFExactMatch(Value : Boolean);
    procedure SetFFilterFn(Value : TExtFunction);
    procedure SetFId(Value : String);
    procedure SetFOperator(Value : String);
    procedure SetFPropertyJS(Value : String);
    procedure SetFRoot(Value : String);
    procedure SetFValue(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function CreateFilterFn(Filters : TExtObjectList) : TExtFunction;
    function SetFilterFn(FilterFn : TExtFunction) : TExtFunction;
    function SetValue(Value : String) : TExtFunction;
    property AnyMatch : Boolean read FAnyMatch write SetFAnyMatch;
    property CaseSensitive : Boolean read FCaseSensitive write SetFCaseSensitive;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property ExactMatch : Boolean read FExactMatch write SetFExactMatch;
    property FilterFn : TExtFunction read FFilterFn write SetFFilterFn;
    property Id : String read FId write SetFId;
    property Operator : String read FOperator write SetFOperator;
    property PropertyJS : String read FPropertyJS write SetFPropertyJS;
    property Root : String read FRoot write SetFRoot;
    property Value : String read FValue write SetFValue;
  end;

  TExtUtilFloating = class(TExtAbstractComponent)
  private
    FConstrain : Boolean;
    FFixed : Boolean;
    FFocusOnToFront : Boolean;
    FShadow : String;
    FShadowBoolean : Boolean;
    FShadowOffset : Integer;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFFixed(Value : Boolean);
    procedure SetFFocusOnToFront(Value : Boolean);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFShadowOffset(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Center : TExtFunction;
    function DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : String = '') : TExtFunction; overload;
    function SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction;
    function ToBack : TExtFunction;
    function ToFront(PreventFocus : Boolean = false) : TExtFunction;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Fixed : Boolean read FFixed write SetFFixed;
    property FocusOnToFront : Boolean read FFocusOnToFront write SetFFocusOnToFront;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property ShadowOffset : Integer read FShadowOffset write SetFShadowOffset;
  end;

  TExtUtilElementContainer = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddChildEls : TExtFunction;
    function RemoveChildEls(TestFn : TExtFunction) : TExtFunction;
  end;

  TExtUtilEvent = class(TExtAbstractComponent)
  private
    FIsEvent : Boolean;
    procedure SetFIsEvent(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsEvent : Boolean read FIsEvent write SetFIsEvent;
  end;

  TExtTipQuickTipManagerSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    function GetQuickTip : TExtFunction;
    function Init(AutoRender : Boolean = false; Config : TExtObject = nil) : TExtFunction;
    function IsEnabled : TExtFunction;
    function Register(Config : TExtObject) : TExtFunction;
    function Tips : TExtFunction;
    function Unregister(El : THTMLElement) : TExtFunction; overload;
    function Unregister(El : TExtElement) : TExtFunction; overload;
    function Unregister(El : String) : TExtFunction; overload;
  end;

  TExtUtilKeyMap = class(TExtAbstractComponent)
  private
    FBinding : TExtObjectList;
    FBindingFn : TExtFunction;
    FBindingHandler : TExtFunction;
    FBindingKey : String;
    FBindingKeyTArrayOfString : TArrayOfString;
    FEventName : String;
    FIgnoreInputFields : Boolean;
    FProcessEvent : TExtFunction;
    FProcessEventScope : TExtObject;
    FTarget : TExtComponent;
    FTargetElement : TExtElement;
    FTargetString : String;
    FTargetTHTMLElement : THTMLElement;
    procedure SetFBinding(Value : TExtObjectList);
    procedure SetFBindingFn(Value : TExtFunction);
    procedure SetFBindingHandler(Value : TExtFunction);
    procedure SetFBindingKey(Value : String);
    procedure SetFBindingKeyTArrayOfString(Value : TArrayOfString);
    procedure SetFEventName(Value : String);
    procedure SetFIgnoreInputFields(Value : Boolean);
    procedure SetFProcessEvent(Value : TExtFunction);
    procedure SetFProcessEventScope(Value : TExtObject);
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddBinding(Binding : TExtObjectList) : TExtFunction; overload;
    function AddBinding(Binding : TExtObject) : TExtFunction; overload;
    constructor Create;
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    function IsEnabled : TExtFunction;
    function On(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function On(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function On(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveBinding(Binding : TExtObject) : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    function Un(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function Un(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function Un(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    destructor Destroy; override;
    property Binding : TExtObjectList read FBinding write SetFBinding;
    property BindingFn : TExtFunction read FBindingFn write SetFBindingFn;
    property BindingHandler : TExtFunction read FBindingHandler write SetFBindingHandler;
    property BindingKey : String read FBindingKey write SetFBindingKey;
    property BindingKeyTArrayOfString : TArrayOfString read FBindingKeyTArrayOfString write SetFBindingKeyTArrayOfString;
    property EventName : String read FEventName write SetFEventName;
    property IgnoreInputFields : Boolean read FIgnoreInputFields write SetFIgnoreInputFields;
    property ProcessEvent : TExtFunction read FProcessEvent write SetFProcessEvent;
    property ProcessEventScope : TExtObject read FProcessEventScope write SetFProcessEventScope;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetElement : TExtElement read FTargetElement write SetFTargetElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
  end;

  TExtTemplate = class(TExtAbstractComponent)
  private
    FCompiled : Boolean;
    FDisableFormats : Boolean;
    FIsTemplate : Boolean;
    procedure SetFCompiled(Value : Boolean);
    procedure SetFDisableFormats(Value : Boolean);
    procedure SetFIsTemplate(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Append(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Append(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Apply(Values : TExtObjectList) : TExtFunction; overload;
    function Apply(Values : TExtObject) : TExtFunction; overload;
    function ApplyOut(Values : TExtObjectList; OutJS : TExtObjectList) : TExtFunction; overload;
    function ApplyOut(Values : TExtObject; OutJS : TExtObjectList) : TExtFunction; overload;
    function ApplyTemplate : TExtFunction;
    function Compile : TExtFunction;
    constructor Create(Html : String; Config : TExtObject = nil);
    function From(El : THTMLElement; Config : TExtObject = nil) : TExtFunction; overload;
    function From(El : String; Config : TExtObject = nil) : TExtFunction; overload;
    function InsertAfter(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertAfter(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertBefore(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function InsertFirst(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function Overwrite(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; overload;
    function SetJS(Html : String; Compile : Boolean = false) : TExtFunction;
    property Compiled : Boolean read FCompiled write SetFCompiled;
    property DisableFormats : Boolean read FDisableFormats write SetFDisableFormats;
    property IsTemplate : Boolean read FIsTemplate write SetFIsTemplate;
  end;

  TExtUtilKeyNav = class(TExtAbstractComponent)
  private
    FDefaultEventAction : String;
    FDisabled : Boolean;
    FEventName : String;
    FForceKeyDown : Boolean;
    FIgnoreInputFields : Boolean;
    FKeyMap : TExtUtilKeyMap;
    FProcessEvent : TExtFunction;
    FProcessEventScope : TExtObject;
    FTarget : TExtComponent;
    FTargetElement : TExtElement;
    FTargetString : String;
    FTargetTHTMLElement : THTMLElement;
    procedure SetFDefaultEventAction(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFEventName(Value : String);
    procedure SetFForceKeyDown(Value : Boolean);
    procedure SetFIgnoreInputFields(Value : Boolean);
    procedure SetFKeyMap(Value : TExtUtilKeyMap);
    procedure SetFProcessEvent(Value : TExtFunction);
    procedure SetFProcessEventScope(Value : TExtObject);
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property DefaultEventAction : String read FDefaultEventAction write SetFDefaultEventAction;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property EventName : String read FEventName write SetFEventName;
    property ForceKeyDown : Boolean read FForceKeyDown write SetFForceKeyDown;
    property IgnoreInputFields : Boolean read FIgnoreInputFields write SetFIgnoreInputFields;
    property KeyMap : TExtUtilKeyMap read FKeyMap write SetFKeyMap;
    property ProcessEvent : TExtFunction read FProcessEvent write SetFProcessEvent;
    property ProcessEventScope : TExtObject read FProcessEventScope write SetFProcessEventScope;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetElement : TExtElement read FTargetElement write SetFTargetElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
  end;

  // Procedural types for events TExtUtilHashMap
  TExtUtilHashMapOnAdd = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject) of object;
  TExtUtilHashMapOnClear = procedure(This : TExtUtilHashMap) of object;
  TExtUtilHashMapOnRemove = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject) of object;
  TExtUtilHashMapOnReplace = procedure(This : TExtUtilHashMap; Key : String; Value : TExtObject; Old : TExtObject) of object;

  TExtUtilHashMap = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FKeyFn : TExtFunction;
    FListeners : TExtObject;
    FOnAdd : TExtUtilHashMapOnAdd;
    FOnClear : TExtUtilHashMapOnClear;
    FOnRemove : TExtUtilHashMapOnRemove;
    FOnReplace : TExtUtilHashMapOnReplace;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFKeyFn(Value : TExtFunction);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnAdd(Value : TExtUtilHashMapOnAdd);
    procedure SetFOnClear(Value : TExtUtilHashMapOnClear);
    procedure SetFOnRemove(Value : TExtUtilHashMapOnRemove);
    procedure SetFOnReplace(Value : TExtUtilHashMapOnReplace);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Key : TExtObject; O : TExtObject = nil) : TExtFunction; overload;
    function Add(Key : String; O : TExtObject = nil) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Clear : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function Clone : TExtFunction;
    function Contains(Value : TExtObject) : TExtFunction;
    function ContainsKey(Key : String) : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function Get(Key : String) : TExtFunction;
    function GetCount : TExtFunction;
    function GetKey(O : TExtObject) : TExtFunction;
    function GetKeys : TExtFunction;
    function GetValues : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function Remove(O : TExtObject) : TExtFunction;
    function RemoveAtKey(Key : String) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Replace(Key : String; Value : TExtObject) : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property KeyFn : TExtFunction read FKeyFn write SetFKeyFn;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnAdd : TExtUtilHashMapOnAdd read FOnAdd write SetFOnAdd;
    property OnClear : TExtUtilHashMapOnClear read FOnClear write SetFOnClear;
    property OnRemove : TExtUtilHashMapOnRemove read FOnRemove write SetFOnRemove;
    property OnReplace : TExtUtilHashMapOnReplace read FOnReplace write SetFOnReplace;
  end;

  // Procedural types for events TExtUtilAbstractMixedCollection
  TExtUtilAbstractMixedCollectionOnAdd = procedure(Index : Integer; O : TExtObject; Key : String) of object;
  TExtUtilAbstractMixedCollectionOnClear = procedure of object;
  TExtUtilAbstractMixedCollectionOnRemove = procedure(O : TExtObject; Key : String = '') of object;
  TExtUtilAbstractMixedCollectionOnReplace = procedure(Key : String; Old : TExtObject; New : TExtObject) of object;

  TExtUtilAbstractMixedCollection = class(TExtAbstractComponent)
  private
    FAllowFunctions : Boolean;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsMixedCollection : Boolean;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FOnAdd : TExtUtilAbstractMixedCollectionOnAdd;
    FOnClear : TExtUtilAbstractMixedCollectionOnClear;
    FOnRemove : TExtUtilAbstractMixedCollectionOnRemove;
    FOnReplace : TExtUtilAbstractMixedCollectionOnReplace;
    procedure SetFAllowFunctions(Value : Boolean);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsMixedCollection(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnAdd(Value : TExtUtilAbstractMixedCollectionOnAdd);
    procedure SetFOnClear(Value : TExtUtilAbstractMixedCollectionOnClear);
    procedure SetFOnRemove(Value : TExtUtilAbstractMixedCollectionOnRemove);
    procedure SetFOnReplace(Value : TExtUtilAbstractMixedCollectionOnReplace);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Key : TExtObject; Obj : TExtObject = nil) : TExtFunction; overload;
    function Add(Key : String; Obj : TExtObject = nil) : TExtFunction; overload;
    function AddAll(Objs : TExtObjectList) : TExtFunction; overload;
    function AddAll(Objs : TExtObject) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Clear : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function Clone : TExtFunction;
    function Collect(PropertyJS : String; Root : String = ''; AllowBlank : Boolean = false) : TExtFunction;
    function Contains(O : TExtObject) : TExtFunction;
    function ContainsKey(Key : String) : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function EachKey(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function Filter(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function Filter(PropertyJS : TExtObjectList; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function Filter(PropertyJS : TExtObjectList; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function Filter(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function FilterBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function FindBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function FindIndex(PropertyJS : String; Value : TRegExp; Start : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function FindIndex(PropertyJS : String; Value : String; Start : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; overload;
    function FindIndexBy(Fn : TExtFunction; Scope : TExtObject = nil; Start : Integer = 0) : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function First : TExtFunction;
    function Get(Key : String) : TExtFunction; overload;
    function Get(Key : Integer) : TExtFunction; overload;
    function GetAt(Index : Integer) : TExtFunction;
    function GetByKey(Key : String) : TExtFunction; overload;
    function GetByKey(Key : Integer) : TExtFunction; overload;
    function GetCount : TExtFunction;
    function GetRange(StartIndex : Integer = 0; EndIndex : Integer = 0) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function IndexOf(O : TExtObject) : TExtFunction;
    function IndexOfKey(Key : String) : TExtFunction;
    function Insert(Index : Integer; Key : String; O : TExtObjectList) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TExtObjectList; O : TExtObjectList) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TExtObjectList; O : TExtObject = nil) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TExtObject; O : TExtObjectList) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TExtObject; O : TExtObject = nil) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TArrayOfString; O : TExtObjectList) : TExtFunction; overload;
    function Insert(Index : Integer; Key : TArrayOfString; O : TExtObject = nil) : TExtFunction; overload;
    function Insert(Index : Integer; Key : String; O : TExtObject = nil) : TExtFunction; overload;
    function Last : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function Remove(O : TExtObject) : TExtFunction;
    function RemoveAll(Items : TExtObjectList = nil) : TExtFunction;
    function RemoveAt(Index : Integer) : TExtFunction;
    function RemoveAtKey(Key : String) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveRange(Index : Integer; RemoveCount : Integer = 0) : TExtFunction;
    function Replace(Key : String; O : TExtObject = nil) : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function Sum(PropertyJS : String; Root : String = ''; Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function UpdateKey(OldKey : TExtObject; NewKey : TExtObject) : TExtFunction;
    property AllowFunctions : Boolean read FAllowFunctions write SetFAllowFunctions;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsMixedCollection : Boolean read FIsMixedCollection write SetFIsMixedCollection;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnAdd : TExtUtilAbstractMixedCollectionOnAdd read FOnAdd write SetFOnAdd;
    property OnClear : TExtUtilAbstractMixedCollectionOnClear read FOnClear write SetFOnClear;
    property OnRemove : TExtUtilAbstractMixedCollectionOnRemove read FOnRemove write SetFOnRemove;
    property OnReplace : TExtUtilAbstractMixedCollectionOnReplace read FOnReplace write SetFOnReplace;
  end;

  TExtUtilInflectorSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Classify(Word : String) : TExtFunction;
    function ClearPlurals : TExtFunction;
    function ClearSingulars : TExtFunction;
    function IsTransnumeral(Word : String) : TExtFunction;
    function Ordinalize(Number : Integer) : TExtFunction;
    function Plural(Matcher : TRegExp; Replacer : String) : TExtFunction;
    function Pluralize(Word : String) : TExtFunction;
    function Singular(Matcher : TRegExp; Replacer : String) : TExtFunction;
    function Singularize(Word : String) : TExtFunction;
  end;

  // Procedural types for events TExtUtilHistorySingleton
  TExtUtilHistorySingletonOnChange = procedure(Token : String) of object;
  TExtUtilHistorySingletonOnReady = procedure(The : TExtUtilHistory) of object;

  TExtUtilHistorySingleton = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FOnChange : TExtUtilHistorySingletonOnChange;
    FOnReady : TExtUtilHistorySingletonOnReady;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnChange(Value : TExtUtilHistorySingletonOnChange);
    procedure SetFOnReady(Value : TExtUtilHistorySingletonOnReady);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Token : String; PreventDuplicates : Boolean = false) : TExtFunction;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Back : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function Forward : TExtFunction;
    function GetToken : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Init(OnReady : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnChange : TExtUtilHistorySingletonOnChange read FOnChange write SetFOnChange;
    property OnReady : TExtUtilHistorySingletonOnReady read FOnReady write SetFOnReady;
  end;

  TExtRtlPanelHeader = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomElement_position = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomElement_scroll = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomElement_anim = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomElement_insertion = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlEventObjectImpl = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlFormFieldSpinner = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomElement_static = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDomLayer = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtPerfAccumulator = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtPerfMonitorSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtPanelProxy = class(TExtAbstractComponent)
  private
    FInsertProxy : Boolean;
    FMoveOnDrag : Boolean;
    procedure SetFInsertProxy(Value : Boolean);
    procedure SetFMoveOnDrag(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Panel : TExtPanel; Config : TExtObject = nil);
    function GetEl : TExtFunction;
    function GetGhost : TExtFunction;
    function GetProxy : TExtFunction;
    function Hide : TExtFunction;
    function MoveProxy(ParentNode : THTMLElement; Before : THTMLElement = nil) : TExtFunction;
    function Show : TExtFunction;
    property InsertProxy : Boolean read FInsertProxy write SetFInsertProxy;
    property MoveOnDrag : Boolean read FMoveOnDrag write SetFMoveOnDrag;
  end;

  TExtUtilObservable = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
  end;

  TExtRtlButton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlDdDD = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtResizer
  TExtResizerOnBeforeresize = procedure(This : TExtResizer; Width : Integer; Height : Integer; E : TExtEventObject) of object;
  TExtResizerOnResize = procedure(This : TExtResizer; Width : Integer; Height : Integer; E : TExtEventObject) of object;
  TExtResizerOnResizedrag = procedure(This : TExtResizer; Width : Integer; Height : Integer; E : TExtEventObject) of object;

  TExtResizer = class(TExtAbstractComponent)
  private
    FConstrainTo : TExtElement;
    FConstrainToRegion : TExtUtilRegion;
    FDynamic : Boolean;
    FEl : TExtElement;
    FGlobalEvents : TExtUtilObservable;
    FHandles : String; // 's e se'
    FHasListeners : TExtObject;
    FHeight : Integer;
    FHeightIncrement : Integer;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FMaxHeight : Integer;
    FMaxWidth : Integer;
    FMinHeight : Integer;
    FMinWidth : Integer;
    FOriginalTarget : TExtElement;
    FOriginalTargetComponent : TExtComponent;
    FPinned : Boolean;
    FPreserveRatio : Boolean;
    FResizeTracker : TExtResizerResizeTracker;
    FTarget : TExtElement;
    FTargetComponent : TExtComponent;
    FTransparent : Boolean;
    FWidth : Integer;
    FWidthIncrement : Integer;
    FOnBeforeresize : TExtResizerOnBeforeresize;
    FOnResize : TExtResizerOnResize;
    FOnResizedrag : TExtResizerOnResizedrag;
    procedure SetFConstrainTo(Value : TExtElement);
    procedure SetFConstrainToRegion(Value : TExtUtilRegion);
    procedure SetFDynamic(Value : Boolean);
    procedure SetFEl(Value : TExtElement);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHandles(Value : String);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHeight(Value : Integer);
    procedure SetFHeightIncrement(Value : Integer);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFMaxHeight(Value : Integer);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFMinHeight(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFOriginalTarget(Value : TExtElement);
    procedure SetFOriginalTargetComponent(Value : TExtComponent);
    procedure SetFPinned(Value : Boolean);
    procedure SetFPreserveRatio(Value : Boolean);
    procedure SetFResizeTracker(Value : TExtResizerResizeTracker);
    procedure SetFTarget(Value : TExtElement);
    procedure SetFTargetComponent(Value : TExtComponent);
    procedure SetFTransparent(Value : Boolean);
    procedure SetFWidth(Value : Integer);
    procedure SetFWidthIncrement(Value : Integer);
    procedure SetFOnBeforeresize(Value : TExtResizerOnBeforeresize);
    procedure SetFOnResize(Value : TExtResizerOnResize);
    procedure SetFOnResizedrag(Value : TExtResizerOnResizedrag);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetEl : TExtFunction;
    function GetTarget : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResizeTo(Width : Integer; Height : Integer) : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property ConstrainTo : TExtElement read FConstrainTo write SetFConstrainTo;
    property ConstrainToRegion : TExtUtilRegion read FConstrainToRegion write SetFConstrainToRegion;
    property Dynamic : Boolean read FDynamic write SetFDynamic;
    property El : TExtElement read FEl write SetFEl;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property Handles : String read FHandles write SetFHandles;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Height : Integer read FHeight write SetFHeight;
    property HeightIncrement : Integer read FHeightIncrement write SetFHeightIncrement;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property MaxHeight : Integer read FMaxHeight write SetFMaxHeight;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property MinHeight : Integer read FMinHeight write SetFMinHeight;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property OriginalTarget : TExtElement read FOriginalTarget write SetFOriginalTarget;
    property OriginalTargetComponent : TExtComponent read FOriginalTargetComponent write SetFOriginalTargetComponent;
    property Pinned : Boolean read FPinned write SetFPinned;
    property PreserveRatio : Boolean read FPreserveRatio write SetFPreserveRatio;
    property ResizeTracker : TExtResizerResizeTracker read FResizeTracker write SetFResizeTracker;
    property Target : TExtElement read FTarget write SetFTarget;
    property TargetComponent : TExtComponent read FTargetComponent write SetFTargetComponent;
    property Transparent : Boolean read FTransparent write SetFTransparent;
    property Width : Integer read FWidth write SetFWidth;
    property WidthIncrement : Integer read FWidthIncrement write SetFWidthIncrement;
    property OnBeforeresize : TExtResizerOnBeforeresize read FOnBeforeresize write SetFOnBeforeresize;
    property OnResize : TExtResizerOnResize read FOnResize write SetFOnResize;
    property OnResizedrag : TExtResizerOnResizedrag read FOnResizedrag write SetFOnResizedrag;
  end;

  TExtRtlAbstractComponent = class(TExtAbstractComponent)
  private
    FRtl : Boolean;
    procedure SetFRtl(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Rtl : Boolean read FRtl write SetFRtl;
  end;

  TExtRtlLayoutContainerBoxOverflowScroller = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContainerColumn = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContainerAbsolute = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContainerBox = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContextItem = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlPanel = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContainerHBox = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutContainerVBox = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlGridPluginHeaderResizer = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlGridPluginRowEditing = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlFormFieldTrigger = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlGridColumn = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutComponentFieldText = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutComponentFieldTrigger = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlGridRowEditor = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtRtlLayoutComponentDock = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtDataBatch
  TExtDataBatchOnComplete = procedure(Batch : TExtDataBatch; Operation : TExtObject) of object;
  TExtDataBatchOnException = procedure(Batch : TExtDataBatch; Operation : TExtObject) of object;
  TExtDataBatchOnOperationcomplete = procedure(Batch : TExtDataBatch; Operation : TExtObject) of object;

  TExtDataBatch = class(TExtAbstractComponent)
  private
    FAutoStart : Boolean;
    FCurrent : Integer;
    FExceptions : TExtObjectList;
    FGlobalEvents : TExtUtilObservable;
    FHasException : Boolean;
    FHasListeners : TExtObject;
    FIsComplete : Boolean;
    FIsObservable : Boolean;
    FIsRunning : Boolean;
    FListeners : TExtObject;
    FOperations : TExtObjectList;
    FPauseOnException : Boolean;
    FTotal : Integer;
    FOnComplete : TExtDataBatchOnComplete;
    FOnException : TExtDataBatchOnException;
    FOnOperationcomplete : TExtDataBatchOnOperationcomplete;
    procedure SetFAutoStart(Value : Boolean);
    procedure SetFCurrent(Value : Integer);
    procedure SetFExceptions(Value : TExtObjectList);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasException(Value : Boolean);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsComplete(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIsRunning(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOperations(Value : TExtObjectList);
    procedure SetFPauseOnException(Value : Boolean);
    procedure SetFTotal(Value : Integer);
    procedure SetFOnComplete(Value : TExtDataBatchOnComplete);
    procedure SetFOnException(Value : TExtDataBatchOnException);
    procedure SetFOnOperationcomplete(Value : TExtDataBatchOnOperationcomplete);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Operation : TExtObject) : TExtFunction;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function Pause : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function Retry : TExtFunction;
    function RunOperation(Index : Integer) : TExtFunction;
    function Start : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property AutoStart : Boolean read FAutoStart write SetFAutoStart;
    property Current : Integer read FCurrent write SetFCurrent;
    property Exceptions : TExtObjectList read FExceptions write SetFExceptions;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasException : Boolean read FHasException write SetFHasException;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsComplete : Boolean read FIsComplete write SetFIsComplete;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property IsRunning : Boolean read FIsRunning write SetFIsRunning;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Operations : TExtObjectList read FOperations write SetFOperations;
    property PauseOnException : Boolean read FPauseOnException write SetFPauseOnException;
    property Total : Integer read FTotal write SetFTotal;
    property OnComplete : TExtDataBatchOnComplete read FOnComplete write SetFOnComplete;
    property OnException : TExtDataBatchOnException read FOnException write SetFOnException;
    property OnOperationcomplete : TExtDataBatchOnOperationcomplete read FOnOperationcomplete write SetFOnOperationcomplete;
  end;

  TExtDataAssociationHasOne = class(TExtAbstractComponent)
  private
    FForeignKey : String; // '_id'
    FGetterName : String; // 'get'
    FSetterName : String; // 'set'
    FTypeJS : String;
    procedure SetFForeignKey(Value : String);
    procedure SetFGetterName(Value : String);
    procedure SetFSetterName(Value : String);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property GetterName : String read FGetterName write SetFGetterName;
    property SetterName : String read FSetterName write SetFSetterName;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  // Procedural types for events TExtDataConnection
  TExtDataConnectionOnBeforerequest = procedure(Conn : TExtDataConnection; Options : TExtObject) of object;
  TExtDataConnectionOnRequestcomplete = procedure(Conn : TExtDataConnection; Response : TExtObject; Options : TExtObject) of object;
  TExtDataConnectionOnRequestexception = procedure(Conn : TExtDataConnection; Response : TExtObject; Options : TExtObject) of object;

  TExtDataConnection = class(TExtAbstractComponent)
  private
    FAutoAbort : Boolean;
    FBinary : Boolean;
    FCors : Boolean;
    FDefaultHeaders : TExtObject;
    FDisableCaching : Boolean;
    FDisableCachingParam : String;
    FExtraParams : TExtObject;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FMethod : String;
    FTimeout : Integer;
    FWithCredentials : Boolean;
    FOnBeforerequest : TExtDataConnectionOnBeforerequest;
    FOnRequestcomplete : TExtDataConnectionOnRequestcomplete;
    FOnRequestexception : TExtDataConnectionOnRequestexception;
    procedure SetFAutoAbort(Value : Boolean);
    procedure SetFBinary(Value : Boolean);
    procedure SetFCors(Value : Boolean);
    procedure SetFDefaultHeaders(Value : TExtObject);
    procedure SetFDisableCaching(Value : Boolean);
    procedure SetFDisableCachingParam(Value : String);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFMethod(Value : String);
    procedure SetFTimeout(Value : Integer);
    procedure SetFWithCredentials(Value : Boolean);
    procedure SetFOnBeforerequest(Value : TExtDataConnectionOnBeforerequest);
    procedure SetFOnRequestcomplete(Value : TExtDataConnectionOnRequestcomplete);
    procedure SetFOnRequestexception(Value : TExtDataConnectionOnRequestexception);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort(Request : TExtObject = nil) : TExtFunction;
    function AbortAll : TExtFunction;
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function IsLoading(Request : TExtObject = nil) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function ParseStatus(Status : Integer) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Request(Options : TExtObject) : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetOptions(Options : TExtObject; Scope : TExtObject) : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function Upload(Form : THTMLElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    function Upload(Form : TExtElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    function Upload(Form : String; Url : String; Params : String; Options : TExtObject) : TExtFunction; overload;
    destructor Destroy; override;
    property AutoAbort : Boolean read FAutoAbort write SetFAutoAbort;
    property Binary : Boolean read FBinary write SetFBinary;
    property Cors : Boolean read FCors write SetFCors;
    property DefaultHeaders : TExtObject read FDefaultHeaders write SetFDefaultHeaders;
    property DisableCaching : Boolean read FDisableCaching write SetFDisableCaching;
    property DisableCachingParam : String read FDisableCachingParam write SetFDisableCachingParam;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Method : String read FMethod write SetFMethod;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property WithCredentials : Boolean read FWithCredentials write SetFWithCredentials;
    property OnBeforerequest : TExtDataConnectionOnBeforerequest read FOnBeforerequest write SetFOnBeforerequest;
    property OnRequestcomplete : TExtDataConnectionOnRequestcomplete read FOnRequestcomplete write SetFOnRequestcomplete;
    property OnRequestexception : TExtDataConnectionOnRequestexception read FOnRequestexception write SetFOnRequestexception;
  end;

  TExtDataFlashBinaryXhr = class(TExtAbstractComponent)
  private
    FReadyState : Integer;
    FResponseBytes : TExtObjectList;
    FStatus : Integer;
    procedure SetFReadyState(Value : Integer);
    procedure SetFResponseBytes(Value : TExtObjectList);
    procedure SetFStatus(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort : TExtFunction;
    constructor Create;
    function GetAllResponseHeaders : TExtFunction;
    function GetResponseHeader : TExtFunction;
    function Open : TExtFunction;
    function OverrideMimeType : TExtFunction;
    function Send(Body : TExtObjectList) : TExtFunction;
    function SetRequestHeader : TExtFunction;
    destructor Destroy; override;
    property ReadyState : Integer read FReadyState write SetFReadyState;
    property ResponseBytes : TExtObjectList read FResponseBytes write SetFResponseBytes;
    property Status : Integer read FStatus write SetFStatus;
  end;

  TExtDataField = class(TExtAbstractComponent)
  private
    FConvert : TExtFunction;
    FDateFormat : String;
    FDateReadFormat : String;
    FDateWriteFormat : String;
    FDefaultValue : TExtObject;
    FMapping : Integer;
    FMappingString : String;
    FName : String;
    FPersist : Boolean; // true
    FSerialize : TExtFunction;
    FSortDir : String; // 'ASC'
    FSortType : TExtFunction;
    FSortTypeString : String;
    FTypeJS : String;
    FTypeJSObject : TExtObject;
    FUseNull : Boolean;
    procedure SetFConvert(Value : TExtFunction);
    procedure SetFDateFormat(Value : String);
    procedure SetFDateReadFormat(Value : String);
    procedure SetFDateWriteFormat(Value : String);
    procedure SetFDefaultValue(Value : TExtObject);
    procedure SetFMapping(Value : Integer);
    procedure SetFMappingString(Value : String);
    procedure SetFName(Value : String);
    procedure SetFPersist(Value : Boolean);
    procedure SetFSerialize(Value : TExtFunction);
    procedure SetFSortDir(Value : String);
    procedure SetFSortType(Value : TExtFunction);
    procedure SetFSortTypeString(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFTypeJSObject(Value : TExtObject);
    procedure SetFUseNull(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Convert : TExtFunction read FConvert write SetFConvert;
    property DateFormat : String read FDateFormat write SetFDateFormat;
    property DateReadFormat : String read FDateReadFormat write SetFDateReadFormat;
    property DateWriteFormat : String read FDateWriteFormat write SetFDateWriteFormat;
    property DefaultValue : TExtObject read FDefaultValue write SetFDefaultValue;
    property Mapping : Integer read FMapping write SetFMapping;
    property MappingString : String read FMappingString write SetFMappingString;
    property Name : String read FName write SetFName;
    property Persist : Boolean read FPersist write SetFPersist;
    property Serialize : TExtFunction read FSerialize write SetFSerialize;
    property SortDir : String read FSortDir write SetFSortDir;
    property SortType : TExtFunction read FSortType write SetFSortType;
    property SortTypeString : String read FSortTypeString write SetFSortTypeString;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property TypeJSObject : TExtObject read FTypeJSObject write SetFTypeJSObject;
    property UseNull : Boolean read FUseNull write SetFUseNull;
  end;

  TExtDataAssociationHasMany = class(TExtAbstractComponent)
  private
    FFilterProperty : String;
    FForeignKey : String; // '_id'
    FName : String;
    FStoreConfig : TExtObject;
    FTypeJS : String;
    procedure SetFFilterProperty(Value : String);
    procedure SetFForeignKey(Value : String);
    procedure SetFName(Value : String);
    procedure SetFStoreConfig(Value : TExtObject);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FilterProperty : String read FFilterProperty write SetFFilterProperty;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property Name : String read FName write SetFName;
    property StoreConfig : TExtObject read FStoreConfig write SetFStoreConfig;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtContainerMonitor = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtContainerDockingContainer
  TExtContainerDockingContainerOnDockedadd = procedure(This : TExtContainerDockingContainer; Component : TExtComponent; Index : Integer) of object;
  TExtContainerDockingContainerOnDockedremove = procedure(This : TExtContainerDockingContainer; Component : TExtComponent) of object;

  TExtContainerDockingContainer = class(TExtAbstractComponent)
  private
    FDefaultDockWeights : TExtObject;
    FOnDockedadd : TExtContainerDockingContainerOnDockedadd;
    FOnDockedremove : TExtContainerDockingContainerOnDockedremove;
    procedure SetFDefaultDockWeights(Value : TExtObject);
    procedure SetFOnDockedadd(Value : TExtContainerDockingContainerOnDockedadd);
    procedure SetFOnDockedremove(Value : TExtContainerDockingContainerOnDockedremove);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; overload;
    function AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; overload;
    constructor Create;
    function GetDockedComponent(Comp : String) : TExtFunction; overload;
    function GetDockedComponent(Comp : Integer) : TExtFunction; overload;
    function GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction;
    function InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; overload;
    function InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; overload;
    function RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property DefaultDockWeights : TExtObject read FDefaultDockWeights write SetFDefaultDockWeights;
    property OnDockedadd : TExtContainerDockingContainerOnDockedadd read FOnDockedadd write SetFOnDockedadd;
    property OnDockedremove : TExtContainerDockingContainerOnDockedremove read FOnDockedremove write SetFOnDockedremove;
  end;

  // Procedural types for events TExtDataAbstractStore
  TExtDataAbstractStoreOnAdd = procedure(Store : TExtDataStore; Records : TExtObjectList; Index : Integer) of object;
  TExtDataAbstractStoreOnBeforeload = procedure(Store : TExtDataStore; Operation : TExtDataOperation) of object;
  TExtDataAbstractStoreOnBeforesync = procedure(Options : TExtObject) of object;
  TExtDataAbstractStoreOnBulkremove = procedure(Store : TExtDataStore; Records : TExtObjectList; Indexes : TArrayOfInteger; IsMove : Boolean) of object;
  TExtDataAbstractStoreOnClear = procedure(This : TExtDataAbstractStore) of object;
  TExtDataAbstractStoreOnDatachanged = procedure(This : TExtDataAbstractStore) of object;
  TExtDataAbstractStoreOnLoad = procedure(This : TExtDataAbstractStore; Records : TExtObjectList; Successful : Boolean) of object;
  TExtDataAbstractStoreOnMetachange = procedure(This : TExtDataAbstractStore; Meta : TExtObject) of object;
  TExtDataAbstractStoreOnRefresh = procedure(This : TExtDataAbstractStore) of object;
  TExtDataAbstractStoreOnRemove = procedure(Store : TExtDataStore; RecordJS : TExtDataModel; Index : Integer; IsMove : Boolean) of object;
  TExtDataAbstractStoreOnUpdate = procedure(This : TExtDataAbstractStore; RecordJS : TExtDataModel; Operation : String; ModifiedFieldNames : TArrayOfString) of object;
  TExtDataAbstractStoreOnWrite = procedure(Store : TExtDataStore; Operation : TExtDataOperation) of object;

  TExtDataAbstractStore = class(TExtAbstractComponent)
  private
    FAutoLoad : Boolean;
    FAutoLoadObject : TExtObject;
    FAutoSync : Boolean;
    FBatchUpdateMode : String;
    FDefaultProxyType : String;
    FDefaultSortDirection : String;
    FFields : TExtObjectList;
    FFilterOnLoad : Boolean; // true
    FFilters : TExtObjectList;
    FFiltersList : TExtObjectList;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsDestroyed : Boolean;
    FIsObservable : Boolean;
    FIsSortable : Boolean;
    FIsStore : Boolean;
    FListeners : TExtObject;
    FModel : String;
    FProxy : String;
    FProxyObject : TExtObject;
    FProxyProxy : TExtDataProxy;
    FRemoteFilter : Boolean;
    FRemoteSort : Boolean;
    FSorters : TExtObjectList;
    FSortersList : TExtObjectList;
    FSortOnLoad : Boolean; // true
    FSortRoot : String;
    FStatefulFilters : Boolean;
    FStoreId : String;
    FOnAdd : TExtDataAbstractStoreOnAdd;
    FOnBeforeload : TExtDataAbstractStoreOnBeforeload;
    FOnBeforesync : TExtDataAbstractStoreOnBeforesync;
    FOnBulkremove : TExtDataAbstractStoreOnBulkremove;
    FOnClear : TExtDataAbstractStoreOnClear;
    FOnDatachanged : TExtDataAbstractStoreOnDatachanged;
    FOnLoad : TExtDataAbstractStoreOnLoad;
    FOnMetachange : TExtDataAbstractStoreOnMetachange;
    FOnRefresh : TExtDataAbstractStoreOnRefresh;
    FOnRemove : TExtDataAbstractStoreOnRemove;
    FOnUpdate : TExtDataAbstractStoreOnUpdate;
    FOnWrite : TExtDataAbstractStoreOnWrite;
    procedure SetFAutoLoad(Value : Boolean);
    procedure SetFAutoLoadObject(Value : TExtObject);
    procedure SetFAutoSync(Value : Boolean);
    procedure SetFBatchUpdateMode(Value : String);
    procedure SetFDefaultProxyType(Value : String);
    procedure SetFDefaultSortDirection(Value : String);
    procedure SetFFields(Value : TExtObjectList);
    procedure SetFFilterOnLoad(Value : Boolean);
    procedure SetFFilters(Value : TExtObjectList);
    procedure SetFFiltersList(Value : TExtObjectList);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsDestroyed(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIsSortable(Value : Boolean);
    procedure SetFIsStore(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFModel(Value : String);
    procedure SetFProxy(Value : String);
    procedure SetFProxyObject(Value : TExtObject);
    procedure SetFProxyProxy(Value : TExtDataProxy);
    procedure SetFRemoteFilter(Value : Boolean);
    procedure SetFRemoteSort(Value : Boolean);
    procedure SetFSorters(Value : TExtObjectList);
    procedure SetFSortersList(Value : TExtObjectList);
    procedure SetFSortOnLoad(Value : Boolean);
    procedure SetFSortRoot(Value : String);
    procedure SetFStatefulFilters(Value : Boolean);
    procedure SetFStoreId(Value : String);
    procedure SetFOnAdd(Value : TExtDataAbstractStoreOnAdd);
    procedure SetFOnBeforeload(Value : TExtDataAbstractStoreOnBeforeload);
    procedure SetFOnBeforesync(Value : TExtDataAbstractStoreOnBeforesync);
    procedure SetFOnBulkremove(Value : TExtDataAbstractStoreOnBulkremove);
    procedure SetFOnClear(Value : TExtDataAbstractStoreOnClear);
    procedure SetFOnDatachanged(Value : TExtDataAbstractStoreOnDatachanged);
    procedure SetFOnLoad(Value : TExtDataAbstractStoreOnLoad);
    procedure SetFOnMetachange(Value : TExtDataAbstractStoreOnMetachange);
    procedure SetFOnRefresh(Value : TExtDataAbstractStoreOnRefresh);
    procedure SetFOnRemove(Value : TExtDataAbstractStoreOnRemove);
    procedure SetFOnUpdate(Value : TExtDataAbstractStoreOnUpdate);
    procedure SetFOnWrite(Value : TExtDataAbstractStoreOnWrite);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Store : TExtObject); overload;
    constructor Create(Store : TExtDataAbstractStore); overload;
    function CreateComparator(Sorters : TExtObjectList) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GenerateComparator : TExtFunction;
    function GetModifiedRecords : TExtFunction;
    function GetNewRecords : TExtFunction;
    function GetProxy : TExtFunction;
    function GetRemovedRecords : TExtFunction;
    function GetUpdatedRecords : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function InitSortable : TExtFunction;
    function Load(Options : TExtObject = nil) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function Reload(Options : TExtObject) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeAutoSync : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetProxy(Proxy : TExtObject) : TExtFunction; overload;
    function SetProxy(Proxy : TExtDataProxy) : TExtFunction; overload;
    function SetProxy(Proxy : String) : TExtFunction; overload;
    function Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; overload;
    function Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; overload;
    function SuspendAutoSync : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function Sync(Options : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property AutoLoad : Boolean read FAutoLoad write SetFAutoLoad;
    property AutoLoadObject : TExtObject read FAutoLoadObject write SetFAutoLoadObject;
    property AutoSync : Boolean read FAutoSync write SetFAutoSync;
    property BatchUpdateMode : String read FBatchUpdateMode write SetFBatchUpdateMode;
    property DefaultProxyType : String read FDefaultProxyType write SetFDefaultProxyType;
    property DefaultSortDirection : String read FDefaultSortDirection write SetFDefaultSortDirection;
    property Fields : TExtObjectList read FFields write SetFFields;
    property FilterOnLoad : Boolean read FFilterOnLoad write SetFFilterOnLoad;
    property Filters : TExtObjectList read FFilters write SetFFilters;
    property FiltersList : TExtObjectList read FFiltersList write SetFFiltersList;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsDestroyed : Boolean read FIsDestroyed write SetFIsDestroyed;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property IsSortable : Boolean read FIsSortable write SetFIsSortable;
    property IsStore : Boolean read FIsStore write SetFIsStore;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Model : String read FModel write SetFModel;
    property Proxy : String read FProxy write SetFProxy;
    property ProxyObject : TExtObject read FProxyObject write SetFProxyObject;
    property ProxyProxy : TExtDataProxy read FProxyProxy write SetFProxyProxy;
    property RemoteFilter : Boolean read FRemoteFilter write SetFRemoteFilter;
    property RemoteSort : Boolean read FRemoteSort write SetFRemoteSort;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
    property SortersList : TExtObjectList read FSortersList write SetFSortersList;
    property SortOnLoad : Boolean read FSortOnLoad write SetFSortOnLoad;
    property SortRoot : String read FSortRoot write SetFSortRoot;
    property StatefulFilters : Boolean read FStatefulFilters write SetFStatefulFilters;
    property StoreId : String read FStoreId write SetFStoreId;
    property OnAdd : TExtDataAbstractStoreOnAdd read FOnAdd write SetFOnAdd;
    property OnBeforeload : TExtDataAbstractStoreOnBeforeload read FOnBeforeload write SetFOnBeforeload;
    property OnBeforesync : TExtDataAbstractStoreOnBeforesync read FOnBeforesync write SetFOnBeforesync;
    property OnBulkremove : TExtDataAbstractStoreOnBulkremove read FOnBulkremove write SetFOnBulkremove;
    property OnClear : TExtDataAbstractStoreOnClear read FOnClear write SetFOnClear;
    property OnDatachanged : TExtDataAbstractStoreOnDatachanged read FOnDatachanged write SetFOnDatachanged;
    property OnLoad : TExtDataAbstractStoreOnLoad read FOnLoad write SetFOnLoad;
    property OnMetachange : TExtDataAbstractStoreOnMetachange read FOnMetachange write SetFOnMetachange;
    property OnRefresh : TExtDataAbstractStoreOnRefresh read FOnRefresh write SetFOnRefresh;
    property OnRemove : TExtDataAbstractStoreOnRemove read FOnRemove write SetFOnRemove;
    property OnUpdate : TExtDataAbstractStoreOnUpdate read FOnUpdate write SetFOnUpdate;
    property OnWrite : TExtDataAbstractStoreOnWrite read FOnWrite write SetFOnWrite;
  end;

  TExtDataAssociationBelongsTo = class(TExtAbstractComponent)
  private
    FForeignKey : String; // '_id'
    FGetterName : String; // 'get'
    FSetterName : String; // 'set'
    FTypeJS : String;
    procedure SetFForeignKey(Value : String);
    procedure SetFGetterName(Value : String);
    procedure SetFSetterName(Value : String);
    procedure SetFTypeJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property ForeignKey : String read FForeignKey write SetFForeignKey;
    property GetterName : String read FGetterName write SetFGetterName;
    property SetterName : String read FSetterName write SetFSetterName;
    property TypeJS : String read FTypeJS write SetFTypeJS;
  end;

  TExtDataAssociation = class(TExtAbstractComponent)
  private
    FAssociatedModel : String;
    FAssociatedName : String;
    FAssociationKey : String;
    FModel : String;
    FOwnerModel : String;
    FOwnerName : String;
    FPrimaryKey : String;
    FReader : TExtDataReader;
    procedure SetFAssociatedModel(Value : String);
    procedure SetFAssociatedName(Value : String);
    procedure SetFAssociationKey(Value : String);
    procedure SetFModel(Value : String);
    procedure SetFOwnerModel(Value : String);
    procedure SetFOwnerName(Value : String);
    procedure SetFPrimaryKey(Value : String);
    procedure SetFReader(Value : TExtDataReader);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function GetReader : TExtFunction;
    destructor Destroy; override;
    property AssociatedModel : String read FAssociatedModel write SetFAssociatedModel;
    property AssociatedName : String read FAssociatedName write SetFAssociatedName;
    property AssociationKey : String read FAssociationKey write SetFAssociationKey;
    property Model : String read FModel write SetFModel;
    property OwnerModel : String read FOwnerModel write SetFOwnerModel;
    property OwnerName : String read FOwnerName write SetFOwnerName;
    property PrimaryKey : String read FPrimaryKey write SetFPrimaryKey;
    property Reader : TExtDataReader read FReader write SetFReader;
  end;

  TExtDataRequest = class(TExtAbstractComponent)
  private
    FAction : String;
    FMethod : String;
    FParams : TExtObject;
    FUrl : String;
    procedure SetFAction(Value : String);
    procedure SetFMethod(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFUrl(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property Action : String read FAction write SetFAction;
    property Method : String read FMethod write SetFMethod;
    property Params : TExtObject read FParams write SetFParams;
    property Url : String read FUrl write SetFUrl;
  end;

  // Procedural types for events TExtDataReader
  TExtDataReaderOnException = procedure(Reader : TExtDataReader; Response : TXMLHttpRequest; Error : TExtDataResultSet) of object;

  TExtDataReader = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIdProperty : String;
    FImplicitIncludes : Boolean;
    FIsObservable : Boolean;
    FIsReader : Boolean;
    FListeners : TExtObject;
    FMessageProperty : String;
    FMetaData : TExtObject;
    FRawData : TExtObject;
    FReadRecordsOnFailure : Boolean;
    FRoot : String;
    FSuccessProperty : String;
    FTotalProperty : String;
    FOnException : TExtDataReaderOnException;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIdProperty(Value : String);
    procedure SetFImplicitIncludes(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIsReader(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFMessageProperty(Value : String);
    procedure SetFMetaData(Value : TExtObject);
    procedure SetFRawData(Value : TExtObject);
    procedure SetFReadRecordsOnFailure(Value : Boolean);
    procedure SetFRoot(Value : String);
    procedure SetFSuccessProperty(Value : String);
    procedure SetFTotalProperty(Value : String);
    procedure SetFOnException(Value : TExtDataReaderOnException);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetResponseData(Response : TExtObject) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function Read(Response : TExtObject) : TExtFunction;
    function ReadRecords(Data : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IdProperty : String read FIdProperty write SetFIdProperty;
    property ImplicitIncludes : Boolean read FImplicitIncludes write SetFImplicitIncludes;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property IsReader : Boolean read FIsReader write SetFIsReader;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property MessageProperty : String read FMessageProperty write SetFMessageProperty;
    property MetaData : TExtObject read FMetaData write SetFMetaData;
    property RawData : TExtObject read FRawData write SetFRawData;
    property ReadRecordsOnFailure : Boolean read FReadRecordsOnFailure write SetFReadRecordsOnFailure;
    property Root : String read FRoot write SetFRoot;
    property SuccessProperty : String read FSuccessProperty write SetFSuccessProperty;
    property TotalProperty : String read FTotalProperty write SetFTotalProperty;
    property OnException : TExtDataReaderOnException read FOnException write SetFOnException;
  end;

  TExtDataResultSet = class(TExtAbstractComponent)
  private
    FCount : Integer;
    FLoaded : Boolean;
    FRecords : TExtObjectList;
    FSuccess : Boolean;
    FTotal : Integer;
    procedure SetFCount(Value : Integer);
    procedure SetFLoaded(Value : Boolean);
    procedure SetFRecords(Value : TExtObjectList);
    procedure SetFSuccess(Value : Boolean);
    procedure SetFTotal(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property Count : Integer read FCount write SetFCount;
    property Loaded : Boolean read FLoaded write SetFLoaded;
    property Records : TExtObjectList read FRecords write SetFRecords;
    property Success : Boolean read FSuccess write SetFSuccess;
    property Total : Integer read FTotal write SetFTotal;
  end;

  // Procedural types for events TExtDataTree
  TExtDataTreeOnAppend = procedure of object;
  TExtDataTreeOnBeforeappend = procedure of object;
  TExtDataTreeOnBeforecollapse = procedure of object;
  TExtDataTreeOnBeforeexpand = procedure of object;
  TExtDataTreeOnBeforeinsert = procedure of object;
  TExtDataTreeOnBeforemove = procedure of object;
  TExtDataTreeOnBeforeremove = procedure of object;
  TExtDataTreeOnCollapse = procedure of object;
  TExtDataTreeOnExpand = procedure of object;
  TExtDataTreeOnInsert = procedure of object;
  TExtDataTreeOnMove = procedure of object;
  TExtDataTreeOnRemove = procedure of object;
  TExtDataTreeOnRootchange = procedure(Root : TExtDataModel) of object;
  TExtDataTreeOnSort = procedure of object;

  TExtDataTree = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FOnAppend : TExtDataTreeOnAppend;
    FOnBeforeappend : TExtDataTreeOnBeforeappend;
    FOnBeforecollapse : TExtDataTreeOnBeforecollapse;
    FOnBeforeexpand : TExtDataTreeOnBeforeexpand;
    FOnBeforeinsert : TExtDataTreeOnBeforeinsert;
    FOnBeforemove : TExtDataTreeOnBeforemove;
    FOnBeforeremove : TExtDataTreeOnBeforeremove;
    FOnCollapse : TExtDataTreeOnCollapse;
    FOnExpand : TExtDataTreeOnExpand;
    FOnInsert : TExtDataTreeOnInsert;
    FOnMove : TExtDataTreeOnMove;
    FOnRemove : TExtDataTreeOnRemove;
    FOnRootchange : TExtDataTreeOnRootchange;
    FOnSort : TExtDataTreeOnSort;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnAppend(Value : TExtDataTreeOnAppend);
    procedure SetFOnBeforeappend(Value : TExtDataTreeOnBeforeappend);
    procedure SetFOnBeforecollapse(Value : TExtDataTreeOnBeforecollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataTreeOnBeforeexpand);
    procedure SetFOnBeforeinsert(Value : TExtDataTreeOnBeforeinsert);
    procedure SetFOnBeforemove(Value : TExtDataTreeOnBeforemove);
    procedure SetFOnBeforeremove(Value : TExtDataTreeOnBeforeremove);
    procedure SetFOnCollapse(Value : TExtDataTreeOnCollapse);
    procedure SetFOnExpand(Value : TExtDataTreeOnExpand);
    procedure SetFOnInsert(Value : TExtDataTreeOnInsert);
    procedure SetFOnMove(Value : TExtDataTreeOnMove);
    procedure SetFOnRemove(Value : TExtDataTreeOnRemove);
    procedure SetFOnRootchange(Value : TExtDataTreeOnRootchange);
    procedure SetFOnSort(Value : TExtDataTreeOnSort);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create(Root : TExtDataNodeInterface = nil);
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetNodeById(Id : String) : TExtFunction;
    function GetRootNode : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveRootNode : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetRootNode(Node : TExtDataNodeInterface) : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnAppend : TExtDataTreeOnAppend read FOnAppend write SetFOnAppend;
    property OnBeforeappend : TExtDataTreeOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforecollapse : TExtDataTreeOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnBeforeexpand : TExtDataTreeOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforeinsert : TExtDataTreeOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnBeforemove : TExtDataTreeOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeremove : TExtDataTreeOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnCollapse : TExtDataTreeOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtDataTreeOnExpand read FOnExpand write SetFOnExpand;
    property OnInsert : TExtDataTreeOnInsert read FOnInsert write SetFOnInsert;
    property OnMove : TExtDataTreeOnMove read FOnMove write SetFOnMove;
    property OnRemove : TExtDataTreeOnRemove read FOnRemove write SetFOnRemove;
    property OnRootchange : TExtDataTreeOnRootchange read FOnRootchange write SetFOnRootchange;
    property OnSort : TExtDataTreeOnSort read FOnSort write SetFOnSort;
  end;

  TExtDataSortTypesSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AsDate(S : TExtObject) : TExtFunction;
    function AsFloat(S : TExtObject) : TExtFunction;
    function AsInt(S : TExtObject) : TExtFunction;
    function AsText(S : TExtObject) : TExtFunction;
    function AsUCString(S : TExtObject) : TExtFunction;
    function AsUCText(S : TExtObject) : TExtFunction;
  end;

  // Procedural types for events TExtDataProxy
  TExtDataProxyOnMetachange = procedure(This : TExtDataProxy; Meta : TExtObject) of object;

  TExtDataProxy = class(TExtAbstractComponent)
  private
    FBatchActions : Boolean; // true
    FBatchOrder : String; // 'create,update,destroy'
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FIsProxy : Boolean;
    FListeners : TExtObject;
    FModel : String;
    FModelModel : TExtDataModel;
    FReader : TExtObject;
    FReaderReader : TExtDataReader;
    FReaderString : String;
    FWriter : TExtObject;
    FWriterString : String;
    FWriterWriter : TExtDataWriter;
    FOnMetachange : TExtDataProxyOnMetachange;
    procedure SetFBatchActions(Value : Boolean);
    procedure SetFBatchOrder(Value : String);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFIsProxy(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFModel(Value : String);
    procedure SetFModelModel(Value : TExtDataModel);
    procedure SetFReader(Value : TExtObject);
    procedure SetFReaderReader(Value : TExtDataReader);
    procedure SetFReaderString(Value : String);
    procedure SetFWriter(Value : TExtObject);
    procedure SetFWriterString(Value : String);
    procedure SetFWriterWriter(Value : TExtDataWriter);
    procedure SetFOnMetachange(Value : TExtDataProxyOnMetachange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetModel : TExtFunction;
    function GetReader : TExtFunction;
    function GetWriter : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetModel(Model : TExtDataModel; SetOnStore : Boolean) : TExtFunction; overload;
    function SetModel(Model : String; SetOnStore : Boolean) : TExtFunction; overload;
    function SetReader(Reader : TExtObject) : TExtFunction; overload;
    function SetReader(Reader : TExtDataReader) : TExtFunction; overload;
    function SetReader(Reader : String) : TExtFunction; overload;
    function SetWriter(Writer : TExtObject) : TExtFunction; overload;
    function SetWriter(Writer : TExtDataWriter) : TExtFunction; overload;
    function SetWriter(Writer : String) : TExtFunction; overload;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property BatchActions : Boolean read FBatchActions write SetFBatchActions;
    property BatchOrder : String read FBatchOrder write SetFBatchOrder;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property IsProxy : Boolean read FIsProxy write SetFIsProxy;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Model : String read FModel write SetFModel;
    property ModelModel : TExtDataModel read FModelModel write SetFModelModel;
    property Reader : TExtObject read FReader write SetFReader;
    property ReaderReader : TExtDataReader read FReaderReader write SetFReaderReader;
    property ReaderString : String read FReaderString write SetFReaderString;
    property Writer : TExtObject read FWriter write SetFWriter;
    property WriterString : String read FWriterString write SetFWriterString;
    property WriterWriter : TExtDataWriter read FWriterWriter write SetFWriterWriter;
    property OnMetachange : TExtDataProxyOnMetachange read FOnMetachange write SetFOnMetachange;
  end;

  TExtDataJsonPSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort(Request : TExtObject) : TExtFunction; overload;
    function Abort(Request : String = '') : TExtFunction; overload;
    function Request(Options : TExtObject) : TExtFunction;
  end;

  TExtDataIdGenerator = class(TExtAbstractComponent)
  private
    FId : String;
    FIsGenerator : Boolean;
    procedure SetFId(Value : String);
    procedure SetFIsGenerator(Value : Boolean);
  public
    function JSClassName : string; override;
    class function All : TExtObject;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function Get(Config : TExtObject) : TExtFunction; overload;
    function Get(Config : String) : TExtFunction; overload;
    property Id : String read FId write SetFId;
    property IsGenerator : Boolean read FIsGenerator write SetFIsGenerator;
  end;

  // Procedural types for events TExtDataModel
  TExtDataModelOnIdchanged = procedure(This : TExtDataModel; OldId : Integer; NewId : Integer) of object;

  TExtDataModel = class(TExtAbstractComponent)
  private
    FAssociations : TExtObjectList;
    FBelongsTo : String;
    FBelongsToList : TExtObjectList;
    FBelongsToObject : TExtObject;
    FBelongsToTArrayOfString : TArrayOfString;
    FClientIdProperty : String;
    FDefaultProxyType : String; // 'ajax'
    FDirty : Boolean;
    FEditing : Boolean;
    FFields : TExtObjectList;
    FFieldsTArrayOfString : TArrayOfString;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FHasMany : String;
    FHasManyList : TExtObjectList;
    FHasManyObject : TExtObject;
    FHasManyTArrayOfString : TArrayOfString;
    FIdProperty : String; // 'id'
    FIdPropertyField : TExtDataField;
    FIdPropertyObject : TExtObject;
    FIsModel : Boolean;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FModified : TExtObject;
    FPhantom : Boolean;
    FProxy : String;
    FProxyObject : TExtObject;
    FProxyProxy : TExtDataProxy;
    FRaw : TExtObject;
    FStore : TExtDataStore;
    FStores : TExtObjectList;
    FValidations : TExtObjectList;
    FOnIdchanged : TExtDataModelOnIdchanged;
    procedure SetFAssociations(Value : TExtObjectList);
    procedure SetFBelongsTo(Value : String);
    procedure SetFBelongsToList(Value : TExtObjectList);
    procedure SetFBelongsToObject(Value : TExtObject);
    procedure SetFBelongsToTArrayOfString(Value : TArrayOfString);
    procedure SetFClientIdProperty(Value : String);
    procedure SetFDefaultProxyType(Value : String);
    procedure SetFDirty(Value : Boolean);
    procedure SetFEditing(Value : Boolean);
    procedure SetFFields(Value : TExtObjectList);
    procedure SetFFieldsTArrayOfString(Value : TArrayOfString);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHasMany(Value : String);
    procedure SetFHasManyList(Value : TExtObjectList);
    procedure SetFHasManyObject(Value : TExtObject);
    procedure SetFHasManyTArrayOfString(Value : TArrayOfString);
    procedure SetFIdProperty(Value : String);
    procedure SetFIdPropertyField(Value : TExtDataField);
    procedure SetFIdPropertyObject(Value : TExtObject);
    procedure SetFIsModel(Value : Boolean);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFModified(Value : TExtObject);
    procedure SetFPhantom(Value : Boolean);
    procedure SetFProxy(Value : String);
    procedure SetFProxyObject(Value : TExtObject);
    procedure SetFProxyProxy(Value : TExtDataProxy);
    procedure SetFRaw(Value : TExtObject);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFStores(Value : TExtObjectList);
    procedure SetFValidations(Value : TExtObjectList);
    procedure SetFOnIdchanged(Value : TExtDataModelOnIdchanged);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function BeginEdit : TExtFunction;
    function CancelEdit : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function Commit(Silent : Boolean = false; ModifiedFieldNames : TArrayOfString = nil) : TExtFunction;
    function Copy(Id : String = '') : TExtFunction;
    constructor Create(Data : TExtObjectList); overload;
    constructor Create; overload;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function EndEdit(Silent : Boolean = false; ModifiedFieldNames : TArrayOfString = nil) : TExtFunction;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function Get(FieldName : String) : TExtFunction;
    function GetAssociatedData : TExtFunction;
    function GetChanges : TExtFunction;
    function GetData(IncludeAssociated : Boolean) : TExtFunction;
    function GetFields : TExtFunction;
    function GetId : TExtFunction;
    function GetProxy : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function IsModified(FieldName : String) : TExtFunction;
    function IsValid : TExtFunction;
    function Join(Store : TExtDataStore) : TExtFunction;
    function Load(Id : String; Config : TExtObject = nil) : TExtFunction; overload;
    function Load(Id : Integer; Config : TExtObject = nil) : TExtFunction; overload;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function Reject(Silent : Boolean = false) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function Save(Options : TExtObject = nil) : TExtFunction;
    function SetDirty : TExtFunction;
    function SetFields : TExtFunction;
    function SetId(Id : String) : TExtFunction; overload;
    function SetId(Id : Integer) : TExtFunction; overload;
    function SetJS(FieldName : TExtObject; NewValue : TExtObject) : TExtFunction; overload;
    function SetJS(FieldName : String; NewValue : TExtObject) : TExtFunction; overload;
    function SetProxy(Proxy : TExtObject) : TExtFunction; overload;
    function SetProxy(Proxy : TExtDataProxy) : TExtFunction; overload;
    function SetProxy(Proxy : String) : TExtFunction; overload;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function Unjoin(Store : TExtDataStore) : TExtFunction;
    function Validate : TExtFunction;
    destructor Destroy; override;
    property Associations : TExtObjectList read FAssociations write SetFAssociations;
    property BelongsTo : String read FBelongsTo write SetFBelongsTo;
    property BelongsToList : TExtObjectList read FBelongsToList write SetFBelongsToList;
    property BelongsToObject : TExtObject read FBelongsToObject write SetFBelongsToObject;
    property BelongsToTArrayOfString : TArrayOfString read FBelongsToTArrayOfString write SetFBelongsToTArrayOfString;
    property ClientIdProperty : String read FClientIdProperty write SetFClientIdProperty;
    property DefaultProxyType : String read FDefaultProxyType write SetFDefaultProxyType;
    property Dirty : Boolean read FDirty write SetFDirty;
    property Editing : Boolean read FEditing write SetFEditing;
    property Fields : TExtObjectList read FFields write SetFFields;
    property FieldsTArrayOfString : TArrayOfString read FFieldsTArrayOfString write SetFFieldsTArrayOfString;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property HasMany : String read FHasMany write SetFHasMany;
    property HasManyList : TExtObjectList read FHasManyList write SetFHasManyList;
    property HasManyObject : TExtObject read FHasManyObject write SetFHasManyObject;
    property HasManyTArrayOfString : TArrayOfString read FHasManyTArrayOfString write SetFHasManyTArrayOfString;
    property IdProperty : String read FIdProperty write SetFIdProperty;
    property IdPropertyField : TExtDataField read FIdPropertyField write SetFIdPropertyField;
    property IdPropertyObject : TExtObject read FIdPropertyObject write SetFIdPropertyObject;
    property IsModel : Boolean read FIsModel write SetFIsModel;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Modified : TExtObject read FModified write SetFModified;
    property Phantom : Boolean read FPhantom write SetFPhantom;
    property Proxy : String read FProxy write SetFProxy;
    property ProxyObject : TExtObject read FProxyObject write SetFProxyObject;
    property ProxyProxy : TExtDataProxy read FProxyProxy write SetFProxyProxy;
    property Raw : TExtObject read FRaw write SetFRaw;
    property Store : TExtDataStore read FStore write SetFStore;
    property Stores : TExtObjectList read FStores write SetFStores;
    property Validations : TExtObjectList read FValidations write SetFValidations;
    property OnIdchanged : TExtDataModelOnIdchanged read FOnIdchanged write SetFOnIdchanged;
  end;

  TExtDataOperation = class(TExtAbstractComponent)
  private
    FAction : String;
    FActionCommitRecordsRe : TRegExp;
    FActionSkipSyncRe : TRegExp;
    FBatch : TExtDataBatch;
    FCallback : TExtFunction;
    FCallbackOperation : TExtDataOperation;
    FCallbackRecords : TExtObjectList;
    FCallbackSuccess : Boolean;
    FFilters : TExtObjectList;
    FGroupers : TExtObjectList;
    FLimit : Integer;
    FParams : TExtObject;
    FScope : TExtObject;
    FSorters : TExtObjectList;
    FStart : Integer;
    FSynchronous : Boolean;
    procedure SetFAction(Value : String);
    procedure SetFActionCommitRecordsRe(Value : TRegExp);
    procedure SetFActionSkipSyncRe(Value : TRegExp);
    procedure SetFBatch(Value : TExtDataBatch);
    procedure SetFCallback(Value : TExtFunction);
    procedure SetFCallbackOperation(Value : TExtDataOperation);
    procedure SetFCallbackRecords(Value : TExtObjectList);
    procedure SetFCallbackSuccess(Value : Boolean);
    procedure SetFFilters(Value : TExtObjectList);
    procedure SetFGroupers(Value : TExtObjectList);
    procedure SetFLimit(Value : Integer);
    procedure SetFParams(Value : TExtObject);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSorters(Value : TExtObjectList);
    procedure SetFStart(Value : Integer);
    procedure SetFSynchronous(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AllowWrite : TExtFunction;
    function CommitRecords(ServerRecords : TExtObjectList) : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function GetError : TExtFunction;
    function GetRecords : TExtFunction;
    function GetResultSet : TExtFunction;
    function HasException : TExtFunction;
    function IsComplete : TExtFunction;
    function IsRunning : TExtFunction;
    function IsStarted : TExtFunction;
    function SetCompleted : TExtFunction;
    function SetException(Error : TExtObject) : TExtFunction; overload;
    function SetException(Error : String = '') : TExtFunction; overload;
    function SetStarted : TExtFunction;
    function SetSuccessful : TExtFunction;
    function WasSuccessful : TExtFunction;
    destructor Destroy; override;
    property Action : String read FAction write SetFAction;
    property ActionCommitRecordsRe : TRegExp read FActionCommitRecordsRe write SetFActionCommitRecordsRe;
    property ActionSkipSyncRe : TRegExp read FActionSkipSyncRe write SetFActionSkipSyncRe;
    property Batch : TExtDataBatch read FBatch write SetFBatch;
    property Callback : TExtFunction read FCallback write SetFCallback;
    property CallbackOperation : TExtDataOperation read FCallbackOperation write SetFCallbackOperation;
    property CallbackRecords : TExtObjectList read FCallbackRecords write SetFCallbackRecords;
    property CallbackSuccess : Boolean read FCallbackSuccess write SetFCallbackSuccess;
    property Filters : TExtObjectList read FFilters write SetFFilters;
    property Groupers : TExtObjectList read FGroupers write SetFGroupers;
    property Limit : Integer read FLimit write SetFLimit;
    property Params : TExtObject read FParams write SetFParams;
    property Scope : TExtObject read FScope write SetFScope;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
    property Start : Integer read FStart write SetFStart;
    property Synchronous : Boolean read FSynchronous write SetFSynchronous;
  end;

  // Procedural types for events TExtDataNodeInterface
  TExtDataNodeInterfaceOnAppend = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnBeforeappend = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforecollapse = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforeexpand = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforeinsert = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnBeforemove = procedure(This : TExtDataNodeInterface; OldParent : TExtDataNodeInterface; NewParent : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnBeforeremove = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; IsMove : Boolean) of object;
  TExtDataNodeInterfaceOnCollapse = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnExpand = procedure(This : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnInsert = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) of object;
  TExtDataNodeInterfaceOnMove = procedure(This : TExtDataNodeInterface; OldParent : TExtDataNodeInterface; NewParent : TExtDataNodeInterface; Index : Integer) of object;
  TExtDataNodeInterfaceOnRemove = procedure(This : TExtDataNodeInterface; Node : TExtDataNodeInterface; IsMove : Boolean) of object;
  TExtDataNodeInterfaceOnSort = procedure(This : TExtDataNodeInterface; ChildNodes : TExtObjectList) of object;

  TExtDataNodeInterface = class(TExtAbstractComponent)
  private
    FAllowDrag : Boolean;
    FAllowDrop : Boolean;
    FChecked : Boolean;
    FChildNodes : TExtObjectList;
    FChildren : TExtObjectList;
    FCls : String;
    FDepth : Integer;
    FExpandable : Boolean;
    FExpanded : Boolean;
    FFirstChild : TExtDataNodeInterface;
    FHref : String;
    FHrefTarget : String;
    FIcon : String;
    FIconCls : String;
    FIndex : Integer;
    FIsFirst : Boolean;
    FIsLast : Boolean;
    FIsNode : Boolean;
    FLastChild : TExtDataNodeInterface;
    FLeaf : Boolean;
    FLoaded : Boolean;
    FLoading : Boolean;
    FNextSibling : TExtDataNodeInterface;
    FParentId : String;
    FParentNode : TExtDataNodeInterface;
    FPreviousSibling : TExtDataNodeInterface;
    FQshowDelay : Integer;
    FQtip : String;
    FQtitle : String;
    FRoot : Boolean;
    FText : String;
    FOnAppend : TExtDataNodeInterfaceOnAppend;
    FOnBeforeappend : TExtDataNodeInterfaceOnBeforeappend;
    FOnBeforecollapse : TExtDataNodeInterfaceOnBeforecollapse;
    FOnBeforeexpand : TExtDataNodeInterfaceOnBeforeexpand;
    FOnBeforeinsert : TExtDataNodeInterfaceOnBeforeinsert;
    FOnBeforemove : TExtDataNodeInterfaceOnBeforemove;
    FOnBeforeremove : TExtDataNodeInterfaceOnBeforeremove;
    FOnCollapse : TExtDataNodeInterfaceOnCollapse;
    FOnExpand : TExtDataNodeInterfaceOnExpand;
    FOnInsert : TExtDataNodeInterfaceOnInsert;
    FOnMove : TExtDataNodeInterfaceOnMove;
    FOnRemove : TExtDataNodeInterfaceOnRemove;
    FOnSort : TExtDataNodeInterfaceOnSort;
    procedure SetFAllowDrag(Value : Boolean);
    procedure SetFAllowDrop(Value : Boolean);
    procedure SetFChecked(Value : Boolean);
    procedure SetFChildNodes(Value : TExtObjectList);
    procedure SetFChildren(Value : TExtObjectList);
    procedure SetFCls(Value : String);
    procedure SetFDepth(Value : Integer);
    procedure SetFExpandable(Value : Boolean);
    procedure SetFExpanded(Value : Boolean);
    procedure SetFFirstChild(Value : TExtDataNodeInterface);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIndex(Value : Integer);
    procedure SetFIsFirst(Value : Boolean);
    procedure SetFIsLast(Value : Boolean);
    procedure SetFIsNode(Value : Boolean);
    procedure SetFLastChild(Value : TExtDataNodeInterface);
    procedure SetFLeaf(Value : Boolean);
    procedure SetFLoaded(Value : Boolean);
    procedure SetFLoading(Value : Boolean);
    procedure SetFNextSibling(Value : TExtDataNodeInterface);
    procedure SetFParentId(Value : String);
    procedure SetFParentNode(Value : TExtDataNodeInterface);
    procedure SetFPreviousSibling(Value : TExtDataNodeInterface);
    procedure SetFQshowDelay(Value : Integer);
    procedure SetFQtip(Value : String);
    procedure SetFQtitle(Value : String);
    procedure SetFRoot(Value : Boolean);
    procedure SetFText(Value : String);
    procedure SetFOnAppend(Value : TExtDataNodeInterfaceOnAppend);
    procedure SetFOnBeforeappend(Value : TExtDataNodeInterfaceOnBeforeappend);
    procedure SetFOnBeforecollapse(Value : TExtDataNodeInterfaceOnBeforecollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataNodeInterfaceOnBeforeexpand);
    procedure SetFOnBeforeinsert(Value : TExtDataNodeInterfaceOnBeforeinsert);
    procedure SetFOnBeforemove(Value : TExtDataNodeInterfaceOnBeforemove);
    procedure SetFOnBeforeremove(Value : TExtDataNodeInterfaceOnBeforeremove);
    procedure SetFOnCollapse(Value : TExtDataNodeInterfaceOnCollapse);
    procedure SetFOnExpand(Value : TExtDataNodeInterfaceOnExpand);
    procedure SetFOnInsert(Value : TExtDataNodeInterfaceOnInsert);
    procedure SetFOnMove(Value : TExtDataNodeInterfaceOnMove);
    procedure SetFOnRemove(Value : TExtDataNodeInterfaceOnRemove);
    procedure SetFOnSort(Value : TExtDataNodeInterfaceOnSort);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AppendChild(Node : TExtObjectList) : TExtFunction; overload;
    function AppendChild(Node : TExtDataNodeInterface) : TExtFunction; overload;
    function Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function CascadeBy(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function Collapse(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function CollapseChildren(Recursive : TExtFunction = nil; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Contains(Node : TExtDataNodeInterface) : TExtFunction;
    function Copy(Id : String = ''; Deep : Boolean = false) : TExtFunction;
    constructor Create;
    function CreateNode : TExtFunction;
    function Decorate(ModelClass : TExtDataModel) : TExtFunction; overload;
    function Decorate(ModelClass : TExtClass) : TExtFunction; overload;
    function EachChild(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function Expand(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandChildren(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function FindChild(Attribute : String; Value : TExtObject; Deep : Boolean = false) : TExtFunction;
    function FindChildBy(Fn : TExtFunction; Scope : TExtObject = nil; Deep : Boolean = false) : TExtFunction;
    function GetChildAt(Index : Integer) : TExtFunction;
    function GetDepth : TExtFunction;
    function GetOwnerTree : TExtFunction;
    function GetPath(Field : String = ''; Separator : String = '') : TExtFunction;
    function HasChildNodes : TExtFunction;
    function IndexOf(Node : TExtDataNodeInterface) : TExtFunction;
    function IndexOfId(Id : String) : TExtFunction;
    function InsertBefore(Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) : TExtFunction;
    function InsertChild(Index : Integer; Node : TExtDataNodeInterface) : TExtFunction;
    function IsAncestor(Node : TExtDataNodeInterface) : TExtFunction;
    function IsExpandable : TExtFunction;
    function IsExpanded : TExtFunction;
    function IsFirst_ : TExtFunction;
    function IsLast_ : TExtFunction;
    function IsLeaf : TExtFunction;
    function IsLoaded : TExtFunction;
    function IsLoading : TExtFunction;
    function IsRoot : TExtFunction;
    function IsVisible : TExtFunction;
    function Remove(Destroy : Boolean = false) : TExtFunction;
    function RemoveAll(Destroy : Boolean = false) : TExtFunction;
    function RemoveChild(Node : TExtDataNodeInterface; Destroy : Boolean = false) : TExtFunction;
    function ReplaceChild(NewChild : TExtDataNodeInterface; OldChild : TExtDataNodeInterface) : TExtFunction;
    function Serialize : TExtFunction;
    function Sort(Fn : TExtFunction; Recursive : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    function UpdateInfo(Commit : Boolean; Info : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property AllowDrag : Boolean read FAllowDrag write SetFAllowDrag;
    property AllowDrop : Boolean read FAllowDrop write SetFAllowDrop;
    property Checked : Boolean read FChecked write SetFChecked;
    property ChildNodes : TExtObjectList read FChildNodes write SetFChildNodes;
    property Children : TExtObjectList read FChildren write SetFChildren;
    property Cls : String read FCls write SetFCls;
    property Depth : Integer read FDepth write SetFDepth;
    property Expandable : Boolean read FExpandable write SetFExpandable;
    property Expanded : Boolean read FExpanded write SetFExpanded;
    property FirstChild : TExtDataNodeInterface read FFirstChild write SetFFirstChild;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property Index : Integer read FIndex write SetFIndex;
    property IsFirst : Boolean read FIsFirst write SetFIsFirst;
    property IsLast : Boolean read FIsLast write SetFIsLast;
    property IsNode : Boolean read FIsNode write SetFIsNode;
    property LastChild : TExtDataNodeInterface read FLastChild write SetFLastChild;
    property Leaf : Boolean read FLeaf write SetFLeaf;
    property Loaded : Boolean read FLoaded write SetFLoaded;
    property Loading : Boolean read FLoading write SetFLoading;
    property NextSibling : TExtDataNodeInterface read FNextSibling write SetFNextSibling;
    property ParentId : String read FParentId write SetFParentId;
    property ParentNode : TExtDataNodeInterface read FParentNode write SetFParentNode;
    property PreviousSibling : TExtDataNodeInterface read FPreviousSibling write SetFPreviousSibling;
    property QshowDelay : Integer read FQshowDelay write SetFQshowDelay;
    property Qtip : String read FQtip write SetFQtip;
    property Qtitle : String read FQtitle write SetFQtitle;
    property Root : Boolean read FRoot write SetFRoot;
    property Text : String read FText write SetFText;
    property OnAppend : TExtDataNodeInterfaceOnAppend read FOnAppend write SetFOnAppend;
    property OnBeforeappend : TExtDataNodeInterfaceOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforecollapse : TExtDataNodeInterfaceOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnBeforeexpand : TExtDataNodeInterfaceOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforeinsert : TExtDataNodeInterfaceOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnBeforemove : TExtDataNodeInterfaceOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeremove : TExtDataNodeInterfaceOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnCollapse : TExtDataNodeInterfaceOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtDataNodeInterfaceOnExpand read FOnExpand write SetFOnExpand;
    property OnInsert : TExtDataNodeInterfaceOnInsert read FOnInsert write SetFOnInsert;
    property OnMove : TExtDataNodeInterfaceOnMove read FOnMove write SetFOnMove;
    property OnRemove : TExtDataNodeInterfaceOnRemove read FOnRemove write SetFOnRemove;
    property OnSort : TExtDataNodeInterfaceOnSort read FOnSort write SetFOnSort;
  end;

  TExtChartAxisAbstract = class(TExtAbstractComponent)
  private
    FFields : TArrayOfString;
    FLabelJS : TExtChartLabel;
    procedure SetFFields(Value : TArrayOfString);
    procedure SetFLabelJS(Value : TExtChartLabel);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property Fields : TArrayOfString read FFields write SetFFields;
    property LabelJS : TExtChartLabel read FLabelJS write SetFLabelJS;
  end;

  TExtButtonManagerSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartCallout = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartLabel = class(TExtAbstractComponent)
  private
    FLabelColor : String;
    FLabelContrast : Boolean;
    FLabelDisplay : String;
    FLabelField : String;
    FLabelFont : String;
    FLabelJS : TExtObject;
    FLabelMinMargin : Integer;
    FLabelOrientation : String;
    FLabelRenderer : TExtFunction;
    FLabelStackedDisplay : String;
    procedure SetFLabelColor(Value : String);
    procedure SetFLabelContrast(Value : Boolean);
    procedure SetFLabelDisplay(Value : String);
    procedure SetFLabelField(Value : String);
    procedure SetFLabelFont(Value : String);
    procedure SetFLabelJS(Value : TExtObject);
    procedure SetFLabelMinMargin(Value : Integer);
    procedure SetFLabelOrientation(Value : String);
    procedure SetFLabelRenderer(Value : TExtFunction);
    procedure SetFLabelStackedDisplay(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property LabelColor : String read FLabelColor write SetFLabelColor;
    property LabelContrast : Boolean read FLabelContrast write SetFLabelContrast;
    property LabelDisplay : String read FLabelDisplay write SetFLabelDisplay;
    property LabelField : String read FLabelField write SetFLabelField;
    property LabelFont : String read FLabelFont write SetFLabelFont;
    property LabelJS : TExtObject read FLabelJS write SetFLabelJS;
    property LabelMinMargin : Integer read FLabelMinMargin write SetFLabelMinMargin;
    property LabelOrientation : String read FLabelOrientation write SetFLabelOrientation;
    property LabelRenderer : TExtFunction read FLabelRenderer write SetFLabelRenderer;
    property LabelStackedDisplay : String read FLabelStackedDisplay write SetFLabelStackedDisplay;
  end;

  TExtChartHighlight = class(TExtAbstractComponent)
  private
    FHighlight : Boolean;
    FHighlightCfg : TExtObject;
    FHighlightObject : TExtObject;
    procedure SetFHighlight(Value : Boolean);
    procedure SetFHighlightCfg(Value : TExtObject);
    procedure SetFHighlightObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function HighlightItem(Item : TExtObject) : TExtFunction;
    function UnHighlightItem : TExtFunction;
    destructor Destroy; override;
    property Highlight : Boolean read FHighlight write SetFHighlight;
    property HighlightCfg : TExtObject read FHighlightCfg write SetFHighlightCfg;
    property HighlightObject : TExtObject read FHighlightObject write SetFHighlightObject;
  end;

  TExtAppEventDomain = class(TExtAbstractComponent)
  private
    FIdProperty : String;
    procedure SetFIdProperty(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IdProperty : String read FIdProperty write SetFIdProperty;
  end;

  TExtAbstractPlugin = class(TExtAbstractComponent)
  private
    FIsPlugin : Boolean;
    FPluginId : String;
    procedure SetFIsPlugin(Value : Boolean);
    procedure SetFPluginId(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Disable : TExtFunction;
    property IsPlugin : Boolean read FIsPlugin write SetFIsPlugin;
    property PluginId : String read FPluginId write SetFPluginId;
  end;

  TExtAbstractManager = class(TExtAbstractComponent)
  private
    FAll : TExtUtilHashMap;
    procedure SetFAll(Value : TExtUtilHashMap);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; DefaultType : String);
    function Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Get(Id : String) : TExtFunction;
    function GetCount : TExtFunction;
    function IsRegistered(TypeJS : String) : TExtFunction;
    function OnAvailable(Id : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Register(Item : TExtObject) : TExtFunction;
    function RegisterType(TypeJS : String; Cls : TExtFunction) : TExtFunction;
    function Unregister(Item : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property All : TExtUtilHashMap read FAll write SetFAll;
  end;

  TExtAction = class(TExtAbstractComponent)
  private
    FDisabled : Boolean;
    FHandler : TExtFunction;
    FHidden : Boolean;
    FIconCls : String;
    FIsAction : Boolean;
    FItemId : String;
    FScope : TExtObject;
    FText : String;
    procedure SetFDisabled(Value : Boolean);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFHidden(Value : Boolean);
    procedure SetFIconCls(Value : String);
    procedure SetFIsAction(Value : Boolean);
    procedure SetFItemId(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFText(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject);
    function Disable : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Enable : TExtFunction;
    function Execute(Args : TExtObjectList) : TExtFunction;
    function GetIconCls : TExtFunction;
    function GetText : TExtFunction;
    function Hide : TExtFunction;
    function IsDisabled : TExtFunction;
    function IsHidden : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    function SetHandler(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function SetHidden(Hidden : Boolean) : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function SetText(Text : String) : TExtFunction;
    function Show : TExtFunction;
    destructor Destroy; override;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property Hidden : Boolean read FHidden write SetFHidden;
    property IconCls : String read FIconCls write SetFIconCls;
    property IsAction : Boolean read FIsAction write SetFIsAction;
    property ItemId : String read FItemId write SetFItemId;
    property Scope : TExtObject read FScope write SetFScope;
    property Text : String read FText write SetFText;
  end;

  TExtAppEventBusSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Control(Selectors : TExtObject; Controller : TExtAppController) : TExtFunction;
    function Listen(ToJS : TExtObject; Controller : TExtAppController) : TExtFunction;
    function Unlisten(ControllerId : String) : TExtFunction;
  end;

  TExtAppController = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FId : String;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FModels : TArrayOfString;
    FRefs : TExtObjectList;
    FStores : TArrayOfString;
    FViews : TArrayOfString;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFId(Value : String);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFModels(Value : TArrayOfString);
    procedure SetFRefs(Value : TExtObjectList);
    procedure SetFStores(Value : TArrayOfString);
    procedure SetFViews(Value : TArrayOfString);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddRef(Refs : TExtObjectList) : TExtFunction; overload;
    function AddRef(Refs : TExtObject) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function Control(Selectors : TExtObject; Listeners : TExtObject = nil) : TExtFunction; overload;
    function Control(Selectors : String; Listeners : TExtObject = nil) : TExtFunction; overload;
    constructor Create(Config : TExtObject = nil);
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetApplication : TExtFunction;
    function GetController(Id : String) : TExtFunction;
    function GetModel(Name : String) : TExtFunction;
    function GetStore(Name : String) : TExtFunction;
    function GetView(Name : String) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function HasRef : TExtFunction;
    function Listen(ToJS : TExtObject) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Id : String read FId write SetFId;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Models : TArrayOfString read FModels write SetFModels;
    property Refs : TExtObjectList read FRefs write SetFRefs;
    property Stores : TArrayOfString read FStores write SetFStores;
    property Views : TArrayOfString read FViews write SetFViews;
  end;

  TExtChartTip = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartThemeBase = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Enumerated types for properties
  TRegionEnum = (reNorth, reSouth, reEast, reWest, reCenter);

  TExtComponent = class(TExtAbstractComponent)
  private
    FAnchor : String;
    FAutoScroll : Boolean;
    FColumnWidth : Integer;
    FColumnWidthString : String;
    FConstrain : Boolean;
    FConstrainTo : TExtUtilRegion;
    FConstrainToElement : TExtElement;
    FDefaultAlign : String;
    FDraggable : Boolean;
    FDraggableObject : TExtObject;
    FFixed : Boolean;
    FFloating : Boolean;
    FFloatParent : TExtContainer;
    FFocusOnToFront : Boolean;
    FFormBind : Boolean;
    FMargins : String;
    FMaxSize : Integer;
    FMinSize : Integer;
    FOverflowX : String;
    FOverflowY : String;
    FRegion : TRegionEnum;
    FResizable : Boolean;
    FResizableObject : TExtObject;
    FResizeHandles : String;
    FShadow : String;
    FShadowBoolean : Boolean;
    FShadowOffset : Integer;
    FSplit : Boolean;
    FToFrontOnShow : Boolean;
    FZIndexManager : TExtZIndexManager;
    FZIndexParent : TExtContainer;
    procedure SetFAnchor(Value : String);
    procedure SetFAutoScroll(Value : Boolean);
    procedure SetFColumnWidth(Value : Integer);
    procedure SetFColumnWidthString(Value : String);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFConstrainTo(Value : TExtUtilRegion);
    procedure SetFConstrainToElement(Value : TExtElement);
    procedure SetFDefaultAlign(Value : String);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFDraggableObject(Value : TExtObject);
    procedure SetFFixed(Value : Boolean);
    procedure SetFFloating(Value : Boolean);
    procedure SetFFloatParent(Value : TExtContainer);
    procedure SetFFocusOnToFront(Value : Boolean);
    procedure SetFFormBind(Value : Boolean);
    procedure SetFMargins(Value : String);
    procedure SetFMaxSize(Value : Integer);
    procedure SetFMinSize(Value : Integer);
    procedure SetFOverflowX(Value : String);
    procedure SetFOverflowY(Value : String);
    procedure SetFRegion(Value : TRegionEnum);
    procedure SetFResizable(Value : Boolean);
    procedure SetFResizableObject(Value : TExtObject);
    procedure SetFResizeHandles(Value : String);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFShadowOffset(Value : Integer);
    procedure SetFSplit(Value : Boolean);
    procedure SetFToFrontOnShow(Value : Boolean);
    procedure SetFZIndexManager(Value : TExtZIndexManager);
    procedure SetFZIndexParent(Value : TExtContainer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function Center : TExtFunction;
    function CloneConfig(Overrides : TExtObject) : TExtFunction;
    constructor Create(Config : TExtObject); overload;
    constructor Create(Config : TExtElement); overload;
    constructor Create(Config : String); overload;
    function DoConstrain(ConstrainTo : String = '') : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; overload;
    function FindParentBy(Fn : TExtFunction) : TExtFunction;
    function FindParentByType(Xtype : TExtClass) : TExtFunction; overload;
    function FindParentByType(Xtype : String) : TExtFunction; overload;
    function Focus(SelectText : Boolean; Delay : Integer) : TExtFunction; overload;
    function Focus(SelectText : Boolean = false; Delay : Boolean = false) : TExtFunction; overload;
    function GetPosition(Local : Boolean = false) : TExtFunction;
    function GetXType : TExtFunction;
    function Hide(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Hide(AnimateTarget : TExtComponent; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Hide(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; overload;
    function SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction;
    function SetAutoScroll(Scroll : Boolean) : TExtFunction;
    function SetLoading(Load : TExtObject; TargetEl : Boolean = false) : TExtFunction; overload;
    function SetLoading(Load : String; TargetEl : Boolean = false) : TExtFunction; overload;
    function SetLoading(Load : Boolean; TargetEl : Boolean = false) : TExtFunction; overload;
    function SetOverflowXY(OverflowX : String; OverflowY : String) : TExtFunction;
    function SetPagePosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPagePosition(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function SetPagePosition(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function SetPagePosition(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function Show(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function Show(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ShowAt(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ShowAt(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; overload;
    function ShowAt(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function ShowAt(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; overload;
    function ShowBy(Component : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function ShowBy(Component : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; overload;
    function ToBack : TExtFunction;
    function ToFront(PreventFocus : Boolean = false) : TExtFunction;
    function UpdateBox(Box : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Anchor : String read FAnchor write SetFAnchor;
    property AutoScroll : Boolean read FAutoScroll write SetFAutoScroll;
    property ColumnWidth : Integer read FColumnWidth write SetFColumnWidth;
    property ColumnWidthString : String read FColumnWidthString write SetFColumnWidthString;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property ConstrainTo : TExtUtilRegion read FConstrainTo write SetFConstrainTo;
    property ConstrainToElement : TExtElement read FConstrainToElement write SetFConstrainToElement;
    property DefaultAlign : String read FDefaultAlign write SetFDefaultAlign;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property DraggableObject : TExtObject read FDraggableObject write SetFDraggableObject;
    property Fixed : Boolean read FFixed write SetFFixed;
    property Floating : Boolean read FFloating write SetFFloating;
    property FloatParent : TExtContainer read FFloatParent write SetFFloatParent;
    property FocusOnToFront : Boolean read FFocusOnToFront write SetFFocusOnToFront;
    property FormBind : Boolean read FFormBind write SetFFormBind;
    property Margins : String read FMargins write SetFMargins;
    property MaxSize : Integer read FMaxSize write SetFMaxSize;
    property MinSize : Integer read FMinSize write SetFMinSize;
    property OverflowX : String read FOverflowX write SetFOverflowX;
    property OverflowY : String read FOverflowY write SetFOverflowY;
    property Region : TRegionEnum read FRegion write SetFRegion;
    property Resizable : Boolean read FResizable write SetFResizable;
    property ResizableObject : TExtObject read FResizableObject write SetFResizableObject;
    property ResizeHandles : String read FResizeHandles write SetFResizeHandles;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property ShadowOffset : Integer read FShadowOffset write SetFShadowOffset;
    property Split : Boolean read FSplit write SetFSplit;
    property ToFrontOnShow : Boolean read FToFrontOnShow write SetFToFrontOnShow;
    property ZIndexManager : TExtZIndexManager read FZIndexManager write SetFZIndexManager;
    property ZIndexParent : TExtContainer read FZIndexParent write SetFZIndexParent;
  end;

  TExtZIndexManager = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BringToFront(Comp : TExtObject) : TExtFunction; overload;
    function BringToFront(Comp : String) : TExtFunction; overload;
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function EachBottomUp(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function EachTopDown(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Get(Id : TExtObject) : TExtFunction; overload;
    function Get(Id : String) : TExtFunction; overload;
    function GetActive : TExtFunction;
    function GetBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function HideAll : TExtFunction;
    function Register(Comp : TExtComponent) : TExtFunction;
    function SendToBack(Comp : TExtObject) : TExtFunction; overload;
    function SendToBack(Comp : String) : TExtFunction; overload;
    function Unregister(Comp : TExtComponent) : TExtFunction;
  end;

  TExtComponentQuerySingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function IsJS(Component : TExtComponent; Selector : String) : TExtFunction;
    function Query(Selector : String; Root : TExtContainer = nil) : TExtFunction;
  end;

  TExtChartTheme = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartMask = class(TExtAbstractComponent)
  private
    FMask : Boolean;
    FMaskString : String;
    procedure SetFMask(Value : Boolean);
    procedure SetFMaskString(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    property Mask : Boolean read FMask write SetFMask;
    property MaskString : String read FMaskString write SetFMaskString;
  end;

  TExtChartLegend = class(TExtAbstractComponent)
  private
    FBoxFill : String;
    FBoxStroke : String;
    FBoxStrokeWidth : String;
    FBoxZIndex : Integer; // 100
    FItemSpacing : Integer;
    FLabelColor : String;
    FLabelFont : String;
    FPadding : Integer;
    FPosition : String;
    FUpdate : Boolean;
    FVisible : Boolean;
    FX : Integer;
    FY : Integer;
    procedure SetFBoxFill(Value : String);
    procedure SetFBoxStroke(Value : String);
    procedure SetFBoxStrokeWidth(Value : String);
    procedure SetFBoxZIndex(Value : Integer);
    procedure SetFItemSpacing(Value : Integer);
    procedure SetFLabelColor(Value : String);
    procedure SetFLabelFont(Value : String);
    procedure SetFPadding(Value : Integer);
    procedure SetFPosition(Value : String);
    procedure SetFUpdate(Value : Boolean);
    procedure SetFVisible(Value : Boolean);
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject); overload;
    constructor Create; overload;
    function Toggle(Show : Boolean) : TExtFunction;
    property BoxFill : String read FBoxFill write SetFBoxFill;
    property BoxStroke : String read FBoxStroke write SetFBoxStroke;
    property BoxStrokeWidth : String read FBoxStrokeWidth write SetFBoxStrokeWidth;
    property BoxZIndex : Integer read FBoxZIndex write SetFBoxZIndex;
    property ItemSpacing : Integer read FItemSpacing write SetFItemSpacing;
    property LabelColor : String read FLabelColor write SetFLabelColor;
    property LabelFont : String read FLabelFont write SetFLabelFont;
    property Padding : Integer read FPadding write SetFPadding;
    property Position : String read FPosition write SetFPosition;
    property Update : Boolean read FUpdate write SetFUpdate;
    property Visible : Boolean read FVisible write SetFVisible;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
  end;

  TExtChartNavigation = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function RestoreZoom : TExtFunction;
    function SetZoom : TExtFunction;
  end;

  TExtChartShapeSingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtChartSeries
  TExtChartSeriesOnTitlechange = procedure(Title : String; Index : Integer) of object;

  TExtChartSeries = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FHighlight : Boolean;
    FHighlightCfg : TExtObject;
    FHighlightObject : TExtObject;
    FIsObservable : Boolean;
    FLabelColor : String;
    FLabelContrast : Boolean;
    FLabelDisplay : String;
    FLabelField : String;
    FLabelFont : String;
    FLabelJS : TExtObject;
    FLabelMinMargin : Integer;
    FLabelOrientation : String;
    FLabelRenderer : TExtFunction;
    FLabelStackedDisplay : String;
    FListeners : TExtObject;
    FRenderer : TExtFunction;
    FShadowAttributes : TExtObjectList;
    FShowInLegend : Boolean;
    FTips : TExtObject;
    FTitle : String;
    FTypeJS : String;
    FOnTitlechange : TExtChartSeriesOnTitlechange;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFHighlight(Value : Boolean);
    procedure SetFHighlightCfg(Value : TExtObject);
    procedure SetFHighlightObject(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFLabelColor(Value : String);
    procedure SetFLabelContrast(Value : Boolean);
    procedure SetFLabelDisplay(Value : String);
    procedure SetFLabelField(Value : String);
    procedure SetFLabelFont(Value : String);
    procedure SetFLabelJS(Value : TExtObject);
    procedure SetFLabelMinMargin(Value : Integer);
    procedure SetFLabelOrientation(Value : String);
    procedure SetFLabelRenderer(Value : TExtFunction);
    procedure SetFLabelStackedDisplay(Value : String);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFShadowAttributes(Value : TExtObjectList);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFTips(Value : TExtObject);
    procedure SetFTitle(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFOnTitlechange(Value : TExtChartSeriesOnTitlechange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EachRecord(Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetItemForPoint(X : Integer; Y : Integer) : TExtFunction;
    function GetLegendColor : TExtFunction;
    function GetRecordCount : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function HideAll : TExtFunction;
    function HighlightItem(Item : TExtObject) : TExtFunction;
    function IsExcluded : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SetTitle(Index : Integer; Title : String) : TExtFunction;
    function ShowAll : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    function UnHighlightItem : TExtFunction;
    destructor Destroy; override;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Highlight : Boolean read FHighlight write SetFHighlight;
    property HighlightCfg : TExtObject read FHighlightCfg write SetFHighlightCfg;
    property HighlightObject : TExtObject read FHighlightObject write SetFHighlightObject;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property LabelColor : String read FLabelColor write SetFLabelColor;
    property LabelContrast : Boolean read FLabelContrast write SetFLabelContrast;
    property LabelDisplay : String read FLabelDisplay write SetFLabelDisplay;
    property LabelField : String read FLabelField write SetFLabelField;
    property LabelFont : String read FLabelFont write SetFLabelFont;
    property LabelJS : TExtObject read FLabelJS write SetFLabelJS;
    property LabelMinMargin : Integer read FLabelMinMargin write SetFLabelMinMargin;
    property LabelOrientation : String read FLabelOrientation write SetFLabelOrientation;
    property LabelRenderer : TExtFunction read FLabelRenderer write SetFLabelRenderer;
    property LabelStackedDisplay : String read FLabelStackedDisplay write SetFLabelStackedDisplay;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property ShadowAttributes : TExtObjectList read FShadowAttributes write SetFShadowAttributes;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property Tips : TExtObject read FTips write SetFTips;
    property Title : String read FTitle write SetFTitle;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property OnTitlechange : TExtChartSeriesOnTitlechange read FOnTitlechange write SetFOnTitlechange;
  end;

  TExtDataValidationsSingleton = class(TExtAbstractComponent)
  private
    FEmailMessage : String;
    FEmailRe : TRegExp;
    FExclusionMessage : String;
    FFormatMessage : String;
    FInclusionMessage : String;
    FLengthMessage : String;
    FPresenceMessage : String;
    procedure SetFEmailMessage(Value : String);
    procedure SetFEmailRe(Value : TRegExp);
    procedure SetFExclusionMessage(Value : String);
    procedure SetFFormatMessage(Value : String);
    procedure SetFInclusionMessage(Value : String);
    procedure SetFLengthMessage(Value : String);
    procedure SetFPresenceMessage(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Email(Config : TExtObject; Email : String) : TExtFunction;
    function Exclusion(Config : TExtObject; Value : String) : TExtFunction;
    function Format(Config : TExtObject; Value : String) : TExtFunction;
    function Inclusion(Config : TExtObject; Value : String) : TExtFunction;
    function Length(Config : TExtObject; Value : String) : TExtFunction;
    function Presence(Config : TExtObject; Value : TExtObject) : TExtFunction;
    property EmailMessage : String read FEmailMessage write SetFEmailMessage;
    property EmailRe : TRegExp read FEmailRe write SetFEmailRe;
    property ExclusionMessage : String read FExclusionMessage write SetFExclusionMessage;
    property FormatMessage : String read FFormatMessage write SetFFormatMessage;
    property InclusionMessage : String read FInclusionMessage write SetFInclusionMessage;
    property LengthMessage : String read FLengthMessage write SetFLengthMessage;
    property PresenceMessage : String read FPresenceMessage write SetFPresenceMessage;
  end;

  TExtDataTypesSingleton = class(TExtAbstractComponent)
  private
    FStripRe : TRegExp;
    procedure SetFStripRe(Value : TRegExp);
  public
    function JSClassName : string; override;
    class function AUTO : TExtObject;
    class function BOOL : TExtObject;
    class function BOOLEAN : TExtObject;
    class function DATE : TExtObject;
    class function FLOAT : TExtObject;
    class function INT : TExtObject;
    class function INTEGER : TExtObject;
    class function NUMBER : TExtObject;
    class function STRINGJS : TExtObject;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property StripRe : TRegExp read FStripRe write SetFStripRe;
  end;

  TExtDdDragDropManagerSingleton = class(TExtAbstractComponent)
  private
    FClickPixelThresh : Integer;
    FClickTimeThresh : Integer;
    FDragCls : String;
    FMode : Integer;
    FNotifyOccluded : Boolean;
    FPreventDefault : Boolean;
    FStopPropagation : Boolean;
    FUseCache : Boolean;
    procedure SetFClickPixelThresh(Value : Integer);
    procedure SetFClickTimeThresh(Value : Integer);
    procedure SetFDragCls(Value : String);
    procedure SetFMode(Value : Integer);
    procedure SetFNotifyOccluded(Value : Boolean);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopPropagation(Value : Boolean);
    procedure SetFUseCache(Value : Boolean);
  public
    function JSClassName : string; override;
    class function INTERSECT : Integer;
    class function POINT : Integer;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetBestMatch(Dds : TExtObjectList) : TExtFunction;
    function GetCss(Id : String) : TExtFunction;
    function GetDDById(Id : String) : TExtFunction;
    function GetLocation(ODD : TExtDdDragDrop) : TExtFunction;
    function GetPosY(El : THTMLElement) : TExtFunction;
    function GetRelated(P_oDD : TExtDdDragDrop; BTargetsOnly : Boolean) : TExtFunction;
    function GetScrollLeft : TExtFunction;
    function GetScrollTop : TExtFunction;
    function GetStyle(El : THTMLElement) : TExtFunction;
    function HandleWasClicked(Node : THTMLElement) : TExtFunction;
    function IsDragDrop(Id : String) : TExtFunction;
    function IsHandle(Id : String) : TExtFunction;
    function IsLegalTarget(ODD : TExtDdDragDrop; OTargetDD : TExtDdDragDrop) : TExtFunction;
    function IsLocked : TExtFunction;
    function IsTypeOfDD(The : TExtObject) : TExtFunction;
    function Lock : TExtFunction;
    function MoveToEl(MoveEl : THTMLElement; TargetEl : THTMLElement) : TExtFunction;
    function NumericSort(A : Integer; B : Integer) : TExtFunction;
    function RefreshCache(Groups : TExtObject) : TExtFunction;
    function RegDragDrop(ODD : TExtDdDragDrop; SGroup : String) : TExtFunction;
    function RegHandle(SDDId : String; SHandleId : String) : TExtFunction;
    function StartDrag(X : Integer; Y : Integer) : TExtFunction;
    function StopEvent(E : TEvent) : TExtFunction;
    function SwapNode(N1 : THTMLElement; N2 : THTMLElement) : TExtFunction;
    function Unlock : TExtFunction;
    function VerifyEl(El : THTMLElement) : TExtFunction;
    property ClickPixelThresh : Integer read FClickPixelThresh write SetFClickPixelThresh;
    property ClickTimeThresh : Integer read FClickTimeThresh write SetFClickTimeThresh;
    property DragCls : String read FDragCls write SetFDragCls;
    property Mode : Integer read FMode write SetFMode;
    property NotifyOccluded : Boolean read FNotifyOccluded write SetFNotifyOccluded;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopPropagation : Boolean read FStopPropagation write SetFStopPropagation;
    property UseCache : Boolean read FUseCache write SetFUseCache;
  end;

  // Procedural types for events TExtDirectManagerSingleton
  TExtDirectManagerSingletonOnEvent = procedure(Event : TExtDirectEvent; Provider : TExtDirectProvider) of object;
  TExtDirectManagerSingletonOnException = procedure(Event : TExtDirectEvent) of object;

  TExtDirectManagerSingleton = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FOnEvent : TExtDirectManagerSingletonOnEvent;
    FOnException : TExtDirectManagerSingletonOnException;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOnEvent(Value : TExtDirectManagerSingletonOnEvent);
    procedure SetFOnException(Value : TExtDirectManagerSingletonOnException);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddProvider(Provider : TExtObjectList) : TExtFunction; overload;
    function AddProvider(Provider : TExtDirectProvider) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetProvider(Id : TExtDirectProvider) : TExtFunction; overload;
    function GetProvider(Id : String) : TExtFunction; overload;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveProvider(Provider : TExtDirectProvider) : TExtFunction; overload;
    function RemoveProvider(Provider : String) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OnEvent : TExtDirectManagerSingletonOnEvent read FOnEvent write SetFOnEvent;
    property OnException : TExtDirectManagerSingletonOnException read FOnException write SetFOnException;
  end;

  TExtDdDragDrop = class(TExtAbstractComponent)
  private
    FAvailable : Boolean;
    FConfig : TExtObject;
    FDefaultPadding : TExtObject;
    FGroups : TExtObject;
    FHasOuterHandles : Boolean;
    FId : String;
    FIgnoreSelf : Boolean; // true
    FInvalidHandleClasses : TArrayOfString;
    FInvalidHandleTypes : TExtObject;
    FIsTarget : Boolean;
    FMaintainOffset : Boolean;
    FMoveOnly : Boolean;
    FPadding : TArrayOfInteger;
    FPrimaryButtonOnly : Boolean;
    FXTicks : TArrayOfInteger;
    FYTicks : TArrayOfInteger;
    procedure SetFAvailable(Value : Boolean);
    procedure SetFConfig(Value : TExtObject);
    procedure SetFDefaultPadding(Value : TExtObject);
    procedure SetFGroups(Value : TExtObject);
    procedure SetFHasOuterHandles(Value : Boolean);
    procedure SetFId(Value : String);
    procedure SetFIgnoreSelf(Value : Boolean);
    procedure SetFInvalidHandleClasses(Value : TArrayOfString);
    procedure SetFInvalidHandleTypes(Value : TExtObject);
    procedure SetFIsTarget(Value : Boolean);
    procedure SetFMaintainOffset(Value : Boolean);
    procedure SetFMoveOnly(Value : Boolean);
    procedure SetFPadding(Value : TArrayOfInteger);
    procedure SetFPrimaryButtonOnly(Value : Boolean);
    procedure SetFXTicks(Value : TArrayOfInteger);
    procedure SetFYTicks(Value : TArrayOfInteger);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddInvalidHandleClass(CssClass : String) : TExtFunction;
    function AddInvalidHandleId(Id : String) : TExtFunction;
    function AddInvalidHandleType(TagName : String) : TExtFunction;
    function AddToGroup(SGroup : String) : TExtFunction;
    function ApplyConfig : TExtFunction;
    function ClearConstraints : TExtFunction;
    function ClearTicks : TExtFunction;
    function ConstrainTo(ConstrainTo : String; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : THTMLElement; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : THTMLElement; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : TExtElement; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : TExtElement; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; overload;
    function ConstrainTo(ConstrainTo : String; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; overload;
    constructor Create(Id : String; SGroup : String; Config : TExtObject);
    function EndDrag(E : TEvent) : TExtFunction;
    function GetDragEl : TExtFunction;
    function GetEl : TExtFunction;
    function Init(Id : String; SGroup : String; Config : TExtObject) : TExtFunction;
    function InitTarget(Id : String; SGroup : String; Config : TExtObject) : TExtFunction;
    function IsLocked : TExtFunction;
    function IsValidHandleChild(Node : THTMLElement) : TExtFunction;
    function Lock : TExtFunction;
    function OnAvailable : TExtFunction;
    function OnDrag(E : TEvent) : TExtFunction;
    function OnDragDrop(E : TEvent; Id : TExtObjectList) : TExtFunction; overload;
    function OnDragDrop(E : TEvent; Id : String) : TExtFunction; overload;
    function OnDragEnter(E : TEvent; Id : TExtObjectList) : TExtFunction; overload;
    function OnDragEnter(E : TEvent; Id : String) : TExtFunction; overload;
    function OnDragOut(E : TEvent; Id : TExtObjectList) : TExtFunction; overload;
    function OnDragOut(E : TEvent; Id : String) : TExtFunction; overload;
    function OnDragOver(E : TEvent; Id : TExtObjectList) : TExtFunction; overload;
    function OnDragOver(E : TEvent; Id : String) : TExtFunction; overload;
    function OnInvalidDrop(E : TEvent) : TExtFunction;
    function OnMouseDown(E : TEvent) : TExtFunction;
    function OnMouseUp(E : TEvent) : TExtFunction;
    function RemoveFromGroup(SGroup : String) : TExtFunction;
    function RemoveInvalidHandleClass(CssClass : String) : TExtFunction;
    function RemoveInvalidHandleId(Id : String) : TExtFunction;
    function RemoveInvalidHandleType(TagName : String) : TExtFunction;
    function ResetConstraints(MaintainOffset : Boolean) : TExtFunction;
    function SetDragElId(Id : String) : TExtFunction;
    function SetHandleElId(Id : String) : TExtFunction;
    function SetInitPosition(DiffX : Integer; DiffY : Integer) : TExtFunction;
    function SetOuterHandleElId(Id : String) : TExtFunction;
    function SetPadding(ITop : Integer; IRight : Integer; IBot : Integer; ILeft : Integer) : TExtFunction;
    function SetXConstraint(ILeft : Integer; IRight : Integer; ITickSize : Integer = 0) : TExtFunction;
    function SetYConstraint(IUp : Integer; IDown : Integer; ITickSize : Integer = 0) : TExtFunction;
    function StartDrag(X : Integer; Y : Integer) : TExtFunction;
    function ToString : TExtFunction;
    function Unlock : TExtFunction;
    function Unreg : TExtFunction;
    destructor Destroy; override;
    property Available : Boolean read FAvailable write SetFAvailable;
    property Config : TExtObject read FConfig write SetFConfig;
    property DefaultPadding : TExtObject read FDefaultPadding write SetFDefaultPadding;
    property Groups : TExtObject read FGroups write SetFGroups;
    property HasOuterHandles : Boolean read FHasOuterHandles write SetFHasOuterHandles;
    property Id : String read FId write SetFId;
    property IgnoreSelf : Boolean read FIgnoreSelf write SetFIgnoreSelf;
    property InvalidHandleClasses : TArrayOfString read FInvalidHandleClasses write SetFInvalidHandleClasses;
    property InvalidHandleTypes : TExtObject read FInvalidHandleTypes write SetFInvalidHandleTypes;
    property IsTarget : Boolean read FIsTarget write SetFIsTarget;
    property MaintainOffset : Boolean read FMaintainOffset write SetFMaintainOffset;
    property MoveOnly : Boolean read FMoveOnly write SetFMoveOnly;
    property Padding : TArrayOfInteger read FPadding write SetFPadding;
    property PrimaryButtonOnly : Boolean read FPrimaryButtonOnly write SetFPrimaryButtonOnly;
    property XTicks : TArrayOfInteger read FXTicks write SetFXTicks;
    property YTicks : TArrayOfInteger read FYTicks write SetFYTicks;
  end;

  // Procedural types for events TExtDdDragTracker
  TExtDdDragTrackerOnBeforestart = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDrag = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDragend = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnDragstart = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMousedown = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMousemove = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMouseout = procedure(This : TExtDdDragTracker; E : TExtObject) of object;
  TExtDdDragTrackerOnMouseover = procedure(This : TExtDdDragTracker; E : TExtObject; Target : THTMLElement) of object;
  TExtDdDragTrackerOnMouseup = procedure(This : TExtDdDragTracker; E : TExtObject) of object;

  TExtDdDragTracker = class(TExtAbstractComponent)
  private
    FActive : Boolean;
    FAutoStart : Boolean;
    FAutoStartInteger : Integer;
    FConstrainTo : TExtUtilRegion;
    FConstrainToElement : TExtElement;
    FDelegate : String;
    FDragTarget : THTMLElement;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FOverCls : String;
    FPreventDefault : Boolean;
    FStopEvent : Boolean;
    FTolerance : Integer;
    FTrackOver : Boolean;
    FOnBeforestart : TExtDdDragTrackerOnBeforestart;
    FOnDrag : TExtDdDragTrackerOnDrag;
    FOnDragend : TExtDdDragTrackerOnDragend;
    FOnDragstart : TExtDdDragTrackerOnDragstart;
    FOnMousedown : TExtDdDragTrackerOnMousedown;
    FOnMousemove : TExtDdDragTrackerOnMousemove;
    FOnMouseout : TExtDdDragTrackerOnMouseout;
    FOnMouseover : TExtDdDragTrackerOnMouseover;
    FOnMouseup : TExtDdDragTrackerOnMouseup;
    procedure SetFActive(Value : Boolean);
    procedure SetFAutoStart(Value : Boolean);
    procedure SetFAutoStartInteger(Value : Integer);
    procedure SetFConstrainTo(Value : TExtUtilRegion);
    procedure SetFConstrainToElement(Value : TExtElement);
    procedure SetFDelegate(Value : String);
    procedure SetFDragTarget(Value : THTMLElement);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFOverCls(Value : String);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopEvent(Value : Boolean);
    procedure SetFTolerance(Value : Integer);
    procedure SetFTrackOver(Value : Boolean);
    procedure SetFOnBeforestart(Value : TExtDdDragTrackerOnBeforestart);
    procedure SetFOnDrag(Value : TExtDdDragTrackerOnDrag);
    procedure SetFOnDragend(Value : TExtDdDragTrackerOnDragend);
    procedure SetFOnDragstart(Value : TExtDdDragTrackerOnDragstart);
    procedure SetFOnMousedown(Value : TExtDdDragTrackerOnMousedown);
    procedure SetFOnMousemove(Value : TExtDdDragTrackerOnMousemove);
    procedure SetFOnMouseout(Value : TExtDdDragTrackerOnMouseout);
    procedure SetFOnMouseover(Value : TExtDdDragTrackerOnMouseover);
    procedure SetFOnMouseup(Value : TExtDdDragTrackerOnMouseup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetDragTarget : TExtFunction;
    function GetOffset(ConstrainMode : String = '') : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function InitEl(El : THTMLElement) : TExtFunction; overload;
    function InitEl(El : TExtElement) : TExtFunction; overload;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Active : Boolean read FActive write SetFActive;
    property AutoStart : Boolean read FAutoStart write SetFAutoStart;
    property AutoStartInteger : Integer read FAutoStartInteger write SetFAutoStartInteger;
    property ConstrainTo : TExtUtilRegion read FConstrainTo write SetFConstrainTo;
    property ConstrainToElement : TExtElement read FConstrainToElement write SetFConstrainToElement;
    property Delegate : String read FDelegate write SetFDelegate;
    property DragTarget : THTMLElement read FDragTarget write SetFDragTarget;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property OverCls : String read FOverCls write SetFOverCls;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopEvent : Boolean read FStopEvent write SetFStopEvent;
    property Tolerance : Integer read FTolerance write SetFTolerance;
    property TrackOver : Boolean read FTrackOver write SetFTrackOver;
    property OnBeforestart : TExtDdDragTrackerOnBeforestart read FOnBeforestart write SetFOnBeforestart;
    property OnDrag : TExtDdDragTrackerOnDrag read FOnDrag write SetFOnDrag;
    property OnDragend : TExtDdDragTrackerOnDragend read FOnDragend write SetFOnDragend;
    property OnDragstart : TExtDdDragTrackerOnDragstart read FOnDragstart write SetFOnDragstart;
    property OnMousedown : TExtDdDragTrackerOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMousemove : TExtDdDragTrackerOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseout : TExtDdDragTrackerOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtDdDragTrackerOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseup : TExtDdDragTrackerOnMouseup read FOnMouseup write SetFOnMouseup;
  end;

  TExtDiagLayoutContext = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDiagLayoutContextItem = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDdScrollManagerSingleton = class(TExtAbstractComponent)
  private
    FDdGroup : String;
    procedure SetFDdGroup(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function RefreshCache : TExtFunction;
    function Register(El : THTMLElement) : TExtFunction; overload;
    function Register(El : TExtObjectList) : TExtFunction; overload;
    function Register(El : TExtElement) : TExtFunction; overload;
    function Register(El : TArrayOfString) : TExtFunction; overload;
    function Register(El : String) : TExtFunction; overload;
    function Unregister(El : THTMLElement) : TExtFunction; overload;
    function Unregister(El : TExtObjectList) : TExtFunction; overload;
    function Unregister(El : TExtElement) : TExtFunction; overload;
    function Unregister(El : TArrayOfString) : TExtFunction; overload;
    function Unregister(El : String) : TExtFunction; overload;
    property DdGroup : String read FDdGroup write SetFDdGroup;
  end;

  TExtDirectEvent = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function GetData : TExtFunction;
    function GetName : TExtFunction;
  end;

  TExtDdRegistrySingleton = class(TExtAbstractComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetHandle(Id : THTMLElement) : TExtFunction; overload;
    function GetHandle(Id : String) : TExtFunction; overload;
    function GetHandleFromEvent(E : TEvent) : TExtFunction;
    function GetTarget(Id : THTMLElement) : TExtFunction; overload;
    function GetTarget(Id : String) : TExtFunction; overload;
    function GetTargetFromEvent(E : TEvent) : TExtFunction;
    function Register(Element : THTMLElement; Data : TExtObject) : TExtFunction; overload;
    function Register(Element : String; Data : TExtObject) : TExtFunction; overload;
    function Unregister(Element : THTMLElement) : TExtFunction; overload;
    function Unregister(Element : String) : TExtFunction; overload;
  end;

  TExtDataWriter = class(TExtAbstractComponent)
  private
    FDateFormat : String;
    FIsWriter : Boolean;
    FNameProperty : String;
    FWriteAllFields : Boolean;
    FWriteRecordId : Boolean;
    procedure SetFDateFormat(Value : String);
    procedure SetFIsWriter(Value : Boolean);
    procedure SetFNameProperty(Value : String);
    procedure SetFWriteAllFields(Value : Boolean);
    procedure SetFWriteRecordId(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function GetRecordData(RecordJS : TExtDataModel; Operation : TExtDataOperation = nil) : TExtFunction;
    function Write(Request : TExtDataRequest) : TExtFunction;
    property DateFormat : String read FDateFormat write SetFDateFormat;
    property IsWriter : Boolean read FIsWriter write SetFIsWriter;
    property NameProperty : String read FNameProperty write SetFNameProperty;
    property WriteAllFields : Boolean read FWriteAllFields write SetFWriteAllFields;
    property WriteRecordId : Boolean read FWriteRecordId write SetFWriteRecordId;
  end;

  // Procedural types for events TExtDirectProvider
  TExtDirectProviderOnConnect = procedure(Provider : TExtDirectProvider) of object;
  TExtDirectProviderOnData = procedure(Provider : TExtDirectProvider; E : TExtDirectEvent) of object;
  TExtDirectProviderOnDisconnect = procedure(Provider : TExtDirectProvider) of object;
  TExtDirectProviderOnException = procedure of object;

  TExtDirectProvider = class(TExtAbstractComponent)
  private
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FId : String;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FRelayedEvents : TArrayOfString;
    FOnConnect : TExtDirectProviderOnConnect;
    FOnData : TExtDirectProviderOnData;
    FOnDisconnect : TExtDirectProviderOnDisconnect;
    FOnException : TExtDirectProviderOnException;
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFId(Value : String);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFRelayedEvents(Value : TArrayOfString);
    procedure SetFOnConnect(Value : TExtDirectProviderOnConnect);
    procedure SetFOnData(Value : TExtDirectProviderOnData);
    procedure SetFOnDisconnect(Value : TExtDirectProviderOnDisconnect);
    procedure SetFOnException(Value : TExtDirectProviderOnException);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property Id : String read FId write SetFId;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property RelayedEvents : TArrayOfString read FRelayedEvents write SetFRelayedEvents;
    property OnConnect : TExtDirectProviderOnConnect read FOnConnect write SetFOnConnect;
    property OnData : TExtDirectProviderOnData read FOnData write SetFOnData;
    property OnDisconnect : TExtDirectProviderOnDisconnect read FOnDisconnect write SetFOnDisconnect;
    property OnException : TExtDirectProviderOnException read FOnException write SetFOnException;
  end;

  TExtGridProperty = class(TExtDataModel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPluginHeaderReorderer = class(TExtAbstractPlugin)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridPluginRowExpander
  TExtGridPluginRowExpanderOnCollapsebody = procedure(RowNode : THTMLElement; RecordJS : TExtDataModel; ExpandRow : THTMLElement) of object;
  TExtGridPluginRowExpanderOnExpandbody = procedure(RowNode : THTMLElement; RecordJS : TExtDataModel; ExpandRow : THTMLElement) of object;

  TExtGridPluginRowExpander = class(TExtAbstractPlugin)
  private
    FExpandOnDblClick : Boolean;
    FExpandOnEnter : Boolean;
    FSelectRowOnExpand : Boolean;
    FOnCollapsebody : TExtGridPluginRowExpanderOnCollapsebody;
    FOnExpandbody : TExtGridPluginRowExpanderOnExpandbody;
    procedure SetFExpandOnDblClick(Value : Boolean);
    procedure SetFExpandOnEnter(Value : Boolean);
    procedure SetFSelectRowOnExpand(Value : Boolean);
    procedure SetFOnCollapsebody(Value : TExtGridPluginRowExpanderOnCollapsebody);
    procedure SetFOnExpandbody(Value : TExtGridPluginRowExpanderOnExpandbody);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ExpandOnDblClick : Boolean read FExpandOnDblClick write SetFExpandOnDblClick;
    property ExpandOnEnter : Boolean read FExpandOnEnter write SetFExpandOnEnter;
    property SelectRowOnExpand : Boolean read FSelectRowOnExpand write SetFSelectRowOnExpand;
    property OnCollapsebody : TExtGridPluginRowExpanderOnCollapsebody read FOnCollapsebody write SetFOnCollapsebody;
    property OnExpandbody : TExtGridPluginRowExpanderOnExpandbody read FOnExpandbody write SetFOnExpandbody;
  end;

  TExtChartSeriesPie = class(TExtChartSeries)
  private
    FAngleField : String;
    FColorSet : TExtObjectList;
    FDonut : Boolean;
    FDonutInteger : Integer;
    FField : String;
    FHighlightDuration : Integer;
    FLengthField : String;
    FShowInLegend : Boolean;
    FStyle : TExtObject;
    FXField : String;
    procedure SetFAngleField(Value : String);
    procedure SetFColorSet(Value : TExtObjectList);
    procedure SetFDonut(Value : Boolean);
    procedure SetFDonutInteger(Value : Integer);
    procedure SetFField(Value : String);
    procedure SetFHighlightDuration(Value : Integer);
    procedure SetFLengthField(Value : String);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFStyle(Value : TExtObject);
    procedure SetFXField(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function GetLegendColor(Info : TExtObject) : TExtFunction;
    function HighlightItem(Info : TExtObject) : TExtFunction;
    function UnHighlightItem(Info : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property AngleField : String read FAngleField write SetFAngleField;
    property ColorSet : TExtObjectList read FColorSet write SetFColorSet;
    property Donut : Boolean read FDonut write SetFDonut;
    property DonutInteger : Integer read FDonutInteger write SetFDonutInteger;
    property Field : String read FField write SetFField;
    property HighlightDuration : Integer read FHighlightDuration write SetFHighlightDuration;
    property LengthField : String read FLengthField write SetFLengthField;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property Style : TExtObject read FStyle write SetFStyle;
    property XField : String read FXField write SetFXField;
  end;

  TExtGridPluginHeaderResizer = class(TExtAbstractPlugin)
  private
    FDynamic : Boolean;
    procedure SetFDynamic(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Dynamic : Boolean read FDynamic write SetFDynamic;
  end;

  TExtLoadMask = class(TExtComponent)
  private
    FConstrain : Boolean;
    FFixed : Boolean;
    FFocusOnToFront : Boolean;
    FMaskCls : String;
    FMsg : String;
    FMsgCls : String;
    FShadow : String;
    FShadowBoolean : Boolean;
    FShadowOffset : Integer;
    FStore : TExtDataStore;
    FTarget : TExtComponent;
    FUseMsg : Boolean;
    FUseTargetEl : Boolean;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFFixed(Value : Boolean);
    procedure SetFFocusOnToFront(Value : Boolean);
    procedure SetFMaskCls(Value : String);
    procedure SetFMsg(Value : String);
    procedure SetFMsgCls(Value : String);
    procedure SetFShadow(Value : String);
    procedure SetFShadowBoolean(Value : Boolean);
    procedure SetFShadowOffset(Value : Integer);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFUseMsg(Value : Boolean);
    procedure SetFUseTargetEl(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    function BindStore(Store : TExtDataStore) : TExtFunction; overload;
    function Center : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function DoConstrain(ConstrainTo : String = '') : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtElement) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; overload;
    function DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; overload;
    function GetStore : TExtFunction;
    function SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction;
    function ToBack : TExtFunction;
    function ToFront(PreventFocus : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Fixed : Boolean read FFixed write SetFFixed;
    property FocusOnToFront : Boolean read FFocusOnToFront write SetFFocusOnToFront;
    property MaskCls : String read FMaskCls write SetFMaskCls;
    property Msg : String read FMsg write SetFMsg;
    property MsgCls : String read FMsgCls write SetFMsgCls;
    property Shadow : String read FShadow write SetFShadow;
    property ShadowBoolean : Boolean read FShadowBoolean write SetFShadowBoolean;
    property ShadowOffset : Integer read FShadowOffset write SetFShadowOffset;
    property Store : TExtDataStore read FStore write SetFStore;
    property Target : TExtComponent read FTarget write SetFTarget;
    property UseMsg : Boolean read FUseMsg write SetFUseMsg;
    property UseTargetEl : Boolean read FUseTargetEl write SetFUseTargetEl;
  end;

  // Procedural types for events TExtFlashComponent
  TExtFlashComponentOnFailure = procedure(This : TExtFlashComponent) of object;
  TExtFlashComponentOnSuccess = procedure(This : TExtFlashComponent) of object;

  TExtFlashComponent = class(TExtComponent)
  private
    FBackgroundColor : String;
    FExpressInstall : Boolean;
    FFlashAttributes : TExtObject;
    FFlashParams : TExtObject;
    FFlashVars : TExtObject;
    FFlashVersion : String;
    FSwf : TExtElement;
    FSwfHeight : Integer; // 100
    FSwfHeightString : String;
    FSwfWidth : Integer; // 100
    FSwfWidthString : String;
    FUrl : String;
    FWmode : String;
    FOnFailure : TExtFlashComponentOnFailure;
    FOnSuccess : TExtFlashComponentOnSuccess;
    procedure SetFBackgroundColor(Value : String);
    procedure SetFExpressInstall(Value : Boolean);
    procedure SetFFlashAttributes(Value : TExtObject);
    procedure SetFFlashParams(Value : TExtObject);
    procedure SetFFlashVars(Value : TExtObject);
    procedure SetFFlashVersion(Value : String);
    procedure SetFSwf(Value : TExtElement);
    procedure SetFSwfHeight(Value : Integer);
    procedure SetFSwfHeightString(Value : String);
    procedure SetFSwfWidth(Value : Integer);
    procedure SetFSwfWidthString(Value : String);
    procedure SetFUrl(Value : String);
    procedure SetFWmode(Value : String);
    procedure SetFOnFailure(Value : TExtFlashComponentOnFailure);
    procedure SetFOnSuccess(Value : TExtFlashComponentOnSuccess);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetSwfId : TExtFunction;
    destructor Destroy; override;
    property BackgroundColor : String read FBackgroundColor write SetFBackgroundColor;
    property ExpressInstall : Boolean read FExpressInstall write SetFExpressInstall;
    property FlashAttributes : TExtObject read FFlashAttributes write SetFFlashAttributes;
    property FlashParams : TExtObject read FFlashParams write SetFFlashParams;
    property FlashVars : TExtObject read FFlashVars write SetFFlashVars;
    property FlashVersion : String read FFlashVersion write SetFFlashVersion;
    property Swf : TExtElement read FSwf write SetFSwf;
    property SwfHeight : Integer read FSwfHeight write SetFSwfHeight;
    property SwfHeightString : String read FSwfHeightString write SetFSwfHeightString;
    property SwfWidth : Integer read FSwfWidth write SetFSwfWidth;
    property SwfWidthString : String read FSwfWidthString write SetFSwfWidthString;
    property Url : String read FUrl write SetFUrl;
    property Wmode : String read FWmode write SetFWmode;
    property OnFailure : TExtFlashComponentOnFailure read FOnFailure write SetFOnFailure;
    property OnSuccess : TExtFlashComponentOnSuccess read FOnSuccess write SetFOnSuccess;
  end;

  TExtDataGroup = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataProxyClient = class(TExtDataProxy)
  private
    FIsSynchronous : Boolean;
    procedure SetFIsSynchronous(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear : TExtFunction;
    property IsSynchronous : Boolean read FIsSynchronous write SetFIsSynchronous;
  end;

  TExtChartSeriesRadar = class(TExtChartSeries)
  private
    FMarkerConfig : TExtObject;
    FShowMarkers : Boolean;
    FStyle : TExtObject;
    FXField : String;
    FYField : String;
    procedure SetFMarkerConfig(Value : TExtObject);
    procedure SetFShowMarkers(Value : Boolean);
    procedure SetFStyle(Value : TExtObject);
    procedure SetFXField(Value : String);
    procedure SetFYField(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property MarkerConfig : TExtObject read FMarkerConfig write SetFMarkerConfig;
    property ShowMarkers : Boolean read FShowMarkers write SetFShowMarkers;
    property Style : TExtObject read FStyle write SetFStyle;
    property XField : String read FXField write SetFXField;
    property YField : String read FYField write SetFYField;
  end;

  TExtUtilTaskManagerSingleton = class(TExtUtilTaskRunner)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridPluginEditing
  TExtGridPluginEditingOnBeforeedit = procedure(Editor : TExtGridPluginEditing; Context : TExtObject) of object;
  TExtGridPluginEditingOnCanceledit = procedure(Editor : TExtGridPluginEditing; Context : TExtObject) of object;
  TExtGridPluginEditingOnEdit = procedure(Editor : TExtGridPluginEditing; Context : TExtObject) of object;
  TExtGridPluginEditingOnValidateedit = procedure(Editor : TExtGridPluginEditing; Context : TExtObject) of object;

  TExtGridPluginEditing = class(TExtAbstractPlugin)
  private
    FClicksToEdit : Integer;
    FEditing : Boolean;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FTriggerEvent : String;
    FOnBeforeedit : TExtGridPluginEditingOnBeforeedit;
    FOnCanceledit : TExtGridPluginEditingOnCanceledit;
    FOnEdit : TExtGridPluginEditingOnEdit;
    FOnValidateedit : TExtGridPluginEditingOnValidateedit;
    procedure SetFClicksToEdit(Value : Integer);
    procedure SetFEditing(Value : Boolean);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFTriggerEvent(Value : String);
    procedure SetFOnBeforeedit(Value : TExtGridPluginEditingOnBeforeedit);
    procedure SetFOnCanceledit(Value : TExtGridPluginEditingOnCanceledit);
    procedure SetFOnEdit(Value : TExtGridPluginEditingOnEdit);
    procedure SetFOnValidateedit(Value : TExtGridPluginEditingOnValidateedit);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function CancelEdit : TExtFunction;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function CompleteEdit : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; overload;
    function StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; overload;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property ClicksToEdit : Integer read FClicksToEdit write SetFClicksToEdit;
    property Editing : Boolean read FEditing write SetFEditing;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property TriggerEvent : String read FTriggerEvent write SetFTriggerEvent;
    property OnBeforeedit : TExtGridPluginEditingOnBeforeedit read FOnBeforeedit write SetFOnBeforeedit;
    property OnCanceledit : TExtGridPluginEditingOnCanceledit read FOnCanceledit write SetFOnCanceledit;
    property OnEdit : TExtGridPluginEditingOnEdit read FOnEdit write SetFOnEdit;
    property OnValidateedit : TExtGridPluginEditingOnValidateedit read FOnValidateedit write SetFOnValidateedit;
  end;

  TExtDomCompositeElement = class(TExtDomCompositeElementLite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtMenuItem
  TExtMenuItemOnActivate = procedure(Item : TExtMenuItem) of object;
  TExtMenuItemOnClick = procedure(Item : TExtMenuItem; E : TExtEventObject) of object;
  TExtMenuItemOnDeactivate = procedure(Item : TExtMenuItem) of object;
  TExtMenuItemOnIconchange = procedure(This : TExtMenuItem; OldIcon : String; NewIcon : String) of object;
  TExtMenuItemOnTextchange = procedure(This : TExtMenuItem; OldText : String; NewText : String) of object;

  TExtMenuItem = class(TExtComponent)
  private
    FActivated : Boolean;
    FActiveCls : String;
    FCanActivate : Boolean;
    FClickHideDelay : Integer;
    FDestroyMenu : Boolean;
    FDisabledCls : String;
    FGlyph : Integer;
    FGlyphString : String;
    FHandler : TExtFunction;
    FHandlerE : TExtEventObject;
    FHandlerItem : TExtMenuItem;
    FHideOnClick : Boolean;
    FHref : String;
    FHrefTarget : String;
    FIcon : String;
    FIconCls : String;
    FMenu : TExtMenu;
    FMenuAlign : String;
    FMenuExpandDelay : Integer;
    FMenuHideDelay : Integer;
    FMenuObject : TExtObject;
    FParentMenu : TExtMenu;
    FPlain : Boolean;
    FText : String;
    FTooltip : String;
    FTooltipObject : TExtObject;
    FTooltipType : String;
    FOnActivate : TExtMenuItemOnActivate;
    FOnClick : TExtMenuItemOnClick;
    FOnDeactivate : TExtMenuItemOnDeactivate;
    FOnIconchange : TExtMenuItemOnIconchange;
    FOnTextchange : TExtMenuItemOnTextchange;
    procedure SetFActivated(Value : Boolean);
    procedure SetFActiveCls(Value : String);
    procedure SetFCanActivate(Value : Boolean);
    procedure SetFClickHideDelay(Value : Integer);
    procedure SetFDestroyMenu(Value : Boolean);
    procedure SetFDisabledCls(Value : String);
    procedure SetFGlyph(Value : Integer);
    procedure SetFGlyphString(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFHandlerE(Value : TExtEventObject);
    procedure SetFHandlerItem(Value : TExtMenuItem);
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFMenuAlign(Value : String);
    procedure SetFMenuExpandDelay(Value : Integer);
    procedure SetFMenuHideDelay(Value : Integer);
    procedure SetFMenuObject(Value : TExtObject);
    procedure SetFParentMenu(Value : TExtMenu);
    procedure SetFPlain(Value : Boolean);
    procedure SetFText(Value : String);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipObject(Value : TExtObject);
    procedure SetFTooltipType(Value : String);
    procedure SetFOnActivate(Value : TExtMenuItemOnActivate);
    procedure SetFOnClick(Value : TExtMenuItemOnClick);
    procedure SetFOnDeactivate(Value : TExtMenuItemOnDeactivate);
    procedure SetFOnIconchange(Value : TExtMenuItemOnIconchange);
    procedure SetFOnTextchange(Value : TExtMenuItemOnTextchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetHandler(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function SetIcon(Icon : String) : TExtFunction;
    function SetIconCls(IconCls : String) : TExtFunction;
    function SetMenu(Menu : TExtObject; DestroyMenu : Boolean = false) : TExtFunction; overload;
    function SetMenu(Menu : TExtMenu; DestroyMenu : Boolean = false) : TExtFunction; overload;
    function SetText(Text : String) : TExtFunction;
    function SetTooltip(Tooltip : TExtObject) : TExtFunction; overload;
    function SetTooltip(Tooltip : String) : TExtFunction; overload;
    destructor Destroy; override;
    property Activated : Boolean read FActivated write SetFActivated;
    property ActiveCls : String read FActiveCls write SetFActiveCls;
    property CanActivate : Boolean read FCanActivate write SetFCanActivate;
    property ClickHideDelay : Integer read FClickHideDelay write SetFClickHideDelay;
    property DestroyMenu : Boolean read FDestroyMenu write SetFDestroyMenu;
    property DisabledCls : String read FDisabledCls write SetFDisabledCls;
    property Glyph : Integer read FGlyph write SetFGlyph;
    property GlyphString : String read FGlyphString write SetFGlyphString;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property HandlerE : TExtEventObject read FHandlerE write SetFHandlerE;
    property HandlerItem : TExtMenuItem read FHandlerItem write SetFHandlerItem;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property MenuAlign : String read FMenuAlign write SetFMenuAlign;
    property MenuExpandDelay : Integer read FMenuExpandDelay write SetFMenuExpandDelay;
    property MenuHideDelay : Integer read FMenuHideDelay write SetFMenuHideDelay;
    property MenuObject : TExtObject read FMenuObject write SetFMenuObject;
    property ParentMenu : TExtMenu read FParentMenu write SetFParentMenu;
    property Plain : Boolean read FPlain write SetFPlain;
    property Text : String read FText write SetFText;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipObject : TExtObject read FTooltipObject write SetFTooltipObject;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property OnActivate : TExtMenuItemOnActivate read FOnActivate write SetFOnActivate;
    property OnClick : TExtMenuItemOnClick read FOnClick write SetFOnClick;
    property OnDeactivate : TExtMenuItemOnDeactivate read FOnDeactivate write SetFOnDeactivate;
    property OnIconchange : TExtMenuItemOnIconchange read FOnIconchange write SetFOnIconchange;
    property OnTextchange : TExtMenuItemOnTextchange read FOnTextchange write SetFOnTextchange;
  end;

  TExtChartMaskLayer = class(TExtComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilPoint = class(TExtUtilRegion)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(X : Integer; Y : Integer);
    function Equals(P : TExtUtilPoint) : TExtFunction; overload;
    function Equals(P : TExtObject) : TExtFunction; overload;
    function FromEvent(E : TExtEventObject) : TExtFunction; overload;
    function FromEvent(E : TEvent) : TExtFunction; overload;
    function IsContainedBy(Region : THTMLElement) : TExtFunction; overload;
    function IsContainedBy(Region : TExtUtilRegion) : TExtFunction; overload;
    function IsContainedBy(Region : TExtDomElement) : TExtFunction; overload;
    function IsContainedBy(Region : TExtComponent) : TExtFunction; overload;
    function IsWithin(P : TExtObject; Threshold : TExtObject) : TExtFunction; overload;
    function IsWithin(P : TExtUtilPoint; Threshold : TExtObject) : TExtFunction; overload;
    function IsWithin(P : TExtUtilPoint; Threshold : Integer) : TExtFunction; overload;
    function IsWithin(P : TExtObject; Threshold : Integer) : TExtFunction; overload;
    function RoundedEquals(P : TExtUtilPoint) : TExtFunction; overload;
    function RoundedEquals(P : TExtObject) : TExtFunction; overload;
    function ToString : TExtFunction;
  end;

  TExtDataWriterJson = class(TExtDataWriter)
  private
    FAllowSingle : Boolean;
    FEncode : Boolean;
    FExpandData : Boolean;
    FRoot : String;
    procedure SetFAllowSingle(Value : Boolean);
    procedure SetFEncode(Value : Boolean);
    procedure SetFExpandData(Value : Boolean);
    procedure SetFRoot(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AllowSingle : Boolean read FAllowSingle write SetFAllowSingle;
    property Encode : Boolean read FEncode write SetFEncode;
    property ExpandData : Boolean read FExpandData write SetFExpandData;
    property Root : String read FRoot write SetFRoot;
  end;

  TExtDdStatusProxy = class(TExtComponent)
  private
    FDropAllowed : String;
    FDropNotAllowed : String;
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    function GetGhost : TExtFunction;
    function Hide(Clear : Boolean) : TExtFunction;
    function Repair(Xy : TArrayOfInteger; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Reset(ClearGhost : Boolean) : TExtFunction;
    function SetStatus(CssClass : String) : TExtFunction;
    function Stop : TExtFunction;
    function Sync : TExtFunction;
    function Update(Html : THTMLElement) : TExtFunction; overload;
    function Update(Html : String) : TExtFunction; overload;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
  end;

  // Procedural types for events TExtDomElement
  TExtDomElementOnAbort = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnBlur = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnChange = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnClick = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnContextmenu = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDblclick = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMActivate = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMAttrModified = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMCharacterDataModified = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMFocusIn = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMFocusOut = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeInserted = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeInsertedIntoDocument = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeRemoved = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMNodeRemovedFromDocument = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnDOMSubtreeModified = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnError = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnFocus = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeydown = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeypress = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnKeyup = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnLoad = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMousedown = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseenter = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseleave = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMousemove = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseout = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseover = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnMouseup = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnReset = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnResize = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnScroll = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnSelect = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnSubmit = procedure(E : TExtEventObject; T : THTMLElement) of object;
  TExtDomElementOnUnload = procedure(E : TExtEventObject; T : THTMLElement) of object;

  TExtDomElement = class(TExtDomAbstractElement)
  private
    FAutoBoxAdjust : Boolean;
    FOnAbort : TExtDomElementOnAbort;
    FOnBlur : TExtDomElementOnBlur;
    FOnChange : TExtDomElementOnChange;
    FOnClick : TExtDomElementOnClick;
    FOnContextmenu : TExtDomElementOnContextmenu;
    FOnDblclick : TExtDomElementOnDblclick;
    FOnDOMActivate : TExtDomElementOnDOMActivate;
    FOnDOMAttrModified : TExtDomElementOnDOMAttrModified;
    FOnDOMCharacterDataModified : TExtDomElementOnDOMCharacterDataModified;
    FOnDOMFocusIn : TExtDomElementOnDOMFocusIn;
    FOnDOMFocusOut : TExtDomElementOnDOMFocusOut;
    FOnDOMNodeInserted : TExtDomElementOnDOMNodeInserted;
    FOnDOMNodeInsertedIntoDocument : TExtDomElementOnDOMNodeInsertedIntoDocument;
    FOnDOMNodeRemoved : TExtDomElementOnDOMNodeRemoved;
    FOnDOMNodeRemovedFromDocument : TExtDomElementOnDOMNodeRemovedFromDocument;
    FOnDOMSubtreeModified : TExtDomElementOnDOMSubtreeModified;
    FOnError : TExtDomElementOnError;
    FOnFocus : TExtDomElementOnFocus;
    FOnKeydown : TExtDomElementOnKeydown;
    FOnKeypress : TExtDomElementOnKeypress;
    FOnKeyup : TExtDomElementOnKeyup;
    FOnLoad : TExtDomElementOnLoad;
    FOnMousedown : TExtDomElementOnMousedown;
    FOnMouseenter : TExtDomElementOnMouseenter;
    FOnMouseleave : TExtDomElementOnMouseleave;
    FOnMousemove : TExtDomElementOnMousemove;
    FOnMouseout : TExtDomElementOnMouseout;
    FOnMouseover : TExtDomElementOnMouseover;
    FOnMouseup : TExtDomElementOnMouseup;
    FOnReset : TExtDomElementOnReset;
    FOnResize : TExtDomElementOnResize;
    FOnScroll : TExtDomElementOnScroll;
    FOnSelect : TExtDomElementOnSelect;
    FOnSubmit : TExtDomElementOnSubmit;
    FOnUnload : TExtDomElementOnUnload;
    procedure SetFAutoBoxAdjust(Value : Boolean);
    procedure SetFOnAbort(Value : TExtDomElementOnAbort);
    procedure SetFOnBlur(Value : TExtDomElementOnBlur);
    procedure SetFOnChange(Value : TExtDomElementOnChange);
    procedure SetFOnClick(Value : TExtDomElementOnClick);
    procedure SetFOnContextmenu(Value : TExtDomElementOnContextmenu);
    procedure SetFOnDblclick(Value : TExtDomElementOnDblclick);
    procedure SetFOnDOMActivate(Value : TExtDomElementOnDOMActivate);
    procedure SetFOnDOMAttrModified(Value : TExtDomElementOnDOMAttrModified);
    procedure SetFOnDOMCharacterDataModified(Value : TExtDomElementOnDOMCharacterDataModified);
    procedure SetFOnDOMFocusIn(Value : TExtDomElementOnDOMFocusIn);
    procedure SetFOnDOMFocusOut(Value : TExtDomElementOnDOMFocusOut);
    procedure SetFOnDOMNodeInserted(Value : TExtDomElementOnDOMNodeInserted);
    procedure SetFOnDOMNodeInsertedIntoDocument(Value : TExtDomElementOnDOMNodeInsertedIntoDocument);
    procedure SetFOnDOMNodeRemoved(Value : TExtDomElementOnDOMNodeRemoved);
    procedure SetFOnDOMNodeRemovedFromDocument(Value : TExtDomElementOnDOMNodeRemovedFromDocument);
    procedure SetFOnDOMSubtreeModified(Value : TExtDomElementOnDOMSubtreeModified);
    procedure SetFOnError(Value : TExtDomElementOnError);
    procedure SetFOnFocus(Value : TExtDomElementOnFocus);
    procedure SetFOnKeydown(Value : TExtDomElementOnKeydown);
    procedure SetFOnKeypress(Value : TExtDomElementOnKeypress);
    procedure SetFOnKeyup(Value : TExtDomElementOnKeyup);
    procedure SetFOnLoad(Value : TExtDomElementOnLoad);
    procedure SetFOnMousedown(Value : TExtDomElementOnMousedown);
    procedure SetFOnMouseenter(Value : TExtDomElementOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtDomElementOnMouseleave);
    procedure SetFOnMousemove(Value : TExtDomElementOnMousemove);
    procedure SetFOnMouseout(Value : TExtDomElementOnMouseout);
    procedure SetFOnMouseover(Value : TExtDomElementOnMouseover);
    procedure SetFOnMouseup(Value : TExtDomElementOnMouseup);
    procedure SetFOnReset(Value : TExtDomElementOnReset);
    procedure SetFOnResize(Value : TExtDomElementOnResize);
    procedure SetFOnScroll(Value : TExtDomElementOnScroll);
    procedure SetFOnSelect(Value : TExtDomElementOnSelect);
    procedure SetFOnSubmit(Value : TExtDomElementOnSubmit);
    procedure SetFOnUnload(Value : TExtDomElementOnUnload);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddKeyListener(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function AddKeyListener(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function AddKeyListener(Key : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function AddKeyListener(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; overload;
    function AddKeyMap(Config : TExtObject) : TExtFunction;
    function Blur : TExtFunction;
    function CacheScrollValues : TExtFunction;
    function Clean(ForceReclean : Boolean = false) : TExtFunction;
    function CreateProxy(Config : String; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : TExtObject; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : TExtObject; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateProxy(Config : String; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; overload;
    function CreateShim : TExtFunction;
    function EnableDisplayMode(Display : String = '') : TExtFunction;
    function Focus(Defer : Integer = 0) : TExtFunction;
    function GetAttributeNS(Namespace : String; Name : String) : TExtFunction;
    function GetLoader : TExtFunction;
    function Hover(OverFn : TExtFunction; OutFn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction;
    function IsBorderBox : TExtFunction;
    function IsDisplayed : TExtFunction;
    function IsFocusable : TExtFunction;
    function IsMasked : TExtFunction;
    function IsVisible(Deep : Boolean = false) : TExtFunction;
    function Load : TExtFunction;
    function Mask(Msg : String = ''; MsgCls : String = '') : TExtFunction;
    function MonitorMouseLeave(Delay : Integer; Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function NeedsTabIndex : TExtFunction;
    function On(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction;
    function PurgeAllListeners : TExtFunction;
    function RelayEvent(EventName : String; Observable : TExtObject) : TExtFunction;
    function RemoveAllListeners : TExtFunction;
    function SwallowEvent(EventName : TArrayOfString; PreventDefault : Boolean = false) : TExtFunction; overload;
    function SwallowEvent(EventName : String; PreventDefault : Boolean = false) : TExtFunction; overload;
    function Un(EventName : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Unmask : TExtFunction;
    function Update(Html : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction;
    property AutoBoxAdjust : Boolean read FAutoBoxAdjust write SetFAutoBoxAdjust;
    property OnAbort : TExtDomElementOnAbort read FOnAbort write SetFOnAbort;
    property OnBlur : TExtDomElementOnBlur read FOnBlur write SetFOnBlur;
    property OnChange : TExtDomElementOnChange read FOnChange write SetFOnChange;
    property OnClick : TExtDomElementOnClick read FOnClick write SetFOnClick;
    property OnContextmenu : TExtDomElementOnContextmenu read FOnContextmenu write SetFOnContextmenu;
    property OnDblclick : TExtDomElementOnDblclick read FOnDblclick write SetFOnDblclick;
    property OnDOMActivate : TExtDomElementOnDOMActivate read FOnDOMActivate write SetFOnDOMActivate;
    property OnDOMAttrModified : TExtDomElementOnDOMAttrModified read FOnDOMAttrModified write SetFOnDOMAttrModified;
    property OnDOMCharacterDataModified : TExtDomElementOnDOMCharacterDataModified read FOnDOMCharacterDataModified write SetFOnDOMCharacterDataModified;
    property OnDOMFocusIn : TExtDomElementOnDOMFocusIn read FOnDOMFocusIn write SetFOnDOMFocusIn;
    property OnDOMFocusOut : TExtDomElementOnDOMFocusOut read FOnDOMFocusOut write SetFOnDOMFocusOut;
    property OnDOMNodeInserted : TExtDomElementOnDOMNodeInserted read FOnDOMNodeInserted write SetFOnDOMNodeInserted;
    property OnDOMNodeInsertedIntoDocument : TExtDomElementOnDOMNodeInsertedIntoDocument read FOnDOMNodeInsertedIntoDocument write SetFOnDOMNodeInsertedIntoDocument;
    property OnDOMNodeRemoved : TExtDomElementOnDOMNodeRemoved read FOnDOMNodeRemoved write SetFOnDOMNodeRemoved;
    property OnDOMNodeRemovedFromDocument : TExtDomElementOnDOMNodeRemovedFromDocument read FOnDOMNodeRemovedFromDocument write SetFOnDOMNodeRemovedFromDocument;
    property OnDOMSubtreeModified : TExtDomElementOnDOMSubtreeModified read FOnDOMSubtreeModified write SetFOnDOMSubtreeModified;
    property OnError : TExtDomElementOnError read FOnError write SetFOnError;
    property OnFocus : TExtDomElementOnFocus read FOnFocus write SetFOnFocus;
    property OnKeydown : TExtDomElementOnKeydown read FOnKeydown write SetFOnKeydown;
    property OnKeypress : TExtDomElementOnKeypress read FOnKeypress write SetFOnKeypress;
    property OnKeyup : TExtDomElementOnKeyup read FOnKeyup write SetFOnKeyup;
    property OnLoad : TExtDomElementOnLoad read FOnLoad write SetFOnLoad;
    property OnMousedown : TExtDomElementOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseenter : TExtDomElementOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtDomElementOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnMousemove : TExtDomElementOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseout : TExtDomElementOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtDomElementOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseup : TExtDomElementOnMouseup read FOnMouseup write SetFOnMouseup;
    property OnReset : TExtDomElementOnReset read FOnReset write SetFOnReset;
    property OnResize : TExtDomElementOnResize read FOnResize write SetFOnResize;
    property OnScroll : TExtDomElementOnScroll read FOnScroll write SetFOnScroll;
    property OnSelect : TExtDomElementOnSelect read FOnSelect write SetFOnSelect;
    property OnSubmit : TExtDomElementOnSubmit read FOnSubmit write SetFOnSubmit;
    property OnUnload : TExtDomElementOnUnload read FOnUnload write SetFOnUnload;
  end;

  TExtChartSeriesGauge = class(TExtChartSeries)
  private
    FAngleField : String;
    FDonut : Boolean;
    FDonutInteger : Integer;
    FHighlightDuration : Integer;
    FNeedle : Boolean;
    FShowInLegend : Boolean;
    FStyle : TExtObject;
    procedure SetFAngleField(Value : String);
    procedure SetFDonut(Value : Boolean);
    procedure SetFDonutInteger(Value : Integer);
    procedure SetFHighlightDuration(Value : Integer);
    procedure SetFNeedle(Value : Boolean);
    procedure SetFShowInLegend(Value : Boolean);
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function GetLegendColor(Info : TExtObject) : TExtFunction;
    function SetValue : TExtFunction;
    destructor Destroy; override;
    property AngleField : String read FAngleField write SetFAngleField;
    property Donut : Boolean read FDonut write SetFDonut;
    property DonutInteger : Integer read FDonutInteger write SetFDonutInteger;
    property HighlightDuration : Integer read FHighlightDuration write SetFHighlightDuration;
    property Needle : Boolean read FNeedle write SetFNeedle;
    property ShowInLegend : Boolean read FShowInLegend write SetFShowInLegend;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtGridPluginDivRenderer = class(TExtAbstractPlugin)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtGridPluginDragDrop
  TExtGridPluginDragDropOnBeforedrop = procedure(Node : THTMLElement; Data : TExtObject; OverModel : TExtDataModel; DropPosition : String; DropHandlers : TExtObject) of object;
  TExtGridPluginDragDropOnDrop = procedure(Node : THTMLElement; Data : TExtObject; OverModel : TExtDataModel; DropPosition : String) of object;

  TExtGridPluginDragDrop = class(TExtAbstractPlugin)
  private
    FContainerScroll : TExtObject;
    FContainerScrollBoolean : Boolean;
    FDdGroup : String;
    FDragGroup : String;
    FDropGroup : String;
    FEnableDrag : Boolean;
    FEnableDrop : Boolean;
    FOnBeforedrop : TExtGridPluginDragDropOnBeforedrop;
    FOnDrop : TExtGridPluginDragDropOnDrop;
    procedure SetFContainerScroll(Value : TExtObject);
    procedure SetFContainerScrollBoolean(Value : Boolean);
    procedure SetFDdGroup(Value : String);
    procedure SetFDragGroup(Value : String);
    procedure SetFDropGroup(Value : String);
    procedure SetFEnableDrag(Value : Boolean);
    procedure SetFEnableDrop(Value : Boolean);
    procedure SetFOnBeforedrop(Value : TExtGridPluginDragDropOnBeforedrop);
    procedure SetFOnDrop(Value : TExtGridPluginDragDropOnDrop);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property ContainerScroll : TExtObject read FContainerScroll write SetFContainerScroll;
    property ContainerScrollBoolean : Boolean read FContainerScrollBoolean write SetFContainerScrollBoolean;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DragGroup : String read FDragGroup write SetFDragGroup;
    property DropGroup : String read FDropGroup write SetFDropGroup;
    property EnableDrag : Boolean read FEnableDrag write SetFEnableDrag;
    property EnableDrop : Boolean read FEnableDrop write SetFEnableDrop;
    property OnBeforedrop : TExtGridPluginDragDropOnBeforedrop read FOnBeforedrop write SetFOnBeforedrop;
    property OnDrop : TExtGridPluginDragDropOnDrop read FOnDrop write SetFOnDrop;
  end;

  TExtMenuKeyNav = class(TExtUtilKeyNav)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPluginBufferedRenderer = class(TExtAbstractPlugin)
  private
    FPosition : Integer;
    FSynchronousRender : Boolean;
    FVariableRowHeight : Boolean;
    procedure SetFPosition(Value : Integer);
    procedure SetFSynchronousRender(Value : Boolean);
    procedure SetFVariableRowHeight(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ScrollTo(RecordIdx : Integer; DoSelect : Boolean; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    property Position : Integer read FPosition write SetFPosition;
    property SynchronousRender : Boolean read FSynchronousRender write SetFSynchronousRender;
    property VariableRowHeight : Boolean read FVariableRowHeight write SetFVariableRowHeight;
  end;

  TExtChartSeriesCartesian = class(TExtChartSeries)
  private
    FAxis : String;
    FAxisTArrayOfString : TArrayOfString;
    FXField : String;
    FYField : String;
    FYFieldTArrayOfString : TArrayOfString;
    procedure SetFAxis(Value : String);
    procedure SetFAxisTArrayOfString(Value : TArrayOfString);
    procedure SetFXField(Value : String);
    procedure SetFYField(Value : String);
    procedure SetFYFieldTArrayOfString(Value : TArrayOfString);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetMinMaxXValues : TExtFunction;
    function GetMinMaxYValues : TExtFunction;
    property Axis : String read FAxis write SetFAxis;
    property AxisTArrayOfString : TArrayOfString read FAxisTArrayOfString write SetFAxisTArrayOfString;
    property XField : String read FXField write SetFXField;
    property YField : String read FYField write SetFYField;
    property YFieldTArrayOfString : TArrayOfString read FYFieldTArrayOfString write SetFYFieldTArrayOfString;
  end;

  TExtDrawEngineSvg = class(TExtDrawSurface)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ApplyZIndex(Sprite : TExtDrawSprite) : TExtFunction;
    function GetRegion : TExtFunction;
    function HasCls(Sprite : TExtDrawSprite; ClassName : String) : TExtFunction;
  end;

  TExtDdDD = class(TExtDdDragDrop)
  private
    FScroll : Boolean;
    procedure SetFScroll(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AlignElWithMouse(El : THTMLElement; IPageX : Integer; IPageY : Integer) : TExtFunction;
    function ApplyConfig : TExtFunction;
    function AutoOffset(IPageX : Integer; IPageY : Integer) : TExtFunction;
    function B4Drag : TExtFunction;
    function B4MouseDown : TExtFunction;
    function CachePosition(IPageX : Integer = 0; IPageY : Integer = 0) : TExtFunction;
    constructor Create(Id : String; SGroup : String; Config : TExtObject);
    function SetDelta(IDeltaX : Integer; IDeltaY : Integer) : TExtFunction;
    function SetDragElPos(IPageX : Integer; IPageY : Integer) : TExtFunction;
    property Scroll : Boolean read FScroll write SetFScroll;
  end;

  // Procedural types for events TExtProgressBar
  TExtProgressBarOnUpdate = procedure(This : TExtProgressBar; Value : Integer; Text : String) of object;

  TExtProgressBar = class(TExtComponent)
  private
    FAnimate : Boolean;
    FAnimateObject : TExtObject;
    FBaseCls : String;
    FId : String;
    FText : String;
    FTextEl : String;
    FTextElElement : TExtElement;
    FTextElTHTMLElement : THTMLElement;
    FValue : Integer;
    FOnUpdate : TExtProgressBarOnUpdate;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFAnimateObject(Value : TExtObject);
    procedure SetFBaseCls(Value : String);
    procedure SetFId(Value : String);
    procedure SetFText(Value : String);
    procedure SetFTextEl(Value : String);
    procedure SetFTextElElement(Value : TExtElement);
    procedure SetFTextElTHTMLElement(Value : THTMLElement);
    procedure SetFValue(Value : Integer);
    procedure SetFOnUpdate(Value : TExtProgressBarOnUpdate);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function IsWaiting : TExtFunction;
    function Reset(Hide : Boolean = false) : TExtFunction;
    function UpdateProgress(Value : Integer = 0; Text : String = ''; Animate : Boolean = false) : TExtFunction;
    function UpdateText(Text : String = '') : TExtFunction;
    function Wait(Config : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property AnimateObject : TExtObject read FAnimateObject write SetFAnimateObject;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Id : String read FId write SetFId;
    property Text : String read FText write SetFText;
    property TextEl : String read FTextEl write SetFTextEl;
    property TextElElement : TExtElement read FTextElElement write SetFTextElElement;
    property TextElTHTMLElement : THTMLElement read FTextElTHTMLElement write SetFTextElTHTMLElement;
    property Value : Integer read FValue write SetFValue;
    property OnUpdate : TExtProgressBarOnUpdate read FOnUpdate write SetFOnUpdate;
  end;

  TExtResizerHandle = class(TExtComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtPanelTool
  TExtPanelToolOnClick = procedure(This : TExtPanelTool; E : TExtEventObject) of object;

  TExtPanelTool = class(TExtComponent)
  private
    FHandler : TExtFunction;
    FIsTool : Boolean;
    FScope : TExtObject;
    FStopEvent : Boolean;
    FTooltip : String;
    FTooltipObject : TExtObject;
    FTooltipType : String;
    FTypeJS : String;
    FOnClick : TExtPanelToolOnClick;
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFIsTool(Value : Boolean);
    procedure SetFScope(Value : TExtObject);
    procedure SetFStopEvent(Value : Boolean);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipObject(Value : TExtObject);
    procedure SetFTooltipType(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFOnClick(Value : TExtPanelToolOnClick);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetType(TypeJS : String) : TExtFunction;
    destructor Destroy; override;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property IsTool : Boolean read FIsTool write SetFIsTool;
    property Scope : TExtObject read FScope write SetFScope;
    property StopEvent : Boolean read FStopEvent write SetFStopEvent;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipObject : TExtObject read FTooltipObject write SetFTooltipObject;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property OnClick : TExtPanelToolOnClick read FOnClick write SetFOnClick;
  end;

  TExtLayoutContainer = class(TExtLayout)
  private
    FItemCls : String;
    FOverflowPadderEl : TExtElement;
    procedure SetFItemCls(Value : String);
    procedure SetFOverflowPadderEl(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddChildEls : TExtFunction;
    function BeginLayout : TExtFunction;
    constructor Create;
    function GetElementTarget : TExtFunction;
    function GetLayoutItems : TExtFunction;
    function GetRenderTarget : TExtFunction;
    function GetTarget : TExtFunction;
    function RemoveChildEls(TestFn : TExtFunction) : TExtFunction;
    destructor Destroy; override;
    property ItemCls : String read FItemCls write SetFItemCls;
    property OverflowPadderEl : TExtElement read FOverflowPadderEl write SetFOverflowPadderEl;
  end;

  TExtPluginManagerSingleton = class(TExtAbstractManager)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; DefaultType : TExtFunction = nil);
    function FindByType(TypeJS : String; DefaultsOnly : Boolean) : TExtFunction;
  end;

  // Procedural types for events TExtPickerColor
  TExtPickerColorOnSelect = procedure(This : TExtPickerColor; Color : String) of object;

  TExtPickerColor = class(TExtComponent)
  private
    FAllowReselect : Boolean;
    FClickEvent : String;
    FColors : TArrayOfString;
    FComponentCls : String;
    FHandler : TExtFunction;
    FItemCls : String;
    FScope : TExtObject;
    FSelectedCls : String;
    FValue : String;
    FOnSelect : TExtPickerColorOnSelect;
    procedure SetFAllowReselect(Value : Boolean);
    procedure SetFClickEvent(Value : String);
    procedure SetFColors(Value : TArrayOfString);
    procedure SetFComponentCls(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFItemCls(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSelectedCls(Value : String);
    procedure SetFValue(Value : String);
    procedure SetFOnSelect(Value : TExtPickerColorOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetValue : TExtFunction;
    function Select(Color : String; SuppressEvent : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property AllowReselect : Boolean read FAllowReselect write SetFAllowReselect;
    property ClickEvent : String read FClickEvent write SetFClickEvent;
    property Colors : TArrayOfString read FColors write SetFColors;
    property ComponentCls : String read FComponentCls write SetFComponentCls;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property ItemCls : String read FItemCls write SetFItemCls;
    property Scope : TExtObject read FScope write SetFScope;
    property SelectedCls : String read FSelectedCls write SetFSelectedCls;
    property Value : String read FValue write SetFValue;
    property OnSelect : TExtPickerColorOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtLayoutContainerBoxOverflowScroller
  TExtLayoutContainerBoxOverflowScrollerOnScroll = procedure(Scroller : TExtLayoutContainerBoxOverflowScroller; NewPosition : Integer; Animate : Boolean) of object;

  TExtLayoutContainerBoxOverflowScroller = class(TExtLayoutContainerBoxOverflowNone)
  private
    FAfterCtCls : String;
    FAfterScrollerCls : String;
    FAnimateScroll : Boolean;
    FBeforeCtCls : String;
    FBeforeScrollerCls : String;
    FGlobalEvents : TExtUtilObservable;
    FHasListeners : TExtObject;
    FIsObservable : Boolean;
    FListeners : TExtObject;
    FScrollDuration : Integer;
    FScrollerCls : String;
    FScrollIncrement : Integer;
    FScrollRepeatInterval : Integer;
    FWheelIncrement : Integer;
    FOnScroll : TExtLayoutContainerBoxOverflowScrollerOnScroll;
    procedure SetFAfterCtCls(Value : String);
    procedure SetFAfterScrollerCls(Value : String);
    procedure SetFAnimateScroll(Value : Boolean);
    procedure SetFBeforeCtCls(Value : String);
    procedure SetFBeforeScrollerCls(Value : String);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFScrollDuration(Value : Integer);
    procedure SetFScrollerCls(Value : String);
    procedure SetFScrollIncrement(Value : Integer);
    procedure SetFScrollRepeatInterval(Value : Integer);
    procedure SetFWheelIncrement(Value : Integer);
    procedure SetFOnScroll(Value : TExtLayoutContainerBoxOverflowScrollerOnScroll);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetScrollPosition : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function ScrollToItem(Item : TExtComponent; Animate : Boolean) : TExtFunction; overload;
    function ScrollToItem(Item : String; Animate : Boolean) : TExtFunction; overload;
    function ScrollToItem(Item : Integer; Animate : Boolean) : TExtFunction; overload;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    property AfterCtCls : String read FAfterCtCls write SetFAfterCtCls;
    property AfterScrollerCls : String read FAfterScrollerCls write SetFAfterScrollerCls;
    property AnimateScroll : Boolean read FAnimateScroll write SetFAnimateScroll;
    property BeforeCtCls : String read FBeforeCtCls write SetFBeforeCtCls;
    property BeforeScrollerCls : String read FBeforeScrollerCls write SetFBeforeScrollerCls;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property ScrollDuration : Integer read FScrollDuration write SetFScrollDuration;
    property ScrollerCls : String read FScrollerCls write SetFScrollerCls;
    property ScrollIncrement : Integer read FScrollIncrement write SetFScrollIncrement;
    property ScrollRepeatInterval : Integer read FScrollRepeatInterval write SetFScrollRepeatInterval;
    property WheelIncrement : Integer read FWheelIncrement write SetFWheelIncrement;
    property OnScroll : TExtLayoutContainerBoxOverflowScrollerOnScroll read FOnScroll write SetFOnScroll;
  end;

  TExtDrawEngineVml = class(TExtDrawSurface)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddGradient(Gradient : TExtObject) : TExtFunction;
  end;

  // Procedural types for events TExtPickerMonth
  TExtPickerMonthOnCancelclick = procedure(This : TExtPickerMonth) of object;
  TExtPickerMonthOnMonthclick = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;
  TExtPickerMonthOnMonthdblclick = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;
  TExtPickerMonthOnOkclick = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;
  TExtPickerMonthOnSelect = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;
  TExtPickerMonthOnYearclick = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;
  TExtPickerMonthOnYeardblclick = procedure(This : TExtPickerMonth; Value : TExtObjectList) of object;

  TExtPickerMonth = class(TExtComponent)
  private
    FBaseCls : String;
    FCancelText : String;
    FOkText : String;
    FSelectedCls : String;
    FShowButtons : Boolean;
    FValue : TDateTime;
    FValueTArrayOfInteger : TArrayOfInteger;
    FOnCancelclick : TExtPickerMonthOnCancelclick;
    FOnMonthclick : TExtPickerMonthOnMonthclick;
    FOnMonthdblclick : TExtPickerMonthOnMonthdblclick;
    FOnOkclick : TExtPickerMonthOnOkclick;
    FOnSelect : TExtPickerMonthOnSelect;
    FOnYearclick : TExtPickerMonthOnYearclick;
    FOnYeardblclick : TExtPickerMonthOnYeardblclick;
    procedure SetFBaseCls(Value : String);
    procedure SetFCancelText(Value : String);
    procedure SetFOkText(Value : String);
    procedure SetFSelectedCls(Value : String);
    procedure SetFShowButtons(Value : Boolean);
    procedure SetFValue(Value : TDateTime);
    procedure SetFValueTArrayOfInteger(Value : TArrayOfInteger);
    procedure SetFOnCancelclick(Value : TExtPickerMonthOnCancelclick);
    procedure SetFOnMonthclick(Value : TExtPickerMonthOnMonthclick);
    procedure SetFOnMonthdblclick(Value : TExtPickerMonthOnMonthdblclick);
    procedure SetFOnOkclick(Value : TExtPickerMonthOnOkclick);
    procedure SetFOnSelect(Value : TExtPickerMonthOnSelect);
    procedure SetFOnYearclick(Value : TExtPickerMonthOnYearclick);
    procedure SetFOnYeardblclick(Value : TExtPickerMonthOnYeardblclick);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AdjustYear(Offset : Integer = 0) : TExtFunction;
    function GetValue : TExtFunction;
    function HasSelection : TExtFunction;
    function SetValue(Value : TDateTime) : TExtFunction; overload;
    function SetValue(Value : TArrayOfInteger) : TExtFunction; overload;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property CancelText : String read FCancelText write SetFCancelText;
    property OkText : String read FOkText write SetFOkText;
    property SelectedCls : String read FSelectedCls write SetFSelectedCls;
    property ShowButtons : Boolean read FShowButtons write SetFShowButtons;
    property Value : TDateTime read FValue write SetFValue;
    property ValueTArrayOfInteger : TArrayOfInteger read FValueTArrayOfInteger write SetFValueTArrayOfInteger;
    property OnCancelclick : TExtPickerMonthOnCancelclick read FOnCancelclick write SetFOnCancelclick;
    property OnMonthclick : TExtPickerMonthOnMonthclick read FOnMonthclick write SetFOnMonthclick;
    property OnMonthdblclick : TExtPickerMonthOnMonthdblclick read FOnMonthdblclick write SetFOnMonthdblclick;
    property OnOkclick : TExtPickerMonthOnOkclick read FOnOkclick write SetFOnOkclick;
    property OnSelect : TExtPickerMonthOnSelect read FOnSelect write SetFOnSelect;
    property OnYearclick : TExtPickerMonthOnYearclick read FOnYearclick write SetFOnYearclick;
    property OnYeardblclick : TExtPickerMonthOnYeardblclick read FOnYeardblclick write SetFOnYeardblclick;
  end;

  // Procedural types for events TExtPickerDate
  TExtPickerDateOnSelect = procedure(This : TExtPickerDate; Date : TDateTime) of object;

  TExtPickerDate = class(TExtComponent)
  private
    FAriaTitle : String;
    FAriaTitleDateFormat : String;
    FBaseCls : String;
    FDayNames : TArrayOfString;
    FDisableAnim : Boolean;
    FDisabledCellCls : String;
    FDisabledDates : TArrayOfString;
    FDisabledDatesRE : TRegExp;
    FDisabledDatesText : String;
    FDisabledDays : TArrayOfInteger;
    FDisabledDaysText : String;
    FFocusOnShow : Boolean;
    FFormat : String;
    FHandler : TExtFunction;
    FKeyNavConfig : TExtObject;
    FLongDayFormat : String;
    FMaxDate : TDateTime;
    FMaxText : String;
    FMinDate : TDateTime;
    FMinText : String;
    FMonthNames : TArrayOfString;
    FMonthYearFormat : String;
    FMonthYearText : String;
    FNextText : String;
    FPrevText : String;
    FScope : TExtObject;
    FSelectedCls : String;
    FShowToday : Boolean;
    FStartDay : Integer; // 0
    FTodayText : String;
    FTodayTip : String;
    FOnSelect : TExtPickerDateOnSelect;
    procedure SetFAriaTitle(Value : String);
    procedure SetFAriaTitleDateFormat(Value : String);
    procedure SetFBaseCls(Value : String);
    procedure SetFDayNames(Value : TArrayOfString);
    procedure SetFDisableAnim(Value : Boolean);
    procedure SetFDisabledCellCls(Value : String);
    procedure SetFDisabledDates(Value : TArrayOfString);
    procedure SetFDisabledDatesRE(Value : TRegExp);
    procedure SetFDisabledDatesText(Value : String);
    procedure SetFDisabledDays(Value : TArrayOfInteger);
    procedure SetFDisabledDaysText(Value : String);
    procedure SetFFocusOnShow(Value : Boolean);
    procedure SetFFormat(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFKeyNavConfig(Value : TExtObject);
    procedure SetFLongDayFormat(Value : String);
    procedure SetFMaxDate(Value : TDateTime);
    procedure SetFMaxText(Value : String);
    procedure SetFMinDate(Value : TDateTime);
    procedure SetFMinText(Value : String);
    procedure SetFMonthNames(Value : TArrayOfString);
    procedure SetFMonthYearFormat(Value : String);
    procedure SetFMonthYearText(Value : String);
    procedure SetFNextText(Value : String);
    procedure SetFPrevText(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSelectedCls(Value : String);
    procedure SetFShowToday(Value : Boolean);
    procedure SetFStartDay(Value : Integer);
    procedure SetFTodayText(Value : String);
    procedure SetFTodayTip(Value : String);
    procedure SetFOnSelect(Value : TExtPickerDateOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetDayInitial : TExtFunction;
    function GetValue : TExtFunction;
    function HideMonthPicker(Animate : Boolean = false) : TExtFunction;
    function SelectToday : TExtFunction;
    function SetDisabledDates(DisabledDates : TRegExp) : TExtFunction; overload;
    function SetDisabledDates(DisabledDates : TArrayOfString) : TExtFunction; overload;
    function SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction;
    function SetMaxDate(Value : TDateTime) : TExtFunction;
    function SetMinDate(Value : TDateTime) : TExtFunction;
    function SetValue(Value : TDateTime) : TExtFunction;
    function ShowMonthPicker(Animate : Boolean = false) : TExtFunction;
    function ShowNextMonth(E : TExtObject) : TExtFunction;
    function ShowNextYear : TExtFunction;
    function ShowPrevMonth(E : TExtObject) : TExtFunction;
    function ShowPrevYear : TExtFunction;
    destructor Destroy; override;
    property AriaTitle : String read FAriaTitle write SetFAriaTitle;
    property AriaTitleDateFormat : String read FAriaTitleDateFormat write SetFAriaTitleDateFormat;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property DayNames : TArrayOfString read FDayNames write SetFDayNames;
    property DisableAnim : Boolean read FDisableAnim write SetFDisableAnim;
    property DisabledCellCls : String read FDisabledCellCls write SetFDisabledCellCls;
    property DisabledDates : TArrayOfString read FDisabledDates write SetFDisabledDates;
    property DisabledDatesRE : TRegExp read FDisabledDatesRE write SetFDisabledDatesRE;
    property DisabledDatesText : String read FDisabledDatesText write SetFDisabledDatesText;
    property DisabledDays : TArrayOfInteger read FDisabledDays write SetFDisabledDays;
    property DisabledDaysText : String read FDisabledDaysText write SetFDisabledDaysText;
    property FocusOnShow : Boolean read FFocusOnShow write SetFFocusOnShow;
    property Format : String read FFormat write SetFFormat;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property KeyNavConfig : TExtObject read FKeyNavConfig write SetFKeyNavConfig;
    property LongDayFormat : String read FLongDayFormat write SetFLongDayFormat;
    property MaxDate : TDateTime read FMaxDate write SetFMaxDate;
    property MaxText : String read FMaxText write SetFMaxText;
    property MinDate : TDateTime read FMinDate write SetFMinDate;
    property MinText : String read FMinText write SetFMinText;
    property MonthNames : TArrayOfString read FMonthNames write SetFMonthNames;
    property MonthYearFormat : String read FMonthYearFormat write SetFMonthYearFormat;
    property MonthYearText : String read FMonthYearText write SetFMonthYearText;
    property NextText : String read FNextText write SetFNextText;
    property PrevText : String read FPrevText write SetFPrevText;
    property Scope : TExtObject read FScope write SetFScope;
    property SelectedCls : String read FSelectedCls write SetFSelectedCls;
    property ShowToday : Boolean read FShowToday write SetFShowToday;
    property StartDay : Integer read FStartDay write SetFStartDay;
    property TodayText : String read FTodayText write SetFTodayText;
    property TodayTip : String read FTodayTip write SetFTodayTip;
    property OnSelect : TExtPickerDateOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtLayoutContainerBoxOverflowMenu = class(TExtLayoutContainerBoxOverflowNone)
  private
    FMenuItems : TExtObjectList;
    FNoItemsMenuText : String;
    FTriggerButtonCls : String;
    procedure SetFMenuItems(Value : TExtObjectList);
    procedure SetFNoItemsMenuText(Value : String);
    procedure SetFTriggerButtonCls(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property MenuItems : TExtObjectList read FMenuItems write SetFMenuItems;
    property NoItemsMenuText : String read FNoItemsMenuText write SetFNoItemsMenuText;
    property TriggerButtonCls : String read FTriggerButtonCls write SetFTriggerButtonCls;
  end;

  TExtLayoutComponent = class(TExtLayout)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetRenderTarget : TExtFunction;
    function GetTarget : TExtFunction;
  end;

  TExtComponentManagerSingleton = class(TExtAbstractManager)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject; DefaultType : String = '');
  end;

  TExtModelManagerSingleton = class(TExtAbstractManager)
  private
    FAssociationStack : TExtObjectList;
    procedure SetFAssociationStack(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetModel(Id : TExtObject) : TExtFunction; overload;
    function GetModel(Id : String) : TExtFunction; overload;
    destructor Destroy; override;
    property AssociationStack : TExtObjectList read FAssociationStack write SetFAssociationStack;
  end;

  TExtDataUuidGenerator = class(TExtDataIdGenerator)
  private
    FSalt : Integer;
    FSaltObject : TExtObject;
    FTimestamp : Integer;
    FTimestampObject : TExtObject;
    FVersion : Integer;
    procedure SetFSalt(Value : Integer);
    procedure SetFSaltObject(Value : TExtObject);
    procedure SetFTimestamp(Value : Integer);
    procedure SetFTimestampObject(Value : TExtObject);
    procedure SetFVersion(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Reconfigure : TExtFunction;
    destructor Destroy; override;
    property Salt : Integer read FSalt write SetFSalt;
    property SaltObject : TExtObject read FSaltObject write SetFSaltObject;
    property Timestamp : Integer read FTimestamp write SetFTimestamp;
    property TimestampObject : TExtObject read FTimestampObject write SetFTimestampObject;
    property Version : Integer read FVersion write SetFVersion;
  end;

  TExtImg = class(TExtComponent)
  private
    FAlt : String;
    FGlyph : Integer;
    FGlyphString : String;
    FImgCls : String;
    FSrc : String;
    FTitle : String;
    procedure SetFAlt(Value : String);
    procedure SetFGlyph(Value : Integer);
    procedure SetFGlyphString(Value : String);
    procedure SetFImgCls(Value : String);
    procedure SetFSrc(Value : String);
    procedure SetFTitle(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetSrc(Src : String) : TExtFunction;
    property Alt : String read FAlt write SetFAlt;
    property Glyph : Integer read FGlyph write SetFGlyph;
    property GlyphString : String read FGlyphString write SetFGlyphString;
    property ImgCls : String read FImgCls write SetFImgCls;
    property Src : String read FSrc write SetFSrc;
    property Title : String read FTitle write SetFTitle;
  end;

  TExtComponentLoader = class(TExtElementLoader)
  private
    FLoadMask : Boolean;
    FLoadMaskObject : TExtObject;
    FRenderer : String;
    FRendererFunction : TExtFunction;
    FScripts : Boolean;
    FTarget : TExtComponent;
    FTargetString : String;
    procedure SetFLoadMask(Value : Boolean);
    procedure SetFLoadMaskObject(Value : TExtObject);
    procedure SetFRenderer(Value : String);
    procedure SetFRendererFunction(Value : TExtFunction);
    procedure SetFScripts(Value : Boolean);
    procedure SetFTarget(Value : TExtComponent);
    procedure SetFTargetString(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetTarget(Target : TExtComponent) : TExtFunction; overload;
    function SetTarget(Target : String) : TExtFunction; overload;
    destructor Destroy; override;
    property LoadMask : Boolean read FLoadMask write SetFLoadMask;
    property LoadMaskObject : TExtObject read FLoadMaskObject write SetFLoadMaskObject;
    property Renderer : String read FRenderer write SetFRenderer;
    property RendererFunction : TExtFunction read FRendererFunction write SetFRendererFunction;
    property Scripts : Boolean read FScripts write SetFScripts;
    property Target : TExtComponent read FTarget write SetFTarget;
    property TargetString : String read FTargetString write SetFTargetString;
  end;

  // Procedural types for events TExtContainerAbstractContainer
  TExtContainerAbstractContainerOnAdd = procedure(This : TExtContainerAbstractContainer; Component : TExtComponent; Index : Integer) of object;
  TExtContainerAbstractContainerOnAfterlayout = procedure(This : TExtContainerAbstractContainer; Layout : TExtLayoutContainer) of object;
  TExtContainerAbstractContainerOnBeforeadd = procedure(This : TExtContainerAbstractContainer; Component : TExtComponent; Index : Integer) of object;
  TExtContainerAbstractContainerOnBeforeremove = procedure(This : TExtContainerAbstractContainer; Component : TExtComponent) of object;
  TExtContainerAbstractContainerOnRemove = procedure(This : TExtContainerAbstractContainer; Component : TExtComponent) of object;

  TExtContainerAbstractContainer = class(TExtComponent)
  private
    FActiveItem : Integer;
    FActiveItemString : String;
    FAutoDestroy : Boolean;
    FBubbleEvents : TArrayOfString;
    FDefaults : TExtObject;
    FDefaultsFunction : TExtFunction;
    FDefaultType : String;
    FDetachOnRemove : Boolean;
    FItems : TExtObjectList;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    FSuspendLayout : Boolean;
    FOnAdd : TExtContainerAbstractContainerOnAdd;
    FOnAfterlayout : TExtContainerAbstractContainerOnAfterlayout;
    FOnBeforeadd : TExtContainerAbstractContainerOnBeforeadd;
    FOnBeforeremove : TExtContainerAbstractContainerOnBeforeremove;
    FOnRemove : TExtContainerAbstractContainerOnRemove;
    procedure SetFActiveItem(Value : Integer);
    procedure SetFActiveItemString(Value : String);
    procedure SetFAutoDestroy(Value : Boolean);
    procedure SetFBubbleEvents(Value : TArrayOfString);
    procedure SetFDefaults(Value : TExtObject);
    procedure SetFDefaultsFunction(Value : TExtFunction);
    procedure SetFDefaultType(Value : String);
    procedure SetFDetachOnRemove(Value : Boolean);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
    procedure SetFSuspendLayout(Value : Boolean);
    procedure SetFOnAdd(Value : TExtContainerAbstractContainerOnAdd);
    procedure SetFOnAfterlayout(Value : TExtContainerAbstractContainerOnAfterlayout);
    procedure SetFOnBeforeadd(Value : TExtContainerAbstractContainerOnBeforeadd);
    procedure SetFOnBeforeremove(Value : TExtContainerAbstractContainerOnBeforeremove);
    procedure SetFOnRemove(Value : TExtContainerAbstractContainerOnRemove);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Component : TExtObjectList) : TExtFunction; overload;
    function Add(Component : TExtComponent) : TExtFunction; overload;
    function Cascade(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction;
    function Child(Selector : TExtComponent) : TExtFunction; overload;
    function Child(Selector : String = '') : TExtFunction; overload;
    function Contains(Comp : TExtComponent; Deep : Boolean = false) : TExtFunction;
    constructor Create;
    function DoLayout : TExtFunction;
    function Down(Selector : TExtComponent) : TExtFunction; overload;
    function Down(Selector : String = '') : TExtFunction; overload;
    function GetComponent(Comp : String) : TExtFunction; overload;
    function GetComponent(Comp : Integer) : TExtFunction; overload;
    function GetLayout : TExtFunction;
    function Insert(Index : Integer; Component : TExtObject) : TExtFunction; overload;
    function Insert(Index : Integer; Component : TExtComponent) : TExtFunction; overload;
    function IsAncestor(PossibleDescendant : TExtComponent) : TExtFunction;
    function Move(FromIdx : Integer; ToIdx : Integer) : TExtFunction;
    function Query(Selector : String = '') : TExtFunction;
    function QueryBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function QueryById(Id : String) : TExtFunction;
    function Remove(Component : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction; overload;
    function Remove(Component : String; AutoDestroy : Boolean = false) : TExtFunction; overload;
    function RemoveAll(AutoDestroy : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property ActiveItem : Integer read FActiveItem write SetFActiveItem;
    property ActiveItemString : String read FActiveItemString write SetFActiveItemString;
    property AutoDestroy : Boolean read FAutoDestroy write SetFAutoDestroy;
    property BubbleEvents : TArrayOfString read FBubbleEvents write SetFBubbleEvents;
    property Defaults : TExtObject read FDefaults write SetFDefaults;
    property DefaultsFunction : TExtFunction read FDefaultsFunction write SetFDefaultsFunction;
    property DefaultType : String read FDefaultType write SetFDefaultType;
    property DetachOnRemove : Boolean read FDetachOnRemove write SetFDetachOnRemove;
    property Items : TExtObjectList read FItems write SetFItems;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
    property SuspendLayout : Boolean read FSuspendLayout write SetFSuspendLayout;
    property OnAdd : TExtContainerAbstractContainerOnAdd read FOnAdd write SetFOnAdd;
    property OnAfterlayout : TExtContainerAbstractContainerOnAfterlayout read FOnAfterlayout write SetFOnAfterlayout;
    property OnBeforeadd : TExtContainerAbstractContainerOnBeforeadd read FOnBeforeadd write SetFOnBeforeadd;
    property OnBeforeremove : TExtContainerAbstractContainerOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnRemove : TExtContainerAbstractContainerOnRemove read FOnRemove write SetFOnRemove;
  end;

  TExtResizerSplitterTracker = class(TExtDdDragTracker)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtResizerSplitter = class(TExtComponent)
  private
    FCollapsedCls : String;
    FCollapseOnDblClick : Boolean;
    FCollapseTarget : String;
    FCollapseTargetPanel : TExtPanel;
    FCollapsible : Boolean;
    FDefaultSplitMax : Integer;
    FDefaultSplitMin : Integer;
    FOrientation : String;
    FPerformCollapse : Boolean;
    FSize : Integer;
    procedure SetFCollapsedCls(Value : String);
    procedure SetFCollapseOnDblClick(Value : Boolean);
    procedure SetFCollapseTarget(Value : String);
    procedure SetFCollapseTargetPanel(Value : TExtPanel);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFDefaultSplitMax(Value : Integer);
    procedure SetFDefaultSplitMin(Value : Integer);
    procedure SetFOrientation(Value : String);
    procedure SetFPerformCollapse(Value : Boolean);
    procedure SetFSize(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property CollapsedCls : String read FCollapsedCls write SetFCollapsedCls;
    property CollapseOnDblClick : Boolean read FCollapseOnDblClick write SetFCollapseOnDblClick;
    property CollapseTarget : String read FCollapseTarget write SetFCollapseTarget;
    property CollapseTargetPanel : TExtPanel read FCollapseTargetPanel write SetFCollapseTargetPanel;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property DefaultSplitMax : Integer read FDefaultSplitMax write SetFDefaultSplitMax;
    property DefaultSplitMin : Integer read FDefaultSplitMin write SetFDefaultSplitMin;
    property Orientation : String read FOrientation write SetFOrientation;
    property PerformCollapse : Boolean read FPerformCollapse write SetFPerformCollapse;
    property Size : Integer read FSize write SetFSize;
  end;

  TExtResizerResizeTracker = class(TExtDdDragTracker)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateProxy(Target : TExtElement) : TExtFunction; overload;
    function CreateProxy(Target : TExtComponent) : TExtFunction; overload;
  end;

  TExtDataWriterXml = class(TExtDataWriter)
  private
    FDefaultDocumentRoot : String;
    FDocumentRoot : String; // 'xmlData'
    FHeader : String;
    FRecordJS : String; // 'record'
    procedure SetFDefaultDocumentRoot(Value : String);
    procedure SetFDocumentRoot(Value : String);
    procedure SetFHeader(Value : String);
    procedure SetFRecordJS(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property DefaultDocumentRoot : String read FDefaultDocumentRoot write SetFDefaultDocumentRoot;
    property DocumentRoot : String read FDocumentRoot write SetFDocumentRoot;
    property Header : String read FHeader write SetFHeader;
    property RecordJS : String read FRecordJS write SetFRecordJS;
  end;

  TExtDdDDTarget = class(TExtDdDragDrop)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Id : String; SGroup : String; Config : TExtObject);
  end;

  // Procedural types for events TExtDrawComponent
  TExtDrawComponentOnClick = procedure of object;
  TExtDrawComponentOnDblclick = procedure of object;
  TExtDrawComponentOnMousedown = procedure of object;
  TExtDrawComponentOnMouseenter = procedure of object;
  TExtDrawComponentOnMouseleave = procedure of object;
  TExtDrawComponentOnMousemove = procedure of object;
  TExtDrawComponentOnMouseup = procedure of object;

  TExtDrawComponent = class(TExtComponent)
  private
    FAutoSize : Boolean;
    FEnginePriority : TArrayOfString;
    FGradients : TExtObjectList;
    FItems : TExtObjectList;
    FSurface : TExtDrawSurface;
    FViewBox : Boolean;
    FOnClick : TExtDrawComponentOnClick;
    FOnDblclick : TExtDrawComponentOnDblclick;
    FOnMousedown : TExtDrawComponentOnMousedown;
    FOnMouseenter : TExtDrawComponentOnMouseenter;
    FOnMouseleave : TExtDrawComponentOnMouseleave;
    FOnMousemove : TExtDrawComponentOnMousemove;
    FOnMouseup : TExtDrawComponentOnMouseup;
    procedure SetFAutoSize(Value : Boolean);
    procedure SetFEnginePriority(Value : TArrayOfString);
    procedure SetFGradients(Value : TExtObjectList);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFSurface(Value : TExtDrawSurface);
    procedure SetFViewBox(Value : Boolean);
    procedure SetFOnClick(Value : TExtDrawComponentOnClick);
    procedure SetFOnDblclick(Value : TExtDrawComponentOnDblclick);
    procedure SetFOnMousedown(Value : TExtDrawComponentOnMousedown);
    procedure SetFOnMouseenter(Value : TExtDrawComponentOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtDrawComponentOnMouseleave);
    procedure SetFOnMousemove(Value : TExtDrawComponentOnMousemove);
    procedure SetFOnMouseup(Value : TExtDrawComponentOnMouseup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property AutoSize : Boolean read FAutoSize write SetFAutoSize;
    property EnginePriority : TArrayOfString read FEnginePriority write SetFEnginePriority;
    property Gradients : TExtObjectList read FGradients write SetFGradients;
    property Items : TExtObjectList read FItems write SetFItems;
    property Surface : TExtDrawSurface read FSurface write SetFSurface;
    property ViewBox : Boolean read FViewBox write SetFViewBox;
    property OnClick : TExtDrawComponentOnClick read FOnClick write SetFOnClick;
    property OnDblclick : TExtDrawComponentOnDblclick read FOnDblclick write SetFOnDblclick;
    property OnMousedown : TExtDrawComponentOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseenter : TExtDrawComponentOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtDrawComponentOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnMousemove : TExtDrawComponentOnMousemove read FOnMousemove write SetFOnMousemove;
    property OnMouseup : TExtDrawComponentOnMouseup read FOnMouseup write SetFOnMouseup;
  end;

  TExtToolbarSpacer = class(TExtComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtToolbarItem = class(TExtComponent)
  private
    FOverflowText : String;
    procedure SetFOverflowText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property OverflowText : String read FOverflowText write SetFOverflowText;
  end;

  TExtToolbarFill = class(TExtComponent)
  private
    FIsFill : Boolean;
    procedure SetFIsFill(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsFill : Boolean read FIsFill write SetFIsFill;
  end;

  TExtAppDomainStoreSingleton = class(TExtAppEventDomain)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtXTemplate = class(TExtTemplate)
  private
    FDefinitions : String;
    FDefinitionsList : TExtObjectList;
    procedure SetFDefinitions(Value : String);
    procedure SetFDefinitionsList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Compile : TExtFunction;
    constructor Create;
    destructor Destroy; override;
    property Definitions : String read FDefinitions write SetFDefinitions;
    property DefinitionsList : TExtObjectList read FDefinitionsList write SetFDefinitionsList;
  end;

  TExtAppDomainGlobalSingleton = class(TExtAppEventDomain)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtTreePluginTreeViewDragDrop
  TExtTreePluginTreeViewDragDropOnBeforedrop = procedure(Node : THTMLElement; Data : TExtObject; OverModel : TExtDataModel; DropPosition : String; DropHandlers : TExtObject) of object;
  TExtTreePluginTreeViewDragDropOnDrop = procedure(Node : THTMLElement; Data : TExtObject; OverModel : TExtDataModel; DropPosition : String) of object;

  TExtTreePluginTreeViewDragDrop = class(TExtAbstractPlugin)
  private
    FAllowContainerDrops : Boolean;
    FAllowParentInserts : Boolean;
    FAppendOnly : Boolean;
    FContainerScroll : TExtObject;
    FContainerScrollBoolean : Boolean;
    FDdGroup : String;
    FDisplayField : String;
    FDragGroup : String;
    FDropGroup : String;
    FEnableDrag : Boolean;
    FEnableDrop : Boolean;
    FExpandDelay : String;
    FNodeHighlightColor : String;
    FNodeHighlightOnDrop : Boolean;
    FNodeHighlightOnRepair : Boolean;
    FSortOnDrop : Boolean;
    FOnBeforedrop : TExtTreePluginTreeViewDragDropOnBeforedrop;
    FOnDrop : TExtTreePluginTreeViewDragDropOnDrop;
    procedure SetFAllowContainerDrops(Value : Boolean);
    procedure SetFAllowParentInserts(Value : Boolean);
    procedure SetFAppendOnly(Value : Boolean);
    procedure SetFContainerScroll(Value : TExtObject);
    procedure SetFContainerScrollBoolean(Value : Boolean);
    procedure SetFDdGroup(Value : String);
    procedure SetFDisplayField(Value : String);
    procedure SetFDragGroup(Value : String);
    procedure SetFDropGroup(Value : String);
    procedure SetFEnableDrag(Value : Boolean);
    procedure SetFEnableDrop(Value : Boolean);
    procedure SetFExpandDelay(Value : String);
    procedure SetFNodeHighlightColor(Value : String);
    procedure SetFNodeHighlightOnDrop(Value : Boolean);
    procedure SetFNodeHighlightOnRepair(Value : Boolean);
    procedure SetFSortOnDrop(Value : Boolean);
    procedure SetFOnBeforedrop(Value : TExtTreePluginTreeViewDragDropOnBeforedrop);
    procedure SetFOnDrop(Value : TExtTreePluginTreeViewDragDropOnDrop);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property AllowContainerDrops : Boolean read FAllowContainerDrops write SetFAllowContainerDrops;
    property AllowParentInserts : Boolean read FAllowParentInserts write SetFAllowParentInserts;
    property AppendOnly : Boolean read FAppendOnly write SetFAppendOnly;
    property ContainerScroll : TExtObject read FContainerScroll write SetFContainerScroll;
    property ContainerScrollBoolean : Boolean read FContainerScrollBoolean write SetFContainerScrollBoolean;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property DragGroup : String read FDragGroup write SetFDragGroup;
    property DropGroup : String read FDropGroup write SetFDropGroup;
    property EnableDrag : Boolean read FEnableDrag write SetFEnableDrag;
    property EnableDrop : Boolean read FEnableDrop write SetFEnableDrop;
    property ExpandDelay : String read FExpandDelay write SetFExpandDelay;
    property NodeHighlightColor : String read FNodeHighlightColor write SetFNodeHighlightColor;
    property NodeHighlightOnDrop : Boolean read FNodeHighlightOnDrop write SetFNodeHighlightOnDrop;
    property NodeHighlightOnRepair : Boolean read FNodeHighlightOnRepair write SetFNodeHighlightOnRepair;
    property SortOnDrop : Boolean read FSortOnDrop write SetFSortOnDrop;
    property OnBeforedrop : TExtTreePluginTreeViewDragDropOnBeforedrop read FOnBeforedrop write SetFOnBeforedrop;
    property OnDrop : TExtTreePluginTreeViewDragDropOnDrop read FOnDrop write SetFOnDrop;
  end;

  TExtFormLabel = class(TExtComponent)
  private
    FForId : String;
    FHtml : String;
    FText : String;
    procedure SetFForId(Value : String);
    procedure SetFHtml(Value : String);
    procedure SetFText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetText(Text : String; Encode : Boolean = false) : TExtFunction;
    property ForId : String read FForId write SetFForId;
    property Html : String read FHtml write SetFHtml;
    property Text : String read FText write SetFText;
  end;

  TExtDataTreeModel = class(TExtDataModel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtDataTreeStore
  TExtDataTreeStoreOnAppend = procedure of object;
  TExtDataTreeStoreOnBeforeappend = procedure of object;
  TExtDataTreeStoreOnBeforecollapse = procedure of object;
  TExtDataTreeStoreOnBeforeexpand = procedure of object;
  TExtDataTreeStoreOnBeforeinsert = procedure of object;
  TExtDataTreeStoreOnBeforemove = procedure of object;
  TExtDataTreeStoreOnBeforeremove = procedure of object;
  TExtDataTreeStoreOnCollapse = procedure of object;
  TExtDataTreeStoreOnExpand = procedure of object;
  TExtDataTreeStoreOnInsert = procedure of object;
  TExtDataTreeStoreOnLoad = procedure(This : TExtDataTreeStore; Node : TExtDataNodeInterface; Records : TExtObjectList; Successful : Boolean) of object;
  TExtDataTreeStoreOnMove = procedure of object;
  TExtDataTreeStoreOnRemove = procedure of object;
  TExtDataTreeStoreOnSort = procedure of object;

  TExtDataTreeStore = class(TExtDataAbstractStore)
  private
    FClearOnLoad : Boolean;
    FClearRemovedOnLoad : Boolean;
    FDefaultRootId : String;
    FDefaultRootProperty : String;
    FDefaultRootText : String;
    FFolderSort : Boolean;
    FNodeParam : String;
    FRoot : TExtDataModel;
    FRootInterface : TExtDataNodeInterface;
    FRootObject : TExtObject;
    FOnAppend : TExtDataTreeStoreOnAppend;
    FOnBeforeappend : TExtDataTreeStoreOnBeforeappend;
    FOnBeforecollapse : TExtDataTreeStoreOnBeforecollapse;
    FOnBeforeexpand : TExtDataTreeStoreOnBeforeexpand;
    FOnBeforeinsert : TExtDataTreeStoreOnBeforeinsert;
    FOnBeforemove : TExtDataTreeStoreOnBeforemove;
    FOnBeforeremove : TExtDataTreeStoreOnBeforeremove;
    FOnCollapse : TExtDataTreeStoreOnCollapse;
    FOnExpand : TExtDataTreeStoreOnExpand;
    FOnInsert : TExtDataTreeStoreOnInsert;
    FOnLoad : TExtDataTreeStoreOnLoad;
    FOnMove : TExtDataTreeStoreOnMove;
    FOnRemove : TExtDataTreeStoreOnRemove;
    FOnSort : TExtDataTreeStoreOnSort;
    procedure SetFClearOnLoad(Value : Boolean);
    procedure SetFClearRemovedOnLoad(Value : Boolean);
    procedure SetFDefaultRootId(Value : String);
    procedure SetFDefaultRootProperty(Value : String);
    procedure SetFDefaultRootText(Value : String);
    procedure SetFFolderSort(Value : Boolean);
    procedure SetFNodeParam(Value : String);
    procedure SetFRoot(Value : TExtDataModel);
    procedure SetFRootInterface(Value : TExtDataNodeInterface);
    procedure SetFRootObject(Value : TExtObject);
    procedure SetFOnAppend(Value : TExtDataTreeStoreOnAppend);
    procedure SetFOnBeforeappend(Value : TExtDataTreeStoreOnBeforeappend);
    procedure SetFOnBeforecollapse(Value : TExtDataTreeStoreOnBeforecollapse);
    procedure SetFOnBeforeexpand(Value : TExtDataTreeStoreOnBeforeexpand);
    procedure SetFOnBeforeinsert(Value : TExtDataTreeStoreOnBeforeinsert);
    procedure SetFOnBeforemove(Value : TExtDataTreeStoreOnBeforemove);
    procedure SetFOnBeforeremove(Value : TExtDataTreeStoreOnBeforeremove);
    procedure SetFOnCollapse(Value : TExtDataTreeStoreOnCollapse);
    procedure SetFOnExpand(Value : TExtDataTreeStoreOnExpand);
    procedure SetFOnInsert(Value : TExtDataTreeStoreOnInsert);
    procedure SetFOnLoad(Value : TExtDataTreeStoreOnLoad);
    procedure SetFOnMove(Value : TExtDataTreeStoreOnMove);
    procedure SetFOnRemove(Value : TExtDataTreeStoreOnRemove);
    procedure SetFOnSort(Value : TExtDataTreeStoreOnSort);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetNodeById : TExtFunction;
    function GetRootNode : TExtFunction;
    function Load(Options : TExtObject = nil) : TExtFunction;
    function SetRootNode(Root : TExtObject) : TExtFunction; overload;
    function SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; overload;
    function SetRootNode(Root : TExtDataModel) : TExtFunction; overload;
    destructor Destroy; override;
    property ClearOnLoad : Boolean read FClearOnLoad write SetFClearOnLoad;
    property ClearRemovedOnLoad : Boolean read FClearRemovedOnLoad write SetFClearRemovedOnLoad;
    property DefaultRootId : String read FDefaultRootId write SetFDefaultRootId;
    property DefaultRootProperty : String read FDefaultRootProperty write SetFDefaultRootProperty;
    property DefaultRootText : String read FDefaultRootText write SetFDefaultRootText;
    property FolderSort : Boolean read FFolderSort write SetFFolderSort;
    property NodeParam : String read FNodeParam write SetFNodeParam;
    property Root : TExtDataModel read FRoot write SetFRoot;
    property RootInterface : TExtDataNodeInterface read FRootInterface write SetFRootInterface;
    property RootObject : TExtObject read FRootObject write SetFRootObject;
    property OnAppend : TExtDataTreeStoreOnAppend read FOnAppend write SetFOnAppend;
    property OnBeforeappend : TExtDataTreeStoreOnBeforeappend read FOnBeforeappend write SetFOnBeforeappend;
    property OnBeforecollapse : TExtDataTreeStoreOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnBeforeexpand : TExtDataTreeStoreOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnBeforeinsert : TExtDataTreeStoreOnBeforeinsert read FOnBeforeinsert write SetFOnBeforeinsert;
    property OnBeforemove : TExtDataTreeStoreOnBeforemove read FOnBeforemove write SetFOnBeforemove;
    property OnBeforeremove : TExtDataTreeStoreOnBeforeremove read FOnBeforeremove write SetFOnBeforeremove;
    property OnCollapse : TExtDataTreeStoreOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtDataTreeStoreOnExpand read FOnExpand write SetFOnExpand;
    property OnInsert : TExtDataTreeStoreOnInsert read FOnInsert write SetFOnInsert;
    property OnLoad : TExtDataTreeStoreOnLoad read FOnLoad write SetFOnLoad;
    property OnMove : TExtDataTreeStoreOnMove read FOnMove write SetFOnMove;
    property OnRemove : TExtDataTreeStoreOnRemove read FOnRemove write SetFOnRemove;
    property OnSort : TExtDataTreeStoreOnSort read FOnSort write SetFOnSort;
  end;

  TExtDataReaderXml = class(TExtDataReader)
  private
    FNamespace : String;
    FRecordJS : String;
    procedure SetFNamespace(Value : String);
    procedure SetFRecordJS(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetData(Data : TExtObject) : TExtFunction;
    function ReadRecords(Doc : TExtObject) : TExtFunction;
    property Namespace : String read FNamespace write SetFNamespace;
    property RecordJS : String read FRecordJS write SetFRecordJS;
  end;

  TExtUtilLruCache = class(TExtUtilHashMap)
  private
    FMaxSize : Integer;
    procedure SetFMaxSize(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clone : TExtFunction;
    function Each(Fn : TExtFunction; Scope : TExtObject; Reverse : Boolean = false) : TExtFunction;
    function Prune : TExtFunction;
    property MaxSize : Integer read FMaxSize write SetFMaxSize;
  end;

  TExtDataSequentialIdGenerator = class(TExtDataIdGenerator)
  private
    FPrefix : String;
    FSeed : Integer;
    procedure SetFPrefix(Value : String);
    procedure SetFSeed(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Generate : TExtFunction;
    property Prefix : String read FPrefix write SetFPrefix;
    property Seed : Integer read FSeed write SetFSeed;
  end;

  TExtDirectJsonProvider = class(TExtDirectProvider)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateEvent(Response : TExtObject) : TExtFunction;
    function CreateEvents(Response : TExtObject) : TExtFunction;
  end;

  // Procedural types for events TExtButton
  TExtButtonOnClick = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnGlyphchange = procedure(This : TExtButton; NewGlyph : Integer; OldGlyph : Integer) of object;
  TExtButtonOnIconchange = procedure(This : TExtButton; OldIcon : String; NewIcon : String) of object;
  TExtButtonOnMenuhide = procedure(This : TExtButton; Menu : TExtMenu) of object;
  TExtButtonOnMenushow = procedure(This : TExtButton; Menu : TExtMenu) of object;
  TExtButtonOnMenutriggerout = procedure(This : TExtButton; Menu : TExtMenu; E : TExtDirectEvent) of object;
  TExtButtonOnMenutriggerover = procedure(This : TExtButton; Menu : TExtMenu; E : TExtDirectEvent) of object;
  TExtButtonOnMouseout = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnMouseover = procedure(This : TExtButton; E : TExtDirectEvent) of object;
  TExtButtonOnTextchange = procedure(This : TExtButton; OldText : String; NewText : String) of object;
  TExtButtonOnToggle = procedure(This : TExtButton; Pressed : Boolean) of object;

  // Enumerated types for properties
  TScaleEnum = (scSmall, scMedium, scLarge);

  TExtButton = class(TExtComponent)
  private
    FAllowDepress : Boolean;
    FArrowAlign : String;
    FArrowCls : String;
    FBaseCls : String;
    FBaseParams : TExtObject;
    FClickEvent : String;
    FCls : String;
    FDestroyMenu : Boolean;
    FDisabled : Boolean;
    FEnableToggle : Boolean;
    FFocusCls : String;
    FGlyph : Integer;
    FGlyphString : String;
    FHandleMouseEvents : Boolean;
    FHandler : TExtFunction;
    FHandlerButton : TExtButton;
    FHandlerE : TExtEventObject;
    FHidden : Boolean;
    FHref : String;
    FHrefTarget : String;
    FIcon : String;
    FIconAlign : String;
    FIconCls : String;
    FIsAction : Boolean;
    FMenu : TExtMenu;
    FMenuActiveCls : String;
    FMenuAlign : String;
    FMenuObject : TExtObject;
    FMenuString : String;
    FMinWidth : Integer;
    FOverCls : String;
    FOverflowText : String;
    FParams : TExtObject;
    FPressed : Boolean;
    FPressedCls : String;
    FPreventDefault : Boolean;
    FRepeatJS : Boolean;
    FRepeatJSObject : TExtObject;
    FScale : TScaleEnum;
    FScope : TExtObject;
    FShowEmptyMenu : Boolean;
    FTabIndex : Integer;
    FTemplate : TExtTemplate;
    FText : String;
    FTextAlign : String;
    FToggleGroup : String;
    FToggleHandler : TExtFunction;
    FToggleHandlerButton : TExtButton;
    FToggleHandlerState : Boolean;
    FTooltip : String;
    FTooltipObject : TExtObject;
    FTooltipType : String;
    FTypeJS : String;
    FOnClick : TExtButtonOnClick;
    FOnGlyphchange : TExtButtonOnGlyphchange;
    FOnIconchange : TExtButtonOnIconchange;
    FOnMenuhide : TExtButtonOnMenuhide;
    FOnMenushow : TExtButtonOnMenushow;
    FOnMenutriggerout : TExtButtonOnMenutriggerout;
    FOnMenutriggerover : TExtButtonOnMenutriggerover;
    FOnMouseout : TExtButtonOnMouseout;
    FOnMouseover : TExtButtonOnMouseover;
    FOnTextchange : TExtButtonOnTextchange;
    FOnToggle : TExtButtonOnToggle;
    procedure SetFAllowDepress(Value : Boolean);
    procedure SetFArrowAlign(Value : String);
    procedure SetFArrowCls(Value : String);
    procedure SetFBaseCls(Value : String);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFClickEvent(Value : String);
    procedure SetFCls(Value : String);
    procedure SetFDestroyMenu(Value : Boolean);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFEnableToggle(Value : Boolean);
    procedure SetFFocusCls(Value : String);
    procedure SetFGlyph(Value : Integer);
    procedure SetFGlyphString(Value : String);
    procedure SetFHandleMouseEvents(Value : Boolean);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFHandlerButton(Value : TExtButton);
    procedure SetFHandlerE(Value : TExtEventObject);
    procedure SetFHidden(Value : Boolean);
    procedure SetFHref(Value : String);
    procedure SetFHrefTarget(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFIconAlign(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIsAction(Value : Boolean);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFMenuActiveCls(Value : String);
    procedure SetFMenuAlign(Value : String);
    procedure SetFMenuObject(Value : TExtObject);
    procedure SetFMenuString(Value : String);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFOverCls(Value : String);
    procedure SetFOverflowText(Value : String);
    procedure SetFParams(Value : TExtObject);
    procedure SetFPressed(Value : Boolean);
    procedure SetFPressedCls(Value : String);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFRepeatJS(Value : Boolean);
    procedure SetFRepeatJSObject(Value : TExtObject);
    procedure SetFScale(Value : TScaleEnum);
    procedure SetFScope(Value : TExtObject);
    procedure SetFShowEmptyMenu(Value : Boolean);
    procedure SetFTabIndex(Value : Integer);
    procedure SetFTemplate(Value : TExtTemplate);
    procedure SetFText(Value : String);
    procedure SetFTextAlign(Value : String);
    procedure SetFToggleGroup(Value : String);
    procedure SetFToggleHandler(Value : TExtFunction);
    procedure SetFToggleHandlerButton(Value : TExtButton);
    procedure SetFToggleHandlerState(Value : Boolean);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipObject(Value : TExtObject);
    procedure SetFTooltipType(Value : String);
    procedure SetFTypeJS(Value : String);
    procedure SetFOnClick(Value : TExtButtonOnClick);
    procedure SetFOnGlyphchange(Value : TExtButtonOnGlyphchange);
    procedure SetFOnIconchange(Value : TExtButtonOnIconchange);
    procedure SetFOnMenuhide(Value : TExtButtonOnMenuhide);
    procedure SetFOnMenushow(Value : TExtButtonOnMenushow);
    procedure SetFOnMenutriggerout(Value : TExtButtonOnMenutriggerout);
    procedure SetFOnMenutriggerover(Value : TExtButtonOnMenutriggerover);
    procedure SetFOnMouseout(Value : TExtButtonOnMouseout);
    procedure SetFOnMouseover(Value : TExtButtonOnMouseover);
    procedure SetFOnTextchange(Value : TExtButtonOnTextchange);
    procedure SetFOnToggle(Value : TExtButtonOnToggle);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTemplateArgs : TExtFunction;
    function GetText : TExtFunction;
    function HasVisibleMenu : TExtFunction;
    function HideMenu : TExtFunction;
    function SetGlyph(Glyph : String) : TExtFunction; overload;
    function SetGlyph(Glyph : Integer) : TExtFunction; overload;
    function SetHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function SetHref(Href : String) : TExtFunction;
    function SetIcon(Icon : String) : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function SetParams(Params : TExtObject) : TExtFunction;
    function SetScale(Scale : String) : TExtFunction;
    function SetText(Text : String) : TExtFunction;
    function SetTextAlign(Align : String) : TExtFunction;
    function SetTooltip(Tooltip : TExtObject) : TExtFunction; overload;
    function SetTooltip(Tooltip : String) : TExtFunction; overload;
    function ShowMenu : TExtFunction;
    function Toggle(State : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property AllowDepress : Boolean read FAllowDepress write SetFAllowDepress;
    property ArrowAlign : String read FArrowAlign write SetFArrowAlign;
    property ArrowCls : String read FArrowCls write SetFArrowCls;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property ClickEvent : String read FClickEvent write SetFClickEvent;
    property Cls : String read FCls write SetFCls;
    property DestroyMenu : Boolean read FDestroyMenu write SetFDestroyMenu;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property EnableToggle : Boolean read FEnableToggle write SetFEnableToggle;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property Glyph : Integer read FGlyph write SetFGlyph;
    property GlyphString : String read FGlyphString write SetFGlyphString;
    property HandleMouseEvents : Boolean read FHandleMouseEvents write SetFHandleMouseEvents;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property HandlerButton : TExtButton read FHandlerButton write SetFHandlerButton;
    property HandlerE : TExtEventObject read FHandlerE write SetFHandlerE;
    property Hidden : Boolean read FHidden write SetFHidden;
    property Href : String read FHref write SetFHref;
    property HrefTarget : String read FHrefTarget write SetFHrefTarget;
    property Icon : String read FIcon write SetFIcon;
    property IconAlign : String read FIconAlign write SetFIconAlign;
    property IconCls : String read FIconCls write SetFIconCls;
    property IsAction : Boolean read FIsAction write SetFIsAction;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property MenuActiveCls : String read FMenuActiveCls write SetFMenuActiveCls;
    property MenuAlign : String read FMenuAlign write SetFMenuAlign;
    property MenuObject : TExtObject read FMenuObject write SetFMenuObject;
    property MenuString : String read FMenuString write SetFMenuString;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property OverCls : String read FOverCls write SetFOverCls;
    property OverflowText : String read FOverflowText write SetFOverflowText;
    property Params : TExtObject read FParams write SetFParams;
    property Pressed : Boolean read FPressed write SetFPressed;
    property PressedCls : String read FPressedCls write SetFPressedCls;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property RepeatJS : Boolean read FRepeatJS write SetFRepeatJS;
    property RepeatJSObject : TExtObject read FRepeatJSObject write SetFRepeatJSObject;
    property Scale : TScaleEnum read FScale write SetFScale;
    property Scope : TExtObject read FScope write SetFScope;
    property ShowEmptyMenu : Boolean read FShowEmptyMenu write SetFShowEmptyMenu;
    property TabIndex : Integer read FTabIndex write SetFTabIndex;
    property Template : TExtTemplate read FTemplate write SetFTemplate;
    property Text : String read FText write SetFText;
    property TextAlign : String read FTextAlign write SetFTextAlign;
    property ToggleGroup : String read FToggleGroup write SetFToggleGroup;
    property ToggleHandler : TExtFunction read FToggleHandler write SetFToggleHandler;
    property ToggleHandlerButton : TExtButton read FToggleHandlerButton write SetFToggleHandlerButton;
    property ToggleHandlerState : Boolean read FToggleHandlerState write SetFToggleHandlerState;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipObject : TExtObject read FTooltipObject write SetFTooltipObject;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property TypeJS : String read FTypeJS write SetFTypeJS;
    property OnClick : TExtButtonOnClick read FOnClick write SetFOnClick;
    property OnGlyphchange : TExtButtonOnGlyphchange read FOnGlyphchange write SetFOnGlyphchange;
    property OnIconchange : TExtButtonOnIconchange read FOnIconchange write SetFOnIconchange;
    property OnMenuhide : TExtButtonOnMenuhide read FOnMenuhide write SetFOnMenuhide;
    property OnMenushow : TExtButtonOnMenushow read FOnMenushow write SetFOnMenushow;
    property OnMenutriggerout : TExtButtonOnMenutriggerout read FOnMenutriggerout write SetFOnMenutriggerout;
    property OnMenutriggerover : TExtButtonOnMenutriggerover read FOnMenutriggerover write SetFOnMenutriggerover;
    property OnMouseout : TExtButtonOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtButtonOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnTextchange : TExtButtonOnTextchange read FOnTextchange write SetFOnTextchange;
    property OnToggle : TExtButtonOnToggle read FOnToggle write SetFOnToggle;
  end;

  TExtAjaxSingleton = class(TExtDataConnection)
  private
    FAutoAbort : Boolean;
    FDefaultHeaders : TExtObject;
    FDisableCaching : Boolean; // true
    FExtraParams : TExtObject;
    FMethod : String;
    FTimeout : Integer; // 30000
    FUrl : String;
    procedure SetFAutoAbort(Value : Boolean);
    procedure SetFDefaultHeaders(Value : TExtObject);
    procedure SetFDisableCaching(Value : Boolean);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFMethod(Value : String);
    procedure SetFTimeout(Value : Integer);
    procedure SetFUrl(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    destructor Destroy; override;
    property AutoAbort : Boolean read FAutoAbort write SetFAutoAbort;
    property DefaultHeaders : TExtObject read FDefaultHeaders write SetFDefaultHeaders;
    property DisableCaching : Boolean read FDisableCaching write SetFDisableCaching;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property Method : String read FMethod write SetFMethod;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Url : String read FUrl write SetFUrl;
  end;

  TExtAppApplication = class(TExtAppController)
  private
    FAppFolder : String;
    FAppProperty : String;
    FAutoCreateViewport : Boolean;
    FControllers : TArrayOfString;
    FEnableQuickTips : Boolean;
    FName : String;
    FNamespaces : TArrayOfString;
    FPaths : TExtObject;
    FScope : TExtObject;
    procedure SetFAppFolder(Value : String);
    procedure SetFAppProperty(Value : String);
    procedure SetFAutoCreateViewport(Value : Boolean);
    procedure SetFControllers(Value : TArrayOfString);
    procedure SetFEnableQuickTips(Value : Boolean);
    procedure SetFName(Value : String);
    procedure SetFNamespaces(Value : TArrayOfString);
    procedure SetFPaths(Value : TExtObject);
    procedure SetFScope(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject = nil);
    destructor Destroy; override;
    property AppFolder : String read FAppFolder write SetFAppFolder;
    property AppProperty : String read FAppProperty write SetFAppProperty;
    property AutoCreateViewport : Boolean read FAutoCreateViewport write SetFAutoCreateViewport;
    property Controllers : TArrayOfString read FControllers write SetFControllers;
    property EnableQuickTips : Boolean read FEnableQuickTips write SetFEnableQuickTips;
    property Name : String read FName write SetFName;
    property Namespaces : TArrayOfString read FNamespaces write SetFNamespaces;
    property Paths : TExtObject read FPaths write SetFPaths;
    property Scope : TExtObject read FScope write SetFScope;
  end;

  // Procedural types for events TExtFormFieldBase
  TExtFormFieldBaseOnChange = procedure(This : TExtFormField; NewValue : TExtObject; OldValue : TExtObject) of object;
  TExtFormFieldBaseOnDirtychange = procedure(This : TExtFormField; IsDirty : Boolean) of object;
  TExtFormFieldBaseOnErrorchange = procedure(This : TExtFormLabelable; Error : String) of object;
  TExtFormFieldBaseOnSpecialkey = procedure(This : TExtFormFieldBase; E : TExtEventObject) of object;
  TExtFormFieldBaseOnValiditychange = procedure(This : TExtFormField; IsValid : Boolean) of object;
  TExtFormFieldBaseOnWriteablechange = procedure(This : TExtFormFieldBase; Read : Boolean) of object;

  TExtFormFieldBase = class(TExtComponent)
  private
    FActiveError : String;
    FActiveErrorsTpl : String;
    FActiveErrorsTplTArrayOfString : TArrayOfString;
    FActiveErrorsTplTemplate : TExtXTemplate;
    FAfterBodyEl : String;
    FAfterBodyElList : TExtObjectList;
    FAfterBodyElTemplate : TExtXTemplate;
    FAfterLabelTextTpl : String;
    FAfterLabelTextTplList : TExtObjectList;
    FAfterLabelTextTplTemplate : TExtXTemplate;
    FAfterLabelTpl : String;
    FAfterLabelTplList : TExtObjectList;
    FAfterLabelTplTemplate : TExtXTemplate;
    FAfterSubTpl : String;
    FAfterSubTplList : TExtObjectList;
    FAfterSubTplTemplate : TExtXTemplate;
    FAutoFitErrors : Boolean;
    FBaseBodyCls : String;
    FBeforeBodyEl : String;
    FBeforeBodyElList : TExtObjectList;
    FBeforeBodyElTemplate : TExtXTemplate;
    FBeforeLabelTextTpl : String;
    FBeforeLabelTextTplList : TExtObjectList;
    FBeforeLabelTextTplTemplate : TExtXTemplate;
    FBeforeLabelTpl : String;
    FBeforeLabelTplList : TExtObjectList;
    FBeforeLabelTplTemplate : TExtXTemplate;
    FBeforeSubTpl : String;
    FBeforeSubTplList : TExtObjectList;
    FBeforeSubTplTemplate : TExtXTemplate;
    FBodyEl : TExtElement;
    FCheckChangeBuffer : Integer; // 50
    FCheckChangeEvents : TArrayOfString;
    FClearCls : String;
    FDirtyCls : String;
    FDisabled : Boolean;
    FErrorEl : TExtElement;
    FErrorMsgCls : String;
    FFieldBodyCls : String;
    FFieldCls : String;
    FFieldLabel : String;
    FFieldStyle : String;
    FFocusCls : String;
    FFormItemCls : String;
    FHideEmptyLabel : Boolean;
    FHideLabel : Boolean;
    FInputAttrTpl : String;
    FInputAttrTplList : TExtObjectList;
    FInputAttrTplTemplate : TExtXTemplate;
    FInputEl : TExtElement;
    FInputId : String;
    FInputType : String;
    FInvalidCls : String;
    FInvalidText : String;
    FIsFieldLabelable : Boolean;
    FIsFormField : Boolean;
    FLabelAlign : TLabelAlignEnum;
    FLabelAttrTpl : String;
    FLabelAttrTplList : TExtObjectList;
    FLabelAttrTplTemplate : TExtXTemplate;
    FLabelCell : TExtElement;
    FLabelCls : String;
    FLabelClsExtra : String;
    FLabelEl : TExtElement;
    FLabelPad : Integer;
    FLabelSeparator : String;
    FLabelStyle : String;
    FLabelWidth : Integer;
    FMsgTarget : String;
    FName : String;
    FOriginalValue : TExtObject;
    FPreventMark : Boolean;
    FReadOnly : Boolean;
    FReadOnlyCls : String;
    FSubmitValue : Boolean;
    FTabIndex : Integer;
    FValidateOnBlur : Boolean;
    FValidateOnChange : Boolean;
    FValue : TExtObject;
    FOnChange : TExtFormFieldBaseOnChange;
    FOnDirtychange : TExtFormFieldBaseOnDirtychange;
    FOnErrorchange : TExtFormFieldBaseOnErrorchange;
    FOnSpecialkey : TExtFormFieldBaseOnSpecialkey;
    FOnValiditychange : TExtFormFieldBaseOnValiditychange;
    FOnWriteablechange : TExtFormFieldBaseOnWriteablechange;
    procedure SetFActiveError(Value : String);
    procedure SetFActiveErrorsTpl(Value : String);
    procedure SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString);
    procedure SetFActiveErrorsTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterBodyEl(Value : String);
    procedure SetFAfterBodyElList(Value : TExtObjectList);
    procedure SetFAfterBodyElTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTextTpl(Value : String);
    procedure SetFAfterLabelTextTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTpl(Value : String);
    procedure SetFAfterLabelTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterSubTpl(Value : String);
    procedure SetFAfterSubTplList(Value : TExtObjectList);
    procedure SetFAfterSubTplTemplate(Value : TExtXTemplate);
    procedure SetFAutoFitErrors(Value : Boolean);
    procedure SetFBaseBodyCls(Value : String);
    procedure SetFBeforeBodyEl(Value : String);
    procedure SetFBeforeBodyElList(Value : TExtObjectList);
    procedure SetFBeforeBodyElTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTextTpl(Value : String);
    procedure SetFBeforeLabelTextTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTpl(Value : String);
    procedure SetFBeforeLabelTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeSubTpl(Value : String);
    procedure SetFBeforeSubTplList(Value : TExtObjectList);
    procedure SetFBeforeSubTplTemplate(Value : TExtXTemplate);
    procedure SetFBodyEl(Value : TExtElement);
    procedure SetFCheckChangeBuffer(Value : Integer);
    procedure SetFCheckChangeEvents(Value : TArrayOfString);
    procedure SetFClearCls(Value : String);
    procedure SetFDirtyCls(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFErrorEl(Value : TExtElement);
    procedure SetFErrorMsgCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFFieldCls(Value : String);
    procedure SetFFieldLabel(Value : String);
    procedure SetFFieldStyle(Value : String);
    procedure SetFFocusCls(Value : String);
    procedure SetFFormItemCls(Value : String);
    procedure SetFHideEmptyLabel(Value : Boolean);
    procedure SetFHideLabel(Value : Boolean);
    procedure SetFInputAttrTpl(Value : String);
    procedure SetFInputAttrTplList(Value : TExtObjectList);
    procedure SetFInputAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFInputEl(Value : TExtElement);
    procedure SetFInputId(Value : String);
    procedure SetFInputType(Value : String);
    procedure SetFInvalidCls(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFIsFieldLabelable(Value : Boolean);
    procedure SetFIsFormField(Value : Boolean);
    procedure SetFLabelAlign(Value : TLabelAlignEnum);
    procedure SetFLabelAttrTpl(Value : String);
    procedure SetFLabelAttrTplList(Value : TExtObjectList);
    procedure SetFLabelAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFLabelCell(Value : TExtElement);
    procedure SetFLabelCls(Value : String);
    procedure SetFLabelClsExtra(Value : String);
    procedure SetFLabelEl(Value : TExtElement);
    procedure SetFLabelPad(Value : Integer);
    procedure SetFLabelSeparator(Value : String);
    procedure SetFLabelStyle(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFMsgTarget(Value : String);
    procedure SetFName(Value : String);
    procedure SetFOriginalValue(Value : TExtObject);
    procedure SetFPreventMark(Value : Boolean);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFReadOnlyCls(Value : String);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFTabIndex(Value : Integer);
    procedure SetFValidateOnBlur(Value : Boolean);
    procedure SetFValidateOnChange(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFOnChange(Value : TExtFormFieldBaseOnChange);
    procedure SetFOnDirtychange(Value : TExtFormFieldBaseOnDirtychange);
    procedure SetFOnErrorchange(Value : TExtFormFieldBaseOnErrorchange);
    procedure SetFOnSpecialkey(Value : TExtFormFieldBaseOnSpecialkey);
    procedure SetFOnValiditychange(Value : TExtFormFieldBaseOnValiditychange);
    procedure SetFOnWriteablechange(Value : TExtFormFieldBaseOnWriteablechange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BatchChanges(Fn : TExtObject) : TExtFunction;
    function CheckChange : TExtFunction;
    function CheckDirty : TExtFunction;
    function ClearInvalid : TExtFunction;
    constructor Create;
    function ExtractFileInput : TExtFunction;
    function GetActiveError : TExtFunction;
    function GetActiveErrors : TExtFunction;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function GetInputId : TExtFunction;
    function GetLabelWidth : TExtFunction;
    function GetModelData : TExtFunction;
    function GetName : TExtFunction;
    function GetRawValue : TExtFunction;
    function GetSubmitData : TExtFunction;
    function GetSubmitValue : TExtFunction;
    function GetSubTplMarkup : TExtFunction;
    function GetValue : TExtFunction;
    function HasActiveError : TExtFunction;
    function HasVisibleLabel : TExtFunction;
    function InitField : TExtFunction;
    function InitLabelable : TExtFunction;
    function InitValue : TExtFunction;
    function IsDirty : TExtFunction;
    function IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction;
    function IsFileUpload : TExtFunction;
    function IsValid : TExtFunction;
    function MarkInvalid(Errors : TArrayOfString) : TExtFunction; overload;
    function MarkInvalid(Errors : String) : TExtFunction; overload;
    function Reset : TExtFunction;
    function ResetOriginalValue : TExtFunction;
    function SetActiveError(Msg : String) : TExtFunction;
    function SetActiveErrors(Errors : TArrayOfString) : TExtFunction;
    function SetFieldDefaults(Defaults : TExtObject) : TExtFunction;
    function SetFieldLabel(LabelJS : String) : TExtFunction;
    function SetFieldStyle(Style : TExtObject) : TExtFunction; overload;
    function SetFieldStyle(Style : TExtFunction) : TExtFunction; overload;
    function SetFieldStyle(Style : String) : TExtFunction; overload;
    function SetRawValue(Value : TExtObject) : TExtFunction;
    function SetReadOnly(ReadOnly : Boolean) : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function TrimLabelSeparator : TExtFunction;
    function UnsetActiveError : TExtFunction;
    function Validate : TExtFunction;
    function ValidateValue(Value : TExtObject) : TExtFunction;
    function ValueToRaw(Value : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property ActiveError : String read FActiveError write SetFActiveError;
    property ActiveErrorsTpl : String read FActiveErrorsTpl write SetFActiveErrorsTpl;
    property ActiveErrorsTplTArrayOfString : TArrayOfString read FActiveErrorsTplTArrayOfString write SetFActiveErrorsTplTArrayOfString;
    property ActiveErrorsTplTemplate : TExtXTemplate read FActiveErrorsTplTemplate write SetFActiveErrorsTplTemplate;
    property AfterBodyEl : String read FAfterBodyEl write SetFAfterBodyEl;
    property AfterBodyElList : TExtObjectList read FAfterBodyElList write SetFAfterBodyElList;
    property AfterBodyElTemplate : TExtXTemplate read FAfterBodyElTemplate write SetFAfterBodyElTemplate;
    property AfterLabelTextTpl : String read FAfterLabelTextTpl write SetFAfterLabelTextTpl;
    property AfterLabelTextTplList : TExtObjectList read FAfterLabelTextTplList write SetFAfterLabelTextTplList;
    property AfterLabelTextTplTemplate : TExtXTemplate read FAfterLabelTextTplTemplate write SetFAfterLabelTextTplTemplate;
    property AfterLabelTpl : String read FAfterLabelTpl write SetFAfterLabelTpl;
    property AfterLabelTplList : TExtObjectList read FAfterLabelTplList write SetFAfterLabelTplList;
    property AfterLabelTplTemplate : TExtXTemplate read FAfterLabelTplTemplate write SetFAfterLabelTplTemplate;
    property AfterSubTpl : String read FAfterSubTpl write SetFAfterSubTpl;
    property AfterSubTplList : TExtObjectList read FAfterSubTplList write SetFAfterSubTplList;
    property AfterSubTplTemplate : TExtXTemplate read FAfterSubTplTemplate write SetFAfterSubTplTemplate;
    property AutoFitErrors : Boolean read FAutoFitErrors write SetFAutoFitErrors;
    property BaseBodyCls : String read FBaseBodyCls write SetFBaseBodyCls;
    property BeforeBodyEl : String read FBeforeBodyEl write SetFBeforeBodyEl;
    property BeforeBodyElList : TExtObjectList read FBeforeBodyElList write SetFBeforeBodyElList;
    property BeforeBodyElTemplate : TExtXTemplate read FBeforeBodyElTemplate write SetFBeforeBodyElTemplate;
    property BeforeLabelTextTpl : String read FBeforeLabelTextTpl write SetFBeforeLabelTextTpl;
    property BeforeLabelTextTplList : TExtObjectList read FBeforeLabelTextTplList write SetFBeforeLabelTextTplList;
    property BeforeLabelTextTplTemplate : TExtXTemplate read FBeforeLabelTextTplTemplate write SetFBeforeLabelTextTplTemplate;
    property BeforeLabelTpl : String read FBeforeLabelTpl write SetFBeforeLabelTpl;
    property BeforeLabelTplList : TExtObjectList read FBeforeLabelTplList write SetFBeforeLabelTplList;
    property BeforeLabelTplTemplate : TExtXTemplate read FBeforeLabelTplTemplate write SetFBeforeLabelTplTemplate;
    property BeforeSubTpl : String read FBeforeSubTpl write SetFBeforeSubTpl;
    property BeforeSubTplList : TExtObjectList read FBeforeSubTplList write SetFBeforeSubTplList;
    property BeforeSubTplTemplate : TExtXTemplate read FBeforeSubTplTemplate write SetFBeforeSubTplTemplate;
    property BodyEl : TExtElement read FBodyEl write SetFBodyEl;
    property CheckChangeBuffer : Integer read FCheckChangeBuffer write SetFCheckChangeBuffer;
    property CheckChangeEvents : TArrayOfString read FCheckChangeEvents write SetFCheckChangeEvents;
    property ClearCls : String read FClearCls write SetFClearCls;
    property DirtyCls : String read FDirtyCls write SetFDirtyCls;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property ErrorEl : TExtElement read FErrorEl write SetFErrorEl;
    property ErrorMsgCls : String read FErrorMsgCls write SetFErrorMsgCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property FieldLabel : String read FFieldLabel write SetFFieldLabel;
    property FieldStyle : String read FFieldStyle write SetFFieldStyle;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property FormItemCls : String read FFormItemCls write SetFFormItemCls;
    property HideEmptyLabel : Boolean read FHideEmptyLabel write SetFHideEmptyLabel;
    property HideLabel : Boolean read FHideLabel write SetFHideLabel;
    property InputAttrTpl : String read FInputAttrTpl write SetFInputAttrTpl;
    property InputAttrTplList : TExtObjectList read FInputAttrTplList write SetFInputAttrTplList;
    property InputAttrTplTemplate : TExtXTemplate read FInputAttrTplTemplate write SetFInputAttrTplTemplate;
    property InputEl : TExtElement read FInputEl write SetFInputEl;
    property InputId : String read FInputId write SetFInputId;
    property InputType : String read FInputType write SetFInputType;
    property InvalidCls : String read FInvalidCls write SetFInvalidCls;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property IsFieldLabelable : Boolean read FIsFieldLabelable write SetFIsFieldLabelable;
    property IsFormField : Boolean read FIsFormField write SetFIsFormField;
    property LabelAlign : TLabelAlignEnum read FLabelAlign write SetFLabelAlign;
    property LabelAttrTpl : String read FLabelAttrTpl write SetFLabelAttrTpl;
    property LabelAttrTplList : TExtObjectList read FLabelAttrTplList write SetFLabelAttrTplList;
    property LabelAttrTplTemplate : TExtXTemplate read FLabelAttrTplTemplate write SetFLabelAttrTplTemplate;
    property LabelCell : TExtElement read FLabelCell write SetFLabelCell;
    property LabelCls : String read FLabelCls write SetFLabelCls;
    property LabelClsExtra : String read FLabelClsExtra write SetFLabelClsExtra;
    property LabelEl : TExtElement read FLabelEl write SetFLabelEl;
    property LabelPad : Integer read FLabelPad write SetFLabelPad;
    property LabelSeparator : String read FLabelSeparator write SetFLabelSeparator;
    property LabelStyle : String read FLabelStyle write SetFLabelStyle;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property MsgTarget : String read FMsgTarget write SetFMsgTarget;
    property Name : String read FName write SetFName;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
    property PreventMark : Boolean read FPreventMark write SetFPreventMark;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property ReadOnlyCls : String read FReadOnlyCls write SetFReadOnlyCls;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property TabIndex : Integer read FTabIndex write SetFTabIndex;
    property ValidateOnBlur : Boolean read FValidateOnBlur write SetFValidateOnBlur;
    property ValidateOnChange : Boolean read FValidateOnChange write SetFValidateOnChange;
    property Value : TExtObject read FValue write SetFValue;
    property OnChange : TExtFormFieldBaseOnChange read FOnChange write SetFOnChange;
    property OnDirtychange : TExtFormFieldBaseOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnErrorchange : TExtFormFieldBaseOnErrorchange read FOnErrorchange write SetFOnErrorchange;
    property OnSpecialkey : TExtFormFieldBaseOnSpecialkey read FOnSpecialkey write SetFOnSpecialkey;
    property OnValiditychange : TExtFormFieldBaseOnValiditychange read FOnValiditychange write SetFOnValiditychange;
    property OnWriteablechange : TExtFormFieldBaseOnWriteablechange read FOnWriteablechange write SetFOnWriteablechange;
  end;

  // Procedural types for events TExtFormBasic
  TExtFormBasicOnActioncomplete = procedure(This : TExtFormBasic; Action : TExtFormAction) of object;
  TExtFormBasicOnActionfailed = procedure(This : TExtFormBasic; Action : TExtFormAction) of object;
  TExtFormBasicOnBeforeaction = procedure(This : TExtFormBasic; Action : TExtFormAction) of object;
  TExtFormBasicOnDirtychange = procedure(This : TExtFormBasic; Dirty : Boolean) of object;
  TExtFormBasicOnValiditychange = procedure(This : TExtFormBasic; Valid : Boolean) of object;

  TExtFormBasic = class(TExtUtilObservable)
  private
    FApi : TExtObject;
    FBaseParams : TExtObject;
    FErrorReader : TExtObject;
    FErrorReaderReader : TExtDataReader;
    FJsonSubmit : Boolean;
    FMethod : String;
    FOwner : TExtContainer;
    FParamOrder : String;
    FParamOrderTArrayOfString : TArrayOfString;
    FParamsAsHash : Boolean;
    FReader : TExtObject;
    FReaderReader : TExtDataReader;
    FStandardSubmit : Boolean;
    FTimeout : Integer;
    FTrackResetOnLoad : Boolean;
    FUrl : String;
    FWaitMsgTarget : String;
    FWaitMsgTargetElement : TExtElement;
    FWaitMsgTargetTHTMLElement : THTMLElement;
    FWaitTitle : String;
    FOnActioncomplete : TExtFormBasicOnActioncomplete;
    FOnActionfailed : TExtFormBasicOnActionfailed;
    FOnBeforeaction : TExtFormBasicOnBeforeaction;
    FOnDirtychange : TExtFormBasicOnDirtychange;
    FOnValiditychange : TExtFormBasicOnValiditychange;
    procedure SetFApi(Value : TExtObject);
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFErrorReader(Value : TExtObject);
    procedure SetFErrorReaderReader(Value : TExtDataReader);
    procedure SetFJsonSubmit(Value : Boolean);
    procedure SetFMethod(Value : String);
    procedure SetFOwner(Value : TExtContainer);
    procedure SetFParamOrder(Value : String);
    procedure SetFParamOrderTArrayOfString(Value : TArrayOfString);
    procedure SetFParamsAsHash(Value : Boolean);
    procedure SetFReader(Value : TExtObject);
    procedure SetFReaderReader(Value : TExtDataReader);
    procedure SetFStandardSubmit(Value : Boolean);
    procedure SetFTimeout(Value : Integer);
    procedure SetFTrackResetOnLoad(Value : Boolean);
    procedure SetFUrl(Value : String);
    procedure SetFWaitMsgTarget(Value : String);
    procedure SetFWaitMsgTargetElement(Value : TExtElement);
    procedure SetFWaitMsgTargetTHTMLElement(Value : THTMLElement);
    procedure SetFWaitTitle(Value : String);
    procedure SetFOnActioncomplete(Value : TExtFormBasicOnActioncomplete);
    procedure SetFOnActionfailed(Value : TExtFormBasicOnActionfailed);
    procedure SetFOnBeforeaction(Value : TExtFormBasicOnBeforeaction);
    procedure SetFOnDirtychange(Value : TExtFormBasicOnDirtychange);
    procedure SetFOnValiditychange(Value : TExtFormBasicOnValiditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ApplyIfToFields(Obj : TExtObject) : TExtFunction;
    function ApplyToFields(Obj : TExtObject) : TExtFunction;
    function CheckDirty : TExtFunction;
    function CheckValidity : TExtFunction;
    function ClearInvalid : TExtFunction;
    constructor Create(Owner : TExtContainer; Config : TExtObject);
    function DoAction(Action : TExtFormAction; Options : TExtObject = nil) : TExtFunction; overload;
    function DoAction(Action : String; Options : TExtObject = nil) : TExtFunction; overload;
    function FindField(Id : String) : TExtFunction;
    function GetFields : TExtFunction;
    function GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction;
    function GetRecord : TExtFunction;
    function GetValues(AsString : Boolean = false; DirtyOnly : Boolean = false; IncludeEmptyText : Boolean = false; UseDataValues : Boolean = false) : TExtFunction;
    function HasInvalidField : TExtFunction;
    function HasUpload : TExtFunction;
    function IsDirty : TExtFunction;
    function IsValid : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function LoadRecord(RecordJS : TExtDataModel) : TExtFunction;
    function MarkInvalid(Errors : TExtObjectList) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtObject) : TExtFunction; overload;
    function MarkInvalid(Errors : TExtDataErrors) : TExtFunction; overload;
    function Reset(ResetRecord : Boolean = false) : TExtFunction;
    function SetValues(Values : TExtObjectList) : TExtFunction; overload;
    function SetValues(Values : TExtObject) : TExtFunction; overload;
    function Submit(Options : TExtObject) : TExtFunction;
    function UpdateRecord(RecordJS : TExtDataModel = nil) : TExtFunction;
    destructor Destroy; override;
    property Api : TExtObject read FApi write SetFApi;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property ErrorReader : TExtObject read FErrorReader write SetFErrorReader;
    property ErrorReaderReader : TExtDataReader read FErrorReaderReader write SetFErrorReaderReader;
    property JsonSubmit : Boolean read FJsonSubmit write SetFJsonSubmit;
    property Method : String read FMethod write SetFMethod;
    property Owner : TExtContainer read FOwner write SetFOwner;
    property ParamOrder : String read FParamOrder write SetFParamOrder;
    property ParamOrderTArrayOfString : TArrayOfString read FParamOrderTArrayOfString write SetFParamOrderTArrayOfString;
    property ParamsAsHash : Boolean read FParamsAsHash write SetFParamsAsHash;
    property Reader : TExtObject read FReader write SetFReader;
    property ReaderReader : TExtDataReader read FReaderReader write SetFReaderReader;
    property StandardSubmit : Boolean read FStandardSubmit write SetFStandardSubmit;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property TrackResetOnLoad : Boolean read FTrackResetOnLoad write SetFTrackResetOnLoad;
    property Url : String read FUrl write SetFUrl;
    property WaitMsgTarget : String read FWaitMsgTarget write SetFWaitMsgTarget;
    property WaitMsgTargetElement : TExtElement read FWaitMsgTargetElement write SetFWaitMsgTargetElement;
    property WaitMsgTargetTHTMLElement : THTMLElement read FWaitMsgTargetTHTMLElement write SetFWaitMsgTargetTHTMLElement;
    property WaitTitle : String read FWaitTitle write SetFWaitTitle;
    property OnActioncomplete : TExtFormBasicOnActioncomplete read FOnActioncomplete write SetFOnActioncomplete;
    property OnActionfailed : TExtFormBasicOnActionfailed read FOnActionfailed write SetFOnActionfailed;
    property OnBeforeaction : TExtFormBasicOnBeforeaction read FOnBeforeaction write SetFOnBeforeaction;
    property OnDirtychange : TExtFormBasicOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnValiditychange : TExtFormBasicOnValiditychange read FOnValiditychange write SetFOnValiditychange;
  end;

  TExtFormActionLoad = class(TExtFormAction)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDirectRemotingEvent = class(TExtDirectEvent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetTransaction : TExtFunction;
  end;

  TExtFormActionSubmit = class(TExtFormAction)
  private
    FClientValidation : Boolean;
    procedure SetFClientValidation(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ClientValidation : Boolean read FClientValidation write SetFClientValidation;
  end;

  // Procedural types for events TExtDataStore
  TExtDataStoreOnBeforeprefetch = procedure(This : TExtDataStore; Operation : TExtDataOperation) of object;
  TExtDataStoreOnFilterchange = procedure(Store : TExtDataStore; Filters : TExtObjectList) of object;
  TExtDataStoreOnGroupchange = procedure(Store : TExtDataStore; Groupers : TExtObjectList) of object;
  TExtDataStoreOnPrefetch = procedure(This : TExtDataStore; Records : TExtObjectList; Successful : Boolean; Operation : TExtDataOperation) of object;

  TExtDataStore = class(TExtDataAbstractStore)
  private
    FAutoDestroy : Boolean;
    FBuffered : Boolean;
    FClearOnPageLoad : Boolean;
    FClearRemovedOnLoad : Boolean;
    FCurrentPage : Integer;
    FData : TExtObjectList;
    FDataList : TExtObjectList;
    FGroupDir : String;
    FGroupers : TExtUtilMixedCollection;
    FGroupField : String;
    FLeadingBufferZone : Integer;
    FPageSize : Integer; // 25
    FProxy : String;
    FProxyObject : TExtObject;
    FProxyProxy : TExtDataProxy;
    FPurgePageCount : Integer;
    FRemoteFilter : Boolean;
    FRemoteGroup : Boolean;
    FRemoteSort : Boolean;
    FSnapshot : TExtUtilMixedCollection;
    FSortOnFilter : Boolean;
    FTrailingBufferZone : Integer;
    FOnBeforeprefetch : TExtDataStoreOnBeforeprefetch;
    FOnFilterchange : TExtDataStoreOnFilterchange;
    FOnGroupchange : TExtDataStoreOnGroupchange;
    FOnPrefetch : TExtDataStoreOnPrefetch;
    procedure SetFAutoDestroy(Value : Boolean);
    procedure SetFBuffered(Value : Boolean);
    procedure SetFClearOnPageLoad(Value : Boolean);
    procedure SetFClearRemovedOnLoad(Value : Boolean);
    procedure SetFCurrentPage(Value : Integer);
    procedure SetFData(Value : TExtObjectList);
    procedure SetFDataList(Value : TExtObjectList);
    procedure SetFGroupDir(Value : String);
    procedure SetFGroupers(Value : TExtUtilMixedCollection);
    procedure SetFGroupField(Value : String);
    procedure SetFLeadingBufferZone(Value : Integer);
    procedure SetFPageSize(Value : Integer);
    procedure SetFProxy(Value : String);
    procedure SetFProxyObject(Value : TExtObject);
    procedure SetFProxyProxy(Value : TExtDataProxy);
    procedure SetFPurgePageCount(Value : Integer);
    procedure SetFRemoteFilter(Value : Boolean);
    procedure SetFRemoteGroup(Value : Boolean);
    procedure SetFRemoteSort(Value : Boolean);
    procedure SetFSnapshot(Value : TExtUtilMixedCollection);
    procedure SetFSortOnFilter(Value : Boolean);
    procedure SetFTrailingBufferZone(Value : Integer);
    procedure SetFOnBeforeprefetch(Value : TExtDataStoreOnBeforeprefetch);
    procedure SetFOnFilterchange(Value : TExtDataStoreOnFilterchange);
    procedure SetFOnGroupchange(Value : TExtDataStoreOnGroupchange);
    procedure SetFOnPrefetch(Value : TExtDataStoreOnPrefetch);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Add(Model : TExtObjectList) : TExtFunction; overload;
    function Add(Model : TExtDataModel) : TExtFunction; overload;
    function AddFilter(Filters : TExtObjectList; ApplyFilters : Boolean = false) : TExtFunction; overload;
    function AddSorted(RecordJS : TExtDataRecord) : TExtFunction;
    function Aggregate(Fn : TExtFunction; Scope : TExtObject = nil; Grouped : Boolean = false; Args : TExtObjectList = nil) : TExtFunction;
    function Average(Field : String; Grouped : Boolean = false) : TExtFunction;
    function ClearFilter(SuppressEvent : Boolean = false) : TExtFunction;
    function ClearGrouping : TExtFunction;
    function Collect(DataIndex : String; AllowNull : Boolean = false; BypassFilter : Boolean = false) : TExtFunction;
    function CommitChanges : TExtFunction;
    function Count(Grouped : Boolean = false) : TExtFunction;
    constructor Create;
    function Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Filter(Filters : TExtObjectList; Value : String = '') : TExtFunction; overload;
    function Filter(Filters : String = ''; Value : String = '') : TExtFunction; overload;
    function FilterBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function Find(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function Find(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function FindBy(Fn : TExtFunction; Scope : TExtObject = nil; StartIndex : Integer = 0) : TExtFunction;
    function FindExact(FieldName : String; Value : TExtObject; StartIndex : Integer = 0) : TExtFunction;
    function FindRecord(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function FindRecord(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function First(Grouped : Boolean = false) : TExtFunction;
    function GetAt(Index : Integer) : TExtFunction;
    function GetById(Id : String) : TExtFunction;
    function GetCount : TExtFunction;
    function GetGroups(GroupName : String = '') : TExtFunction;
    function GetGroupString(Instance : TExtDataModel) : TExtFunction;
    function GetPageFromRecordIndex(Index : Integer) : TExtFunction;
    function GetRange(Start : Integer; EndJS : Integer; Options : TExtObject = nil) : TExtFunction;
    function GetTotalCount : TExtFunction;
    function Group(Groupers : TExtObjectList; Direction : String = '') : TExtFunction; overload;
    function Group(Groupers : String; Direction : String = '') : TExtFunction; overload;
    function IndexOf(RecordJS : TExtDataModel) : TExtFunction;
    function IndexOfId(Id : String) : TExtFunction;
    function IndexOfTotal(RecordJS : TExtDataModel) : TExtFunction;
    function Insert(Index : Integer; Records : TExtObjectList) : TExtFunction;
    function IsFiltered : TExtFunction;
    function IsGrouped : TExtFunction;
    function Last(Grouped : Boolean = false) : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction; overload;
    function Load(Options : TExtFunction = nil) : TExtFunction; overload;
    function LoadData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; overload;
    function LoadPage(Page : Integer; Options : TExtObject = nil) : TExtFunction;
    function LoadRawData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction;
    function LoadRecords(Records : TExtObjectList; Options : TExtObject) : TExtFunction;
    function Max(Field : String; Grouped : Boolean = false) : TExtFunction;
    function Min(Field : String; Grouped : Boolean = false) : TExtFunction;
    function NextPage(Options : TExtObject) : TExtFunction;
    function Prefetch(Options : TExtObject = nil) : TExtFunction;
    function PrefetchPage(Page : Integer; Options : TExtObject = nil) : TExtFunction;
    function PrefetchRange : TExtFunction;
    function PreviousPage(Options : TExtObject) : TExtFunction;
    function Query(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function Query(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; overload;
    function QueryBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RejectChanges : TExtFunction;
    function Remove(Records : TExtObjectList) : TExtFunction; overload;
    function Remove(Records : TExtDataModel) : TExtFunction; overload;
    function Remove(Records : TArrayOfInteger) : TExtFunction; overload;
    function Remove(Records : Integer) : TExtFunction; overload;
    function RemoveAll(Silent : Boolean = false) : TExtFunction;
    function RemoveAt(Index : Integer; Count : Integer = 0) : TExtFunction;
    function RemoveFilter(ToRemove : String; ApplyFilters : Boolean = false) : TExtFunction;
    function Sum(Field : String; Grouped : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property AutoDestroy : Boolean read FAutoDestroy write SetFAutoDestroy;
    property Buffered : Boolean read FBuffered write SetFBuffered;
    property ClearOnPageLoad : Boolean read FClearOnPageLoad write SetFClearOnPageLoad;
    property ClearRemovedOnLoad : Boolean read FClearRemovedOnLoad write SetFClearRemovedOnLoad;
    property CurrentPage : Integer read FCurrentPage write SetFCurrentPage;
    property Data : TExtObjectList read FData write SetFData;
    property DataList : TExtObjectList read FDataList write SetFDataList;
    property GroupDir : String read FGroupDir write SetFGroupDir;
    property Groupers : TExtUtilMixedCollection read FGroupers write SetFGroupers;
    property GroupField : String read FGroupField write SetFGroupField;
    property LeadingBufferZone : Integer read FLeadingBufferZone write SetFLeadingBufferZone;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property Proxy : String read FProxy write SetFProxy;
    property ProxyObject : TExtObject read FProxyObject write SetFProxyObject;
    property ProxyProxy : TExtDataProxy read FProxyProxy write SetFProxyProxy;
    property PurgePageCount : Integer read FPurgePageCount write SetFPurgePageCount;
    property RemoteFilter : Boolean read FRemoteFilter write SetFRemoteFilter;
    property RemoteGroup : Boolean read FRemoteGroup write SetFRemoteGroup;
    property RemoteSort : Boolean read FRemoteSort write SetFRemoteSort;
    property Snapshot : TExtUtilMixedCollection read FSnapshot write SetFSnapshot;
    property SortOnFilter : Boolean read FSortOnFilter write SetFSortOnFilter;
    property TrailingBufferZone : Integer read FTrailingBufferZone write SetFTrailingBufferZone;
    property OnBeforeprefetch : TExtDataStoreOnBeforeprefetch read FOnBeforeprefetch write SetFOnBeforeprefetch;
    property OnFilterchange : TExtDataStoreOnFilterchange read FOnFilterchange write SetFOnFilterchange;
    property OnGroupchange : TExtDataStoreOnGroupchange read FOnGroupchange write SetFOnGroupchange;
    property OnPrefetch : TExtDataStoreOnPrefetch read FOnPrefetch write SetFOnPrefetch;
  end;

  TExtAppDomainControllerSingleton = class(TExtAppEventDomain)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtAppDomainDirectSingleton = class(TExtAppEventDomain)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilGrouper = class(TExtUtilSorter)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetGroupString(Instance : TExtDataModel) : TExtFunction;
  end;

  TExtAppDomainComponentSingleton = class(TExtAppEventDomain)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtUtilComponentDragger = class(TExtDdDragTracker)
  private
    FConstrain : Boolean;
    FConstrainDelegate : Boolean;
    FDelegate : String;
    FDelegateElement : TExtElement;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFConstrainDelegate(Value : Boolean);
    procedure SetFDelegate(Value : String);
    procedure SetFDelegateElement(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Comp : TExtObject; Config : TExtObject = nil);
    destructor Destroy; override;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property ConstrainDelegate : Boolean read FConstrainDelegate write SetFConstrainDelegate;
    property Delegate : String read FDelegate write SetFDelegate;
    property DelegateElement : TExtElement read FDelegateElement write SetFDelegateElement;
  end;

  TExtXTemplateCompiler = class(TExtXTemplateParser)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtUtilClickRepeater
  TExtUtilClickRepeaterOnClick = procedure(This : TExtUtilClickRepeater; E : TExtEventObject) of object;
  TExtUtilClickRepeaterOnMousedown = procedure(This : TExtUtilClickRepeater; E : TExtEventObject) of object;
  TExtUtilClickRepeaterOnMouseup = procedure(This : TExtUtilClickRepeater; E : TExtEventObject) of object;

  TExtUtilClickRepeater = class(TExtUtilObservable)
  private
    FAccelerate : Boolean;
    FDelay : Integer;
    FEl : String;
    FElElement : TExtElement;
    FElTHTMLElement : THTMLElement;
    FInterval : Integer;
    FPressedCls : String;
    FPreventDefault : Boolean;
    FStopDefault : Boolean;
    FOnClick : TExtUtilClickRepeaterOnClick;
    FOnMousedown : TExtUtilClickRepeaterOnMousedown;
    FOnMouseup : TExtUtilClickRepeaterOnMouseup;
    procedure SetFAccelerate(Value : Boolean);
    procedure SetFDelay(Value : Integer);
    procedure SetFEl(Value : String);
    procedure SetFElElement(Value : TExtElement);
    procedure SetFElTHTMLElement(Value : THTMLElement);
    procedure SetFInterval(Value : Integer);
    procedure SetFPressedCls(Value : String);
    procedure SetFPreventDefault(Value : Boolean);
    procedure SetFStopDefault(Value : Boolean);
    procedure SetFOnClick(Value : TExtUtilClickRepeaterOnClick);
    procedure SetFOnMousedown(Value : TExtUtilClickRepeaterOnMousedown);
    procedure SetFOnMouseup(Value : TExtUtilClickRepeaterOnMouseup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(El : THTMLElement; Config : TExtObject = nil); overload;
    constructor Create(El : TExtElement; Config : TExtObject = nil); overload;
    constructor Create(El : String; Config : TExtObject = nil); overload;
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    function SetDisabled(Disabled : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Accelerate : Boolean read FAccelerate write SetFAccelerate;
    property Delay : Integer read FDelay write SetFDelay;
    property El : String read FEl write SetFEl;
    property ElElement : TExtElement read FElElement write SetFElElement;
    property ElTHTMLElement : THTMLElement read FElTHTMLElement write SetFElTHTMLElement;
    property Interval : Integer read FInterval write SetFInterval;
    property PressedCls : String read FPressedCls write SetFPressedCls;
    property PreventDefault : Boolean read FPreventDefault write SetFPreventDefault;
    property StopDefault : Boolean read FStopDefault write SetFStopDefault;
    property OnClick : TExtUtilClickRepeaterOnClick read FOnClick write SetFOnClick;
    property OnMousedown : TExtUtilClickRepeaterOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseup : TExtUtilClickRepeaterOnMouseup read FOnMouseup write SetFOnMouseup;
  end;

  TExtDataReaderJson = class(TExtDataReader)
  private
    FMetaProperty : String;
    FRecordJS : String;
    FUseSimpleAccessors : Boolean;
    procedure SetFMetaProperty(Value : String);
    procedure SetFRecordJS(Value : String);
    procedure SetFUseSimpleAccessors(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ReadRecords(Data : TExtObject) : TExtFunction;
    property MetaProperty : String read FMetaProperty write SetFMetaProperty;
    property RecordJS : String read FRecordJS write SetFRecordJS;
    property UseSimpleAccessors : Boolean read FUseSimpleAccessors write SetFUseSimpleAccessors;
  end;

  TExtStateCookieProvider = class(TExtStateProvider)
  private
    FDomain : String; // 'www'
    FExpires : TDateTime;
    FPath : String; // '/'
    FSecure : Boolean;
    procedure SetFDomain(Value : String);
    procedure SetFExpires(Value : TDateTime);
    procedure SetFPath(Value : String);
    procedure SetFSecure(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    property Domain : String read FDomain write SetFDomain;
    property Expires : TDateTime read FExpires write SetFExpires;
    property Path : String read FPath write SetFPath;
    property Secure : Boolean read FSecure write SetFSecure;
  end;

  TExtUtilMixedCollection = class(TExtUtilAbstractMixedCollection)
  private
    FAllowFunctions : Boolean;
    FDefaultSortDirection : String;
    FIsSortable : Boolean;
    FSorters : TExtObjectList;
    FSortersList : TExtObjectList;
    FSortRoot : String;
    procedure SetFAllowFunctions(Value : Boolean);
    procedure SetFDefaultSortDirection(Value : String);
    procedure SetFIsSortable(Value : Boolean);
    procedure SetFSorters(Value : TExtObjectList);
    procedure SetFSortersList(Value : TExtObjectList);
    procedure SetFSortRoot(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Config : TExtObject);
    function CreateComparator(Sorters : TExtObjectList) : TExtFunction;
    function FindInsertionIndex(NewItem : TExtObject; SorterFn : TExtFunction = nil) : TExtFunction;
    function GenerateComparator : TExtFunction;
    function InitSortable : TExtFunction;
    function Reorder(Mapping : TExtObject) : TExtFunction;
    function Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; overload;
    function Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; overload;
    function SortBy(SorterFn : TExtFunction) : TExtFunction;
    function SortByKey(Direction : String = ''; Fn : TExtFunction = nil) : TExtFunction;
    property AllowFunctions : Boolean read FAllowFunctions write SetFAllowFunctions;
    property DefaultSortDirection : String read FDefaultSortDirection write SetFDefaultSortDirection;
    property IsSortable : Boolean read FIsSortable write SetFIsSortable;
    property Sorters : TExtObjectList read FSorters write SetFSorters;
    property SortersList : TExtObjectList read FSortersList write SetFSortersList;
    property SortRoot : String read FSortRoot write SetFSortRoot;
  end;

  // Procedural types for events TExtDataProxyServer
  TExtDataProxyServerOnException = procedure(This : TExtDataProxyServer; Response : TExtObject; Operation : TExtDataOperation) of object;

  TExtDataProxyServer = class(TExtDataProxy)
  private
    FApi : TExtObject;
    FCacheString : String; // '_dc'
    FDirectionParam : String;
    FExtraParams : TExtObject;
    FFilterParam : String; // 'filter'
    FGroupDirectionParam : String;
    FGroupParam : String; // 'group'
    FIdParam : String;
    FLimitParam : String; // 'limit'
    FNoCache : Boolean; // true
    FPageParam : String; // 'page'
    FSimpleGroupMode : Boolean;
    FSimpleSortMode : Boolean;
    FSortParam : String; // 'sort'
    FStartParam : String; // 'start'
    FTimeout : Integer; // 30000
    FUrl : String;
    FOnException : TExtDataProxyServerOnException;
    procedure SetFApi(Value : TExtObject);
    procedure SetFCacheString(Value : String);
    procedure SetFDirectionParam(Value : String);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFFilterParam(Value : String);
    procedure SetFGroupDirectionParam(Value : String);
    procedure SetFGroupParam(Value : String);
    procedure SetFIdParam(Value : String);
    procedure SetFLimitParam(Value : String);
    procedure SetFNoCache(Value : Boolean);
    procedure SetFPageParam(Value : String);
    procedure SetFSimpleGroupMode(Value : Boolean);
    procedure SetFSimpleSortMode(Value : Boolean);
    procedure SetFSortParam(Value : String);
    procedure SetFStartParam(Value : String);
    procedure SetFTimeout(Value : Integer);
    procedure SetFUrl(Value : String);
    procedure SetFOnException(Value : TExtDataProxyServerOnException);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BuildRequest(Operation : TExtDataOperation) : TExtFunction;
    function BuildUrl(Request : TExtDataRequest) : TExtFunction;
    constructor Create;
    function DoRequest(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    function EncodeFilters(Filters : TExtObjectList) : TExtFunction;
    function EncodeSorters(Sorters : TExtObjectList) : TExtFunction;
    function SetExtraParam(Name : String; Value : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Api : TExtObject read FApi write SetFApi;
    property CacheString : String read FCacheString write SetFCacheString;
    property DirectionParam : String read FDirectionParam write SetFDirectionParam;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property FilterParam : String read FFilterParam write SetFFilterParam;
    property GroupDirectionParam : String read FGroupDirectionParam write SetFGroupDirectionParam;
    property GroupParam : String read FGroupParam write SetFGroupParam;
    property IdParam : String read FIdParam write SetFIdParam;
    property LimitParam : String read FLimitParam write SetFLimitParam;
    property NoCache : Boolean read FNoCache write SetFNoCache;
    property PageParam : String read FPageParam write SetFPageParam;
    property SimpleGroupMode : Boolean read FSimpleGroupMode write SetFSimpleGroupMode;
    property SimpleSortMode : Boolean read FSimpleSortMode write SetFSimpleSortMode;
    property SortParam : String read FSortParam write SetFSortParam;
    property StartParam : String read FStartParam write SetFStartParam;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Url : String read FUrl write SetFUrl;
    property OnException : TExtDataProxyServerOnException read FOnException write SetFOnException;
  end;

  TExtFxTargetElement = class(TExtFxTarget)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtStateLocalStorageProvider = class(TExtStateProvider)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetSprite = class(TExtFxTarget)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridFeature = class(TExtUtilObservable)
  private
    FIsFeature : Boolean;
    procedure SetFIsFeature(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Disable : TExtFunction;
    function Enable : TExtFunction;
    property IsFeature : Boolean read FIsFeature write SetFIsFeature;
  end;

  // Procedural types for events TExtSelectionModel
  TExtSelectionModelOnFocuschange = procedure(This : TExtSelectionModel; OldFocused : TExtDataModel; NewFocused : TExtDataModel) of object;
  TExtSelectionModelOnSelectionchange = procedure(This : TExtSelectionModel; Selected : TExtObjectList) of object;

  // Enumerated types for properties
  TModeEnum = (moSINGLE, moSIMPLE, moMULTI);

  TExtSelectionModel = class(TExtUtilObservable)
  private
    FAllowDeselect : Boolean;
    FMode : TModeEnum;
    FPruneRemoved : Boolean;
    FSelected : TExtUtilMixedCollection;
    FOnFocuschange : TExtSelectionModelOnFocuschange;
    FOnSelectionchange : TExtSelectionModelOnSelectionchange;
    procedure SetFAllowDeselect(Value : Boolean);
    procedure SetFMode(Value : TModeEnum);
    procedure SetFPruneRemoved(Value : Boolean);
    procedure SetFSelected(Value : TExtUtilMixedCollection);
    procedure SetFOnFocuschange(Value : TExtSelectionModelOnFocuschange);
    procedure SetFOnSelectionchange(Value : TExtSelectionModelOnSelectionchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    constructor Create;
    function Deselect(Records : TExtObjectList; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function Deselect(Records : Integer; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function DeselectAll(SuppressEvent : Boolean = false) : TExtFunction;
    function DeselectRange(StartRow : Integer; EndRow : TExtDataModel) : TExtFunction; overload;
    function DeselectRange(StartRow : TExtDataModel; EndRow : TExtDataModel) : TExtFunction; overload;
    function DeselectRange(StartRow : TExtDataModel; EndRow : Integer) : TExtFunction; overload;
    function DeselectRange(StartRow : Integer; EndRow : Integer) : TExtFunction; overload;
    function GetCount : TExtFunction;
    function GetLastSelected : TExtFunction;
    function GetSelection : TExtFunction;
    function GetSelectionMode : TExtFunction;
    function GetStore : TExtFunction;
    function HasSelection : TExtFunction;
    function IsFocused(RecordJS : TExtDataModel) : TExtFunction;
    function IsLocked : TExtFunction;
    function IsRangeSelected(From : Integer; ToJS : TExtDataModel) : TExtFunction; overload;
    function IsRangeSelected(From : TExtDataModel; ToJS : TExtDataModel) : TExtFunction; overload;
    function IsRangeSelected(From : TExtDataModel; ToJS : Integer) : TExtFunction; overload;
    function IsRangeSelected(From : Integer; ToJS : Integer) : TExtFunction; overload;
    function IsSelected(RecordJS : TExtDataModel) : TExtFunction; overload;
    function IsSelected(RecordJS : Integer) : TExtFunction; overload;
    function Select(Records : TExtObjectList; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function Select(Records : Integer; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; overload;
    function SelectAll(SuppressEvent : Boolean) : TExtFunction;
    function SelectRange(StartRow : Integer; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : TExtDataModel; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : TExtDataModel; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SelectRange(StartRow : Integer; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; overload;
    function SetLastFocused(RecordJS : TExtDataModel) : TExtFunction;
    function SetLocked(Locked : Boolean) : TExtFunction;
    function SetSelectionMode(SelMode : String) : TExtFunction;
    destructor Destroy; override;
    property AllowDeselect : Boolean read FAllowDeselect write SetFAllowDeselect;
    property Mode : TModeEnum read FMode write SetFMode;
    property PruneRemoved : Boolean read FPruneRemoved write SetFPruneRemoved;
    property Selected : TExtUtilMixedCollection read FSelected write SetFSelected;
    property OnFocuschange : TExtSelectionModelOnFocuschange read FOnFocuschange write SetFOnFocuschange;
    property OnSelectionchange : TExtSelectionModelOnSelectionchange read FOnSelectionchange write SetFOnSelectionchange;
  end;

  TExtGridFeatureGroupStore = class(TExtUtilObservable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartAxisGauge = class(TExtChartAxisAbstract)
  private
    FMargin : Integer;
    FMaximum : Integer;
    FMinimum : Integer;
    FSteps : Integer;
    FTitle : String;
    procedure SetFMargin(Value : Integer);
    procedure SetFMaximum(Value : Integer);
    procedure SetFMinimum(Value : Integer);
    procedure SetFSteps(Value : Integer);
    procedure SetFTitle(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetTitle(Title : String) : TExtFunction;
    property Margin : Integer read FMargin write SetFMargin;
    property Maximum : Integer read FMaximum write SetFMaximum;
    property Minimum : Integer read FMinimum write SetFMinimum;
    property Steps : Integer read FSteps write SetFSteps;
    property Title : String read FTitle write SetFTitle;
  end;

  TExtViewBoundListKeyNav = class(TExtUtilKeyNav)
  private
    FBoundList : TExtViewBoundList;
    procedure SetFBoundList(Value : TExtViewBoundList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function HighlightAt(Index : Integer) : TExtFunction;
    function SelectHighlighted : TExtFunction;
    destructor Destroy; override;
    property BoundList : TExtViewBoundList read FBoundList write SetFBoundList;
  end;

  // Procedural types for events TExtViewAbstractView
  TExtViewAbstractViewOnBeforerefresh = procedure(This : TExtViewAbstractView) of object;
  TExtViewAbstractViewOnItemadd = procedure(Records : TExtObjectList; Index : Integer; Node : TExtObjectList) of object;
  TExtViewAbstractViewOnItemremove = procedure(RecordJS : TExtDataModel; Index : Integer) of object;
  TExtViewAbstractViewOnItemupdate = procedure(RecordJS : TExtDataModel; Index : Integer; Node : THTMLElement) of object;
  TExtViewAbstractViewOnRefresh = procedure(This : TExtViewAbstractView) of object;
  TExtViewAbstractViewOnViewready = procedure(This : TExtViewAbstractView) of object;

  TExtViewAbstractView = class(TExtComponent)
  private
    FBlockRefresh : Boolean;
    FDeferEmptyText : Boolean;
    FDeferInitialRefresh : Boolean; // true
    FDisableSelection : Boolean;
    FEmptyText : String;
    FItemCls : String;
    FItemSelector : String;
    FItemTpl : String;
    FItemTplTArrayOfString : TArrayOfString;
    FItemTplTemplate : TExtXTemplate;
    FLoadingCls : String;
    FLoadingHeight : Integer;
    FLoadingText : String;
    FLoadMask : Boolean;
    FLoadMaskObject : TExtObject;
    FOverItemCls : String;
    FPreserveScrollOnRefresh : Boolean;
    FSelectedItemCls : String;
    FSingleSelect : Boolean;
    FStore : TExtDataStore;
    FTpl : String;
    FTplTArrayOfString : TArrayOfString;
    FTplTemplate : TExtXTemplate;
    FTrackOver : Boolean;
    FOnBeforerefresh : TExtViewAbstractViewOnBeforerefresh;
    FOnItemadd : TExtViewAbstractViewOnItemadd;
    FOnItemremove : TExtViewAbstractViewOnItemremove;
    FOnItemupdate : TExtViewAbstractViewOnItemupdate;
    FOnRefresh : TExtViewAbstractViewOnRefresh;
    FOnViewready : TExtViewAbstractViewOnViewready;
    procedure SetFBlockRefresh(Value : Boolean);
    procedure SetFDeferEmptyText(Value : Boolean);
    procedure SetFDeferInitialRefresh(Value : Boolean);
    procedure SetFDisableSelection(Value : Boolean);
    procedure SetFEmptyText(Value : String);
    procedure SetFItemCls(Value : String);
    procedure SetFItemSelector(Value : String);
    procedure SetFItemTpl(Value : String);
    procedure SetFItemTplTArrayOfString(Value : TArrayOfString);
    procedure SetFItemTplTemplate(Value : TExtXTemplate);
    procedure SetFLoadingCls(Value : String);
    procedure SetFLoadingHeight(Value : Integer);
    procedure SetFLoadingText(Value : String);
    procedure SetFLoadMask(Value : Boolean);
    procedure SetFLoadMaskObject(Value : TExtObject);
    procedure SetFOverItemCls(Value : String);
    procedure SetFPreserveScrollOnRefresh(Value : Boolean);
    procedure SetFSelectedItemCls(Value : String);
    procedure SetFSingleSelect(Value : Boolean);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFTpl(Value : String);
    procedure SetFTplTArrayOfString(Value : TArrayOfString);
    procedure SetFTplTemplate(Value : TExtXTemplate);
    procedure SetFTrackOver(Value : Boolean);
    procedure SetFOnBeforerefresh(Value : TExtViewAbstractViewOnBeforerefresh);
    procedure SetFOnItemadd(Value : TExtViewAbstractViewOnItemadd);
    procedure SetFOnItemremove(Value : TExtViewAbstractViewOnItemremove);
    procedure SetFOnItemupdate(Value : TExtViewAbstractViewOnItemupdate);
    procedure SetFOnRefresh(Value : TExtViewAbstractViewOnRefresh);
    procedure SetFOnViewready(Value : TExtViewAbstractViewOnViewready);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    function BindStore(Store : TExtDataStore) : TExtFunction; overload;
    function CollectData(Records : TExtObjectList; StartIndex : Integer) : TExtFunction;
    constructor Create;
    function Deselect(Records : TExtObjectList; SuppressEvent : Boolean) : TExtFunction; overload;
    function Deselect(Records : Integer; SuppressEvent : Boolean) : TExtFunction; overload;
    function FindItemByChild(Node : THTMLElement) : TExtFunction;
    function FindTargetByEvent(E : TExtEventObject) : TExtFunction;
    function GetNode(NodeInfo : THTMLElement) : TExtFunction; overload;
    function GetNode(NodeInfo : TExtDataModel) : TExtFunction; overload;
    function GetNode(NodeInfo : String) : TExtFunction; overload;
    function GetNode(NodeInfo : Integer) : TExtFunction; overload;
    function GetNodes(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    function GetRecord(Node : THTMLElement) : TExtFunction; overload;
    function GetRecord(Node : TExtElement) : TExtFunction; overload;
    function GetRecords(Nodes : TExtObjectList) : TExtFunction;
    function GetSelectedNodes : TExtFunction;
    function GetSelectionModel : TExtFunction;
    function GetStore : TExtFunction;
    function IndexOf(NodeInfo : THTMLElement) : TExtFunction; overload;
    function IndexOf(NodeInfo : TExtDataModel) : TExtFunction; overload;
    function IndexOf(NodeInfo : String) : TExtFunction; overload;
    function IndexOf(NodeInfo : Integer) : TExtFunction; overload;
    function IsSelected(Node : THTMLElement) : TExtFunction; overload;
    function IsSelected(Node : TExtDataModel) : TExtFunction; overload;
    function IsSelected(Node : Integer) : TExtFunction; overload;
    function PrepareData(Data : TExtObjectList; RecordIndex : Integer; RecordJS : TExtDataModel) : TExtFunction; overload;
    function PrepareData(Data : TExtObject; RecordIndex : Integer; RecordJS : TExtDataModel) : TExtFunction; overload;
    function Refresh : TExtFunction;
    function RefreshNode(Index : Integer) : TExtFunction;
    destructor Destroy; override;
    property BlockRefresh : Boolean read FBlockRefresh write SetFBlockRefresh;
    property DeferEmptyText : Boolean read FDeferEmptyText write SetFDeferEmptyText;
    property DeferInitialRefresh : Boolean read FDeferInitialRefresh write SetFDeferInitialRefresh;
    property DisableSelection : Boolean read FDisableSelection write SetFDisableSelection;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property ItemCls : String read FItemCls write SetFItemCls;
    property ItemSelector : String read FItemSelector write SetFItemSelector;
    property ItemTpl : String read FItemTpl write SetFItemTpl;
    property ItemTplTArrayOfString : TArrayOfString read FItemTplTArrayOfString write SetFItemTplTArrayOfString;
    property ItemTplTemplate : TExtXTemplate read FItemTplTemplate write SetFItemTplTemplate;
    property LoadingCls : String read FLoadingCls write SetFLoadingCls;
    property LoadingHeight : Integer read FLoadingHeight write SetFLoadingHeight;
    property LoadingText : String read FLoadingText write SetFLoadingText;
    property LoadMask : Boolean read FLoadMask write SetFLoadMask;
    property LoadMaskObject : TExtObject read FLoadMaskObject write SetFLoadMaskObject;
    property OverItemCls : String read FOverItemCls write SetFOverItemCls;
    property PreserveScrollOnRefresh : Boolean read FPreserveScrollOnRefresh write SetFPreserveScrollOnRefresh;
    property SelectedItemCls : String read FSelectedItemCls write SetFSelectedItemCls;
    property SingleSelect : Boolean read FSingleSelect write SetFSingleSelect;
    property Store : TExtDataStore read FStore write SetFStore;
    property Tpl : String read FTpl write SetFTpl;
    property TplTArrayOfString : TArrayOfString read FTplTArrayOfString write SetFTplTArrayOfString;
    property TplTemplate : TExtXTemplate read FTplTemplate write SetFTplTemplate;
    property TrackOver : Boolean read FTrackOver write SetFTrackOver;
    property OnBeforerefresh : TExtViewAbstractViewOnBeforerefresh read FOnBeforerefresh write SetFOnBeforerefresh;
    property OnItemadd : TExtViewAbstractViewOnItemadd read FOnItemadd write SetFOnItemadd;
    property OnItemremove : TExtViewAbstractViewOnItemremove read FOnItemremove write SetFOnItemremove;
    property OnItemupdate : TExtViewAbstractViewOnItemupdate read FOnItemupdate write SetFOnItemupdate;
    property OnRefresh : TExtViewAbstractViewOnRefresh read FOnRefresh write SetFOnRefresh;
    property OnViewready : TExtViewAbstractViewOnViewready read FOnViewready write SetFOnViewready;
  end;

  TExtFxTargetComponent = class(TExtFxTarget)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartAxis = class(TExtChartAxisAbstract)
  private
    FAdjustEnd : Boolean;
    FDashSize : Integer;
    FGrid : Boolean;
    FGridObject : TExtObject;
    FLength : Integer;
    FMajorTickSteps : Integer;
    FMinorTickSteps : Integer;
    FPosition : String;
    FTitle : String;
    FWidth : Integer;
    procedure SetFAdjustEnd(Value : Boolean);
    procedure SetFDashSize(Value : Integer);
    procedure SetFGrid(Value : Boolean);
    procedure SetFGridObject(Value : TExtObject);
    procedure SetFLength(Value : Integer);
    procedure SetFMajorTickSteps(Value : Integer);
    procedure SetFMinorTickSteps(Value : Integer);
    procedure SetFPosition(Value : String);
    procedure SetFTitle(Value : String);
    procedure SetFWidth(Value : Integer);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawAxis : TExtFunction;
    function DrawGrid : TExtFunction;
    function DrawLabel : TExtFunction;
    function SetTitle(Title : String) : TExtFunction;
    destructor Destroy; override;
    property AdjustEnd : Boolean read FAdjustEnd write SetFAdjustEnd;
    property DashSize : Integer read FDashSize write SetFDashSize;
    property Grid : Boolean read FGrid write SetFGrid;
    property GridObject : TExtObject read FGridObject write SetFGridObject;
    property Length : Integer read FLength write SetFLength;
    property MajorTickSteps : Integer read FMajorTickSteps write SetFMajorTickSteps;
    property MinorTickSteps : Integer read FMinorTickSteps write SetFMinorTickSteps;
    property Position : String read FPosition write SetFPosition;
    property Title : String read FTitle write SetFTitle;
    property Width : Integer read FWidth write SetFWidth;
  end;

  TExtDataDirectStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtMenuSeparator = class(TExtMenuItem)
  private
    FSeparatorCls : String;
    procedure SetFSeparatorCls(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property SeparatorCls : String read FSeparatorCls write SetFSeparatorCls;
  end;

  // Procedural types for events TExtSelectionRowModel
  TExtSelectionRowModelOnBeforedeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnBeforeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnDeselect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;
  TExtSelectionRowModelOnSelect = procedure(This : TExtSelectionRowModel; RecordJS : TExtDataModel; Index : Integer) of object;

  TExtSelectionRowModel = class(TExtSelectionModel)
  private
    FEnableKeyNav : Boolean;
    FIgnoreRightMouseSelection : Boolean;
    FOnBeforedeselect : TExtSelectionRowModelOnBeforedeselect;
    FOnBeforeselect : TExtSelectionRowModelOnBeforeselect;
    FOnDeselect : TExtSelectionRowModelOnDeselect;
    FOnSelect : TExtSelectionRowModelOnSelect;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFIgnoreRightMouseSelection(Value : Boolean);
    procedure SetFOnBeforedeselect(Value : TExtSelectionRowModelOnBeforedeselect);
    procedure SetFOnBeforeselect(Value : TExtSelectionRowModelOnBeforeselect);
    procedure SetFOnDeselect(Value : TExtSelectionRowModelOnDeselect);
    procedure SetFOnSelect(Value : TExtSelectionRowModelOnSelect);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCurrentPosition : TExtFunction;
    function SelectNext(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    function SelectPrevious(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property IgnoreRightMouseSelection : Boolean read FIgnoreRightMouseSelection write SetFIgnoreRightMouseSelection;
    property OnBeforedeselect : TExtSelectionRowModelOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforeselect : TExtSelectionRowModelOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnDeselect : TExtSelectionRowModelOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnSelect : TExtSelectionRowModelOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtChartSeriesArea = class(TExtChartSeriesCartesian)
  private
    FStyle : TExtObject;
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function GetLegendColor(Item : TExtObject) : TExtFunction;
    function HighlightItem(Info : TExtObject) : TExtFunction;
    function HighlightSeries(Item : TExtObject) : TExtFunction;
    function UnHighlightItem(Item : TExtObject) : TExtFunction;
    function UnHighlightSeries(Item : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtDataXmlStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtDirectPollingProvider
  TExtDirectPollingProviderOnBeforepoll = procedure(This : TExtDirectPollingProvider) of object;
  TExtDirectPollingProviderOnPoll = procedure(This : TExtDirectPollingProvider) of object;

  TExtDirectPollingProvider = class(TExtDirectJsonProvider)
  private
    FBaseParams : TExtObject;
    FInterval : Integer; // 3
    FUrl : String;
    FUrlFunction : TExtFunction;
    FOnBeforepoll : TExtDirectPollingProviderOnBeforepoll;
    FOnPoll : TExtDirectPollingProviderOnPoll;
    procedure SetFBaseParams(Value : TExtObject);
    procedure SetFInterval(Value : Integer);
    procedure SetFUrl(Value : String);
    procedure SetFUrlFunction(Value : TExtFunction);
    procedure SetFOnBeforepoll(Value : TExtDirectPollingProviderOnBeforepoll);
    procedure SetFOnPoll(Value : TExtDirectPollingProviderOnPoll);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Connect : TExtFunction;
    constructor Create;
    function Disconnect : TExtFunction;
    function IsConnected : TExtFunction;
    destructor Destroy; override;
    property BaseParams : TExtObject read FBaseParams write SetFBaseParams;
    property Interval : Integer read FInterval write SetFInterval;
    property Url : String read FUrl write SetFUrl;
    property UrlFunction : TExtFunction read FUrlFunction write SetFUrlFunction;
    property OnBeforepoll : TExtDirectPollingProviderOnBeforepoll read FOnBeforepoll write SetFOnBeforepoll;
    property OnPoll : TExtDirectPollingProviderOnPoll read FOnPoll write SetFOnPoll;
  end;

  TExtDataBufferStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtSelectionDataViewModel
  TExtSelectionDataViewModelOnBeforedeselect = procedure(This : TExtSelectionDataViewModel; RecordJS : TExtDataModel) of object;
  TExtSelectionDataViewModelOnBeforeselect = procedure(This : TExtSelectionDataViewModel; RecordJS : TExtDataModel) of object;
  TExtSelectionDataViewModelOnDeselect = procedure(This : TExtSelectionDataViewModel; RecordJS : TExtDataModel) of object;
  TExtSelectionDataViewModelOnSelect = procedure(This : TExtSelectionDataViewModel; RecordJS : TExtDataModel) of object;

  TExtSelectionDataViewModel = class(TExtSelectionModel)
  private
    FEnableKeyNav : Boolean;
    FOnBeforedeselect : TExtSelectionDataViewModelOnBeforedeselect;
    FOnBeforeselect : TExtSelectionDataViewModelOnBeforeselect;
    FOnDeselect : TExtSelectionDataViewModelOnDeselect;
    FOnSelect : TExtSelectionDataViewModelOnSelect;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFOnBeforedeselect(Value : TExtSelectionDataViewModelOnBeforedeselect);
    procedure SetFOnBeforeselect(Value : TExtSelectionDataViewModelOnBeforeselect);
    procedure SetFOnDeselect(Value : TExtSelectionDataViewModelOnDeselect);
    procedure SetFOnSelect(Value : TExtSelectionDataViewModelOnSelect);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property OnBeforedeselect : TExtSelectionDataViewModelOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforeselect : TExtSelectionDataViewModelOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnDeselect : TExtSelectionDataViewModelOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnSelect : TExtSelectionDataViewModelOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtChartTipSurface = class(TExtDrawComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDirectExceptionEvent = class(TExtDirectRemotingEvent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtSelectionCellModel
  TExtSelectionCellModelOnDeselect = procedure(This : TExtSelectionCellModel; RecordJS : TExtDataModel; Row : Integer; Column : Integer) of object;
  TExtSelectionCellModelOnSelect = procedure(This : TExtSelectionCellModel; RecordJS : TExtDataModel; Row : Integer; Column : Integer) of object;

  TExtSelectionCellModel = class(TExtSelectionModel)
  private
    FEnableKeyNav : Boolean;
    FMode : TModeEnum;
    FPreventWrap : Boolean;
    FOnDeselect : TExtSelectionCellModelOnDeselect;
    FOnSelect : TExtSelectionCellModelOnSelect;
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFMode(Value : TModeEnum);
    procedure SetFPreventWrap(Value : Boolean);
    procedure SetFOnDeselect(Value : TExtSelectionCellModelOnDeselect);
    procedure SetFOnSelect(Value : TExtSelectionCellModelOnSelect);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetCurrentPosition : TExtFunction;
    function SetCurrentPosition(Position : TExtObject) : TExtFunction;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property Mode : TModeEnum read FMode write SetFMode;
    property PreventWrap : Boolean read FPreventWrap write SetFPreventWrap;
    property OnDeselect : TExtSelectionCellModelOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnSelect : TExtSelectionCellModelOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtTab
  TExtTabOnActivate = procedure(This : TExtTab) of object;
  TExtTabOnBeforeclose = procedure(Tab : TExtTab) of object;
  TExtTabOnClose = procedure(Tab : TExtTab) of object;
  TExtTabOnDeactivate = procedure(This : TExtTab) of object;

  TExtTab = class(TExtButton)
  private
    FActive : Boolean;
    FActiveCls : String;
    FClosable : Boolean;
    FClosableCls : String;
    FCloseText : String;
    FDisabledCls : String;
    FIsTab : Boolean;
    FOnActivate : TExtTabOnActivate;
    FOnBeforeclose : TExtTabOnBeforeclose;
    FOnClose : TExtTabOnClose;
    FOnDeactivate : TExtTabOnDeactivate;
    procedure SetFActive(Value : Boolean);
    procedure SetFActiveCls(Value : String);
    procedure SetFClosable(Value : Boolean);
    procedure SetFClosableCls(Value : String);
    procedure SetFCloseText(Value : String);
    procedure SetFDisabledCls(Value : String);
    procedure SetFIsTab(Value : Boolean);
    procedure SetFOnActivate(Value : TExtTabOnActivate);
    procedure SetFOnBeforeclose(Value : TExtTabOnBeforeclose);
    procedure SetFOnClose(Value : TExtTabOnClose);
    procedure SetFOnDeactivate(Value : TExtTabOnDeactivate);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetCard(Card : TExtComponent) : TExtFunction;
    function SetClosable(Closable : Boolean) : TExtFunction;
    property Active : Boolean read FActive write SetFActive;
    property ActiveCls : String read FActiveCls write SetFActiveCls;
    property Closable : Boolean read FClosable write SetFClosable;
    property ClosableCls : String read FClosableCls write SetFClosableCls;
    property CloseText : String read FCloseText write SetFCloseText;
    property DisabledCls : String read FDisabledCls write SetFDisabledCls;
    property IsTab : Boolean read FIsTab write SetFIsTab;
    property OnActivate : TExtTabOnActivate read FOnActivate write SetFOnActivate;
    property OnBeforeclose : TExtTabOnBeforeclose read FOnBeforeclose write SetFOnBeforeclose;
    property OnClose : TExtTabOnClose read FOnClose write SetFOnClose;
    property OnDeactivate : TExtTabOnDeactivate read FOnDeactivate write SetFOnDeactivate;
  end;

  TExtDataErrors = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetByField(FieldName : String) : TExtFunction;
    function IsValid : TExtFunction;
  end;

  // Procedural types for events TExtDirectRemotingProvider
  TExtDirectRemotingProviderOnBeforecall = procedure(Provider : TExtDirectRemotingProvider; Transaction : TExtDirectTransaction; Meta : TExtObject) of object;
  TExtDirectRemotingProviderOnBeforecallback = procedure(Provider : TExtDirectRemotingProvider; Transaction : TExtDirectTransaction) of object;
  TExtDirectRemotingProviderOnCall = procedure(Provider : TExtDirectRemotingProvider; Transaction : TExtDirectTransaction; Meta : TExtObject) of object;

  TExtDirectRemotingProvider = class(TExtDirectJsonProvider)
  private
    FActions : TExtObject;
    FDisableNestedActions : Boolean;
    FEnableBuffer : Integer;
    FEnableBufferBoolean : Boolean;
    FEnableUrlEncode : String;
    FMaxRetries : Integer;
    FNamespace : String;
    FNamespaceObject : TExtObject;
    FTimeout : Integer;
    FUrl : String;
    FOnBeforecall : TExtDirectRemotingProviderOnBeforecall;
    FOnBeforecallback : TExtDirectRemotingProviderOnBeforecallback;
    FOnCall : TExtDirectRemotingProviderOnCall;
    procedure SetFActions(Value : TExtObject);
    procedure SetFDisableNestedActions(Value : Boolean);
    procedure SetFEnableBuffer(Value : Integer);
    procedure SetFEnableBufferBoolean(Value : Boolean);
    procedure SetFEnableUrlEncode(Value : String);
    procedure SetFMaxRetries(Value : Integer);
    procedure SetFNamespace(Value : String);
    procedure SetFNamespaceObject(Value : TExtObject);
    procedure SetFTimeout(Value : Integer);
    procedure SetFUrl(Value : String);
    procedure SetFOnBeforecall(Value : TExtDirectRemotingProviderOnBeforecall);
    procedure SetFOnBeforecallback(Value : TExtDirectRemotingProviderOnBeforecallback);
    procedure SetFOnCall(Value : TExtDirectRemotingProviderOnCall);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Connect : TExtFunction;
    constructor Create;
    function Disconnect : TExtFunction;
    function IsConnected : TExtFunction;
    destructor Destroy; override;
    property Actions : TExtObject read FActions write SetFActions;
    property DisableNestedActions : Boolean read FDisableNestedActions write SetFDisableNestedActions;
    property EnableBuffer : Integer read FEnableBuffer write SetFEnableBuffer;
    property EnableBufferBoolean : Boolean read FEnableBufferBoolean write SetFEnableBufferBoolean;
    property EnableUrlEncode : String read FEnableUrlEncode write SetFEnableUrlEncode;
    property MaxRetries : Integer read FMaxRetries write SetFMaxRetries;
    property Namespace : String read FNamespace write SetFNamespace;
    property NamespaceObject : TExtObject read FNamespaceObject write SetFNamespaceObject;
    property Timeout : Integer read FTimeout write SetFTimeout;
    property Url : String read FUrl write SetFUrl;
    property OnBeforecall : TExtDirectRemotingProviderOnBeforecall read FOnBeforecall write SetFOnBeforecall;
    property OnBeforecallback : TExtDirectRemotingProviderOnBeforecallback read FOnBeforecallback write SetFOnBeforecallback;
    property OnCall : TExtDirectRemotingProviderOnCall read FOnCall write SetFOnCall;
  end;

  // Procedural types for events TExtButtonSplit
  TExtButtonSplitOnArrowclick = procedure(This : TExtButtonSplit; E : TExtDirectEvent) of object;

  TExtButtonSplit = class(TExtButton)
  private
    FArrowHandler : TExtFunction;
    FArrowHandlerE : TEvent;
    FArrowHandlerThis : TExtButtonSplit;
    FArrowTooltip : String;
    FOnArrowclick : TExtButtonSplitOnArrowclick;
    procedure SetFArrowHandler(Value : TExtFunction);
    procedure SetFArrowHandlerE(Value : TEvent);
    procedure SetFArrowHandlerThis(Value : TExtButtonSplit);
    procedure SetFArrowTooltip(Value : String);
    procedure SetFOnArrowclick(Value : TExtButtonSplitOnArrowclick);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetArrowHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property ArrowHandler : TExtFunction read FArrowHandler write SetFArrowHandler;
    property ArrowHandlerE : TEvent read FArrowHandlerE write SetFArrowHandlerE;
    property ArrowHandlerThis : TExtButtonSplit read FArrowHandlerThis write SetFArrowHandlerThis;
    property ArrowTooltip : String read FArrowTooltip write SetFArrowTooltip;
    property OnArrowclick : TExtButtonSplitOnArrowclick read FOnArrowclick write SetFOnArrowclick;
  end;

  TExtChartSeriesBar = class(TExtChartSeriesCartesian)
  private
    FColumn : Boolean;
    FGroupGutter : Integer;
    FGutter : Integer;
    FStacked : Boolean;
    FXPadding : Integer;
    FXPaddingObject : TExtObject;
    FYPadding : Integer;
    FYPaddingObject : TExtObject;
    procedure SetFColumn(Value : Boolean);
    procedure SetFGroupGutter(Value : Integer);
    procedure SetFGutter(Value : Integer);
    procedure SetFStacked(Value : Boolean);
    procedure SetFXPadding(Value : Integer);
    procedure SetFXPaddingObject(Value : TExtObject);
    procedure SetFYPadding(Value : Integer);
    procedure SetFYPaddingObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    function GetLegendColor : TExtFunction;
    destructor Destroy; override;
    property Column : Boolean read FColumn write SetFColumn;
    property GroupGutter : Integer read FGroupGutter write SetFGroupGutter;
    property Gutter : Integer read FGutter write SetFGutter;
    property Stacked : Boolean read FStacked write SetFStacked;
    property XPadding : Integer read FXPadding write SetFXPadding;
    property XPaddingObject : TExtObject read FXPaddingObject write SetFXPaddingObject;
    property YPadding : Integer read FYPadding write SetFYPadding;
    property YPaddingObject : TExtObject read FYPaddingObject write SetFYPaddingObject;
  end;

  TExtToolbarTextItem = class(TExtToolbarItem)
  private
    FText : String;
    procedure SetFText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetText(Text : String) : TExtFunction;
    property Text : String read FText write SetFText;
  end;

  TExtResizerBorderSplitterTracker = class(TExtResizerSplitterTracker)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtResizerBorderSplitter = class(TExtResizerSplitter)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtDrawCompositeSprite
  TExtDrawCompositeSpriteOnClick = procedure of object;
  TExtDrawCompositeSpriteOnMousedown = procedure of object;
  TExtDrawCompositeSpriteOnMouseout = procedure of object;
  TExtDrawCompositeSpriteOnMouseover = procedure of object;
  TExtDrawCompositeSpriteOnMouseup = procedure of object;

  TExtDrawCompositeSprite = class(TExtUtilMixedCollection)
  private
    FOnClick : TExtDrawCompositeSpriteOnClick;
    FOnMousedown : TExtDrawCompositeSpriteOnMousedown;
    FOnMouseout : TExtDrawCompositeSpriteOnMouseout;
    FOnMouseover : TExtDrawCompositeSpriteOnMouseover;
    FOnMouseup : TExtDrawCompositeSpriteOnMouseup;
    procedure SetFOnClick(Value : TExtDrawCompositeSpriteOnClick);
    procedure SetFOnMousedown(Value : TExtDrawCompositeSpriteOnMousedown);
    procedure SetFOnMouseout(Value : TExtDrawCompositeSpriteOnMouseout);
    procedure SetFOnMouseover(Value : TExtDrawCompositeSpriteOnMouseover);
    procedure SetFOnMouseup(Value : TExtDrawCompositeSpriteOnMouseup);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddCls(Cls : String) : TExtFunction;
    function Animate(Config : TExtObject) : TExtFunction;
    function GetActiveAnimation : TExtFunction;
    function GetBBox : TExtFunction;
    function Hide(Redraw : Boolean) : TExtFunction;
    function Redraw : TExtFunction;
    function RemoveCls(Cls : String) : TExtFunction;
    function SequenceFx : TExtFunction;
    function SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction;
    function SetStyle(Style : String) : TExtFunction;
    function Show(Redraw : Boolean) : TExtFunction;
    function StopAnimation : TExtFunction;
    function SyncFx : TExtFunction;
    property OnClick : TExtDrawCompositeSpriteOnClick read FOnClick write SetFOnClick;
    property OnMousedown : TExtDrawCompositeSpriteOnMousedown read FOnMousedown write SetFOnMousedown;
    property OnMouseout : TExtDrawCompositeSpriteOnMouseout read FOnMouseout write SetFOnMouseout;
    property OnMouseover : TExtDrawCompositeSpriteOnMouseover read FOnMouseover write SetFOnMouseover;
    property OnMouseup : TExtDrawCompositeSpriteOnMouseup read FOnMouseup write SetFOnMouseup;
  end;

  TExtDdDDProxy = class(TExtDdDD)
  private
    FCenterFrame : Boolean;
    FResizeFrame : Boolean;
    procedure SetFCenterFrame(Value : Boolean);
    procedure SetFResizeFrame(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateFrame : TExtFunction;
    function InitFrame : TExtFunction;
    property CenterFrame : Boolean read FCenterFrame write SetFCenterFrame;
    property ResizeFrame : Boolean read FResizeFrame write SetFResizeFrame;
  end;

  TExtDataArrayStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtToolbarSeparator = class(TExtToolbarItem)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtChart
  TExtChartOnBeforerefresh = procedure(This : TExtChart) of object;
  TExtChartOnRefresh = procedure(This : TExtChart) of object;

  TExtChart = class(TExtDrawComponent)
  private
    FAnimate : Boolean;
    FAnimateObject : TExtObject;
    FAxes : TExtObjectList;
    FBackground : TExtObject;
    FBackgroundBoolean : Boolean;
    FGlobalEvents : TExtUtilObservable;
    FGradients : TExtObjectList;
    FHasListeners : TExtObject;
    FInsetPadding : Integer; // 10
    FIsObservable : Boolean;
    FLegend : Boolean;
    FLegendObject : TExtObject;
    FListeners : TExtObject;
    FMask : Boolean;
    FMaskString : String;
    FSeries : TExtObjectList;
    FStore : TExtDataStore;
    FTheme : String;
    FOnBeforerefresh : TExtChartOnBeforerefresh;
    FOnRefresh : TExtChartOnRefresh;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFAnimateObject(Value : TExtObject);
    procedure SetFAxes(Value : TExtObjectList);
    procedure SetFBackground(Value : TExtObject);
    procedure SetFBackgroundBoolean(Value : Boolean);
    procedure SetFGlobalEvents(Value : TExtUtilObservable);
    procedure SetFGradients(Value : TExtObjectList);
    procedure SetFHasListeners(Value : TExtObject);
    procedure SetFInsetPadding(Value : Integer);
    procedure SetFIsObservable(Value : Boolean);
    procedure SetFLegend(Value : Boolean);
    procedure SetFLegendObject(Value : TExtObject);
    procedure SetFListeners(Value : TExtObject);
    procedure SetFMask(Value : Boolean);
    procedure SetFMaskString(Value : String);
    procedure SetFSeries(Value : TExtObjectList);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFTheme(Value : String);
    procedure SetFOnBeforerefresh(Value : TExtChartOnBeforerefresh);
    procedure SetFOnRefresh(Value : TExtChartOnRefresh);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddEvents(EventNames : String) : TExtFunction; overload;
    function AddEvents(EventNames : TExtObject) : TExtFunction; overload;
    function AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; overload;
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    function Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function ClearListeners : TExtFunction;
    function ClearManagedListeners : TExtFunction;
    constructor Create;
    function EnableBubble(EventNames : String) : TExtFunction; overload;
    function EnableBubble(EventNames : TArrayOfString) : TExtFunction; overload;
    function FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction;
    function FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction;
    function GetStore : TExtFunction;
    function HasListener(EventName : String) : TExtFunction;
    function Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction;
    function Redraw(Resize : Boolean = false) : TExtFunction;
    function RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction;
    function ReleaseCapture(O : TExtUtilObservable) : TExtFunction;
    function RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction;
    function RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; overload;
    function RestoreZoom : TExtFunction;
    function ResumeEvent(EventName : String) : TExtFunction;
    function ResumeEvents : TExtFunction;
    function Save(Config : TExtObject = nil) : TExtFunction;
    function SetZoom : TExtFunction;
    function SuspendEvent(EventName : String) : TExtFunction;
    function SuspendEvents(QueueSuspended : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property AnimateObject : TExtObject read FAnimateObject write SetFAnimateObject;
    property Axes : TExtObjectList read FAxes write SetFAxes;
    property Background : TExtObject read FBackground write SetFBackground;
    property BackgroundBoolean : Boolean read FBackgroundBoolean write SetFBackgroundBoolean;
    property GlobalEvents : TExtUtilObservable read FGlobalEvents write SetFGlobalEvents;
    property Gradients : TExtObjectList read FGradients write SetFGradients;
    property HasListeners : TExtObject read FHasListeners write SetFHasListeners;
    property InsetPadding : Integer read FInsetPadding write SetFInsetPadding;
    property IsObservable : Boolean read FIsObservable write SetFIsObservable;
    property Legend : Boolean read FLegend write SetFLegend;
    property LegendObject : TExtObject read FLegendObject write SetFLegendObject;
    property Listeners : TExtObject read FListeners write SetFListeners;
    property Mask : Boolean read FMask write SetFMask;
    property MaskString : String read FMaskString write SetFMaskString;
    property Series : TExtObjectList read FSeries write SetFSeries;
    property Store : TExtDataStore read FStore write SetFStore;
    property Theme : String read FTheme write SetFTheme;
    property OnBeforerefresh : TExtChartOnBeforerefresh read FOnBeforerefresh write SetFOnBeforerefresh;
    property OnRefresh : TExtChartOnRefresh read FOnRefresh write SetFOnRefresh;
  end;

  TExtContainer = class(TExtContainerAbstractContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetChildByElement(El : THTMLElement; Deep : Boolean) : TExtFunction; overload;
    function GetChildByElement(El : TExtElement; Deep : Boolean) : TExtFunction; overload;
    function GetChildByElement(El : String; Deep : Boolean) : TExtFunction; overload;
  end;

  TExtDdDropTarget = class(TExtDdDDTarget)
  private
    FDdGroup : String;
    FDropAllowed : String;
    FDropNotAllowed : String;
    FOverClass : String;
    procedure SetFDdGroup(Value : String);
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
    procedure SetFOverClass(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(El : THTMLElement; Config : TExtObject); overload;
    constructor Create(El : TExtElement; Config : TExtObject); overload;
    constructor Create(El : String; Config : TExtObject); overload;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
    property OverClass : String read FOverClass write SetFOverClass;
  end;

  TExtChartAxisNumeric = class(TExtChartAxis)
  private
    FAdjustMaximumByMajorUnit : Boolean;
    FAdjustMinimumByMajorUnit : Boolean;
    FConstrain : Boolean;
    FDecimals : Integer;
    FMaximum : Integer;
    FMinimum : Integer;
    FPosition : String;
    procedure SetFAdjustMaximumByMajorUnit(Value : Boolean);
    procedure SetFAdjustMinimumByMajorUnit(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFDecimals(Value : Integer);
    procedure SetFMaximum(Value : Integer);
    procedure SetFMinimum(Value : Integer);
    procedure SetFPosition(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AdjustMaximumByMajorUnit : Boolean read FAdjustMaximumByMajorUnit write SetFAdjustMaximumByMajorUnit;
    property AdjustMinimumByMajorUnit : Boolean read FAdjustMinimumByMajorUnit write SetFAdjustMinimumByMajorUnit;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Decimals : Integer read FDecimals write SetFDecimals;
    property Maximum : Integer read FMaximum write SetFMaximum;
    property Minimum : Integer read FMinimum write SetFMinimum;
    property Position : String read FPosition write SetFPosition;
  end;

  TExtChartSeriesLine = class(TExtChartSeriesCartesian)
  private
    FFill : Boolean;
    FMarkerConfig : TExtObject;
    FSelectionTolerance : Integer;
    FShowMarkers : Boolean;
    FSmooth : Boolean;
    FSmoothInteger : Integer;
    FStyle : TExtObject;
    procedure SetFFill(Value : Boolean);
    procedure SetFMarkerConfig(Value : TExtObject);
    procedure SetFSelectionTolerance(Value : Integer);
    procedure SetFShowMarkers(Value : Boolean);
    procedure SetFSmooth(Value : Boolean);
    procedure SetFSmoothInteger(Value : Integer);
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property Fill : Boolean read FFill write SetFFill;
    property MarkerConfig : TExtObject read FMarkerConfig write SetFMarkerConfig;
    property SelectionTolerance : Integer read FSelectionTolerance write SetFSelectionTolerance;
    property ShowMarkers : Boolean read FShowMarkers write SetFShowMarkers;
    property Smooth : Boolean read FSmooth write SetFSmooth;
    property SmoothInteger : Integer read FSmoothInteger write SetFSmoothInteger;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtChartSeriesScatter = class(TExtChartSeriesCartesian)
  private
    FMarkerConfig : TExtObject;
    FStyle : TExtObject;
    procedure SetFMarkerConfig(Value : TExtObject);
    procedure SetFStyle(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DrawSeries : TExtFunction;
    destructor Destroy; override;
    property MarkerConfig : TExtObject read FMarkerConfig write SetFMarkerConfig;
    property Style : TExtObject read FStyle write SetFStyle;
  end;

  TExtChartAxisCategory = class(TExtChartAxis)
  private
    FCalculateCategoryCount : Boolean;
    FCategoryNames : String;
    procedure SetFCalculateCategoryCount(Value : Boolean);
    procedure SetFCategoryNames(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property CalculateCategoryCount : Boolean read FCalculateCategoryCount write SetFCalculateCategoryCount;
    property CategoryNames : String read FCategoryNames write SetFCategoryNames;
  end;

  // Procedural types for events TExtSliderMulti
  TExtSliderMultiOnBeforechange = procedure(Slider : TExtSliderMulti; NewValue : Integer; OldValue : Integer) of object;
  TExtSliderMultiOnChange = procedure(Slider : TExtSliderMulti; NewValue : Integer; Thumb : TExtSliderThumb) of object;
  TExtSliderMultiOnChangecomplete = procedure(Slider : TExtSliderMulti; NewValue : Integer; Thumb : TExtSliderThumb) of object;
  TExtSliderMultiOnDrag = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;
  TExtSliderMultiOnDragend = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;
  TExtSliderMultiOnDragstart = procedure(Slider : TExtSliderMulti; E : TExtEventObject) of object;

  TExtSliderMulti = class(TExtFormFieldBase)
  private
    FAnimate : Boolean;
    FClickToChange : Boolean;
    FConstrainThumbs : Boolean;
    FDecimalPrecision : Integer;
    FDecimalPrecisionBoolean : Boolean;
    FDragging : Boolean;
    FIncrement : Integer;
    FKeyIncrement : Integer;
    FMaxValue : Integer;
    FMinValue : Integer;
    FThumbs : TExtObjectList;
    FTipText : TExtFunction;
    FTipTextReturn : String;
    FTipTextThumb : TExtSliderThumb;
    FUseTips : TExtObject;
    FUseTipsBoolean : Boolean;
    FValue : Integer;
    FValues : TArrayOfInteger;
    FVertical : Boolean;
    FZeroBasedSnapping : Boolean;
    FOnBeforechange : TExtSliderMultiOnBeforechange;
    FOnChange : TExtSliderMultiOnChange;
    FOnChangecomplete : TExtSliderMultiOnChangecomplete;
    FOnDrag : TExtSliderMultiOnDrag;
    FOnDragend : TExtSliderMultiOnDragend;
    FOnDragstart : TExtSliderMultiOnDragstart;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFClickToChange(Value : Boolean);
    procedure SetFConstrainThumbs(Value : Boolean);
    procedure SetFDecimalPrecision(Value : Integer);
    procedure SetFDecimalPrecisionBoolean(Value : Boolean);
    procedure SetFDragging(Value : Boolean);
    procedure SetFIncrement(Value : Integer);
    procedure SetFKeyIncrement(Value : Integer);
    procedure SetFMaxValue(Value : Integer);
    procedure SetFMinValue(Value : Integer);
    procedure SetFThumbs(Value : TExtObjectList);
    procedure SetFTipText(Value : TExtFunction);
    procedure SetFTipTextReturn(Value : String);
    procedure SetFTipTextThumb(Value : TExtSliderThumb);
    procedure SetFUseTips(Value : TExtObject);
    procedure SetFUseTipsBoolean(Value : Boolean);
    procedure SetFValue(Value : Integer);
    procedure SetFValues(Value : TArrayOfInteger);
    procedure SetFVertical(Value : Boolean);
    procedure SetFZeroBasedSnapping(Value : Boolean);
    procedure SetFOnBeforechange(Value : TExtSliderMultiOnBeforechange);
    procedure SetFOnChange(Value : TExtSliderMultiOnChange);
    procedure SetFOnChangecomplete(Value : TExtSliderMultiOnChangecomplete);
    procedure SetFOnDrag(Value : TExtSliderMultiOnDrag);
    procedure SetFOnDragend(Value : TExtSliderMultiOnDragend);
    procedure SetFOnDragstart(Value : TExtSliderMultiOnDragstart);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddThumb(Value : Integer = 0) : TExtFunction;
    constructor Create;
    function GetValue(Index : Integer) : TExtFunction;
    function GetValues : TExtFunction;
    function SetMaxValue(Val : Integer) : TExtFunction;
    function SetMinValue(Val : Integer) : TExtFunction;
    function SetValue(Index : TArrayOfInteger; Value : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SetValue(Index : Integer; Value : Integer; Animate : Boolean = false) : TExtFunction; overload;
    function SyncThumbs : TExtFunction;
    destructor Destroy; override;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property ClickToChange : Boolean read FClickToChange write SetFClickToChange;
    property ConstrainThumbs : Boolean read FConstrainThumbs write SetFConstrainThumbs;
    property DecimalPrecision : Integer read FDecimalPrecision write SetFDecimalPrecision;
    property DecimalPrecisionBoolean : Boolean read FDecimalPrecisionBoolean write SetFDecimalPrecisionBoolean;
    property Dragging : Boolean read FDragging write SetFDragging;
    property Increment : Integer read FIncrement write SetFIncrement;
    property KeyIncrement : Integer read FKeyIncrement write SetFKeyIncrement;
    property MaxValue : Integer read FMaxValue write SetFMaxValue;
    property MinValue : Integer read FMinValue write SetFMinValue;
    property Thumbs : TExtObjectList read FThumbs write SetFThumbs;
    property TipText : TExtFunction read FTipText write SetFTipText;
    property TipTextReturn : String read FTipTextReturn write SetFTipTextReturn;
    property TipTextThumb : TExtSliderThumb read FTipTextThumb write SetFTipTextThumb;
    property UseTips : TExtObject read FUseTips write SetFUseTips;
    property UseTipsBoolean : Boolean read FUseTipsBoolean write SetFUseTipsBoolean;
    property Value : Integer read FValue write SetFValue;
    property Values : TArrayOfInteger read FValues write SetFValues;
    property Vertical : Boolean read FVertical write SetFVertical;
    property ZeroBasedSnapping : Boolean read FZeroBasedSnapping write SetFZeroBasedSnapping;
    property OnBeforechange : TExtSliderMultiOnBeforechange read FOnBeforechange write SetFOnBeforechange;
    property OnChange : TExtSliderMultiOnChange read FOnChange write SetFOnChange;
    property OnChangecomplete : TExtSliderMultiOnChangecomplete read FOnChangecomplete write SetFOnChangecomplete;
    property OnDrag : TExtSliderMultiOnDrag read FOnDrag write SetFOnDrag;
    property OnDragend : TExtSliderMultiOnDragend read FOnDragend write SetFOnDragend;
    property OnDragstart : TExtSliderMultiOnDragstart read FOnDragstart write SetFOnDragstart;
  end;

  TExtLayoutComponentDock = class(TExtLayoutComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function InvalidateAxes : TExtFunction;
  end;

  TExtFxTargetElementCSS = class(TExtFxTargetElement)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetCompositeSprite = class(TExtFxTargetSprite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataNodeStore = class(TExtDataStore)
  private
    FIsNodeStore : Boolean;
    FNode : TExtDataModel;
    FRecursive : Boolean;
    FRootVisible : Boolean;
    FTreeStore : TExtDataTreeStore;
    procedure SetFIsNodeStore(Value : Boolean);
    procedure SetFNode(Value : TExtDataModel);
    procedure SetFRecursive(Value : Boolean);
    procedure SetFRootVisible(Value : Boolean);
    procedure SetFTreeStore(Value : TExtDataTreeStore);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property IsNodeStore : Boolean read FIsNodeStore write SetFIsNodeStore;
    property Node : TExtDataModel read FNode write SetFNode;
    property Recursive : Boolean read FRecursive write SetFRecursive;
    property RootVisible : Boolean read FRootVisible write SetFRootVisible;
    property TreeStore : TExtDataTreeStore read FTreeStore write SetFTreeStore;
  end;

  TExtLayoutComponentAuto = class(TExtLayoutComponent)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormFieldText
  TExtFormFieldTextOnAutosize = procedure(This : TExtFormFieldText; Width : Integer) of object;
  TExtFormFieldTextOnKeydown = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;
  TExtFormFieldTextOnKeypress = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;
  TExtFormFieldTextOnKeyup = procedure(This : TExtFormFieldText; E : TExtEventObject) of object;

  TExtFormFieldText = class(TExtFormFieldBase)
  private
    FAllowBlank : Boolean;
    FAllowOnlyWhitespace : Boolean;
    FBlankText : String;
    FDisableKeyFilter : Boolean;
    FEmptyCls : String;
    FEmptyText : String;
    FEnableKeyEvents : Boolean;
    FEnforceMaxLength : Boolean;
    FGrow : Boolean;
    FGrowAppend : String; // 'W'
    FGrowMax : Integer;
    FGrowMin : Integer;
    FMaskRe : TRegExp;
    FMaxLength : Integer;
    FMaxLengthText : String;
    FMinLength : Integer;
    FRegex : TRegExp;
    FRegexText : String;
    FRequiredCls : String;
    FSelectOnFocus : Boolean;
    FSize : Integer; // 20
    FStripCharsRe : TRegExp;
    FValidateBlank : Boolean;
    FValidator : TExtFunction;
    FValidatorReturn : Boolean;
    FValidatorReturnString : String;
    FValidatorValue : TExtObject;
    FVtype : String;
    FVtypeText : String;
    FOnAutosize : TExtFormFieldTextOnAutosize;
    FOnKeydown : TExtFormFieldTextOnKeydown;
    FOnKeypress : TExtFormFieldTextOnKeypress;
    FOnKeyup : TExtFormFieldTextOnKeyup;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFAllowOnlyWhitespace(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFDisableKeyFilter(Value : Boolean);
    procedure SetFEmptyCls(Value : String);
    procedure SetFEmptyText(Value : String);
    procedure SetFEnableKeyEvents(Value : Boolean);
    procedure SetFEnforceMaxLength(Value : Boolean);
    procedure SetFGrow(Value : Boolean);
    procedure SetFGrowAppend(Value : String);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowMin(Value : Integer);
    procedure SetFMaskRe(Value : TRegExp);
    procedure SetFMaxLength(Value : Integer);
    procedure SetFMaxLengthText(Value : String);
    procedure SetFMinLength(Value : Integer);
    procedure SetFRegex(Value : TRegExp);
    procedure SetFRegexText(Value : String);
    procedure SetFRequiredCls(Value : String);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFSize(Value : Integer);
    procedure SetFStripCharsRe(Value : TRegExp);
    procedure SetFValidateBlank(Value : Boolean);
    procedure SetFValidator(Value : TExtFunction);
    procedure SetFValidatorReturn(Value : Boolean);
    procedure SetFValidatorReturnString(Value : String);
    procedure SetFValidatorValue(Value : TExtObject);
    procedure SetFVtype(Value : String);
    procedure SetFVtypeText(Value : String);
    procedure SetFOnAutosize(Value : TExtFormFieldTextOnAutosize);
    procedure SetFOnKeydown(Value : TExtFormFieldTextOnKeydown);
    procedure SetFOnKeypress(Value : TExtFormFieldTextOnKeypress);
    procedure SetFOnKeyup(Value : TExtFormFieldTextOnKeyup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AutoSize : TExtFunction;
    constructor Create;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function GetRawValue : TExtFunction;
    function ProcessRawValue(Value : String) : TExtFunction;
    function Reset : TExtFunction;
    function SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property AllowOnlyWhitespace : Boolean read FAllowOnlyWhitespace write SetFAllowOnlyWhitespace;
    property BlankText : String read FBlankText write SetFBlankText;
    property DisableKeyFilter : Boolean read FDisableKeyFilter write SetFDisableKeyFilter;
    property EmptyCls : String read FEmptyCls write SetFEmptyCls;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property EnableKeyEvents : Boolean read FEnableKeyEvents write SetFEnableKeyEvents;
    property EnforceMaxLength : Boolean read FEnforceMaxLength write SetFEnforceMaxLength;
    property Grow : Boolean read FGrow write SetFGrow;
    property GrowAppend : String read FGrowAppend write SetFGrowAppend;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property MaskRe : TRegExp read FMaskRe write SetFMaskRe;
    property MaxLength : Integer read FMaxLength write SetFMaxLength;
    property MaxLengthText : String read FMaxLengthText write SetFMaxLengthText;
    property MinLength : Integer read FMinLength write SetFMinLength;
    property Regex : TRegExp read FRegex write SetFRegex;
    property RegexText : String read FRegexText write SetFRegexText;
    property RequiredCls : String read FRequiredCls write SetFRequiredCls;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property Size : Integer read FSize write SetFSize;
    property StripCharsRe : TRegExp read FStripCharsRe write SetFStripCharsRe;
    property ValidateBlank : Boolean read FValidateBlank write SetFValidateBlank;
    property Validator : TExtFunction read FValidator write SetFValidator;
    property ValidatorReturn : Boolean read FValidatorReturn write SetFValidatorReturn;
    property ValidatorReturnString : String read FValidatorReturnString write SetFValidatorReturnString;
    property ValidatorValue : TExtObject read FValidatorValue write SetFValidatorValue;
    property Vtype : String read FVtype write SetFVtype;
    property VtypeText : String read FVtypeText write SetFVtypeText;
    property OnAutosize : TExtFormFieldTextOnAutosize read FOnAutosize write SetFOnAutosize;
    property OnKeydown : TExtFormFieldTextOnKeydown read FOnKeydown write SetFOnKeydown;
    property OnKeypress : TExtFormFieldTextOnKeypress read FOnKeypress write SetFOnKeypress;
    property OnKeyup : TExtFormFieldTextOnKeyup read FOnKeyup write SetFOnKeyup;
  end;

  TExtFormFieldDisplay = class(TExtFormFieldBase)
  private
    FFieldCls : String;
    FHtmlEncode : Boolean;
    FRenderer : TExtFunction;
    FScope : TExtObject;
    procedure SetFFieldCls(Value : String);
    procedure SetFHtmlEncode(Value : Boolean);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFScope(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property HtmlEncode : Boolean read FHtmlEncode write SetFHtmlEncode;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property Scope : TExtObject read FScope write SetFScope;
  end;

  TExtDataJsonPStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetCompositeElement = class(TExtFxTargetElement)
  private
    FIsComposite : Boolean;
    procedure SetFIsComposite(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsComposite : Boolean read FIsComposite write SetFIsComposite;
  end;

  TExtFormFieldHidden = class(TExtFormFieldBase)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataJsonStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormFieldFileButton = class(TExtButton)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataProxyMemory = class(TExtDataProxyClient)
  private
    FData : TExtObject;
    FEnablePaging : Boolean;
    procedure SetFData(Value : TExtObject);
    procedure SetFEnablePaging(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject);
    function Read(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    function Update(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property Data : TExtObject read FData write SetFData;
    property EnablePaging : Boolean read FEnablePaging write SetFEnablePaging;
  end;

  // Procedural types for events TExtDataProxyJsonP
  TExtDataProxyJsonPOnException = procedure(This : TExtDataProxyJsonP; Request : TExtDataRequest; Operation : TExtDataOperation) of object;

  TExtDataProxyJsonP = class(TExtDataProxyServer)
  private
    FAutoAppendParams : Boolean; // true
    FCallbackKey : String;
    FRecordParam : String;
    FOnException : TExtDataProxyJsonPOnException;
    procedure SetFAutoAppendParams(Value : Boolean);
    procedure SetFCallbackKey(Value : String);
    procedure SetFRecordParam(Value : String);
    procedure SetFOnException(Value : TExtDataProxyJsonPOnException);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Abort : TExtFunction;
    function BuildUrl(Request : TExtDataRequest) : TExtFunction;
    constructor Create;
    function EncodeRecords(Records : TExtObjectList) : TExtFunction;
    property AutoAppendParams : Boolean read FAutoAppendParams write SetFAutoAppendParams;
    property CallbackKey : String read FCallbackKey write SetFCallbackKey;
    property RecordParam : String read FRecordParam write SetFRecordParam;
    property OnException : TExtDataProxyJsonPOnException read FOnException write SetFOnException;
  end;

  TExtDataProxyDirect = class(TExtDataProxyServer)
  private
    FApi : TExtObject;
    FDirectFn : TExtFunction;
    FDirectFnString : String;
    FExtraParams : TExtObject;
    FParamOrder : String;
    FParamOrderTArrayOfString : TArrayOfString;
    FParamsAsHash : Boolean;
    procedure SetFApi(Value : TExtObject);
    procedure SetFDirectFn(Value : TExtFunction);
    procedure SetFDirectFnString(Value : String);
    procedure SetFExtraParams(Value : TExtObject);
    procedure SetFParamOrder(Value : String);
    procedure SetFParamOrderTArrayOfString(Value : TArrayOfString);
    procedure SetFParamsAsHash(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Api : TExtObject read FApi write SetFApi;
    property DirectFn : TExtFunction read FDirectFn write SetFDirectFn;
    property DirectFnString : String read FDirectFnString write SetFDirectFnString;
    property ExtraParams : TExtObject read FExtraParams write SetFExtraParams;
    property ParamOrder : String read FParamOrder write SetFParamOrder;
    property ParamOrderTArrayOfString : TArrayOfString read FParamOrderTArrayOfString write SetFParamOrderTArrayOfString;
    property ParamsAsHash : Boolean read FParamsAsHash write SetFParamsAsHash;
  end;

  // Procedural types for events TExtView
  TExtViewOnBeforecontainerclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainercontextmenu = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainerdblclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainerkeydown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermousedown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseout = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseover = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforecontainermouseup = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnBeforedeselect = procedure of object;
  TExtViewOnBeforeitemclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemcontextmenu = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemdblclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemkeydown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmousedown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseenter = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseleave = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeitemmouseup = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnBeforeselect = procedure of object;
  TExtViewOnContainerclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainercontextmenu = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainerdblclick = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainerkeydown = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseout = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseover = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnContainermouseup = procedure(This : TExtView; E : TExtEventObject) of object;
  TExtViewOnDeselect = procedure of object;
  TExtViewOnFocuschange = procedure of object;
  TExtViewOnHighlightitem = procedure(View : TExtView; Node : TExtElement) of object;
  TExtViewOnItemclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemcontextmenu = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemdblclick = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemkeydown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmousedown = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseenter = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseleave = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnItemmouseup = procedure(This : TExtView; RecordJS : TExtDataModel; Item : THTMLElement; Index : Integer; E : TExtEventObject) of object;
  TExtViewOnSelect = procedure of object;
  TExtViewOnSelectionchange = procedure of object;
  TExtViewOnUnhighlightitem = procedure(View : TExtView; Node : TExtElement) of object;

  TExtView = class(TExtViewAbstractView)
  private
    FMouseOverOutBuffer : Integer;
    FOnBeforecontainerclick : TExtViewOnBeforecontainerclick;
    FOnBeforecontainercontextmenu : TExtViewOnBeforecontainercontextmenu;
    FOnBeforecontainerdblclick : TExtViewOnBeforecontainerdblclick;
    FOnBeforecontainerkeydown : TExtViewOnBeforecontainerkeydown;
    FOnBeforecontainermousedown : TExtViewOnBeforecontainermousedown;
    FOnBeforecontainermouseout : TExtViewOnBeforecontainermouseout;
    FOnBeforecontainermouseover : TExtViewOnBeforecontainermouseover;
    FOnBeforecontainermouseup : TExtViewOnBeforecontainermouseup;
    FOnBeforedeselect : TExtViewOnBeforedeselect;
    FOnBeforeitemclick : TExtViewOnBeforeitemclick;
    FOnBeforeitemcontextmenu : TExtViewOnBeforeitemcontextmenu;
    FOnBeforeitemdblclick : TExtViewOnBeforeitemdblclick;
    FOnBeforeitemkeydown : TExtViewOnBeforeitemkeydown;
    FOnBeforeitemmousedown : TExtViewOnBeforeitemmousedown;
    FOnBeforeitemmouseenter : TExtViewOnBeforeitemmouseenter;
    FOnBeforeitemmouseleave : TExtViewOnBeforeitemmouseleave;
    FOnBeforeitemmouseup : TExtViewOnBeforeitemmouseup;
    FOnBeforeselect : TExtViewOnBeforeselect;
    FOnContainerclick : TExtViewOnContainerclick;
    FOnContainercontextmenu : TExtViewOnContainercontextmenu;
    FOnContainerdblclick : TExtViewOnContainerdblclick;
    FOnContainerkeydown : TExtViewOnContainerkeydown;
    FOnContainermouseout : TExtViewOnContainermouseout;
    FOnContainermouseover : TExtViewOnContainermouseover;
    FOnContainermouseup : TExtViewOnContainermouseup;
    FOnDeselect : TExtViewOnDeselect;
    FOnFocuschange : TExtViewOnFocuschange;
    FOnHighlightitem : TExtViewOnHighlightitem;
    FOnItemclick : TExtViewOnItemclick;
    FOnItemcontextmenu : TExtViewOnItemcontextmenu;
    FOnItemdblclick : TExtViewOnItemdblclick;
    FOnItemkeydown : TExtViewOnItemkeydown;
    FOnItemmousedown : TExtViewOnItemmousedown;
    FOnItemmouseenter : TExtViewOnItemmouseenter;
    FOnItemmouseleave : TExtViewOnItemmouseleave;
    FOnItemmouseup : TExtViewOnItemmouseup;
    FOnSelect : TExtViewOnSelect;
    FOnSelectionchange : TExtViewOnSelectionchange;
    FOnUnhighlightitem : TExtViewOnUnhighlightitem;
    procedure SetFMouseOverOutBuffer(Value : Integer);
    procedure SetFOnBeforecontainerclick(Value : TExtViewOnBeforecontainerclick);
    procedure SetFOnBeforecontainercontextmenu(Value : TExtViewOnBeforecontainercontextmenu);
    procedure SetFOnBeforecontainerdblclick(Value : TExtViewOnBeforecontainerdblclick);
    procedure SetFOnBeforecontainerkeydown(Value : TExtViewOnBeforecontainerkeydown);
    procedure SetFOnBeforecontainermousedown(Value : TExtViewOnBeforecontainermousedown);
    procedure SetFOnBeforecontainermouseout(Value : TExtViewOnBeforecontainermouseout);
    procedure SetFOnBeforecontainermouseover(Value : TExtViewOnBeforecontainermouseover);
    procedure SetFOnBeforecontainermouseup(Value : TExtViewOnBeforecontainermouseup);
    procedure SetFOnBeforedeselect(Value : TExtViewOnBeforedeselect);
    procedure SetFOnBeforeitemclick(Value : TExtViewOnBeforeitemclick);
    procedure SetFOnBeforeitemcontextmenu(Value : TExtViewOnBeforeitemcontextmenu);
    procedure SetFOnBeforeitemdblclick(Value : TExtViewOnBeforeitemdblclick);
    procedure SetFOnBeforeitemkeydown(Value : TExtViewOnBeforeitemkeydown);
    procedure SetFOnBeforeitemmousedown(Value : TExtViewOnBeforeitemmousedown);
    procedure SetFOnBeforeitemmouseenter(Value : TExtViewOnBeforeitemmouseenter);
    procedure SetFOnBeforeitemmouseleave(Value : TExtViewOnBeforeitemmouseleave);
    procedure SetFOnBeforeitemmouseup(Value : TExtViewOnBeforeitemmouseup);
    procedure SetFOnBeforeselect(Value : TExtViewOnBeforeselect);
    procedure SetFOnContainerclick(Value : TExtViewOnContainerclick);
    procedure SetFOnContainercontextmenu(Value : TExtViewOnContainercontextmenu);
    procedure SetFOnContainerdblclick(Value : TExtViewOnContainerdblclick);
    procedure SetFOnContainerkeydown(Value : TExtViewOnContainerkeydown);
    procedure SetFOnContainermouseout(Value : TExtViewOnContainermouseout);
    procedure SetFOnContainermouseover(Value : TExtViewOnContainermouseover);
    procedure SetFOnContainermouseup(Value : TExtViewOnContainermouseup);
    procedure SetFOnDeselect(Value : TExtViewOnDeselect);
    procedure SetFOnFocuschange(Value : TExtViewOnFocuschange);
    procedure SetFOnHighlightitem(Value : TExtViewOnHighlightitem);
    procedure SetFOnItemclick(Value : TExtViewOnItemclick);
    procedure SetFOnItemcontextmenu(Value : TExtViewOnItemcontextmenu);
    procedure SetFOnItemdblclick(Value : TExtViewOnItemdblclick);
    procedure SetFOnItemkeydown(Value : TExtViewOnItemkeydown);
    procedure SetFOnItemmousedown(Value : TExtViewOnItemmousedown);
    procedure SetFOnItemmouseenter(Value : TExtViewOnItemmouseenter);
    procedure SetFOnItemmouseleave(Value : TExtViewOnItemmouseleave);
    procedure SetFOnItemmouseup(Value : TExtViewOnItemmouseup);
    procedure SetFOnSelect(Value : TExtViewOnSelect);
    procedure SetFOnSelectionchange(Value : TExtViewOnSelectionchange);
    procedure SetFOnUnhighlightitem(Value : TExtViewOnUnhighlightitem);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ClearHighlight : TExtFunction;
    function FocusNode(Rec : TExtDataModel) : TExtFunction;
    function HighlightItem(Item : THTMLElement) : TExtFunction;
    property MouseOverOutBuffer : Integer read FMouseOverOutBuffer write SetFMouseOverOutBuffer;
    property OnBeforecontainerclick : TExtViewOnBeforecontainerclick read FOnBeforecontainerclick write SetFOnBeforecontainerclick;
    property OnBeforecontainercontextmenu : TExtViewOnBeforecontainercontextmenu read FOnBeforecontainercontextmenu write SetFOnBeforecontainercontextmenu;
    property OnBeforecontainerdblclick : TExtViewOnBeforecontainerdblclick read FOnBeforecontainerdblclick write SetFOnBeforecontainerdblclick;
    property OnBeforecontainerkeydown : TExtViewOnBeforecontainerkeydown read FOnBeforecontainerkeydown write SetFOnBeforecontainerkeydown;
    property OnBeforecontainermousedown : TExtViewOnBeforecontainermousedown read FOnBeforecontainermousedown write SetFOnBeforecontainermousedown;
    property OnBeforecontainermouseout : TExtViewOnBeforecontainermouseout read FOnBeforecontainermouseout write SetFOnBeforecontainermouseout;
    property OnBeforecontainermouseover : TExtViewOnBeforecontainermouseover read FOnBeforecontainermouseover write SetFOnBeforecontainermouseover;
    property OnBeforecontainermouseup : TExtViewOnBeforecontainermouseup read FOnBeforecontainermouseup write SetFOnBeforecontainermouseup;
    property OnBeforedeselect : TExtViewOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforeitemclick : TExtViewOnBeforeitemclick read FOnBeforeitemclick write SetFOnBeforeitemclick;
    property OnBeforeitemcontextmenu : TExtViewOnBeforeitemcontextmenu read FOnBeforeitemcontextmenu write SetFOnBeforeitemcontextmenu;
    property OnBeforeitemdblclick : TExtViewOnBeforeitemdblclick read FOnBeforeitemdblclick write SetFOnBeforeitemdblclick;
    property OnBeforeitemkeydown : TExtViewOnBeforeitemkeydown read FOnBeforeitemkeydown write SetFOnBeforeitemkeydown;
    property OnBeforeitemmousedown : TExtViewOnBeforeitemmousedown read FOnBeforeitemmousedown write SetFOnBeforeitemmousedown;
    property OnBeforeitemmouseenter : TExtViewOnBeforeitemmouseenter read FOnBeforeitemmouseenter write SetFOnBeforeitemmouseenter;
    property OnBeforeitemmouseleave : TExtViewOnBeforeitemmouseleave read FOnBeforeitemmouseleave write SetFOnBeforeitemmouseleave;
    property OnBeforeitemmouseup : TExtViewOnBeforeitemmouseup read FOnBeforeitemmouseup write SetFOnBeforeitemmouseup;
    property OnBeforeselect : TExtViewOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnContainerclick : TExtViewOnContainerclick read FOnContainerclick write SetFOnContainerclick;
    property OnContainercontextmenu : TExtViewOnContainercontextmenu read FOnContainercontextmenu write SetFOnContainercontextmenu;
    property OnContainerdblclick : TExtViewOnContainerdblclick read FOnContainerdblclick write SetFOnContainerdblclick;
    property OnContainerkeydown : TExtViewOnContainerkeydown read FOnContainerkeydown write SetFOnContainerkeydown;
    property OnContainermouseout : TExtViewOnContainermouseout read FOnContainermouseout write SetFOnContainermouseout;
    property OnContainermouseover : TExtViewOnContainermouseover read FOnContainermouseover write SetFOnContainermouseover;
    property OnContainermouseup : TExtViewOnContainermouseup read FOnContainermouseup write SetFOnContainermouseup;
    property OnDeselect : TExtViewOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnFocuschange : TExtViewOnFocuschange read FOnFocuschange write SetFOnFocuschange;
    property OnHighlightitem : TExtViewOnHighlightitem read FOnHighlightitem write SetFOnHighlightitem;
    property OnItemclick : TExtViewOnItemclick read FOnItemclick write SetFOnItemclick;
    property OnItemcontextmenu : TExtViewOnItemcontextmenu read FOnItemcontextmenu write SetFOnItemcontextmenu;
    property OnItemdblclick : TExtViewOnItemdblclick read FOnItemdblclick write SetFOnItemdblclick;
    property OnItemkeydown : TExtViewOnItemkeydown read FOnItemkeydown write SetFOnItemkeydown;
    property OnItemmousedown : TExtViewOnItemmousedown read FOnItemmousedown write SetFOnItemmousedown;
    property OnItemmouseenter : TExtViewOnItemmouseenter read FOnItemmouseenter write SetFOnItemmouseenter;
    property OnItemmouseleave : TExtViewOnItemmouseleave read FOnItemmouseleave write SetFOnItemmouseleave;
    property OnItemmouseup : TExtViewOnItemmouseup read FOnItemmouseup write SetFOnItemmouseup;
    property OnSelect : TExtViewOnSelect read FOnSelect write SetFOnSelect;
    property OnSelectionchange : TExtViewOnSelectionchange read FOnSelectionchange write SetFOnSelectionchange;
    property OnUnhighlightitem : TExtViewOnUnhighlightitem read FOnUnhighlightitem write SetFOnUnhighlightitem;
  end;

  TExtGridFeatureRowWrap = class(TExtGridFeature)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridFeatureRowBody = class(TExtGridFeature)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetupRowData(Data : TExtObject; Idx : Integer; RecordJS : TExtDataModel; Orig : TExtObject) : TExtFunction;
  end;

  // Procedural types for events TExtGridFeatureGrouping
  TExtGridFeatureGroupingOnGroupclick = procedure(View : TExtViewTable; Node : THTMLElement; Group : String; E : TExtEventObject) of object;
  TExtGridFeatureGroupingOnGroupcollapse = procedure(View : TExtViewTable; Node : THTMLElement; Group : String) of object;
  TExtGridFeatureGroupingOnGroupcontextmenu = procedure(View : TExtViewTable; Node : THTMLElement; Group : String; E : TExtEventObject) of object;
  TExtGridFeatureGroupingOnGroupdblclick = procedure(View : TExtViewTable; Node : THTMLElement; Group : String; E : TExtEventObject) of object;
  TExtGridFeatureGroupingOnGroupexpand = procedure(View : TExtViewTable; Node : THTMLElement; Group : String) of object;

  TExtGridFeatureGrouping = class(TExtGridFeature)
  private
    FCollapsible : Boolean;
    FDepthToIndent : Integer;
    FEnableGroupingMenu : Boolean;
    FEnableNoGroups : Boolean;
    FGroupByText : String;
    FGroupHeaderTpl : String;
    FGroupHeaderTplChildren : TExtObjectList;
    FGroupHeaderTplList : TExtObjectList;
    FGroupHeaderTplRows : TExtObjectList;
    FGroupHeaderTplTemplate : TExtTemplate;
    FHideGroupedHeader : Boolean;
    FRemoteRoot : String;
    FShowGroupsText : String;
    FStartCollapsed : Boolean;
    FOnGroupclick : TExtGridFeatureGroupingOnGroupclick;
    FOnGroupcollapse : TExtGridFeatureGroupingOnGroupcollapse;
    FOnGroupcontextmenu : TExtGridFeatureGroupingOnGroupcontextmenu;
    FOnGroupdblclick : TExtGridFeatureGroupingOnGroupdblclick;
    FOnGroupexpand : TExtGridFeatureGroupingOnGroupexpand;
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFDepthToIndent(Value : Integer);
    procedure SetFEnableGroupingMenu(Value : Boolean);
    procedure SetFEnableNoGroups(Value : Boolean);
    procedure SetFGroupByText(Value : String);
    procedure SetFGroupHeaderTpl(Value : String);
    procedure SetFGroupHeaderTplChildren(Value : TExtObjectList);
    procedure SetFGroupHeaderTplList(Value : TExtObjectList);
    procedure SetFGroupHeaderTplRows(Value : TExtObjectList);
    procedure SetFGroupHeaderTplTemplate(Value : TExtTemplate);
    procedure SetFHideGroupedHeader(Value : Boolean);
    procedure SetFRemoteRoot(Value : String);
    procedure SetFShowGroupsText(Value : String);
    procedure SetFStartCollapsed(Value : Boolean);
    procedure SetFOnGroupclick(Value : TExtGridFeatureGroupingOnGroupclick);
    procedure SetFOnGroupcollapse(Value : TExtGridFeatureGroupingOnGroupcollapse);
    procedure SetFOnGroupcontextmenu(Value : TExtGridFeatureGroupingOnGroupcontextmenu);
    procedure SetFOnGroupdblclick(Value : TExtGridFeatureGroupingOnGroupdblclick);
    procedure SetFOnGroupexpand(Value : TExtGridFeatureGroupingOnGroupexpand);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Collapse(GroupName : String; Focus : Boolean) : TExtFunction;
    function CollapseAll : TExtFunction;
    constructor Create;
    function Expand(GroupName : String; Focus : Boolean) : TExtFunction;
    function ExpandAll : TExtFunction;
    function GetRecordGroup(RecordJS : TExtDataModel) : TExtFunction;
    function IsExpanded(GroupName : String) : TExtFunction;
    function ToggleSummaryRow(Visible : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property DepthToIndent : Integer read FDepthToIndent write SetFDepthToIndent;
    property EnableGroupingMenu : Boolean read FEnableGroupingMenu write SetFEnableGroupingMenu;
    property EnableNoGroups : Boolean read FEnableNoGroups write SetFEnableNoGroups;
    property GroupByText : String read FGroupByText write SetFGroupByText;
    property GroupHeaderTpl : String read FGroupHeaderTpl write SetFGroupHeaderTpl;
    property GroupHeaderTplChildren : TExtObjectList read FGroupHeaderTplChildren write SetFGroupHeaderTplChildren;
    property GroupHeaderTplList : TExtObjectList read FGroupHeaderTplList write SetFGroupHeaderTplList;
    property GroupHeaderTplRows : TExtObjectList read FGroupHeaderTplRows write SetFGroupHeaderTplRows;
    property GroupHeaderTplTemplate : TExtTemplate read FGroupHeaderTplTemplate write SetFGroupHeaderTplTemplate;
    property HideGroupedHeader : Boolean read FHideGroupedHeader write SetFHideGroupedHeader;
    property RemoteRoot : String read FRemoteRoot write SetFRemoteRoot;
    property ShowGroupsText : String read FShowGroupsText write SetFShowGroupsText;
    property StartCollapsed : Boolean read FStartCollapsed write SetFStartCollapsed;
    property OnGroupclick : TExtGridFeatureGroupingOnGroupclick read FOnGroupclick write SetFOnGroupclick;
    property OnGroupcollapse : TExtGridFeatureGroupingOnGroupcollapse read FOnGroupcollapse write SetFOnGroupcollapse;
    property OnGroupcontextmenu : TExtGridFeatureGroupingOnGroupcontextmenu read FOnGroupcontextmenu write SetFOnGroupcontextmenu;
    property OnGroupdblclick : TExtGridFeatureGroupingOnGroupdblclick read FOnGroupdblclick write SetFOnGroupdblclick;
    property OnGroupexpand : TExtGridFeatureGroupingOnGroupexpand read FOnGroupexpand write SetFOnGroupexpand;
  end;

  TExtGridFeatureAbstractSummary = class(TExtGridFeature)
  private
    FRemoteRoot : String;
    procedure SetFRemoteRoot(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ToggleSummaryRow(Visible : Boolean) : TExtFunction;
    property RemoteRoot : String read FRemoteRoot write SetFRemoteRoot;
  end;

  TExtDataProxyAjax = class(TExtDataProxyServer)
  private
    FActionMethods : TExtObject;
    FBinary : Boolean;
    FHeaders : TExtObject;
    procedure SetFActionMethods(Value : TExtObject);
    procedure SetFBinary(Value : Boolean);
    procedure SetFHeaders(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetMethod(Request : TExtDataRequest) : TExtFunction;
    destructor Destroy; override;
    property ActionMethods : TExtObject read FActionMethods write SetFActionMethods;
    property Binary : Boolean read FBinary write SetFBinary;
    property Headers : TExtObject read FHeaders write SetFHeaders;
  end;

  // Procedural types for events TExtGridPluginCellEditing
  TExtGridPluginCellEditingOnBeforeedit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnCanceledit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnEdit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;
  TExtGridPluginCellEditingOnValidateedit = procedure(Editor : TExtGridPluginCellEditing; E : TExtObject) of object;

  TExtGridPluginCellEditing = class(TExtGridPluginEditing)
  private
    FOnBeforeedit : TExtGridPluginCellEditingOnBeforeedit;
    FOnCanceledit : TExtGridPluginCellEditingOnCanceledit;
    FOnEdit : TExtGridPluginCellEditingOnEdit;
    FOnValidateedit : TExtGridPluginCellEditingOnValidateedit;
    procedure SetFOnBeforeedit(Value : TExtGridPluginCellEditingOnBeforeedit);
    procedure SetFOnCanceledit(Value : TExtGridPluginCellEditingOnCanceledit);
    procedure SetFOnEdit(Value : TExtGridPluginCellEditingOnEdit);
    procedure SetFOnValidateedit(Value : TExtGridPluginCellEditingOnValidateedit);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CancelEdit : TExtFunction;
    function StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; overload;
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; overload;
    function StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; overload;
    function StartEditByPosition(Position : TExtObject) : TExtFunction;
    property OnBeforeedit : TExtGridPluginCellEditingOnBeforeedit read FOnBeforeedit write SetFOnBeforeedit;
    property OnCanceledit : TExtGridPluginCellEditingOnCanceledit read FOnCanceledit write SetFOnCanceledit;
    property OnEdit : TExtGridPluginCellEditingOnEdit read FOnEdit write SetFOnEdit;
    property OnValidateedit : TExtGridPluginCellEditingOnValidateedit read FOnValidateedit write SetFOnValidateedit;
  end;

  TExtGridPluginRowEditing = class(TExtGridPluginEditing)
  private
    FAutoCancel : Boolean;
    FClicksToMoveEditor : Integer;
    FErrorSummary : Boolean;
    procedure SetFAutoCancel(Value : Boolean);
    procedure SetFClicksToMoveEditor(Value : Integer);
    procedure SetFErrorSummary(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction;
    property AutoCancel : Boolean read FAutoCancel write SetFAutoCancel;
    property ClicksToMoveEditor : Integer read FClicksToMoveEditor write SetFClicksToMoveEditor;
    property ErrorSummary : Boolean read FErrorSummary write SetFErrorSummary;
  end;

  TExtGridPropertyStore = class(TExtDataStore)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Grid : TExtGridPanel; Source : TExtObject);
  end;

  TExtDataProxyWebStorage = class(TExtDataProxyClient)
  private
    FCache : TExtObject;
    FId : String;
    procedure SetFCache(Value : TExtObject);
    procedure SetFId(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Clear : TExtFunction;
    constructor Create(Config : TExtObject = nil);
    function SetRecord(RecordJS : TExtDataModel; Id : String = '') : TExtFunction;
    destructor Destroy; override;
    property Cache : TExtObject read FCache write SetFCache;
    property Id : String read FId write SetFId;
  end;

  TExtLayoutContainerTable = class(TExtLayoutContainer)
  private
    FColumns : Integer;
    FTableAttrs : TExtObject;
    FTdAttrs : TExtObject;
    FTrAttrs : TExtObject;
    procedure SetFColumns(Value : Integer);
    procedure SetFTableAttrs(Value : TExtObject);
    procedure SetFTdAttrs(Value : TExtObject);
    procedure SetFTrAttrs(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Columns : Integer read FColumns write SetFColumns;
    property TableAttrs : TExtObject read FTableAttrs write SetFTableAttrs;
    property TdAttrs : TExtObject read FTdAttrs write SetFTdAttrs;
    property TrAttrs : TExtObject read FTrAttrs write SetFTrAttrs;
  end;

  TExtFormCheckboxManagerSingleton = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormActionStandardSubmit = class(TExtFormActionSubmit)
  private
    FTarget : String;
    procedure SetFTarget(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Target : String read FTarget write SetFTarget;
  end;

  TExtDrawText = class(TExtDrawComponent)
  private
    FDegrees : Integer;
    FStyleSelector : String;
    FText : String;
    procedure SetFDegrees(Value : Integer);
    procedure SetFStyleSelector(Value : String);
    procedure SetFText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function SetAngle(Degrees : Integer) : TExtFunction;
    function SetText(T : String) : TExtFunction;
    property Degrees : Integer read FDegrees write SetFDegrees;
    property StyleSelector : String read FStyleSelector write SetFStyleSelector;
    property Text : String read FText write SetFText;
  end;

  TExtLayoutContainerFit = class(TExtLayoutContainer)
  private
    FDefaultMargins : TExtObject;
    procedure SetFDefaultMargins(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DefaultMargins : TExtObject read FDefaultMargins write SetFDefaultMargins;
  end;

  TExtLayoutContainerEditor = class(TExtLayoutContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormRadioManagerSingleton = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerCheckboxGroup = class(TExtLayoutContainer)
  private
    FAutoFlex : Boolean;
    procedure SetFAutoFlex(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AutoFlex : Boolean read FAutoFlex write SetFAutoFlex;
  end;

  TExtDataReaderArray = class(TExtDataReaderJson)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtMenuCheckItem
  TExtMenuCheckItemOnBeforecheckchange = procedure(This : TExtMenuCheckItem; Checked : Boolean) of object;
  TExtMenuCheckItemOnCheckchange = procedure(This : TExtMenuCheckItem; Checked : Boolean) of object;

  TExtMenuCheckItem = class(TExtMenuItem)
  private
    FCheckChangeDisabled : Boolean;
    FChecked : Boolean;
    FCheckedCls : String;
    FCheckHandler : TExtFunction;
    FGroup : String;
    FGroupCls : String;
    FHideOnClick : Boolean; // true
    FScope : TExtObject;
    FUncheckedCls : String;
    FOnBeforecheckchange : TExtMenuCheckItemOnBeforecheckchange;
    FOnCheckchange : TExtMenuCheckItemOnCheckchange;
    procedure SetFCheckChangeDisabled(Value : Boolean);
    procedure SetFChecked(Value : Boolean);
    procedure SetFCheckedCls(Value : String);
    procedure SetFCheckHandler(Value : TExtFunction);
    procedure SetFGroup(Value : String);
    procedure SetFGroupCls(Value : String);
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFScope(Value : TExtObject);
    procedure SetFUncheckedCls(Value : String);
    procedure SetFOnBeforecheckchange(Value : TExtMenuCheckItemOnBeforecheckchange);
    procedure SetFOnCheckchange(Value : TExtMenuCheckItemOnCheckchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DisableCheckChange : TExtFunction;
    function EnableCheckChange : TExtFunction;
    function SetChecked(Checked : Boolean; SuppressEvents : Boolean = false) : TExtFunction;
    destructor Destroy; override;
    property CheckChangeDisabled : Boolean read FCheckChangeDisabled write SetFCheckChangeDisabled;
    property Checked : Boolean read FChecked write SetFChecked;
    property CheckedCls : String read FCheckedCls write SetFCheckedCls;
    property CheckHandler : TExtFunction read FCheckHandler write SetFCheckHandler;
    property Group : String read FGroup write SetFGroup;
    property GroupCls : String read FGroupCls write SetFGroupCls;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property Scope : TExtObject read FScope write SetFScope;
    property UncheckedCls : String read FUncheckedCls write SetFUncheckedCls;
    property OnBeforecheckchange : TExtMenuCheckItemOnBeforecheckchange read FOnBeforecheckchange write SetFOnBeforecheckchange;
    property OnCheckchange : TExtMenuCheckItemOnCheckchange read FOnCheckchange write SetFOnCheckchange;
  end;

  TExtFormActionDirectLoad = class(TExtFormActionLoad)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormFieldCheckbox = class(TExtFormFieldBase)
  private
    FAfterBoxLabelTextTpl : String;
    FAfterBoxLabelTextTplList : TExtObjectList;
    FAfterBoxLabelTextTplTemplate : TExtXTemplate;
    FAfterBoxLabelTpl : String;
    FAfterBoxLabelTplList : TExtObjectList;
    FAfterBoxLabelTplTemplate : TExtXTemplate;
    FBeforeBoxLabelTextTpl : String;
    FBeforeBoxLabelTextTplList : TExtObjectList;
    FBeforeBoxLabelTextTplTemplate : TExtXTemplate;
    FBeforeBoxLabelTpl : String;
    FBeforeBoxLabelTplList : TExtObjectList;
    FBeforeBoxLabelTplTemplate : TExtXTemplate;
    FBoxLabel : String;
    FBoxLabelAlign : String;
    FBoxLabelAttrTpl : String;
    FBoxLabelAttrTplList : TExtObjectList;
    FBoxLabelAttrTplTemplate : TExtXTemplate;
    FBoxLabelCls : String;
    FBoxLabelEl : TExtElement;
    FChecked : Boolean;
    FCheckedCls : String;
    FFieldBodyCls : String;
    FFieldCls : String;
    FFocusCls : String;
    FHandler : TExtFunction;
    FHandlerCheckbox : TExtFormFieldCheckbox;
    FHandlerChecked : Boolean;
    FInputValue : String;
    FIsCheckbox : Boolean;
    FOriginalValue : TExtObject;
    FScope : TExtObject;
    FUncheckedValue : String;
    procedure SetFAfterBoxLabelTextTpl(Value : String);
    procedure SetFAfterBoxLabelTextTplList(Value : TExtObjectList);
    procedure SetFAfterBoxLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterBoxLabelTpl(Value : String);
    procedure SetFAfterBoxLabelTplList(Value : TExtObjectList);
    procedure SetFAfterBoxLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeBoxLabelTextTpl(Value : String);
    procedure SetFBeforeBoxLabelTextTplList(Value : TExtObjectList);
    procedure SetFBeforeBoxLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeBoxLabelTpl(Value : String);
    procedure SetFBeforeBoxLabelTplList(Value : TExtObjectList);
    procedure SetFBeforeBoxLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFBoxLabel(Value : String);
    procedure SetFBoxLabelAlign(Value : String);
    procedure SetFBoxLabelAttrTpl(Value : String);
    procedure SetFBoxLabelAttrTplList(Value : TExtObjectList);
    procedure SetFBoxLabelAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFBoxLabelCls(Value : String);
    procedure SetFBoxLabelEl(Value : TExtElement);
    procedure SetFChecked(Value : Boolean);
    procedure SetFCheckedCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFFieldCls(Value : String);
    procedure SetFFocusCls(Value : String);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFHandlerCheckbox(Value : TExtFormFieldCheckbox);
    procedure SetFHandlerChecked(Value : Boolean);
    procedure SetFInputValue(Value : String);
    procedure SetFIsCheckbox(Value : Boolean);
    procedure SetFOriginalValue(Value : TExtObject);
    procedure SetFScope(Value : TExtObject);
    procedure SetFUncheckedValue(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetRawValue : TExtFunction;
    function GetSubmitValue : TExtFunction;
    function GetValue : TExtFunction;
    function SetBoxLabel(BoxLabel : String) : TExtFunction;
    function SetRawValue(Value : String) : TExtFunction; overload;
    function SetRawValue(Value : Integer) : TExtFunction; overload;
    function SetRawValue(Value : Boolean) : TExtFunction; overload;
    function SetValue(Checked : String) : TExtFunction; overload;
    function SetValue(Checked : Boolean) : TExtFunction; overload;
    destructor Destroy; override;
    property AfterBoxLabelTextTpl : String read FAfterBoxLabelTextTpl write SetFAfterBoxLabelTextTpl;
    property AfterBoxLabelTextTplList : TExtObjectList read FAfterBoxLabelTextTplList write SetFAfterBoxLabelTextTplList;
    property AfterBoxLabelTextTplTemplate : TExtXTemplate read FAfterBoxLabelTextTplTemplate write SetFAfterBoxLabelTextTplTemplate;
    property AfterBoxLabelTpl : String read FAfterBoxLabelTpl write SetFAfterBoxLabelTpl;
    property AfterBoxLabelTplList : TExtObjectList read FAfterBoxLabelTplList write SetFAfterBoxLabelTplList;
    property AfterBoxLabelTplTemplate : TExtXTemplate read FAfterBoxLabelTplTemplate write SetFAfterBoxLabelTplTemplate;
    property BeforeBoxLabelTextTpl : String read FBeforeBoxLabelTextTpl write SetFBeforeBoxLabelTextTpl;
    property BeforeBoxLabelTextTplList : TExtObjectList read FBeforeBoxLabelTextTplList write SetFBeforeBoxLabelTextTplList;
    property BeforeBoxLabelTextTplTemplate : TExtXTemplate read FBeforeBoxLabelTextTplTemplate write SetFBeforeBoxLabelTextTplTemplate;
    property BeforeBoxLabelTpl : String read FBeforeBoxLabelTpl write SetFBeforeBoxLabelTpl;
    property BeforeBoxLabelTplList : TExtObjectList read FBeforeBoxLabelTplList write SetFBeforeBoxLabelTplList;
    property BeforeBoxLabelTplTemplate : TExtXTemplate read FBeforeBoxLabelTplTemplate write SetFBeforeBoxLabelTplTemplate;
    property BoxLabel : String read FBoxLabel write SetFBoxLabel;
    property BoxLabelAlign : String read FBoxLabelAlign write SetFBoxLabelAlign;
    property BoxLabelAttrTpl : String read FBoxLabelAttrTpl write SetFBoxLabelAttrTpl;
    property BoxLabelAttrTplList : TExtObjectList read FBoxLabelAttrTplList write SetFBoxLabelAttrTplList;
    property BoxLabelAttrTplTemplate : TExtXTemplate read FBoxLabelAttrTplTemplate write SetFBoxLabelAttrTplTemplate;
    property BoxLabelCls : String read FBoxLabelCls write SetFBoxLabelCls;
    property BoxLabelEl : TExtElement read FBoxLabelEl write SetFBoxLabelEl;
    property Checked : Boolean read FChecked write SetFChecked;
    property CheckedCls : String read FCheckedCls write SetFCheckedCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property FieldCls : String read FFieldCls write SetFFieldCls;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property HandlerCheckbox : TExtFormFieldCheckbox read FHandlerCheckbox write SetFHandlerCheckbox;
    property HandlerChecked : Boolean read FHandlerChecked write SetFHandlerChecked;
    property InputValue : String read FInputValue write SetFInputValue;
    property IsCheckbox : Boolean read FIsCheckbox write SetFIsCheckbox;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
    property Scope : TExtObject read FScope write SetFScope;
    property UncheckedValue : String read FUncheckedValue write SetFUncheckedValue;
  end;

  TExtDataStoreManagerSingleton = class(TExtUtilMixedCollection)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Lookup(Store : TExtObject) : TExtFunction; overload;
    function Lookup(Store : String) : TExtFunction; overload;
    function Register(Stores : TExtDataStore) : TExtFunction;
    function Unregister(Stores : TExtObjectList) : TExtFunction; overload;
    function Unregister(Stores : String) : TExtFunction; overload;
  end;

  TExtLayoutContainerAuto = class(TExtLayoutContainer)
  private
    FManageOverflow : Boolean;
    FManagePadding : Boolean;
    FReserveScrollbar : Boolean;
    procedure SetFManageOverflow(Value : Boolean);
    procedure SetFManagePadding(Value : Boolean);
    procedure SetFReserveScrollbar(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ManageOverflow : Boolean read FManageOverflow write SetFManageOverflow;
    property ManagePadding : Boolean read FManagePadding write SetFManagePadding;
    property ReserveScrollbar : Boolean read FReserveScrollbar write SetFReserveScrollbar;
  end;

  TExtLayoutContainerBox = class(TExtLayoutContainer)
  private
    FDefaultMargins : TExtObject;
    FFlex : Integer;
    FPack : String;
    FPadding : String;
    FStretchMaxPartner : String;
    FStretchMaxPartnerComponent : TExtComponent;
    procedure SetFDefaultMargins(Value : TExtObject);
    procedure SetFFlex(Value : Integer);
    procedure SetFPack(Value : String);
    procedure SetFPadding(Value : String);
    procedure SetFStretchMaxPartner(Value : String);
    procedure SetFStretchMaxPartnerComponent(Value : TExtComponent);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DefaultMargins : TExtObject read FDefaultMargins write SetFDefaultMargins;
    property Flex : Integer read FFlex write SetFFlex;
    property Pack : String read FPack write SetFPack;
    property Padding : String read FPadding write SetFPadding;
    property StretchMaxPartner : String read FStretchMaxPartner write SetFStretchMaxPartner;
    property StretchMaxPartnerComponent : TExtComponent read FStretchMaxPartnerComponent write SetFStretchMaxPartnerComponent;
  end;

  TExtLayoutContainerForm = class(TExtLayoutContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CalculateOverflow(OwnerContext : TExtLayoutContextItem; ContainerSize : TExtObject; Dimensions : Integer) : TExtFunction;
    function DoRenderPadder : TExtFunction;
  end;

  TExtFormActionDirectSubmit = class(TExtFormActionSubmit)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerBorder = class(TExtLayoutContainer)
  private
    FPadding : Integer;
    FPaddingObject : TExtObject;
    FPaddingString : String;
    FRegionWeights : TExtObject;
    FSplit : Boolean;
    FSplitterResize : Boolean;
    procedure SetFPadding(Value : Integer);
    procedure SetFPaddingObject(Value : TExtObject);
    procedure SetFPaddingString(Value : String);
    procedure SetFRegionWeights(Value : TExtObject);
    procedure SetFSplit(Value : Boolean);
    procedure SetFSplitterResize(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Padding : Integer read FPadding write SetFPadding;
    property PaddingObject : TExtObject read FPaddingObject write SetFPaddingObject;
    property PaddingString : String read FPaddingString write SetFPaddingString;
    property RegionWeights : TExtObject read FRegionWeights write SetFRegionWeights;
    property Split : Boolean read FSplit write SetFSplit;
    property SplitterResize : Boolean read FSplitterResize write SetFSplitterResize;
  end;

  // Procedural types for events TExtViewTable
  TExtViewTableOnBeforecellclick = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnBeforecellcontextmenu = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnBeforecelldblclick = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnBeforecellkeydown = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnBeforecellmousedown = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnBeforecellmouseup = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCellclick = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCellcontextmenu = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCelldblclick = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCellkeydown = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCellmousedown = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;
  TExtViewTableOnCellmouseup = procedure(This : TExtViewTable; Td : THTMLElement; CellIndex : Integer; RecordJS : TExtDataModel; Tr : THTMLElement; RowIndex : Integer; E : TExtEventObject) of object;

  TExtViewTable = class(TExtView)
  private
    FFirstCls : String;
    FLastCls : String;
    FOnBeforecellclick : TExtViewTableOnBeforecellclick;
    FOnBeforecellcontextmenu : TExtViewTableOnBeforecellcontextmenu;
    FOnBeforecelldblclick : TExtViewTableOnBeforecelldblclick;
    FOnBeforecellkeydown : TExtViewTableOnBeforecellkeydown;
    FOnBeforecellmousedown : TExtViewTableOnBeforecellmousedown;
    FOnBeforecellmouseup : TExtViewTableOnBeforecellmouseup;
    FOnCellclick : TExtViewTableOnCellclick;
    FOnCellcontextmenu : TExtViewTableOnCellcontextmenu;
    FOnCelldblclick : TExtViewTableOnCelldblclick;
    FOnCellkeydown : TExtViewTableOnCellkeydown;
    FOnCellmousedown : TExtViewTableOnCellmousedown;
    FOnCellmouseup : TExtViewTableOnCellmouseup;
    procedure SetFFirstCls(Value : String);
    procedure SetFLastCls(Value : String);
    procedure SetFOnBeforecellclick(Value : TExtViewTableOnBeforecellclick);
    procedure SetFOnBeforecellcontextmenu(Value : TExtViewTableOnBeforecellcontextmenu);
    procedure SetFOnBeforecelldblclick(Value : TExtViewTableOnBeforecelldblclick);
    procedure SetFOnBeforecellkeydown(Value : TExtViewTableOnBeforecellkeydown);
    procedure SetFOnBeforecellmousedown(Value : TExtViewTableOnBeforecellmousedown);
    procedure SetFOnBeforecellmouseup(Value : TExtViewTableOnBeforecellmouseup);
    procedure SetFOnCellclick(Value : TExtViewTableOnCellclick);
    procedure SetFOnCellcontextmenu(Value : TExtViewTableOnCellcontextmenu);
    procedure SetFOnCelldblclick(Value : TExtViewTableOnCelldblclick);
    procedure SetFOnCellkeydown(Value : TExtViewTableOnCellkeydown);
    procedure SetFOnCellmousedown(Value : TExtViewTableOnCellmousedown);
    procedure SetFOnCellmouseup(Value : TExtViewTableOnCellmouseup);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : String; Cls : String) : TExtFunction; overload;
    function AddRowCls(RowInfo : Integer; Cls : String) : TExtFunction; overload;
    function AutoSizeColumn(Header : TExtGridColumn) : TExtFunction; overload;
    function AutoSizeColumn(Header : Integer) : TExtFunction; overload;
    function FocusRow(RowIdx : THTMLElement) : TExtFunction; overload;
    function FocusRow(RowIdx : TExtDataModel) : TExtFunction; overload;
    function FocusRow(RowIdx : String) : TExtFunction; overload;
    function FocusRow(RowIdx : Integer) : TExtFunction; overload;
    function GetBodySelector : TExtFunction;
    function GetCellSelector(Header : TExtGridColumn = nil) : TExtFunction;
    function GetColumnSizerSelector : TExtFunction;
    function GetDataRowSelector : TExtFunction;
    function GetFeature(Id : String) : TExtFunction;
    function GetItemSelector : TExtFunction;
    function GetNode(NodeInfo : THTMLElement; DataRow : Boolean = false) : TExtFunction; overload;
    function GetNode(NodeInfo : TExtDataModel; DataRow : Boolean = false) : TExtFunction; overload;
    function GetNode(NodeInfo : String; DataRow : Boolean = false) : TExtFunction; overload;
    function GetNode(NodeInfo : Integer; DataRow : Boolean = false) : TExtFunction; overload;
    function GetNodeContainerSelector : TExtFunction;
    function Refresh : TExtFunction;
    function RemoveRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : String; Cls : String) : TExtFunction; overload;
    function RemoveRowCls(RowInfo : Integer; Cls : String) : TExtFunction; overload;
    function WalkRecs(StartRec : TExtDataModel; Distance : Integer) : TExtFunction;
    function WalkRows(StartRow : Integer; Distance : Integer) : TExtFunction;
    property FirstCls : String read FFirstCls write SetFFirstCls;
    property LastCls : String read FLastCls write SetFLastCls;
    property OnBeforecellclick : TExtViewTableOnBeforecellclick read FOnBeforecellclick write SetFOnBeforecellclick;
    property OnBeforecellcontextmenu : TExtViewTableOnBeforecellcontextmenu read FOnBeforecellcontextmenu write SetFOnBeforecellcontextmenu;
    property OnBeforecelldblclick : TExtViewTableOnBeforecelldblclick read FOnBeforecelldblclick write SetFOnBeforecelldblclick;
    property OnBeforecellkeydown : TExtViewTableOnBeforecellkeydown read FOnBeforecellkeydown write SetFOnBeforecellkeydown;
    property OnBeforecellmousedown : TExtViewTableOnBeforecellmousedown read FOnBeforecellmousedown write SetFOnBeforecellmousedown;
    property OnBeforecellmouseup : TExtViewTableOnBeforecellmouseup read FOnBeforecellmouseup write SetFOnBeforecellmouseup;
    property OnCellclick : TExtViewTableOnCellclick read FOnCellclick write SetFOnCellclick;
    property OnCellcontextmenu : TExtViewTableOnCellcontextmenu read FOnCellcontextmenu write SetFOnCellcontextmenu;
    property OnCelldblclick : TExtViewTableOnCelldblclick read FOnCelldblclick write SetFOnCelldblclick;
    property OnCellkeydown : TExtViewTableOnCellkeydown read FOnCellkeydown write SetFOnCellkeydown;
    property OnCellmousedown : TExtViewTableOnCellmousedown read FOnCellmousedown write SetFOnCellmousedown;
    property OnCellmouseup : TExtViewTableOnCellmouseup read FOnCellmouseup write SetFOnCellmouseup;
  end;

  TExtGridFeatureGroupingSummary = class(TExtGridFeatureGrouping)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridFeatureSummary = class(TExtGridFeatureAbstractSummary)
  private
    FDock : String;
    procedure SetFDock(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Dock : String read FDock write SetFDock;
  end;

  // Procedural types for events TExtGridHeaderContainer
  TExtGridHeaderContainerOnColumnhide = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn) of object;
  TExtGridHeaderContainerOnColumnmove = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; FromIdx : Integer; ToIdx : Integer) of object;
  TExtGridHeaderContainerOnColumnresize = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; Width : Integer) of object;
  TExtGridHeaderContainerOnColumnschanged = procedure(Ct : TExtGridHeaderContainer) of object;
  TExtGridHeaderContainerOnColumnshow = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn) of object;
  TExtGridHeaderContainerOnHeaderclick = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; E : TExtEventObject; T : THTMLElement) of object;
  TExtGridHeaderContainerOnHeadercontextmenu = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; E : TExtEventObject; T : THTMLElement) of object;
  TExtGridHeaderContainerOnHeadertriggerclick = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; E : TExtEventObject; T : THTMLElement) of object;
  TExtGridHeaderContainerOnMenucreate = procedure(Ct : TExtGridHeaderContainer; Menu : TExtMenu) of object;
  TExtGridHeaderContainerOnSortchange = procedure(Ct : TExtGridHeaderContainer; Column : TExtGridColumn; Direction : String) of object;

  TExtGridHeaderContainer = class(TExtContainer)
  private
    FDefaultWidth : Integer;
    FEnableColumnHide : Boolean;
    FIsGroupHeader : Boolean;
    FSealed : Boolean;
    FSortable : Boolean;
    FWeight : Integer;
    FOnColumnhide : TExtGridHeaderContainerOnColumnhide;
    FOnColumnmove : TExtGridHeaderContainerOnColumnmove;
    FOnColumnresize : TExtGridHeaderContainerOnColumnresize;
    FOnColumnschanged : TExtGridHeaderContainerOnColumnschanged;
    FOnColumnshow : TExtGridHeaderContainerOnColumnshow;
    FOnHeaderclick : TExtGridHeaderContainerOnHeaderclick;
    FOnHeadercontextmenu : TExtGridHeaderContainerOnHeadercontextmenu;
    FOnHeadertriggerclick : TExtGridHeaderContainerOnHeadertriggerclick;
    FOnMenucreate : TExtGridHeaderContainerOnMenucreate;
    FOnSortchange : TExtGridHeaderContainerOnSortchange;
    procedure SetFDefaultWidth(Value : Integer);
    procedure SetFEnableColumnHide(Value : Boolean);
    procedure SetFIsGroupHeader(Value : Boolean);
    procedure SetFSealed(Value : Boolean);
    procedure SetFSortable(Value : Boolean);
    procedure SetFWeight(Value : Integer);
    procedure SetFOnColumnhide(Value : TExtGridHeaderContainerOnColumnhide);
    procedure SetFOnColumnmove(Value : TExtGridHeaderContainerOnColumnmove);
    procedure SetFOnColumnresize(Value : TExtGridHeaderContainerOnColumnresize);
    procedure SetFOnColumnschanged(Value : TExtGridHeaderContainerOnColumnschanged);
    procedure SetFOnColumnshow(Value : TExtGridHeaderContainerOnColumnshow);
    procedure SetFOnHeaderclick(Value : TExtGridHeaderContainerOnHeaderclick);
    procedure SetFOnHeadercontextmenu(Value : TExtGridHeaderContainerOnHeadercontextmenu);
    procedure SetFOnHeadertriggerclick(Value : TExtGridHeaderContainerOnHeadertriggerclick);
    procedure SetFOnMenucreate(Value : TExtGridHeaderContainerOnMenucreate);
    procedure SetFOnSortchange(Value : TExtGridHeaderContainerOnSortchange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetColumnCount : TExtFunction;
    function GetColumnMenu : TExtFunction;
    function GetFullWidth : TExtFunction;
    function GetGridColumns : TExtFunction;
    function GetHeaderAtIndex(Index : Integer) : TExtFunction;
    function GetHeaderIndex(Header : TExtGridColumn) : TExtFunction;
    function GetMenuItems : TExtFunction;
    function GetVisibleGridColumns : TExtFunction;
    function GetVisibleHeaderClosestToIndex(Index : Integer) : TExtFunction;
    property DefaultWidth : Integer read FDefaultWidth write SetFDefaultWidth;
    property EnableColumnHide : Boolean read FEnableColumnHide write SetFEnableColumnHide;
    property IsGroupHeader : Boolean read FIsGroupHeader write SetFIsGroupHeader;
    property Sealed : Boolean read FSealed write SetFSealed;
    property Sortable : Boolean read FSortable write SetFSortable;
    property Weight : Integer read FWeight write SetFWeight;
    property OnColumnhide : TExtGridHeaderContainerOnColumnhide read FOnColumnhide write SetFOnColumnhide;
    property OnColumnmove : TExtGridHeaderContainerOnColumnmove read FOnColumnmove write SetFOnColumnmove;
    property OnColumnresize : TExtGridHeaderContainerOnColumnresize read FOnColumnresize write SetFOnColumnresize;
    property OnColumnschanged : TExtGridHeaderContainerOnColumnschanged read FOnColumnschanged write SetFOnColumnschanged;
    property OnColumnshow : TExtGridHeaderContainerOnColumnshow read FOnColumnshow write SetFOnColumnshow;
    property OnHeaderclick : TExtGridHeaderContainerOnHeaderclick read FOnHeaderclick write SetFOnHeaderclick;
    property OnHeadercontextmenu : TExtGridHeaderContainerOnHeadercontextmenu read FOnHeadercontextmenu write SetFOnHeadercontextmenu;
    property OnHeadertriggerclick : TExtGridHeaderContainerOnHeadertriggerclick read FOnHeadertriggerclick write SetFOnHeadertriggerclick;
    property OnMenucreate : TExtGridHeaderContainerOnMenucreate read FOnMenucreate write SetFOnMenucreate;
    property OnSortchange : TExtGridHeaderContainerOnSortchange read FOnSortchange write SetFOnSortchange;
  end;

  // Procedural types for events TExtToolbar
  TExtToolbarOnOverflowchange = procedure(LastHiddenCount : Integer; HiddenCount : Integer; The : TExtObjectList) of object;

  TExtToolbar = class(TExtContainer)
  private
    FDefaultButtonUI : String;
    FEnableOverflow : Boolean;
    FIsToolbar : Boolean;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    FMenuTriggerCls : String;
    FVertical : Boolean;
    FOnOverflowchange : TExtToolbarOnOverflowchange;
    procedure SetFDefaultButtonUI(Value : String);
    procedure SetFEnableOverflow(Value : Boolean);
    procedure SetFIsToolbar(Value : Boolean);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
    procedure SetFMenuTriggerCls(Value : String);
    procedure SetFVertical(Value : Boolean);
    procedure SetFOnOverflowchange(Value : TExtToolbarOnOverflowchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property DefaultButtonUI : String read FDefaultButtonUI write SetFDefaultButtonUI;
    property EnableOverflow : Boolean read FEnableOverflow write SetFEnableOverflow;
    property IsToolbar : Boolean read FIsToolbar write SetFIsToolbar;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
    property MenuTriggerCls : String read FMenuTriggerCls write SetFMenuTriggerCls;
    property Vertical : Boolean read FVertical write SetFVertical;
    property OnOverflowchange : TExtToolbarOnOverflowchange read FOnOverflowchange write SetFOnOverflowchange;
  end;

  TExtViewTableLayout = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartAxisTime = class(TExtChartAxisNumeric)
  private
    FConstrain : Boolean;
    FDateFormat : String;
    FDateFormatBoolean : Boolean;
    FFromDate : TDateTime;
    FStep : TExtObjectList;
    FToDate : TDateTime;
    procedure SetFConstrain(Value : Boolean);
    procedure SetFDateFormat(Value : String);
    procedure SetFDateFormatBoolean(Value : Boolean);
    procedure SetFFromDate(Value : TDateTime);
    procedure SetFStep(Value : TExtObjectList);
    procedure SetFToDate(Value : TDateTime);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property DateFormat : String read FDateFormat write SetFDateFormat;
    property DateFormatBoolean : Boolean read FDateFormatBoolean write SetFDateFormatBoolean;
    property FromDate : TDateTime read FFromDate write SetFFromDate;
    property Step : TExtObjectList read FStep write SetFStep;
    property ToDate : TDateTime read FToDate write SetFToDate;
  end;

  // Procedural types for events TExtFormFieldTextArea
  TExtFormFieldTextAreaOnAutosize = procedure(This : TExtFormFieldTextArea; Height : Integer) of object;

  TExtFormFieldTextArea = class(TExtFormFieldText)
  private
    FCols : Integer;
    FEnterIsSpecial : Boolean;
    FGrowAppend : String;
    FGrowMax : Integer;
    FGrowMin : Integer;
    FPreventScrollbars : Boolean;
    FRows : Integer; // 4
    FOnAutosize : TExtFormFieldTextAreaOnAutosize;
    procedure SetFCols(Value : Integer);
    procedure SetFEnterIsSpecial(Value : Boolean);
    procedure SetFGrowAppend(Value : String);
    procedure SetFGrowMax(Value : Integer);
    procedure SetFGrowMin(Value : Integer);
    procedure SetFPreventScrollbars(Value : Boolean);
    procedure SetFRows(Value : Integer);
    procedure SetFOnAutosize(Value : TExtFormFieldTextAreaOnAutosize);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AutoSize : TExtFunction;
    constructor Create;
    property Cols : Integer read FCols write SetFCols;
    property EnterIsSpecial : Boolean read FEnterIsSpecial write SetFEnterIsSpecial;
    property GrowAppend : String read FGrowAppend write SetFGrowAppend;
    property GrowMax : Integer read FGrowMax write SetFGrowMax;
    property GrowMin : Integer read FGrowMin write SetFGrowMin;
    property PreventScrollbars : Boolean read FPreventScrollbars write SetFPreventScrollbars;
    property Rows : Integer read FRows write SetFRows;
    property OnAutosize : TExtFormFieldTextAreaOnAutosize read FOnAutosize write SetFOnAutosize;
  end;

  TExtSliderSingle = class(TExtSliderMulti)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetValue : TExtFunction;
    function SetValue(Value : Integer; Animate : Boolean = false) : TExtFunction;
  end;

  TExtFormFieldTrigger = class(TExtFormFieldText)
  private
    FEditable : Boolean;
    FHideTrigger : Boolean;
    FInputCell : TExtElement;
    FReadOnly : Boolean;
    FRepeatTriggerClick : Boolean;
    FSelectOnFocus : Boolean;
    FTriggerCls : String;
    FTriggerEl : TExtCompositeElement;
    FTriggerWrap : TExtElement;
    procedure SetFEditable(Value : Boolean);
    procedure SetFHideTrigger(Value : Boolean);
    procedure SetFInputCell(Value : TExtElement);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFRepeatTriggerClick(Value : Boolean);
    procedure SetFSelectOnFocus(Value : Boolean);
    procedure SetFTriggerCls(Value : String);
    procedure SetFTriggerEl(Value : TExtCompositeElement);
    procedure SetFTriggerWrap(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTriggerWidth : TExtFunction;
    function SetEditable(Editable : Boolean) : TExtFunction;
    function SetReadOnly(ReadOnly : Boolean) : TExtFunction;
    destructor Destroy; override;
    property Editable : Boolean read FEditable write SetFEditable;
    property HideTrigger : Boolean read FHideTrigger write SetFHideTrigger;
    property InputCell : TExtElement read FInputCell write SetFInputCell;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property RepeatTriggerClick : Boolean read FRepeatTriggerClick write SetFRepeatTriggerClick;
    property SelectOnFocus : Boolean read FSelectOnFocus write SetFSelectOnFocus;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property TriggerEl : TExtCompositeElement read FTriggerEl write SetFTriggerEl;
    property TriggerWrap : TExtElement read FTriggerWrap write SetFTriggerWrap;
  end;

  TExtDataProxySessionStorage = class(TExtDataProxyWebStorage)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFxTargetCompositeElementCSS = class(TExtFxTargetCompositeElement)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridColumnComponentLayout = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtSelectionCheckboxModel = class(TExtSelectionRowModel)
  private
    FCheckOnly : Boolean;
    FCheckSelector : String;
    FInjectCheckbox : Integer;
    FInjectCheckboxString : String;
    FMode : TModeEnum;
    FShowHeaderCheckbox : Boolean;
    procedure SetFCheckOnly(Value : Boolean);
    procedure SetFCheckSelector(Value : String);
    procedure SetFInjectCheckbox(Value : Integer);
    procedure SetFInjectCheckboxString(Value : String);
    procedure SetFMode(Value : TModeEnum);
    procedure SetFShowHeaderCheckbox(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetHeaderConfig : TExtFunction;
    function OnHeaderClick : TExtFunction;
    function Renderer : TExtFunction;
    property CheckOnly : Boolean read FCheckOnly write SetFCheckOnly;
    property CheckSelector : String read FCheckSelector write SetFCheckSelector;
    property InjectCheckbox : Integer read FInjectCheckbox write SetFInjectCheckbox;
    property InjectCheckboxString : String read FInjectCheckboxString write SetFInjectCheckboxString;
    property Mode : TModeEnum read FMode write SetFMode;
    property ShowHeaderCheckbox : Boolean read FShowHeaderCheckbox write SetFShowHeaderCheckbox;
  end;

  // Procedural types for events TExtButtonCycle
  TExtButtonCycleOnChange = procedure(This : TExtButtonCycle; Item : TExtMenuCheckItem) of object;

  TExtButtonCycle = class(TExtButtonSplit)
  private
    FChangeHandler : TExtFunction;
    FForceGlyph : Integer;
    FForceGlyphString : String;
    FForceIcon : String;
    FMenu : TExtMenu;
    FPrependText : String;
    FShowText : Boolean;
    FOnChange : TExtButtonCycleOnChange;
    procedure SetFChangeHandler(Value : TExtFunction);
    procedure SetFForceGlyph(Value : Integer);
    procedure SetFForceGlyphString(Value : String);
    procedure SetFForceIcon(Value : String);
    procedure SetFMenu(Value : TExtMenu);
    procedure SetFPrependText(Value : String);
    procedure SetFShowText(Value : Boolean);
    procedure SetFOnChange(Value : TExtButtonCycleOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetActiveItem : TExtFunction;
    function SetActiveItem(Item : TExtMenuCheckItem; SuppressEvent : Boolean = false) : TExtFunction;
    function ToggleSelected : TExtFunction;
    destructor Destroy; override;
    property ChangeHandler : TExtFunction read FChangeHandler write SetFChangeHandler;
    property ForceGlyph : Integer read FForceGlyph write SetFForceGlyph;
    property ForceGlyphString : String read FForceGlyphString write SetFForceGlyphString;
    property ForceIcon : String read FForceIcon write SetFForceIcon;
    property Menu : TExtMenu read FMenu write SetFMenu;
    property PrependText : String read FPrependText write SetFPrependText;
    property ShowText : Boolean read FShowText write SetFShowText;
    property OnChange : TExtButtonCycleOnChange read FOnChange write SetFOnChange;
  end;

  TExtViewBoundList = class(TExtView)
  private
    FDisplayField : String;
    FPageSize : Integer;
    FPagingToolbar : TExtToolbarPaging;
    FTpl : String;
    FTplTemplate : TExtXTemplate;
    procedure SetFDisplayField(Value : String);
    procedure SetFPageSize(Value : Integer);
    procedure SetFPagingToolbar(Value : TExtToolbarPaging);
    procedure SetFTpl(Value : String);
    procedure SetFTplTemplate(Value : TExtXTemplate);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetInnerTpl(DisplayField : String) : TExtFunction;
    destructor Destroy; override;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property PagingToolbar : TExtToolbarPaging read FPagingToolbar write SetFPagingToolbar;
    property Tpl : String read FTpl write SetFTpl;
    property TplTemplate : TExtXTemplate read FTplTemplate write SetFTplTemplate;
  end;

  TExtChartAxisRadial = class(TExtChartAxisNumeric)
  private
    FMaximum : Integer;
    FSteps : Integer;
    procedure SetFMaximum(Value : Integer);
    procedure SetFSteps(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Maximum : Integer read FMaximum write SetFMaximum;
    property Steps : Integer read FSteps write SetFSteps;
  end;

  TExtSelectionTreeModel = class(TExtSelectionRowModel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtEditor
  TExtEditorOnBeforecomplete = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnBeforestartedit = procedure(This : TExtEditor; BoundEl : TExtElement; Value : TExtObject) of object;
  TExtEditorOnCanceledit = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnComplete = procedure(This : TExtEditor; Value : TExtObject; StartValue : TExtObject) of object;
  TExtEditorOnSpecialkey = procedure(This : TExtEditor; Field : TExtFormField; Event : TExtEventObject) of object;
  TExtEditorOnStartedit = procedure(This : TExtEditor; BoundEl : TExtElement; Value : TExtObject) of object;

  TExtEditor = class(TExtContainer)
  private
    FAlignment : String;
    FAllowBlur : Boolean;
    FAutoSize : Boolean;
    FAutoSizeObject : TExtObject;
    FCancelOnEsc : Boolean;
    FCompleteOnEnter : Boolean;
    FConstrain : Boolean;
    FField : TExtFormField;
    FHideEl : Boolean;
    FIgnoreNoChange : Boolean;
    FOffsets : TArrayOfInteger;
    FParentEl : String;
    FParentElElement : TExtElement;
    FParentElTHTMLElement : THTMLElement;
    FRevertInvalid : Boolean;
    FShadow : Boolean;
    FShadowString : String;
    FSwallowKeys : Boolean;
    FUpdateEl : Boolean;
    FValue : TExtObject;
    FOnBeforecomplete : TExtEditorOnBeforecomplete;
    FOnBeforestartedit : TExtEditorOnBeforestartedit;
    FOnCanceledit : TExtEditorOnCanceledit;
    FOnComplete : TExtEditorOnComplete;
    FOnSpecialkey : TExtEditorOnSpecialkey;
    FOnStartedit : TExtEditorOnStartedit;
    procedure SetFAlignment(Value : String);
    procedure SetFAllowBlur(Value : Boolean);
    procedure SetFAutoSize(Value : Boolean);
    procedure SetFAutoSizeObject(Value : TExtObject);
    procedure SetFCancelOnEsc(Value : Boolean);
    procedure SetFCompleteOnEnter(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFField(Value : TExtFormField);
    procedure SetFHideEl(Value : Boolean);
    procedure SetFIgnoreNoChange(Value : Boolean);
    procedure SetFOffsets(Value : TArrayOfInteger);
    procedure SetFParentEl(Value : String);
    procedure SetFParentElElement(Value : TExtElement);
    procedure SetFParentElTHTMLElement(Value : THTMLElement);
    procedure SetFRevertInvalid(Value : Boolean);
    procedure SetFShadow(Value : Boolean);
    procedure SetFShadowString(Value : String);
    procedure SetFSwallowKeys(Value : Boolean);
    procedure SetFUpdateEl(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFOnBeforecomplete(Value : TExtEditorOnBeforecomplete);
    procedure SetFOnBeforestartedit(Value : TExtEditorOnBeforestartedit);
    procedure SetFOnCanceledit(Value : TExtEditorOnCanceledit);
    procedure SetFOnComplete(Value : TExtEditorOnComplete);
    procedure SetFOnSpecialkey(Value : TExtEditorOnSpecialkey);
    procedure SetFOnStartedit(Value : TExtEditorOnStartedit);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CancelEdit(RemainVisible : Boolean = false) : TExtFunction;
    function CompleteEdit(RemainVisible : Boolean = false) : TExtFunction;
    constructor Create;
    function GetValue : TExtFunction;
    function Realign(AutoSize : Boolean = false) : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function StartEdit(El : THTMLElement; Value : String = '') : TExtFunction; overload;
    function StartEdit(El : TExtElement; Value : String = '') : TExtFunction; overload;
    function StartEdit(El : String; Value : String = '') : TExtFunction; overload;
    destructor Destroy; override;
    property Alignment : String read FAlignment write SetFAlignment;
    property AllowBlur : Boolean read FAllowBlur write SetFAllowBlur;
    property AutoSize : Boolean read FAutoSize write SetFAutoSize;
    property AutoSizeObject : TExtObject read FAutoSizeObject write SetFAutoSizeObject;
    property CancelOnEsc : Boolean read FCancelOnEsc write SetFCancelOnEsc;
    property CompleteOnEnter : Boolean read FCompleteOnEnter write SetFCompleteOnEnter;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property Field : TExtFormField read FField write SetFField;
    property HideEl : Boolean read FHideEl write SetFHideEl;
    property IgnoreNoChange : Boolean read FIgnoreNoChange write SetFIgnoreNoChange;
    property Offsets : TArrayOfInteger read FOffsets write SetFOffsets;
    property ParentEl : String read FParentEl write SetFParentEl;
    property ParentElElement : TExtElement read FParentElElement write SetFParentElElement;
    property ParentElTHTMLElement : THTMLElement read FParentElTHTMLElement write SetFParentElTHTMLElement;
    property RevertInvalid : Boolean read FRevertInvalid write SetFRevertInvalid;
    property Shadow : Boolean read FShadow write SetFShadow;
    property ShadowString : String read FShadowString write SetFShadowString;
    property SwallowKeys : Boolean read FSwallowKeys write SetFSwallowKeys;
    property UpdateEl : Boolean read FUpdateEl write SetFUpdateEl;
    property Value : TExtObject read FValue write SetFValue;
    property OnBeforecomplete : TExtEditorOnBeforecomplete read FOnBeforecomplete write SetFOnBeforecomplete;
    property OnBeforestartedit : TExtEditorOnBeforestartedit read FOnBeforestartedit write SetFOnBeforestartedit;
    property OnCanceledit : TExtEditorOnCanceledit read FOnCanceledit write SetFOnCanceledit;
    property OnComplete : TExtEditorOnComplete read FOnComplete write SetFOnComplete;
    property OnSpecialkey : TExtEditorOnSpecialkey read FOnSpecialkey write SetFOnSpecialkey;
    property OnStartedit : TExtEditorOnStartedit read FOnStartedit write SetFOnStartedit;
  end;

  // Procedural types for events TExtFormFieldContainer
  TExtFormFieldContainerOnErrorchange = procedure(This : TExtFormLabelable; Error : String) of object;
  TExtFormFieldContainerOnFielderrorchange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; Error : String) of object;
  TExtFormFieldContainerOnFieldvaliditychange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; IsValid : String) of object;

  TExtFormFieldContainer = class(TExtContainer)
  private
    FActiveError : String;
    FActiveErrorsTpl : String;
    FActiveErrorsTplTArrayOfString : TArrayOfString;
    FActiveErrorsTplTemplate : TExtXTemplate;
    FAfterBodyEl : String;
    FAfterBodyElList : TExtObjectList;
    FAfterBodyElTemplate : TExtXTemplate;
    FAfterLabelTextTpl : String;
    FAfterLabelTextTplList : TExtObjectList;
    FAfterLabelTextTplTemplate : TExtXTemplate;
    FAfterLabelTpl : String;
    FAfterLabelTplList : TExtObjectList;
    FAfterLabelTplTemplate : TExtXTemplate;
    FAfterSubTpl : String;
    FAfterSubTplList : TExtObjectList;
    FAfterSubTplTemplate : TExtXTemplate;
    FAutoFitErrors : Boolean;
    FBaseBodyCls : String;
    FBeforeBodyEl : String;
    FBeforeBodyElList : TExtObjectList;
    FBeforeBodyElTemplate : TExtXTemplate;
    FBeforeLabelTextTpl : String;
    FBeforeLabelTextTplList : TExtObjectList;
    FBeforeLabelTextTplTemplate : TExtXTemplate;
    FBeforeLabelTpl : String;
    FBeforeLabelTplList : TExtObjectList;
    FBeforeLabelTplTemplate : TExtXTemplate;
    FBeforeSubTpl : String;
    FBeforeSubTplList : TExtObjectList;
    FBeforeSubTplTemplate : TExtXTemplate;
    FBodyEl : TExtElement;
    FClearCls : String;
    FCombineErrors : Boolean;
    FCombineLabels : Boolean;
    FErrorEl : TExtElement;
    FErrorMsgCls : String;
    FFieldBodyCls : String;
    FFieldDefaults : TExtObject;
    FFieldLabel : String;
    FFormItemCls : String;
    FHideEmptyLabel : Boolean;
    FHideLabel : Boolean;
    FInvalidCls : String;
    FIsFieldLabelable : Boolean;
    FLabelAlign : TLabelAlignEnum;
    FLabelAttrTpl : String;
    FLabelAttrTplList : TExtObjectList;
    FLabelAttrTplTemplate : TExtXTemplate;
    FLabelCell : TExtElement;
    FLabelCls : String;
    FLabelClsExtra : String;
    FLabelConnector : String; // ','
    FLabelEl : TExtElement;
    FLabelPad : Integer;
    FLabelSeparator : String;
    FLabelStyle : String;
    FLabelWidth : Integer;
    FMsgTarget : String;
    FPreventMark : Boolean;
    FOnErrorchange : TExtFormFieldContainerOnErrorchange;
    FOnFielderrorchange : TExtFormFieldContainerOnFielderrorchange;
    FOnFieldvaliditychange : TExtFormFieldContainerOnFieldvaliditychange;
    procedure SetFActiveError(Value : String);
    procedure SetFActiveErrorsTpl(Value : String);
    procedure SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString);
    procedure SetFActiveErrorsTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterBodyEl(Value : String);
    procedure SetFAfterBodyElList(Value : TExtObjectList);
    procedure SetFAfterBodyElTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTextTpl(Value : String);
    procedure SetFAfterLabelTextTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterLabelTpl(Value : String);
    procedure SetFAfterLabelTplList(Value : TExtObjectList);
    procedure SetFAfterLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterSubTpl(Value : String);
    procedure SetFAfterSubTplList(Value : TExtObjectList);
    procedure SetFAfterSubTplTemplate(Value : TExtXTemplate);
    procedure SetFAutoFitErrors(Value : Boolean);
    procedure SetFBaseBodyCls(Value : String);
    procedure SetFBeforeBodyEl(Value : String);
    procedure SetFBeforeBodyElList(Value : TExtObjectList);
    procedure SetFBeforeBodyElTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTextTpl(Value : String);
    procedure SetFBeforeLabelTextTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeLabelTpl(Value : String);
    procedure SetFBeforeLabelTplList(Value : TExtObjectList);
    procedure SetFBeforeLabelTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeSubTpl(Value : String);
    procedure SetFBeforeSubTplList(Value : TExtObjectList);
    procedure SetFBeforeSubTplTemplate(Value : TExtXTemplate);
    procedure SetFBodyEl(Value : TExtElement);
    procedure SetFClearCls(Value : String);
    procedure SetFCombineErrors(Value : Boolean);
    procedure SetFCombineLabels(Value : Boolean);
    procedure SetFErrorEl(Value : TExtElement);
    procedure SetFErrorMsgCls(Value : String);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFFieldDefaults(Value : TExtObject);
    procedure SetFFieldLabel(Value : String);
    procedure SetFFormItemCls(Value : String);
    procedure SetFHideEmptyLabel(Value : Boolean);
    procedure SetFHideLabel(Value : Boolean);
    procedure SetFInvalidCls(Value : String);
    procedure SetFIsFieldLabelable(Value : Boolean);
    procedure SetFLabelAlign(Value : TLabelAlignEnum);
    procedure SetFLabelAttrTpl(Value : String);
    procedure SetFLabelAttrTplList(Value : TExtObjectList);
    procedure SetFLabelAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFLabelCell(Value : TExtElement);
    procedure SetFLabelCls(Value : String);
    procedure SetFLabelClsExtra(Value : String);
    procedure SetFLabelConnector(Value : String);
    procedure SetFLabelEl(Value : TExtElement);
    procedure SetFLabelPad(Value : Integer);
    procedure SetFLabelSeparator(Value : String);
    procedure SetFLabelStyle(Value : String);
    procedure SetFLabelWidth(Value : Integer);
    procedure SetFMsgTarget(Value : String);
    procedure SetFPreventMark(Value : Boolean);
    procedure SetFOnErrorchange(Value : TExtFormFieldContainerOnErrorchange);
    procedure SetFOnFielderrorchange(Value : TExtFormFieldContainerOnFielderrorchange);
    procedure SetFOnFieldvaliditychange(Value : TExtFormFieldContainerOnFieldvaliditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetActiveError : TExtFunction;
    function GetActiveErrors : TExtFunction;
    function GetCombinedErrors(InvalidFields : TExtObjectList) : TExtFunction;
    function GetInputId : TExtFunction;
    function GetLabelWidth : TExtFunction;
    function HasActiveError : TExtFunction;
    function HasVisibleLabel : TExtFunction;
    function InitLabelable : TExtFunction;
    function SetActiveError(Msg : String) : TExtFunction;
    function SetActiveErrors(Errors : TArrayOfString) : TExtFunction;
    function SetFieldDefaults(Defaults : TExtObject) : TExtFunction;
    function SetFieldLabel(LabelJS : String) : TExtFunction;
    function TrimLabelSeparator : TExtFunction;
    function UnsetActiveError : TExtFunction;
    property ActiveError : String read FActiveError write SetFActiveError;
    property ActiveErrorsTpl : String read FActiveErrorsTpl write SetFActiveErrorsTpl;
    property ActiveErrorsTplTArrayOfString : TArrayOfString read FActiveErrorsTplTArrayOfString write SetFActiveErrorsTplTArrayOfString;
    property ActiveErrorsTplTemplate : TExtXTemplate read FActiveErrorsTplTemplate write SetFActiveErrorsTplTemplate;
    property AfterBodyEl : String read FAfterBodyEl write SetFAfterBodyEl;
    property AfterBodyElList : TExtObjectList read FAfterBodyElList write SetFAfterBodyElList;
    property AfterBodyElTemplate : TExtXTemplate read FAfterBodyElTemplate write SetFAfterBodyElTemplate;
    property AfterLabelTextTpl : String read FAfterLabelTextTpl write SetFAfterLabelTextTpl;
    property AfterLabelTextTplList : TExtObjectList read FAfterLabelTextTplList write SetFAfterLabelTextTplList;
    property AfterLabelTextTplTemplate : TExtXTemplate read FAfterLabelTextTplTemplate write SetFAfterLabelTextTplTemplate;
    property AfterLabelTpl : String read FAfterLabelTpl write SetFAfterLabelTpl;
    property AfterLabelTplList : TExtObjectList read FAfterLabelTplList write SetFAfterLabelTplList;
    property AfterLabelTplTemplate : TExtXTemplate read FAfterLabelTplTemplate write SetFAfterLabelTplTemplate;
    property AfterSubTpl : String read FAfterSubTpl write SetFAfterSubTpl;
    property AfterSubTplList : TExtObjectList read FAfterSubTplList write SetFAfterSubTplList;
    property AfterSubTplTemplate : TExtXTemplate read FAfterSubTplTemplate write SetFAfterSubTplTemplate;
    property AutoFitErrors : Boolean read FAutoFitErrors write SetFAutoFitErrors;
    property BaseBodyCls : String read FBaseBodyCls write SetFBaseBodyCls;
    property BeforeBodyEl : String read FBeforeBodyEl write SetFBeforeBodyEl;
    property BeforeBodyElList : TExtObjectList read FBeforeBodyElList write SetFBeforeBodyElList;
    property BeforeBodyElTemplate : TExtXTemplate read FBeforeBodyElTemplate write SetFBeforeBodyElTemplate;
    property BeforeLabelTextTpl : String read FBeforeLabelTextTpl write SetFBeforeLabelTextTpl;
    property BeforeLabelTextTplList : TExtObjectList read FBeforeLabelTextTplList write SetFBeforeLabelTextTplList;
    property BeforeLabelTextTplTemplate : TExtXTemplate read FBeforeLabelTextTplTemplate write SetFBeforeLabelTextTplTemplate;
    property BeforeLabelTpl : String read FBeforeLabelTpl write SetFBeforeLabelTpl;
    property BeforeLabelTplList : TExtObjectList read FBeforeLabelTplList write SetFBeforeLabelTplList;
    property BeforeLabelTplTemplate : TExtXTemplate read FBeforeLabelTplTemplate write SetFBeforeLabelTplTemplate;
    property BeforeSubTpl : String read FBeforeSubTpl write SetFBeforeSubTpl;
    property BeforeSubTplList : TExtObjectList read FBeforeSubTplList write SetFBeforeSubTplList;
    property BeforeSubTplTemplate : TExtXTemplate read FBeforeSubTplTemplate write SetFBeforeSubTplTemplate;
    property BodyEl : TExtElement read FBodyEl write SetFBodyEl;
    property ClearCls : String read FClearCls write SetFClearCls;
    property CombineErrors : Boolean read FCombineErrors write SetFCombineErrors;
    property CombineLabels : Boolean read FCombineLabels write SetFCombineLabels;
    property ErrorEl : TExtElement read FErrorEl write SetFErrorEl;
    property ErrorMsgCls : String read FErrorMsgCls write SetFErrorMsgCls;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property FieldDefaults : TExtObject read FFieldDefaults write SetFFieldDefaults;
    property FieldLabel : String read FFieldLabel write SetFFieldLabel;
    property FormItemCls : String read FFormItemCls write SetFFormItemCls;
    property HideEmptyLabel : Boolean read FHideEmptyLabel write SetFHideEmptyLabel;
    property HideLabel : Boolean read FHideLabel write SetFHideLabel;
    property InvalidCls : String read FInvalidCls write SetFInvalidCls;
    property IsFieldLabelable : Boolean read FIsFieldLabelable write SetFIsFieldLabelable;
    property LabelAlign : TLabelAlignEnum read FLabelAlign write SetFLabelAlign;
    property LabelAttrTpl : String read FLabelAttrTpl write SetFLabelAttrTpl;
    property LabelAttrTplList : TExtObjectList read FLabelAttrTplList write SetFLabelAttrTplList;
    property LabelAttrTplTemplate : TExtXTemplate read FLabelAttrTplTemplate write SetFLabelAttrTplTemplate;
    property LabelCell : TExtElement read FLabelCell write SetFLabelCell;
    property LabelCls : String read FLabelCls write SetFLabelCls;
    property LabelClsExtra : String read FLabelClsExtra write SetFLabelClsExtra;
    property LabelConnector : String read FLabelConnector write SetFLabelConnector;
    property LabelEl : TExtElement read FLabelEl write SetFLabelEl;
    property LabelPad : Integer read FLabelPad write SetFLabelPad;
    property LabelSeparator : String read FLabelSeparator write SetFLabelSeparator;
    property LabelStyle : String read FLabelStyle write SetFLabelStyle;
    property LabelWidth : Integer read FLabelWidth write SetFLabelWidth;
    property MsgTarget : String read FMsgTarget write SetFMsgTarget;
    property PreventMark : Boolean read FPreventMark write SetFPreventMark;
    property OnErrorchange : TExtFormFieldContainerOnErrorchange read FOnErrorchange write SetFOnErrorchange;
    property OnFielderrorchange : TExtFormFieldContainerOnFielderrorchange read FOnFielderrorchange write SetFOnFielderrorchange;
    property OnFieldvaliditychange : TExtFormFieldContainerOnFieldvaliditychange read FOnFieldvaliditychange write SetFOnFieldvaliditychange;
  end;

  TExtLayoutComponentProgressBar = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtContainerViewport = class(TExtContainer)
  private
    FIsViewport : Boolean;
    procedure SetFIsViewport(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsViewport : Boolean read FIsViewport write SetFIsViewport;
  end;

  TExtLayoutComponentButton = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentDraw = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentField = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function DestroyTip : TExtFunction;
    function ElementIdApplyIf : TExtFunction;
    function GetErrorStrategy : TExtFunction;
    function GetLabelStrategy : TExtFunction;
    function InitTip : TExtFunction;
    function QtipApplyIf : TExtFunction;
    function SideApplyIf : TExtFunction;
    function TitleApplyIf : TExtFunction;
    function TopExtApplyIf : TExtFunction;
    function UnderApplyIf : TExtFunction;
  end;

  // Procedural types for events TExtPanelAbstractPanel
  TExtPanelAbstractPanelOnDockedadd = procedure(This : TExtContainerDockingContainer; Component : TExtComponent; Index : Integer) of object;
  TExtPanelAbstractPanelOnDockedremove = procedure(This : TExtContainerDockingContainer; Component : TExtComponent) of object;

  TExtPanelAbstractPanel = class(TExtContainer)
  private
    FBaseCls : String;
    FBody : TExtDomElement;
    FBodyBorder : Boolean;
    FBodyCls : String;
    FBodyClsTArrayOfString : TArrayOfString;
    FBodyPadding : Integer;
    FBodyPaddingString : String;
    FBodyStyle : String;
    FBodyStyleFunction : TExtFunction;
    FBodyStyleObject : TExtObject;
    FContentPaddingProperty : String;
    FDefaultDockWeights : TExtObject;
    FDockedItems : TExtObjectList;
    FIsPanel : Boolean;
    FShrinkWrapDock : Boolean;
    FShrinkWrapDockInteger : Integer;
    FOnDockedadd : TExtPanelAbstractPanelOnDockedadd;
    FOnDockedremove : TExtPanelAbstractPanelOnDockedremove;
    procedure SetFBaseCls(Value : String);
    procedure SetFBody(Value : TExtDomElement);
    procedure SetFBodyBorder(Value : Boolean);
    procedure SetFBodyCls(Value : String);
    procedure SetFBodyClsTArrayOfString(Value : TArrayOfString);
    procedure SetFBodyPadding(Value : Integer);
    procedure SetFBodyPaddingString(Value : String);
    procedure SetFBodyStyle(Value : String);
    procedure SetFBodyStyleFunction(Value : TExtFunction);
    procedure SetFBodyStyleObject(Value : TExtObject);
    procedure SetFContentPaddingProperty(Value : String);
    procedure SetFDefaultDockWeights(Value : TExtObject);
    procedure SetFDockedItems(Value : TExtObjectList);
    procedure SetFIsPanel(Value : Boolean);
    procedure SetFShrinkWrapDock(Value : Boolean);
    procedure SetFShrinkWrapDockInteger(Value : Integer);
    procedure SetFOnDockedadd(Value : TExtPanelAbstractPanelOnDockedadd);
    procedure SetFOnDockedremove(Value : TExtPanelAbstractPanelOnDockedremove);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddBodyCls(Cls : String) : TExtFunction;
    function AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; overload;
    function AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; overload;
    constructor Create;
    function GetComponent(Comp : String) : TExtFunction; overload;
    function GetComponent(Comp : Integer) : TExtFunction; overload;
    function GetDockedComponent(Comp : Integer) : TExtFunction; overload;
    function GetDockedComponent(Comp : String) : TExtFunction; overload;
    function GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction;
    function InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; overload;
    function InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; overload;
    function RemoveBodyCls(Cls : String) : TExtFunction;
    function RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction;
    function SetBodyStyle(Style : String; Value : String) : TExtFunction;
    destructor Destroy; override;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Body : TExtDomElement read FBody write SetFBody;
    property BodyBorder : Boolean read FBodyBorder write SetFBodyBorder;
    property BodyCls : String read FBodyCls write SetFBodyCls;
    property BodyClsTArrayOfString : TArrayOfString read FBodyClsTArrayOfString write SetFBodyClsTArrayOfString;
    property BodyPadding : Integer read FBodyPadding write SetFBodyPadding;
    property BodyPaddingString : String read FBodyPaddingString write SetFBodyPaddingString;
    property BodyStyle : String read FBodyStyle write SetFBodyStyle;
    property BodyStyleFunction : TExtFunction read FBodyStyleFunction write SetFBodyStyleFunction;
    property BodyStyleObject : TExtObject read FBodyStyleObject write SetFBodyStyleObject;
    property ContentPaddingProperty : String read FContentPaddingProperty write SetFContentPaddingProperty;
    property DefaultDockWeights : TExtObject read FDefaultDockWeights write SetFDefaultDockWeights;
    property DockedItems : TExtObjectList read FDockedItems write SetFDockedItems;
    property IsPanel : Boolean read FIsPanel write SetFIsPanel;
    property ShrinkWrapDock : Boolean read FShrinkWrapDock write SetFShrinkWrapDock;
    property ShrinkWrapDockInteger : Integer read FShrinkWrapDockInteger write SetFShrinkWrapDockInteger;
    property OnDockedadd : TExtPanelAbstractPanelOnDockedadd read FOnDockedadd write SetFOnDockedadd;
    property OnDockedremove : TExtPanelAbstractPanelOnDockedremove read FOnDockedremove write SetFOnDockedremove;
  end;

  // Enumerated types for properties
  TAlignRoundingMethodEnum = (alRound, alFloor, alCeil);

  TExtLayoutContainerHBox = class(TExtLayoutContainerBox)
  private
    FAlign : String;
    FAlignRoundingMethod : TAlignRoundingMethodEnum;
    FConstrainAlign : Boolean;
    procedure SetFAlign(Value : String);
    procedure SetFAlignRoundingMethod(Value : TAlignRoundingMethodEnum);
    procedure SetFConstrainAlign(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Align : String read FAlign write SetFAlign;
    property AlignRoundingMethod : TAlignRoundingMethodEnum read FAlignRoundingMethod write SetFAlignRoundingMethod;
    property ConstrainAlign : Boolean read FConstrainAlign write SetFConstrainAlign;
  end;

  TExtLayoutContainerVBox = class(TExtLayoutContainerBox)
  private
    FAlign : String;
    FAlignRoundingMethod : TAlignRoundingMethodEnum;
    FConstrainAlign : Boolean;
    procedure SetFAlign(Value : String);
    procedure SetFAlignRoundingMethod(Value : TAlignRoundingMethodEnum);
    procedure SetFConstrainAlign(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Align : String read FAlign write SetFAlign;
    property AlignRoundingMethod : TAlignRoundingMethodEnum read FAlignRoundingMethod write SetFAlignRoundingMethod;
    property ConstrainAlign : Boolean read FConstrainAlign write SetFConstrainAlign;
  end;

  // Procedural types for events TExtPanelHeader
  TExtPanelHeaderOnClick = procedure(This : TExtPanelHeader; E : TExtEventObject) of object;
  TExtPanelHeaderOnDblclick = procedure(This : TExtPanelHeader; E : TExtEventObject) of object;

  TExtPanelHeader = class(TExtContainer)
  private
    FGlyph : Integer;
    FGlyphString : String;
    FIcon : String;
    FIconCls : String;
    FIsHeader : Boolean;
    FTitle : String;
    FTitleAlign : String; // 's natural * behavior depending on the css direction property - `'
    FTitlePosition : Integer;
    FOnClick : TExtPanelHeaderOnClick;
    FOnDblclick : TExtPanelHeaderOnDblclick;
    procedure SetFGlyph(Value : Integer);
    procedure SetFGlyphString(Value : String);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIsHeader(Value : Boolean);
    procedure SetFTitle(Value : String);
    procedure SetFTitleAlign(Value : String);
    procedure SetFTitlePosition(Value : Integer);
    procedure SetFOnClick(Value : TExtPanelHeaderOnClick);
    procedure SetFOnDblclick(Value : TExtPanelHeaderOnDblclick);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddTool(Tool : TExtObject) : TExtFunction;
    constructor Create;
    function GetTools : TExtFunction;
    function SetGlyph(Glyph : String) : TExtFunction; overload;
    function SetGlyph(Glyph : Integer) : TExtFunction; overload;
    function SetIcon(Icon : String) : TExtFunction;
    function SetIconCls(Cls : String) : TExtFunction;
    function SetTitle(Title : String) : TExtFunction;
    property Glyph : Integer read FGlyph write SetFGlyph;
    property GlyphString : String read FGlyphString write SetFGlyphString;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property IsHeader : Boolean read FIsHeader write SetFIsHeader;
    property Title : String read FTitle write SetFTitle;
    property TitleAlign : String read FTitleAlign write SetFTitleAlign;
    property TitlePosition : Integer read FTitlePosition write SetFTitlePosition;
    property OnClick : TExtPanelHeaderOnClick read FOnClick write SetFOnClick;
    property OnDblclick : TExtPanelHeaderOnDblclick read FOnDblclick write SetFOnDblclick;
  end;

  TExtLayoutContainerAnchor = class(TExtLayoutContainerAuto)
  private
    FAnchor : String;
    FAnchorSize : Integer;
    FAnchorSizeObject : TExtObject;
    FDefaultAnchor : String;
    procedure SetFAnchor(Value : String);
    procedure SetFAnchorSize(Value : Integer);
    procedure SetFAnchorSizeObject(Value : TExtObject);
    procedure SetFDefaultAnchor(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Anchor : String read FAnchor write SetFAnchor;
    property AnchorSize : Integer read FAnchorSize write SetFAnchorSize;
    property AnchorSizeObject : TExtObject read FAnchorSizeObject write SetFAnchorSizeObject;
    property DefaultAnchor : String read FDefaultAnchor write SetFDefaultAnchor;
  end;

  TExtLayoutContainerCard = class(TExtLayoutContainerFit)
  private
    FDeferredRender : Boolean;
    procedure SetFDeferredRender(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetActiveItem : TExtFunction;
    function GetNext : TExtFunction;
    function GetPrev : TExtFunction;
    function Next : TExtFunction;
    function Prev : TExtFunction;
    function SetActiveItem(NewCard : TExtComponent) : TExtFunction; overload;
    function SetActiveItem(NewCard : String) : TExtFunction; overload;
    function SetActiveItem(NewCard : Integer) : TExtFunction; overload;
    property DeferredRender : Boolean read FDeferredRender write SetFDeferredRender;
  end;

  TExtLayoutContainerColumn = class(TExtLayoutContainerAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentBoundList = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDataProxyLocalStorage = class(TExtDataProxyWebStorage)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtChartSeriesColumn = class(TExtChartSeriesBar)
  private
    FAxis : String;
    FXPadding : Integer;
    FXPaddingObject : TExtObject;
    FYPadding : Integer;
    FYPaddingObject : TExtObject;
    procedure SetFAxis(Value : String);
    procedure SetFXPadding(Value : Integer);
    procedure SetFXPaddingObject(Value : TExtObject);
    procedure SetFYPadding(Value : Integer);
    procedure SetFYPaddingObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Axis : String read FAxis write SetFAxis;
    property XPadding : Integer read FXPadding write SetFXPadding;
    property XPaddingObject : TExtObject read FXPaddingObject write SetFXPaddingObject;
    property YPadding : Integer read FYPadding write SetFYPadding;
    property YPaddingObject : TExtObject read FYPaddingObject write SetFYPaddingObject;
  end;

  TExtDdDropZone = class(TExtDdDropTarget)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetTargetFromEvent(E : TEvent) : TExtFunction;
    function OnNodeEnter(NodeData : TExtObject; Source : TExtDdDragSource; E : TEvent; Data : TExtObject) : TExtFunction;
  end;

  TExtDataProxyRest = class(TExtDataProxyAjax)
  private
    FActionMethods : TExtObject;
    FAppendId : Boolean; // true
    FBatchActions : Boolean;
    FFormat : String;
    procedure SetFActionMethods(Value : TExtObject);
    procedure SetFAppendId(Value : Boolean);
    procedure SetFBatchActions(Value : Boolean);
    procedure SetFFormat(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BuildUrl(Request : TExtObject) : TExtFunction;
    constructor Create;
    destructor Destroy; override;
    property ActionMethods : TExtObject read FActionMethods write SetFActionMethods;
    property AppendId : Boolean read FAppendId write SetFAppendId;
    property BatchActions : Boolean read FBatchActions write SetFBatchActions;
    property Format : String read FFormat write SetFFormat;
  end;

  TExtChartLegendItem = class(TExtDrawCompositeSprite)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CreateLegend : TExtFunction;
    function UpdatePosition(RelativeTo : TExtObject = nil) : TExtFunction;
  end;

  // Procedural types for events TExtFormFieldSet
  TExtFormFieldSetOnBeforecollapse = procedure(F : TExtFormFieldSet) of object;
  TExtFormFieldSetOnBeforeexpand = procedure(F : TExtFormFieldSet) of object;
  TExtFormFieldSetOnCollapse = procedure(F : TExtFormFieldSet) of object;
  TExtFormFieldSetOnExpand = procedure(F : TExtFormFieldSet) of object;
  TExtFormFieldSetOnFielderrorchange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; Error : String) of object;
  TExtFormFieldSetOnFieldvaliditychange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; IsValid : String) of object;

  TExtFormFieldSet = class(TExtContainer)
  private
    FBaseCls : String;
    FCheckboxCmp : TExtFormFieldCheckbox;
    FCheckboxName : String;
    FCheckboxToggle : Boolean;
    FCollapsed : Boolean;
    FCollapsible : Boolean;
    FFieldDefaults : TExtObject;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    FLegend : TExtComponent;
    FTitle : String;
    FToggleCmp : TExtPanelTool;
    FToggleOnTitleClick : Boolean;
    FOnBeforecollapse : TExtFormFieldSetOnBeforecollapse;
    FOnBeforeexpand : TExtFormFieldSetOnBeforeexpand;
    FOnCollapse : TExtFormFieldSetOnCollapse;
    FOnExpand : TExtFormFieldSetOnExpand;
    FOnFielderrorchange : TExtFormFieldSetOnFielderrorchange;
    FOnFieldvaliditychange : TExtFormFieldSetOnFieldvaliditychange;
    procedure SetFBaseCls(Value : String);
    procedure SetFCheckboxCmp(Value : TExtFormFieldCheckbox);
    procedure SetFCheckboxName(Value : String);
    procedure SetFCheckboxToggle(Value : Boolean);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFFieldDefaults(Value : TExtObject);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
    procedure SetFLegend(Value : TExtComponent);
    procedure SetFTitle(Value : String);
    procedure SetFToggleCmp(Value : TExtPanelTool);
    procedure SetFToggleOnTitleClick(Value : Boolean);
    procedure SetFOnBeforecollapse(Value : TExtFormFieldSetOnBeforecollapse);
    procedure SetFOnBeforeexpand(Value : TExtFormFieldSetOnBeforeexpand);
    procedure SetFOnCollapse(Value : TExtFormFieldSetOnCollapse);
    procedure SetFOnExpand(Value : TExtFormFieldSetOnExpand);
    procedure SetFOnFielderrorchange(Value : TExtFormFieldSetOnFielderrorchange);
    procedure SetFOnFieldvaliditychange(Value : TExtFormFieldSetOnFieldvaliditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Collapse : TExtFunction;
    constructor Create;
    function Expand : TExtFunction;
    function SetTitle(Title : String) : TExtFunction;
    function Toggle : TExtFunction;
    destructor Destroy; override;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property CheckboxCmp : TExtFormFieldCheckbox read FCheckboxCmp write SetFCheckboxCmp;
    property CheckboxName : String read FCheckboxName write SetFCheckboxName;
    property CheckboxToggle : Boolean read FCheckboxToggle write SetFCheckboxToggle;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property FieldDefaults : TExtObject read FFieldDefaults write SetFFieldDefaults;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
    property Legend : TExtComponent read FLegend write SetFLegend;
    property Title : String read FTitle write SetFTitle;
    property ToggleCmp : TExtPanelTool read FToggleCmp write SetFToggleCmp;
    property ToggleOnTitleClick : Boolean read FToggleOnTitleClick write SetFToggleOnTitleClick;
    property OnBeforecollapse : TExtFormFieldSetOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnBeforeexpand : TExtFormFieldSetOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnCollapse : TExtFormFieldSetOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtFormFieldSetOnExpand read FOnExpand write SetFOnExpand;
    property OnFielderrorchange : TExtFormFieldSetOnFielderrorchange read FOnFielderrorchange write SetFOnFielderrorchange;
    property OnFieldvaliditychange : TExtFormFieldSetOnFieldvaliditychange read FOnFieldvaliditychange write SetFOnFieldvaliditychange;
  end;

  TExtFormFieldRadio = class(TExtFormFieldCheckbox)
  private
    FFocusCls : String;
    FIsRadio : Boolean;
    procedure SetFFocusCls(Value : String);
    procedure SetFIsRadio(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetGroupValue : TExtFunction;
    function GetSubmitValue : TExtFunction;
    function SetValue(Value : String) : TExtFunction; overload;
    function SetValue(Value : Boolean) : TExtFunction; overload;
    property FocusCls : String read FFocusCls write SetFFocusCls;
    property IsRadio : Boolean read FIsRadio write SetFIsRadio;
  end;

  TExtGridRowEditorButtons = class(TExtContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtDdDragSource = class(TExtDdDDProxy)
  private
    FAnimRepair : Boolean;
    FDdGroup : String;
    FDropAllowed : String;
    FDropNotAllowed : String;
    FRepairHighlightColor : String;
    procedure SetFAnimRepair(Value : Boolean);
    procedure SetFDdGroup(Value : String);
    procedure SetFDropAllowed(Value : String);
    procedure SetFDropNotAllowed(Value : String);
    procedure SetFRepairHighlightColor(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(El : THTMLElement; Config : TExtObject = nil); overload;
    constructor Create(El : TExtElement; Config : TExtObject = nil); overload;
    constructor Create(El : String; Config : TExtObject = nil); overload;
    function GetDragData : TExtFunction;
    function GetProxy : TExtFunction;
    function HideProxy : TExtFunction;
    property AnimRepair : Boolean read FAnimRepair write SetFAnimRepair;
    property DdGroup : String read FDdGroup write SetFDdGroup;
    property DropAllowed : String read FDropAllowed write SetFDropAllowed;
    property DropNotAllowed : String read FDropNotAllowed write SetFDropNotAllowed;
    property RepairHighlightColor : String read FRepairHighlightColor write SetFRepairHighlightColor;
  end;

  TExtLayoutComponentBody = class(TExtLayoutComponentAuto)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtFormCheckboxGroup
  TExtFormCheckboxGroupOnChange = procedure(This : TExtFormField; NewValue : TExtObject; OldValue : TExtObject) of object;
  TExtFormCheckboxGroupOnDirtychange = procedure(This : TExtFormField; IsDirty : Boolean) of object;
  TExtFormCheckboxGroupOnValiditychange = procedure(This : TExtFormField; IsValid : Boolean) of object;

  TExtFormCheckboxGroup = class(TExtFormFieldContainer)
  private
    FAllowBlank : Boolean;
    FBlankText : String;
    FColumns : Integer;
    FColumnsString : String;
    FColumnsTArrayOfInteger : TArrayOfInteger;
    FDisabled : Boolean;
    FFieldBodyCls : String;
    FIsFormField : Boolean;
    FItems : TExtObjectList;
    FItemsList : TExtObjectList;
    FName : String;
    FOriginalValue : TExtObject;
    FSubmitValue : Boolean;
    FValidateOnChange : Boolean;
    FValue : TExtObject;
    FVertical : Boolean;
    FOnChange : TExtFormCheckboxGroupOnChange;
    FOnDirtychange : TExtFormCheckboxGroupOnDirtychange;
    FOnValiditychange : TExtFormCheckboxGroupOnValiditychange;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFColumns(Value : Integer);
    procedure SetFColumnsString(Value : String);
    procedure SetFColumnsTArrayOfInteger(Value : TArrayOfInteger);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFIsFormField(Value : Boolean);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFItemsList(Value : TExtObjectList);
    procedure SetFName(Value : String);
    procedure SetFOriginalValue(Value : TExtObject);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFValidateOnChange(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFVertical(Value : Boolean);
    procedure SetFOnChange(Value : TExtFormCheckboxGroupOnChange);
    procedure SetFOnDirtychange(Value : TExtFormCheckboxGroupOnDirtychange);
    procedure SetFOnValiditychange(Value : TExtFormCheckboxGroupOnValiditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BatchChanges(Fn : TExtObject) : TExtFunction;
    function CheckChange : TExtFunction;
    function CheckDirty : TExtFunction;
    constructor Create;
    function ExtractFileInput : TExtFunction;
    function GetChecked : TExtFunction;
    function GetErrors : TExtFunction;
    function GetModelData : TExtFunction;
    function GetName : TExtFunction;
    function GetSubmitData : TExtFunction;
    function GetValue : TExtFunction;
    function InitField : TExtFunction;
    function InitValue : TExtFunction;
    function IsDirty : TExtFunction;
    function IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction;
    function IsFileUpload : TExtFunction;
    function IsValid : TExtFunction;
    function Reset : TExtFunction;
    function ResetOriginalValue : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function Validate : TExtFunction;
    destructor Destroy; override;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property Columns : Integer read FColumns write SetFColumns;
    property ColumnsString : String read FColumnsString write SetFColumnsString;
    property ColumnsTArrayOfInteger : TArrayOfInteger read FColumnsTArrayOfInteger write SetFColumnsTArrayOfInteger;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property IsFormField : Boolean read FIsFormField write SetFIsFormField;
    property Items : TExtObjectList read FItems write SetFItems;
    property ItemsList : TExtObjectList read FItemsList write SetFItemsList;
    property Name : String read FName write SetFName;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property ValidateOnChange : Boolean read FValidateOnChange write SetFValidateOnChange;
    property Value : TExtObject read FValue write SetFValue;
    property Vertical : Boolean read FVertical write SetFVertical;
    property OnChange : TExtFormCheckboxGroupOnChange read FOnChange write SetFOnChange;
    property OnDirtychange : TExtFormCheckboxGroupOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnValiditychange : TExtFormCheckboxGroupOnValiditychange read FOnValiditychange write SetFOnValiditychange;
  end;

  // Procedural types for events TExtFormFieldSpinner
  TExtFormFieldSpinnerOnSpin = procedure(This : TExtFormFieldSpinner; Direction : String) of object;
  TExtFormFieldSpinnerOnSpindown = procedure(This : TExtFormFieldSpinner) of object;
  TExtFormFieldSpinnerOnSpinup = procedure(This : TExtFormFieldSpinner) of object;

  TExtFormFieldSpinner = class(TExtFormFieldTrigger)
  private
    FKeyNavEnabled : Boolean; // true
    FMouseWheelEnabled : Boolean; // true
    FRepeatTriggerClick : Boolean; // true
    FSpinDownEl : TExtElement;
    FSpinDownEnabled : Boolean; // true
    FSpinUpEl : TExtElement;
    FSpinUpEnabled : Boolean; // true
    FOnSpin : TExtFormFieldSpinnerOnSpin;
    FOnSpindown : TExtFormFieldSpinnerOnSpindown;
    FOnSpinup : TExtFormFieldSpinnerOnSpinup;
    procedure SetFKeyNavEnabled(Value : Boolean);
    procedure SetFMouseWheelEnabled(Value : Boolean);
    procedure SetFRepeatTriggerClick(Value : Boolean);
    procedure SetFSpinDownEl(Value : TExtElement);
    procedure SetFSpinDownEnabled(Value : Boolean);
    procedure SetFSpinUpEl(Value : TExtElement);
    procedure SetFSpinUpEnabled(Value : Boolean);
    procedure SetFOnSpin(Value : TExtFormFieldSpinnerOnSpin);
    procedure SetFOnSpindown(Value : TExtFormFieldSpinnerOnSpindown);
    procedure SetFOnSpinup(Value : TExtFormFieldSpinnerOnSpinup);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTriggerWidth : TExtFunction;
    function SetSpinDownEnabled(Enabled : Boolean) : TExtFunction;
    function SetSpinUpEnabled(Enabled : Boolean) : TExtFunction;
    function SpinDown : TExtFunction;
    function SpinUp : TExtFunction;
    destructor Destroy; override;
    property KeyNavEnabled : Boolean read FKeyNavEnabled write SetFKeyNavEnabled;
    property MouseWheelEnabled : Boolean read FMouseWheelEnabled write SetFMouseWheelEnabled;
    property RepeatTriggerClick : Boolean read FRepeatTriggerClick write SetFRepeatTriggerClick;
    property SpinDownEl : TExtElement read FSpinDownEl write SetFSpinDownEl;
    property SpinDownEnabled : Boolean read FSpinDownEnabled write SetFSpinDownEnabled;
    property SpinUpEl : TExtElement read FSpinUpEl write SetFSpinUpEl;
    property SpinUpEnabled : Boolean read FSpinUpEnabled write SetFSpinUpEnabled;
    property OnSpin : TExtFormFieldSpinnerOnSpin read FOnSpin write SetFOnSpin;
    property OnSpindown : TExtFormFieldSpinnerOnSpindown read FOnSpindown write SetFOnSpindown;
    property OnSpinup : TExtFormFieldSpinnerOnSpinup read FOnSpinup write SetFOnSpinup;
  end;

  // Procedural types for events TExtFormFieldFile
  TExtFormFieldFileOnChange = procedure(This : TExtFormFieldFile; Value : String) of object;

  TExtFormFieldFile = class(TExtFormFieldTrigger)
  private
    FButton : TExtButton;
    FButtonConfig : TExtObject;
    FButtonMargin : Integer;
    FButtonOnly : Boolean;
    FButtonText : String;
    FClearOnSubmit : Boolean;
    FFieldBodyCls : String;
    FFileInputEl : TExtElement;
    FReadOnly : Boolean;
    FOnChange : TExtFormFieldFileOnChange;
    procedure SetFButton(Value : TExtButton);
    procedure SetFButtonConfig(Value : TExtObject);
    procedure SetFButtonMargin(Value : Integer);
    procedure SetFButtonOnly(Value : Boolean);
    procedure SetFButtonText(Value : String);
    procedure SetFClearOnSubmit(Value : Boolean);
    procedure SetFFieldBodyCls(Value : String);
    procedure SetFFileInputEl(Value : TExtElement);
    procedure SetFReadOnly(Value : Boolean);
    procedure SetFOnChange(Value : TExtFormFieldFileOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetTriggerMarkup : TExtFunction;
    function SetValueExtEmptyFnReset : TExtFunction;
    destructor Destroy; override;
    property Button : TExtButton read FButton write SetFButton;
    property ButtonConfig : TExtObject read FButtonConfig write SetFButtonConfig;
    property ButtonMargin : Integer read FButtonMargin write SetFButtonMargin;
    property ButtonOnly : Boolean read FButtonOnly write SetFButtonOnly;
    property ButtonText : String read FButtonText write SetFButtonText;
    property ClearOnSubmit : Boolean read FClearOnSubmit write SetFClearOnSubmit;
    property FieldBodyCls : String read FFieldBodyCls write SetFFieldBodyCls;
    property FileInputEl : TExtElement read FFileInputEl write SetFFileInputEl;
    property ReadOnly : Boolean read FReadOnly write SetFReadOnly;
    property OnChange : TExtFormFieldFileOnChange read FOnChange write SetFOnChange;
  end;

  // Procedural types for events TExtToolbarPaging
  TExtToolbarPagingOnBeforechange = procedure(This : TExtToolbarPaging; Page : Integer) of object;
  TExtToolbarPagingOnChange = procedure(This : TExtToolbarPaging; PageData : TExtObject) of object;

  TExtToolbarPaging = class(TExtToolbar)
  private
    FAfterPageText : String;
    FBeforePageText : String;
    FDisplayInfo : Boolean;
    FDisplayMsg : String;
    FEmptyMsg : String;
    FFirstText : String;
    FInputItemWidth : Integer;
    FLastText : String;
    FNextText : String;
    FPrependButtons : Boolean;
    FPrevText : String;
    FRefreshText : String;
    FStore : TExtDataStore;
    FOnBeforechange : TExtToolbarPagingOnBeforechange;
    FOnChange : TExtToolbarPagingOnChange;
    procedure SetFAfterPageText(Value : String);
    procedure SetFBeforePageText(Value : String);
    procedure SetFDisplayInfo(Value : Boolean);
    procedure SetFDisplayMsg(Value : String);
    procedure SetFEmptyMsg(Value : String);
    procedure SetFFirstText(Value : String);
    procedure SetFInputItemWidth(Value : Integer);
    procedure SetFLastText(Value : String);
    procedure SetFNextText(Value : String);
    procedure SetFPrependButtons(Value : Boolean);
    procedure SetFPrevText(Value : String);
    procedure SetFRefreshText(Value : String);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFOnBeforechange(Value : TExtToolbarPagingOnBeforechange);
    procedure SetFOnChange(Value : TExtToolbarPagingOnChange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Bind(Store : TExtDataStore) : TExtFunction;
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    constructor Create;
    function DoRefresh : TExtFunction;
    function GetStore : TExtFunction;
    function MoveFirst : TExtFunction;
    function MoveLast : TExtFunction;
    function MoveNext : TExtFunction;
    function MovePrevious : TExtFunction;
    function Unbind(Store : TExtDataStore) : TExtFunction;
    destructor Destroy; override;
    property AfterPageText : String read FAfterPageText write SetFAfterPageText;
    property BeforePageText : String read FBeforePageText write SetFBeforePageText;
    property DisplayInfo : Boolean read FDisplayInfo write SetFDisplayInfo;
    property DisplayMsg : String read FDisplayMsg write SetFDisplayMsg;
    property EmptyMsg : String read FEmptyMsg write SetFEmptyMsg;
    property FirstText : String read FFirstText write SetFFirstText;
    property InputItemWidth : Integer read FInputItemWidth write SetFInputItemWidth;
    property LastText : String read FLastText write SetFLastText;
    property NextText : String read FNextText write SetFNextText;
    property PrependButtons : Boolean read FPrependButtons write SetFPrependButtons;
    property PrevText : String read FPrevText write SetFPrevText;
    property RefreshText : String read FRefreshText write SetFRefreshText;
    property Store : TExtDataStore read FStore write SetFStore;
    property OnBeforechange : TExtToolbarPagingOnBeforechange read FOnBeforechange write SetFOnBeforechange;
    property OnChange : TExtToolbarPagingOnChange read FOnChange write SetFOnChange;
  end;

  // Procedural types for events TExtFormFieldPicker
  TExtFormFieldPickerOnCollapse = procedure(Field : TExtFormFieldPicker) of object;
  TExtFormFieldPickerOnExpand = procedure(Field : TExtFormFieldPicker) of object;
  TExtFormFieldPickerOnSelect = procedure(Field : TExtFormFieldPicker; Value : TExtObject) of object;

  TExtFormFieldPicker = class(TExtFormFieldTrigger)
  private
    FEditable : Boolean;
    FIsExpanded : Boolean;
    FMatchFieldWidth : Boolean; // true
    FOpenCls : String;
    FPickerAlign : String; // 'tl-bl?'
    FOnCollapse : TExtFormFieldPickerOnCollapse;
    FOnExpand : TExtFormFieldPickerOnExpand;
    FOnSelect : TExtFormFieldPickerOnSelect;
    procedure SetFEditable(Value : Boolean);
    procedure SetFIsExpanded(Value : Boolean);
    procedure SetFMatchFieldWidth(Value : Boolean);
    procedure SetFOpenCls(Value : String);
    procedure SetFPickerAlign(Value : String);
    procedure SetFOnCollapse(Value : TExtFormFieldPickerOnCollapse);
    procedure SetFOnExpand(Value : TExtFormFieldPickerOnExpand);
    procedure SetFOnSelect(Value : TExtFormFieldPickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Collapse : TExtFunction;
    constructor Create;
    function Expand : TExtFunction;
    function GetPicker : TExtFunction;
    property Editable : Boolean read FEditable write SetFEditable;
    property IsExpanded : Boolean read FIsExpanded write SetFIsExpanded;
    property MatchFieldWidth : Boolean read FMatchFieldWidth write SetFMatchFieldWidth;
    property OpenCls : String read FOpenCls write SetFOpenCls;
    property PickerAlign : String read FPickerAlign write SetFPickerAlign;
    property OnCollapse : TExtFormFieldPickerOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtFormFieldPickerOnExpand read FOnExpand write SetFOnExpand;
    property OnSelect : TExtFormFieldPickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtFormFieldHtmlEditor
  TExtFormFieldHtmlEditorOnActivate = procedure(This : TExtFormFieldHtmlEditor) of object;
  TExtFormFieldHtmlEditorOnBeforepush = procedure(This : TExtFormFieldHtmlEditor; Html : String) of object;
  TExtFormFieldHtmlEditorOnBeforesync = procedure(This : TExtFormFieldHtmlEditor; Html : String) of object;
  TExtFormFieldHtmlEditorOnChange = procedure(This : TExtFormField; NewValue : TExtObject; OldValue : TExtObject) of object;
  TExtFormFieldHtmlEditorOnDirtychange = procedure(This : TExtFormField; IsDirty : Boolean) of object;
  TExtFormFieldHtmlEditorOnEditmodechange = procedure(This : TExtFormFieldHtmlEditor; SourceEdit : Boolean) of object;
  TExtFormFieldHtmlEditorOnInitialize = procedure(This : TExtFormFieldHtmlEditor) of object;
  TExtFormFieldHtmlEditorOnPush = procedure(This : TExtFormFieldHtmlEditor; Html : String) of object;
  TExtFormFieldHtmlEditorOnSync = procedure(This : TExtFormFieldHtmlEditor; Html : String) of object;
  TExtFormFieldHtmlEditorOnValiditychange = procedure(This : TExtFormField; IsValid : Boolean) of object;

  TExtFormFieldHtmlEditor = class(TExtFormFieldContainer)
  private
    FAfterIFrameTpl : String;
    FAfterIFrameTplList : TExtObjectList;
    FAfterIFrameTplTemplate : TExtXTemplate;
    FAfterTextAreaTpl : String;
    FAfterTextAreaTplList : TExtObjectList;
    FAfterTextAreaTplTemplate : TExtXTemplate;
    FBeforeIFrameTpl : String;
    FBeforeIFrameTplList : TExtObjectList;
    FBeforeIFrameTplTemplate : TExtXTemplate;
    FBeforeTextAreaTpl : String;
    FBeforeTextAreaTplList : TExtObjectList;
    FBeforeTextAreaTplTemplate : TExtXTemplate;
    FButtonTips : TExtObject;
    FCreateLinkText : String;
    FDefaultButtonUI : String;
    FDefaultLinkValue : String;
    FDefaultValue : String;
    FDisabled : Boolean;
    FEnableAlignments : Boolean;
    FEnableColors : Boolean;
    FEnableFont : Boolean;
    FEnableFontSize : Boolean;
    FEnableFormat : Boolean;
    FEnableLinks : Boolean;
    FEnableLists : Boolean;
    FEnableSourceEdit : Boolean;
    FFontFamilies : TArrayOfString;
    FIframeAttrTpl : String;
    FIframeAttrTplList : TExtObjectList;
    FIframeAttrTplTemplate : TExtXTemplate;
    FIsFormField : Boolean;
    FName : String;
    FOriginalValue : TExtObject;
    FSubmitValue : Boolean;
    FValidateOnChange : Boolean;
    FValue : TExtObject;
    FOnActivate : TExtFormFieldHtmlEditorOnActivate;
    FOnBeforepush : TExtFormFieldHtmlEditorOnBeforepush;
    FOnBeforesync : TExtFormFieldHtmlEditorOnBeforesync;
    FOnChange : TExtFormFieldHtmlEditorOnChange;
    FOnDirtychange : TExtFormFieldHtmlEditorOnDirtychange;
    FOnEditmodechange : TExtFormFieldHtmlEditorOnEditmodechange;
    FOnInitialize : TExtFormFieldHtmlEditorOnInitialize;
    FOnPush : TExtFormFieldHtmlEditorOnPush;
    FOnSync : TExtFormFieldHtmlEditorOnSync;
    FOnValiditychange : TExtFormFieldHtmlEditorOnValiditychange;
    procedure SetFAfterIFrameTpl(Value : String);
    procedure SetFAfterIFrameTplList(Value : TExtObjectList);
    procedure SetFAfterIFrameTplTemplate(Value : TExtXTemplate);
    procedure SetFAfterTextAreaTpl(Value : String);
    procedure SetFAfterTextAreaTplList(Value : TExtObjectList);
    procedure SetFAfterTextAreaTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeIFrameTpl(Value : String);
    procedure SetFBeforeIFrameTplList(Value : TExtObjectList);
    procedure SetFBeforeIFrameTplTemplate(Value : TExtXTemplate);
    procedure SetFBeforeTextAreaTpl(Value : String);
    procedure SetFBeforeTextAreaTplList(Value : TExtObjectList);
    procedure SetFBeforeTextAreaTplTemplate(Value : TExtXTemplate);
    procedure SetFButtonTips(Value : TExtObject);
    procedure SetFCreateLinkText(Value : String);
    procedure SetFDefaultButtonUI(Value : String);
    procedure SetFDefaultLinkValue(Value : String);
    procedure SetFDefaultValue(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFEnableAlignments(Value : Boolean);
    procedure SetFEnableColors(Value : Boolean);
    procedure SetFEnableFont(Value : Boolean);
    procedure SetFEnableFontSize(Value : Boolean);
    procedure SetFEnableFormat(Value : Boolean);
    procedure SetFEnableLinks(Value : Boolean);
    procedure SetFEnableLists(Value : Boolean);
    procedure SetFEnableSourceEdit(Value : Boolean);
    procedure SetFFontFamilies(Value : TArrayOfString);
    procedure SetFIframeAttrTpl(Value : String);
    procedure SetFIframeAttrTplList(Value : TExtObjectList);
    procedure SetFIframeAttrTplTemplate(Value : TExtXTemplate);
    procedure SetFIsFormField(Value : Boolean);
    procedure SetFName(Value : String);
    procedure SetFOriginalValue(Value : TExtObject);
    procedure SetFSubmitValue(Value : Boolean);
    procedure SetFValidateOnChange(Value : Boolean);
    procedure SetFValue(Value : TExtObject);
    procedure SetFOnActivate(Value : TExtFormFieldHtmlEditorOnActivate);
    procedure SetFOnBeforepush(Value : TExtFormFieldHtmlEditorOnBeforepush);
    procedure SetFOnBeforesync(Value : TExtFormFieldHtmlEditorOnBeforesync);
    procedure SetFOnChange(Value : TExtFormFieldHtmlEditorOnChange);
    procedure SetFOnDirtychange(Value : TExtFormFieldHtmlEditorOnDirtychange);
    procedure SetFOnEditmodechange(Value : TExtFormFieldHtmlEditorOnEditmodechange);
    procedure SetFOnInitialize(Value : TExtFormFieldHtmlEditorOnInitialize);
    procedure SetFOnPush(Value : TExtFormFieldHtmlEditorOnPush);
    procedure SetFOnSync(Value : TExtFormFieldHtmlEditorOnSync);
    procedure SetFOnValiditychange(Value : TExtFormFieldHtmlEditorOnValiditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BatchChanges(Fn : TExtObject) : TExtFunction;
    function CheckChange : TExtFunction;
    function CheckDirty : TExtFunction;
    constructor Create;
    function ExecCmd(Cmd : String; Value : String) : TExtFunction; overload;
    function ExecCmd(Cmd : String; Value : Boolean = false) : TExtFunction; overload;
    function ExtractFileInput : TExtFunction;
    function GetErrors(Value : TExtObject) : TExtFunction;
    function GetModelData : TExtFunction;
    function GetName : TExtFunction;
    function GetSubmitData : TExtFunction;
    function GetToolbar : TExtFunction;
    function GetValue : TExtFunction;
    function InitField : TExtFunction;
    function InitValue : TExtFunction;
    function InsertAtCursor(Text : String) : TExtFunction;
    function IsDirty : TExtFunction;
    function IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction;
    function IsFileUpload : TExtFunction;
    function IsValid : TExtFunction;
    function RelayCmd(Cmd : String; Value : String) : TExtFunction; overload;
    function RelayCmd(Cmd : String; Value : Boolean = false) : TExtFunction; overload;
    function Reset : TExtFunction;
    function ResetOriginalValue : TExtFunction;
    function SetReadOnly(ReadOnly : Boolean) : TExtFunction;
    function SetValue(Value : TExtObject) : TExtFunction;
    function ToggleSourceEdit(SourceEditMode : Boolean = false) : TExtFunction;
    function Validate : TExtFunction;
    destructor Destroy; override;
    property AfterIFrameTpl : String read FAfterIFrameTpl write SetFAfterIFrameTpl;
    property AfterIFrameTplList : TExtObjectList read FAfterIFrameTplList write SetFAfterIFrameTplList;
    property AfterIFrameTplTemplate : TExtXTemplate read FAfterIFrameTplTemplate write SetFAfterIFrameTplTemplate;
    property AfterTextAreaTpl : String read FAfterTextAreaTpl write SetFAfterTextAreaTpl;
    property AfterTextAreaTplList : TExtObjectList read FAfterTextAreaTplList write SetFAfterTextAreaTplList;
    property AfterTextAreaTplTemplate : TExtXTemplate read FAfterTextAreaTplTemplate write SetFAfterTextAreaTplTemplate;
    property BeforeIFrameTpl : String read FBeforeIFrameTpl write SetFBeforeIFrameTpl;
    property BeforeIFrameTplList : TExtObjectList read FBeforeIFrameTplList write SetFBeforeIFrameTplList;
    property BeforeIFrameTplTemplate : TExtXTemplate read FBeforeIFrameTplTemplate write SetFBeforeIFrameTplTemplate;
    property BeforeTextAreaTpl : String read FBeforeTextAreaTpl write SetFBeforeTextAreaTpl;
    property BeforeTextAreaTplList : TExtObjectList read FBeforeTextAreaTplList write SetFBeforeTextAreaTplList;
    property BeforeTextAreaTplTemplate : TExtXTemplate read FBeforeTextAreaTplTemplate write SetFBeforeTextAreaTplTemplate;
    property ButtonTips : TExtObject read FButtonTips write SetFButtonTips;
    property CreateLinkText : String read FCreateLinkText write SetFCreateLinkText;
    property DefaultButtonUI : String read FDefaultButtonUI write SetFDefaultButtonUI;
    property DefaultLinkValue : String read FDefaultLinkValue write SetFDefaultLinkValue;
    property DefaultValue : String read FDefaultValue write SetFDefaultValue;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property EnableAlignments : Boolean read FEnableAlignments write SetFEnableAlignments;
    property EnableColors : Boolean read FEnableColors write SetFEnableColors;
    property EnableFont : Boolean read FEnableFont write SetFEnableFont;
    property EnableFontSize : Boolean read FEnableFontSize write SetFEnableFontSize;
    property EnableFormat : Boolean read FEnableFormat write SetFEnableFormat;
    property EnableLinks : Boolean read FEnableLinks write SetFEnableLinks;
    property EnableLists : Boolean read FEnableLists write SetFEnableLists;
    property EnableSourceEdit : Boolean read FEnableSourceEdit write SetFEnableSourceEdit;
    property FontFamilies : TArrayOfString read FFontFamilies write SetFFontFamilies;
    property IframeAttrTpl : String read FIframeAttrTpl write SetFIframeAttrTpl;
    property IframeAttrTplList : TExtObjectList read FIframeAttrTplList write SetFIframeAttrTplList;
    property IframeAttrTplTemplate : TExtXTemplate read FIframeAttrTplTemplate write SetFIframeAttrTplTemplate;
    property IsFormField : Boolean read FIsFormField write SetFIsFormField;
    property Name : String read FName write SetFName;
    property OriginalValue : TExtObject read FOriginalValue write SetFOriginalValue;
    property SubmitValue : Boolean read FSubmitValue write SetFSubmitValue;
    property ValidateOnChange : Boolean read FValidateOnChange write SetFValidateOnChange;
    property Value : TExtObject read FValue write SetFValue;
    property OnActivate : TExtFormFieldHtmlEditorOnActivate read FOnActivate write SetFOnActivate;
    property OnBeforepush : TExtFormFieldHtmlEditorOnBeforepush read FOnBeforepush write SetFOnBeforepush;
    property OnBeforesync : TExtFormFieldHtmlEditorOnBeforesync read FOnBeforesync write SetFOnBeforesync;
    property OnChange : TExtFormFieldHtmlEditorOnChange read FOnChange write SetFOnChange;
    property OnDirtychange : TExtFormFieldHtmlEditorOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnEditmodechange : TExtFormFieldHtmlEditorOnEditmodechange read FOnEditmodechange write SetFOnEditmodechange;
    property OnInitialize : TExtFormFieldHtmlEditorOnInitialize read FOnInitialize write SetFOnInitialize;
    property OnPush : TExtFormFieldHtmlEditorOnPush read FOnPush write SetFOnPush;
    property OnSync : TExtFormFieldHtmlEditorOnSync read FOnSync write SetFOnSync;
    property OnValiditychange : TExtFormFieldHtmlEditorOnValiditychange read FOnValiditychange write SetFOnValiditychange;
  end;

  // Procedural types for events TExtTreeView
  TExtTreeViewOnAfteritemcollapse = procedure(Node : TExtDataNodeInterface; Index : Integer; Item : THTMLElement) of object;
  TExtTreeViewOnAfteritemexpand = procedure(Node : TExtDataNodeInterface; Index : Integer; Item : THTMLElement) of object;
  TExtTreeViewOnNodedragover = procedure(TargetNode : TExtDataNodeInterface; Position : String; DragData : TExtObject; E : TExtEventObject) of object;

  TExtTreeView = class(TExtViewTable)
  private
    FAnimate : Boolean;
    FDeferInitialRefresh : Boolean;
    FIsTreeView : Boolean;
    FRootVisible : Boolean;
    FOnAfteritemcollapse : TExtTreeViewOnAfteritemcollapse;
    FOnAfteritemexpand : TExtTreeViewOnAfteritemexpand;
    FOnNodedragover : TExtTreeViewOnNodedragover;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFDeferInitialRefresh(Value : Boolean);
    procedure SetFIsTreeView(Value : Boolean);
    procedure SetFRootVisible(Value : Boolean);
    procedure SetFOnAfteritemcollapse(Value : TExtTreeViewOnAfteritemcollapse);
    procedure SetFOnAfteritemexpand(Value : TExtTreeViewOnAfteritemexpand);
    procedure SetFOnNodedragover(Value : TExtTreeViewOnNodedragover);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Collapse(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Expand(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function GetTreeStore : TExtFunction;
    function Toggle(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property DeferInitialRefresh : Boolean read FDeferInitialRefresh write SetFDeferInitialRefresh;
    property IsTreeView : Boolean read FIsTreeView write SetFIsTreeView;
    property RootVisible : Boolean read FRootVisible write SetFRootVisible;
    property OnAfteritemcollapse : TExtTreeViewOnAfteritemcollapse read FOnAfteritemcollapse write SetFOnAfteritemcollapse;
    property OnAfteritemexpand : TExtTreeViewOnAfteritemexpand read FOnAfteritemexpand write SetFOnAfteritemexpand;
    property OnNodedragover : TExtTreeViewOnNodedragover read FOnNodedragover write SetFOnNodedragover;
  end;

  TExtLayoutComponentFieldText = class(TExtLayoutComponentField)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldTrigger = class(TExtLayoutComponentField)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldSlider = class(TExtLayoutComponentField)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldFieldContainer = class(TExtLayoutComponentField)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldSet = class(TExtLayoutComponentBody)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerAbsolute = class(TExtLayoutContainerAnchor)
  private
    FIgnoreOnContentChange : Boolean;
    procedure SetFIgnoreOnContentChange(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IgnoreOnContentChange : Boolean read FIgnoreOnContentChange write SetFIgnoreOnContentChange;
  end;

  // Procedural types for events TExtPanel
  TExtPanelOnBeforeclose = procedure(Panel : TExtPanel) of object;
  TExtPanelOnBeforecollapse = procedure(P : TExtPanel; Direction : String; Animate : Boolean) of object;
  TExtPanelOnBeforeexpand = procedure(P : TExtPanel; Animate : Boolean) of object;
  TExtPanelOnClose = procedure(Panel : TExtPanel) of object;
  TExtPanelOnCollapse = procedure(P : TExtPanel) of object;
  TExtPanelOnExpand = procedure(P : TExtPanel) of object;
  TExtPanelOnFloat = procedure of object;
  TExtPanelOnGlyphchange = procedure(This : TExtPanel; NewGlyph : Integer; OldGlyph : Integer) of object;
  TExtPanelOnIconchange = procedure(P : TExtPanel; NewIcon : String; OldIcon : String) of object;
  TExtPanelOnIconclschange = procedure(P : TExtPanel; NewIconCls : String; OldIconCls : String) of object;
  TExtPanelOnTitlechange = procedure(P : TExtPanel; NewTitle : String; OldTitle : String) of object;
  TExtPanelOnUnfloat = procedure of object;

  // Enumerated types for properties
  TButtonAlignEnum = (buRight, buLeft, buCenter);

  TExtPanel = class(TExtPanelAbstractPanel)
  private
    FAnimCollapse : Boolean;
    FBbar : TExtObjectList;
    FButtonAlign : TButtonAlignEnum;
    FButtons : TExtObjectList;
    FClosable : Boolean;
    FCloseAction : String;
    FCollapsed : Boolean;
    FCollapsedCls : String;
    FCollapseDirection : String;
    FCollapseFirst : Boolean;
    FCollapseMode : String;
    FCollapsible : Boolean;
    FConstrain : Boolean;
    FConstrainHeader : Boolean;
    FDd : TExtDdDragSource;
    FDdDragger : TExtUtilComponentDragger;
    FDockedItems : TExtObjectList;
    FFbar : TExtObjectList;
    FFloatable : Boolean;
    FFrame : Boolean;
    FFrameHeader : Boolean;
    FGlyph : Integer;
    FGlyphString : String;
    FHeader : Boolean;
    FHeaderObject : TExtObject;
    FHeaderOverCls : String;
    FHeaderPosition : String;
    FHideCollapseTool : Boolean;
    FIcon : String;
    FIconCls : String;
    FLbar : TExtObjectList;
    FManageHeight : Boolean;
    FMinButtonWidth : Integer;
    FOverlapHeader : Boolean;
    FPlaceholder : TExtComponent;
    FPlaceholderCollapseHideMode : Integer;
    FPlaceholderObject : TExtObject;
    FRbar : TExtObjectList;
    FSimpleDrag : Boolean;
    FTbar : TExtObjectList;
    FTitle : String;
    FTitleAlign : String; // 's natural * behavior depending on the css direction property - `'
    FTitleCollapse : Boolean;
    FTools : TExtObjectList;
    FToolsList : TExtObjectList;
    FOnBeforeclose : TExtPanelOnBeforeclose;
    FOnBeforecollapse : TExtPanelOnBeforecollapse;
    FOnBeforeexpand : TExtPanelOnBeforeexpand;
    FOnClose : TExtPanelOnClose;
    FOnCollapse : TExtPanelOnCollapse;
    FOnExpand : TExtPanelOnExpand;
    FOnFloat : TExtPanelOnFloat;
    FOnGlyphchange : TExtPanelOnGlyphchange;
    FOnIconchange : TExtPanelOnIconchange;
    FOnIconclschange : TExtPanelOnIconclschange;
    FOnTitlechange : TExtPanelOnTitlechange;
    FOnUnfloat : TExtPanelOnUnfloat;
    procedure SetFAnimCollapse(Value : Boolean);
    procedure SetFBbar(Value : TExtObjectList);
    procedure SetFButtonAlign(Value : TButtonAlignEnum);
    procedure SetFButtons(Value : TExtObjectList);
    procedure SetFClosable(Value : Boolean);
    procedure SetFCloseAction(Value : String);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFCollapsedCls(Value : String);
    procedure SetFCollapseDirection(Value : String);
    procedure SetFCollapseFirst(Value : Boolean);
    procedure SetFCollapseMode(Value : String);
    procedure SetFCollapsible(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFConstrainHeader(Value : Boolean);
    procedure SetFDd(Value : TExtDdDragSource);
    procedure SetFDdDragger(Value : TExtUtilComponentDragger);
    procedure SetFDockedItems(Value : TExtObjectList);
    procedure SetFFbar(Value : TExtObjectList);
    procedure SetFFloatable(Value : Boolean);
    procedure SetFFrame(Value : Boolean);
    procedure SetFFrameHeader(Value : Boolean);
    procedure SetFGlyph(Value : Integer);
    procedure SetFGlyphString(Value : String);
    procedure SetFHeader(Value : Boolean);
    procedure SetFHeaderObject(Value : TExtObject);
    procedure SetFHeaderOverCls(Value : String);
    procedure SetFHeaderPosition(Value : String);
    procedure SetFHideCollapseTool(Value : Boolean);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFLbar(Value : TExtObjectList);
    procedure SetFManageHeight(Value : Boolean);
    procedure SetFMinButtonWidth(Value : Integer);
    procedure SetFOverlapHeader(Value : Boolean);
    procedure SetFPlaceholder(Value : TExtComponent);
    procedure SetFPlaceholderCollapseHideMode(Value : Integer);
    procedure SetFPlaceholderObject(Value : TExtObject);
    procedure SetFRbar(Value : TExtObjectList);
    procedure SetFSimpleDrag(Value : Boolean);
    procedure SetFTbar(Value : TExtObjectList);
    procedure SetFTitle(Value : String);
    procedure SetFTitleAlign(Value : String);
    procedure SetFTitleCollapse(Value : Boolean);
    procedure SetFTools(Value : TExtObjectList);
    procedure SetFToolsList(Value : TExtObjectList);
    procedure SetFOnBeforeclose(Value : TExtPanelOnBeforeclose);
    procedure SetFOnBeforecollapse(Value : TExtPanelOnBeforecollapse);
    procedure SetFOnBeforeexpand(Value : TExtPanelOnBeforeexpand);
    procedure SetFOnClose(Value : TExtPanelOnClose);
    procedure SetFOnCollapse(Value : TExtPanelOnCollapse);
    procedure SetFOnExpand(Value : TExtPanelOnExpand);
    procedure SetFOnFloat(Value : TExtPanelOnFloat);
    procedure SetFOnGlyphchange(Value : TExtPanelOnGlyphchange);
    procedure SetFOnIconchange(Value : TExtPanelOnIconchange);
    procedure SetFOnIconclschange(Value : TExtPanelOnIconclschange);
    procedure SetFOnTitlechange(Value : TExtPanelOnTitlechange);
    procedure SetFOnUnfloat(Value : TExtPanelOnUnfloat);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AddTool(Tools : TExtObjectList) : TExtFunction; overload;
    function Close : TExtFunction;
    function Collapse(Direction : String = ''; Animate : Boolean = false) : TExtFunction;
    function ConvertCollapseDir : TExtFunction;
    constructor Create;
    function Expand(Animate : Boolean = false) : TExtFunction;
    function GetCollapsed : TExtFunction;
    function GetHeader : TExtFunction;
    function SetGlyph(NewGlyph : String) : TExtFunction; overload;
    function SetGlyph(NewGlyph : Integer) : TExtFunction; overload;
    function SetIcon(NewIcon : String) : TExtFunction;
    function SetIconCls(NewIconCls : String) : TExtFunction;
    function SetTitle(NewTitle : String) : TExtFunction;
    function ToggleCollapse : TExtFunction;
    destructor Destroy; override;
    property AnimCollapse : Boolean read FAnimCollapse write SetFAnimCollapse;
    property Bbar : TExtObjectList read FBbar write SetFBbar;
    property ButtonAlign : TButtonAlignEnum read FButtonAlign write SetFButtonAlign;
    property Buttons : TExtObjectList read FButtons write SetFButtons;
    property Closable : Boolean read FClosable write SetFClosable;
    property CloseAction : String read FCloseAction write SetFCloseAction;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property CollapsedCls : String read FCollapsedCls write SetFCollapsedCls;
    property CollapseDirection : String read FCollapseDirection write SetFCollapseDirection;
    property CollapseFirst : Boolean read FCollapseFirst write SetFCollapseFirst;
    property CollapseMode : String read FCollapseMode write SetFCollapseMode;
    property Collapsible : Boolean read FCollapsible write SetFCollapsible;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property ConstrainHeader : Boolean read FConstrainHeader write SetFConstrainHeader;
    property Dd : TExtDdDragSource read FDd write SetFDd;
    property DdDragger : TExtUtilComponentDragger read FDdDragger write SetFDdDragger;
    property DockedItems : TExtObjectList read FDockedItems write SetFDockedItems;
    property Fbar : TExtObjectList read FFbar write SetFFbar;
    property Floatable : Boolean read FFloatable write SetFFloatable;
    property Frame : Boolean read FFrame write SetFFrame;
    property FrameHeader : Boolean read FFrameHeader write SetFFrameHeader;
    property Glyph : Integer read FGlyph write SetFGlyph;
    property GlyphString : String read FGlyphString write SetFGlyphString;
    property Header : Boolean read FHeader write SetFHeader;
    property HeaderObject : TExtObject read FHeaderObject write SetFHeaderObject;
    property HeaderOverCls : String read FHeaderOverCls write SetFHeaderOverCls;
    property HeaderPosition : String read FHeaderPosition write SetFHeaderPosition;
    property HideCollapseTool : Boolean read FHideCollapseTool write SetFHideCollapseTool;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property Lbar : TExtObjectList read FLbar write SetFLbar;
    property ManageHeight : Boolean read FManageHeight write SetFManageHeight;
    property MinButtonWidth : Integer read FMinButtonWidth write SetFMinButtonWidth;
    property OverlapHeader : Boolean read FOverlapHeader write SetFOverlapHeader;
    property Placeholder : TExtComponent read FPlaceholder write SetFPlaceholder;
    property PlaceholderCollapseHideMode : Integer read FPlaceholderCollapseHideMode write SetFPlaceholderCollapseHideMode;
    property PlaceholderObject : TExtObject read FPlaceholderObject write SetFPlaceholderObject;
    property Rbar : TExtObjectList read FRbar write SetFRbar;
    property SimpleDrag : Boolean read FSimpleDrag write SetFSimpleDrag;
    property Tbar : TExtObjectList read FTbar write SetFTbar;
    property Title : String read FTitle write SetFTitle;
    property TitleAlign : String read FTitleAlign write SetFTitleAlign;
    property TitleCollapse : Boolean read FTitleCollapse write SetFTitleCollapse;
    property Tools : TExtObjectList read FTools write SetFTools;
    property ToolsList : TExtObjectList read FToolsList write SetFToolsList;
    property OnBeforeclose : TExtPanelOnBeforeclose read FOnBeforeclose write SetFOnBeforeclose;
    property OnBeforecollapse : TExtPanelOnBeforecollapse read FOnBeforecollapse write SetFOnBeforecollapse;
    property OnBeforeexpand : TExtPanelOnBeforeexpand read FOnBeforeexpand write SetFOnBeforeexpand;
    property OnClose : TExtPanelOnClose read FOnClose write SetFOnClose;
    property OnCollapse : TExtPanelOnCollapse read FOnCollapse write SetFOnCollapse;
    property OnExpand : TExtPanelOnExpand read FOnExpand write SetFOnExpand;
    property OnFloat : TExtPanelOnFloat read FOnFloat write SetFOnFloat;
    property OnGlyphchange : TExtPanelOnGlyphchange read FOnGlyphchange write SetFOnGlyphchange;
    property OnIconchange : TExtPanelOnIconchange read FOnIconchange write SetFOnIconchange;
    property OnIconclschange : TExtPanelOnIconclschange read FOnIconclschange write SetFOnIconclschange;
    property OnTitlechange : TExtPanelOnTitlechange read FOnTitlechange write SetFOnTitlechange;
    property OnUnfloat : TExtPanelOnUnfloat read FOnUnfloat write SetFOnUnfloat;
  end;

  TExtDrawSpriteDD = class(TExtDdDragSource)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtPanelDD = class(TExtDdDragSource)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutContainerAccordion = class(TExtLayoutContainerVBox)
  private
    FActiveOnTop : Boolean;
    FAnimate : Boolean;
    FAutoWidth : Boolean;
    FCollapseFirst : Boolean;
    FFill : Boolean;
    FHideCollapseTool : Boolean;
    FMulti : Boolean;
    FTitleCollapse : Boolean;
    procedure SetFActiveOnTop(Value : Boolean);
    procedure SetFAnimate(Value : Boolean);
    procedure SetFAutoWidth(Value : Boolean);
    procedure SetFCollapseFirst(Value : Boolean);
    procedure SetFFill(Value : Boolean);
    procedure SetFHideCollapseTool(Value : Boolean);
    procedure SetFMulti(Value : Boolean);
    procedure SetFTitleCollapse(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property ActiveOnTop : Boolean read FActiveOnTop write SetFActiveOnTop;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property AutoWidth : Boolean read FAutoWidth write SetFAutoWidth;
    property CollapseFirst : Boolean read FCollapseFirst write SetFCollapseFirst;
    property Fill : Boolean read FFill write SetFFill;
    property HideCollapseTool : Boolean read FHideCollapseTool write SetFHideCollapseTool;
    property Multi : Boolean read FMulti write SetFMulti;
    property TitleCollapse : Boolean read FTitleCollapse write SetFTitleCollapse;
  end;

  TExtPickerTime = class(TExtViewBoundList)
  private
    FFormat : String; // 'g:i A'
    FIncrement : Integer;
    FMaxValue : TDateTime;
    FMinValue : TDateTime;
    procedure SetFFormat(Value : String);
    procedure SetFIncrement(Value : Integer);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMinValue(Value : TDateTime);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetMaxValue(Value : TDateTime) : TExtFunction;
    function SetMinValue(Value : TDateTime) : TExtFunction;
    function UpdateList : TExtFunction;
    property Format : String read FFormat write SetFFormat;
    property Increment : Integer read FIncrement write SetFIncrement;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
  end;

  TExtGridView = class(TExtViewTable)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtViewDropZone = class(TExtDdDropZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtTabBar
  TExtTabBarOnChange = procedure(TabBar : TExtTabBar; Tab : TExtTab; Card : TExtComponent) of object;

  TExtTabBar = class(TExtPanelHeader)
  private
    FIsTabBar : Boolean;
    FPlain : Boolean;
    FOnChange : TExtTabBarOnChange;
    procedure SetFIsTabBar(Value : Boolean);
    procedure SetFPlain(Value : Boolean);
    procedure SetFOnChange(Value : TExtTabBarOnChange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property IsTabBar : Boolean read FIsTabBar write SetFIsTabBar;
    property Plain : Boolean read FPlain write SetFPlain;
    property OnChange : TExtTabBarOnChange read FOnChange write SetFOnChange;
  end;

  // Enumerated types for properties
  TAlignEnum = (alLeft, alRight, alCenter);

  TExtGridColumn = class(TExtGridHeaderContainer)
  private
    FAlign : TAlignEnum;
    FColumns : TExtObjectList;
    FDataIndex : String;
    FDraggable : Boolean;
    FEditor : TExtObject;
    FEditorString : String;
    FEditRenderer : TExtFunction;
    FEmptyCellText : String;
    FGroupable : Boolean;
    FHideable : Boolean;
    FIsHeader : Boolean;
    FLockable : Boolean;
    FLocked : Boolean;
    FMenuDisabled : Boolean;
    FMenuText : String;
    FRenderer : TExtFunction;
    FRendererColIndex : Integer;
    FRendererMetaData : TExtObject;
    FRendererRecord : TExtDataModel;
    FRendererReturn : String;
    FRendererRowIndex : Integer;
    FRendererStore : TExtDataStore;
    FRendererString : String;
    FRendererValue : TExtObject;
    FRendererView : TExtView;
    FResizable : Boolean;
    FScope : TExtObject;
    FSortable : Boolean;
    FStateId : String;
    FTdCls : String;
    FText : String;
    FTextEl : TExtElement;
    FTooltip : String;
    FTooltipType : String;
    FTriggerEl : TExtElement;
    procedure SetFAlign(Value : TAlignEnum);
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFDataIndex(Value : String);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFEditor(Value : TExtObject);
    procedure SetFEditorString(Value : String);
    procedure SetFEditRenderer(Value : TExtFunction);
    procedure SetFEmptyCellText(Value : String);
    procedure SetFGroupable(Value : Boolean);
    procedure SetFHideable(Value : Boolean);
    procedure SetFIsHeader(Value : Boolean);
    procedure SetFLockable(Value : Boolean);
    procedure SetFLocked(Value : Boolean);
    procedure SetFMenuDisabled(Value : Boolean);
    procedure SetFMenuText(Value : String);
    procedure SetFRenderer(Value : TExtFunction);
    procedure SetFRendererColIndex(Value : Integer);
    procedure SetFRendererMetaData(Value : TExtObject);
    procedure SetFRendererRecord(Value : TExtDataModel);
    procedure SetFRendererReturn(Value : String);
    procedure SetFRendererRowIndex(Value : Integer);
    procedure SetFRendererStore(Value : TExtDataStore);
    procedure SetFRendererString(Value : String);
    procedure SetFRendererValue(Value : TExtObject);
    procedure SetFRendererView(Value : TExtView);
    procedure SetFResizable(Value : Boolean);
    procedure SetFScope(Value : TExtObject);
    procedure SetFSortable(Value : Boolean);
    procedure SetFStateId(Value : String);
    procedure SetFTdCls(Value : String);
    procedure SetFText(Value : String);
    procedure SetFTextEl(Value : TExtElement);
    procedure SetFTooltip(Value : String);
    procedure SetFTooltipType(Value : String);
    procedure SetFTriggerEl(Value : TExtElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function AutoSize(The : TExtGridColumn) : TExtFunction; overload;
    function AutoSize(The : Integer) : TExtFunction; overload;
    constructor Create;
    function GetIndex : TExtFunction;
    function GetSortParam : TExtFunction;
    function GetVisibleIndex : TExtFunction;
    function IsHideable : TExtFunction;
    function IsLockable : TExtFunction;
    function SetText(Text : String) : TExtFunction;
    destructor Destroy; override;
    property Align : TAlignEnum read FAlign write SetFAlign;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property DataIndex : String read FDataIndex write SetFDataIndex;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Editor : TExtObject read FEditor write SetFEditor;
    property EditorString : String read FEditorString write SetFEditorString;
    property EditRenderer : TExtFunction read FEditRenderer write SetFEditRenderer;
    property EmptyCellText : String read FEmptyCellText write SetFEmptyCellText;
    property Groupable : Boolean read FGroupable write SetFGroupable;
    property Hideable : Boolean read FHideable write SetFHideable;
    property IsHeader : Boolean read FIsHeader write SetFIsHeader;
    property Lockable : Boolean read FLockable write SetFLockable;
    property Locked : Boolean read FLocked write SetFLocked;
    property MenuDisabled : Boolean read FMenuDisabled write SetFMenuDisabled;
    property MenuText : String read FMenuText write SetFMenuText;
    property Renderer : TExtFunction read FRenderer write SetFRenderer;
    property RendererColIndex : Integer read FRendererColIndex write SetFRendererColIndex;
    property RendererMetaData : TExtObject read FRendererMetaData write SetFRendererMetaData;
    property RendererRecord : TExtDataModel read FRendererRecord write SetFRendererRecord;
    property RendererReturn : String read FRendererReturn write SetFRendererReturn;
    property RendererRowIndex : Integer read FRendererRowIndex write SetFRendererRowIndex;
    property RendererStore : TExtDataStore read FRendererStore write SetFRendererStore;
    property RendererString : String read FRendererString write SetFRendererString;
    property RendererValue : TExtObject read FRendererValue write SetFRendererValue;
    property RendererView : TExtView read FRendererView write SetFRendererView;
    property Resizable : Boolean read FResizable write SetFResizable;
    property Scope : TExtObject read FScope write SetFScope;
    property Sortable : Boolean read FSortable write SetFSortable;
    property StateId : String read FStateId write SetFStateId;
    property TdCls : String read FTdCls write SetFTdCls;
    property Text : String read FText write SetFText;
    property TextEl : TExtElement read FTextEl write SetFTextEl;
    property Tooltip : String read FTooltip write SetFTooltip;
    property TooltipType : String read FTooltipType write SetFTooltipType;
    property TriggerEl : TExtElement read FTriggerEl write SetFTriggerEl;
  end;

  TExtGridCellEditor = class(TExtEditor)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridColumnLayout = class(TExtLayoutContainerHBox)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridPropertyHeaderContainer = class(TExtGridHeaderContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(Grid : TExtGridPropertyGrid; Source : TExtObject);
  end;

  TExtDdDragZone = class(TExtDdDragSource)
  private
    FContainerScroll : TExtObject;
    FContainerScrollBoolean : Boolean;
    FDragData : TExtObject;
    FScrollEl : String;
    FScrollElElement : TExtDomElement;
    FScrollElTHTMLElement : THTMLElement;
    procedure SetFContainerScroll(Value : TExtObject);
    procedure SetFContainerScrollBoolean(Value : Boolean);
    procedure SetFDragData(Value : TExtObject);
    procedure SetFScrollEl(Value : String);
    procedure SetFScrollElElement(Value : TExtDomElement);
    procedure SetFScrollElTHTMLElement(Value : THTMLElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create(El : THTMLElement; Config : TExtObject); overload;
    constructor Create(El : TExtElement; Config : TExtObject); overload;
    constructor Create(El : String; Config : TExtObject); overload;
    function GetDragData(E : TEvent) : TExtFunction;
    destructor Destroy; override;
    property ContainerScroll : TExtObject read FContainerScroll write SetFContainerScroll;
    property ContainerScrollBoolean : Boolean read FContainerScrollBoolean write SetFContainerScrollBoolean;
    property DragData : TExtObject read FDragData write SetFDragData;
    property ScrollEl : String read FScrollEl write SetFScrollEl;
    property ScrollElElement : TExtDomElement read FScrollElElement write SetFScrollElElement;
    property ScrollElTHTMLElement : THTMLElement read FScrollElTHTMLElement write SetFScrollElTHTMLElement;
  end;

  TExtGridHeaderDropZone = class(TExtDdDropZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridLockingHeaderContainer = class(TExtGridHeaderContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtViewDragZone = class(TExtDdDragZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  // Procedural types for events TExtWindow
  TExtWindowOnActivate = procedure(This : TExtWindow) of object;
  TExtWindowOnDeactivate = procedure(This : TExtWindow) of object;
  TExtWindowOnMaximize = procedure(This : TExtWindow) of object;
  TExtWindowOnMinimize = procedure(This : TExtWindow) of object;
  TExtWindowOnResize = procedure(This : TExtWindow; Width : Integer; Height : Integer) of object;
  TExtWindowOnRestore = procedure(This : TExtWindow) of object;

  TExtWindow = class(TExtPanel)
  private
    FAnimateTarget : String;
    FAnimateTargetElement : TExtElement;
    FBaseCls : String;
    FClosable : Boolean;
    FCollapsed : Boolean;
    FConstrain : Boolean;
    FConstrainHeader : Boolean;
    FDd : TExtUtilComponentDragger;
    FDefaultFocus : Integer;
    FDefaultFocusComponent : TExtComponent;
    FDefaultFocusString : String;
    FDraggable : Boolean;
    FExpandOnShow : Boolean;
    FGhost : Boolean;
    FGhostFunction : TExtFunction;
    FHidden : Boolean;
    FHideShadowOnDeactivate : Boolean;
    FIsWindow : Boolean;
    FMaximizable : Boolean;
    FMaximized : Boolean;
    FMinimizable : Boolean;
    FModal : Boolean;
    FOnEsc : TExtFunction;
    FPlain : Boolean;
    FResizable : Boolean;
    FResizableObject : TExtObject;
    FX : Integer;
    FY : Integer;
    FOnActivate : TExtWindowOnActivate;
    FOnDeactivate : TExtWindowOnDeactivate;
    FOnMaximize : TExtWindowOnMaximize;
    FOnMinimize : TExtWindowOnMinimize;
    FOnResize : TExtWindowOnResize;
    FOnRestore : TExtWindowOnRestore;
    procedure SetFAnimateTarget(Value : String);
    procedure SetFAnimateTargetElement(Value : TExtElement);
    procedure SetFBaseCls(Value : String);
    procedure SetFClosable(Value : Boolean);
    procedure SetFCollapsed(Value : Boolean);
    procedure SetFConstrain(Value : Boolean);
    procedure SetFConstrainHeader(Value : Boolean);
    procedure SetFDd(Value : TExtUtilComponentDragger);
    procedure SetFDefaultFocus(Value : Integer);
    procedure SetFDefaultFocusComponent(Value : TExtComponent);
    procedure SetFDefaultFocusString(Value : String);
    procedure SetFDraggable(Value : Boolean);
    procedure SetFExpandOnShow(Value : Boolean);
    procedure SetFGhost(Value : Boolean);
    procedure SetFGhostFunction(Value : TExtFunction);
    procedure SetFHidden(Value : Boolean);
    procedure SetFHideShadowOnDeactivate(Value : Boolean);
    procedure SetFIsWindow(Value : Boolean);
    procedure SetFMaximizable(Value : Boolean);
    procedure SetFMaximized(Value : Boolean);
    procedure SetFMinimizable(Value : Boolean);
    procedure SetFModal(Value : Boolean);
    procedure SetFOnEsc(Value : TExtFunction);
    procedure SetFPlain(Value : Boolean);
    procedure SetFResizable(Value : Boolean);
    procedure SetFResizableObject(Value : TExtObject);
    procedure SetFX(Value : Integer);
    procedure SetFY(Value : Integer);
    procedure SetFOnActivate(Value : TExtWindowOnActivate);
    procedure SetFOnDeactivate(Value : TExtWindowOnDeactivate);
    procedure SetFOnMaximize(Value : TExtWindowOnMaximize);
    procedure SetFOnMinimize(Value : TExtWindowOnMinimize);
    procedure SetFOnResize(Value : TExtWindowOnResize);
    procedure SetFOnRestore(Value : TExtWindowOnRestore);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetDefaultFocus : TExtFunction;
    function Maximize(Animate : Boolean) : TExtFunction;
    function Minimize : TExtFunction;
    function Restore : TExtFunction;
    function ToggleMaximize : TExtFunction;
    destructor Destroy; override;
    property AnimateTarget : String read FAnimateTarget write SetFAnimateTarget;
    property AnimateTargetElement : TExtElement read FAnimateTargetElement write SetFAnimateTargetElement;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Closable : Boolean read FClosable write SetFClosable;
    property Collapsed : Boolean read FCollapsed write SetFCollapsed;
    property Constrain : Boolean read FConstrain write SetFConstrain;
    property ConstrainHeader : Boolean read FConstrainHeader write SetFConstrainHeader;
    property Dd : TExtUtilComponentDragger read FDd write SetFDd;
    property DefaultFocus : Integer read FDefaultFocus write SetFDefaultFocus;
    property DefaultFocusComponent : TExtComponent read FDefaultFocusComponent write SetFDefaultFocusComponent;
    property DefaultFocusString : String read FDefaultFocusString write SetFDefaultFocusString;
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property ExpandOnShow : Boolean read FExpandOnShow write SetFExpandOnShow;
    property Ghost : Boolean read FGhost write SetFGhost;
    property GhostFunction : TExtFunction read FGhostFunction write SetFGhostFunction;
    property Hidden : Boolean read FHidden write SetFHidden;
    property HideShadowOnDeactivate : Boolean read FHideShadowOnDeactivate write SetFHideShadowOnDeactivate;
    property IsWindow : Boolean read FIsWindow write SetFIsWindow;
    property Maximizable : Boolean read FMaximizable write SetFMaximizable;
    property Maximized : Boolean read FMaximized write SetFMaximized;
    property Minimizable : Boolean read FMinimizable write SetFMinimizable;
    property Modal : Boolean read FModal write SetFModal;
    property OnEsc : TExtFunction read FOnEsc write SetFOnEsc;
    property Plain : Boolean read FPlain write SetFPlain;
    property Resizable : Boolean read FResizable write SetFResizable;
    property ResizableObject : TExtObject read FResizableObject write SetFResizableObject;
    property X : Integer read FX write SetFX;
    property Y : Integer read FY write SetFY;
    property OnActivate : TExtWindowOnActivate read FOnActivate write SetFOnActivate;
    property OnDeactivate : TExtWindowOnDeactivate read FOnDeactivate write SetFOnDeactivate;
    property OnMaximize : TExtWindowOnMaximize read FOnMaximize write SetFOnMaximize;
    property OnMinimize : TExtWindowOnMinimize read FOnMinimize write SetFOnMinimize;
    property OnResize : TExtWindowOnResize read FOnResize write SetFOnResize;
    property OnRestore : TExtWindowOnRestore read FOnRestore write SetFOnRestore;
  end;

  TExtGridColumnNumber = class(TExtGridColumn)
  private
    FFormat : String;
    procedure SetFFormat(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Format : String read FFormat write SetFFormat;
  end;

  TExtGridColumnTemplate = class(TExtGridColumn)
  private
    FTpl : String;
    FTplTemplate : TExtXTemplate;
    procedure SetFTpl(Value : String);
    procedure SetFTplTemplate(Value : TExtXTemplate);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Tpl : String read FTpl write SetFTpl;
    property TplTemplate : TExtXTemplate read FTplTemplate write SetFTplTemplate;
  end;

  // Procedural types for events TExtGridColumnCheckColumn
  TExtGridColumnCheckColumnOnBeforecheckchange = procedure(This : TExtGridColumnCheckColumn; RowIndex : Integer; Checked : Boolean) of object;
  TExtGridColumnCheckColumnOnCheckchange = procedure(This : TExtGridColumnCheckColumn; RowIndex : Integer; Checked : Boolean) of object;

  TExtGridColumnCheckColumn = class(TExtGridColumn)
  private
    FStopSelection : Boolean;
    FOnBeforecheckchange : TExtGridColumnCheckColumnOnBeforecheckchange;
    FOnCheckchange : TExtGridColumnCheckColumnOnCheckchange;
    procedure SetFStopSelection(Value : Boolean);
    procedure SetFOnBeforecheckchange(Value : TExtGridColumnCheckColumnOnBeforecheckchange);
    procedure SetFOnCheckchange(Value : TExtGridColumnCheckColumnOnCheckchange);
  protected
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function OnDisable(Silent : Boolean = false) : TExtFunction;
    function OnEnable(Silent : Boolean = false) : TExtFunction;
    property StopSelection : Boolean read FStopSelection write SetFStopSelection;
    property OnBeforecheckchange : TExtGridColumnCheckColumnOnBeforecheckchange read FOnBeforecheckchange write SetFOnBeforecheckchange;
    property OnCheckchange : TExtGridColumnCheckColumnOnCheckchange read FOnCheckchange write SetFOnCheckchange;
  end;

  TExtGridColumnDate = class(TExtGridColumn)
  private
    FFormat : String;
    procedure SetFFormat(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Format : String read FFormat write SetFFormat;
  end;

  TExtGridViewDropZone = class(TExtViewDropZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldComboBox = class(TExtLayoutComponentFieldTrigger)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridHeaderDragZone = class(TExtDdDragZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtGridRowNumberer = class(TExtGridColumn)
  private
    FDraggable : Boolean;
    FText : String;
    FWidth : Integer;
    procedure SetFDraggable(Value : Boolean);
    procedure SetFText(Value : String);
    procedure SetFWidth(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property Draggable : Boolean read FDraggable write SetFDraggable;
    property Text : String read FText write SetFText;
    property Width : Integer read FWidth write SetFWidth;
  end;

  TExtFormFieldDate = class(TExtFormFieldPicker)
  private
    FAltFormats : String;
    FDisabledDates : TArrayOfString;
    FDisabledDatesText : String;
    FDisabledDays : TArrayOfInteger;
    FDisabledDaysText : String;
    FFormat : String;
    FInvalidText : String;
    FMaxText : String;
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FMinText : String;
    FMinValue : TDateTime;
    FMinValueString : String;
    FShowToday : Boolean;
    FStartDay : Integer; // 0
    FSubmitFormat : String;
    FTriggerCls : String;
    FUseStrict : Boolean;
    procedure SetFAltFormats(Value : String);
    procedure SetFDisabledDates(Value : TArrayOfString);
    procedure SetFDisabledDatesText(Value : String);
    procedure SetFDisabledDays(Value : TArrayOfInteger);
    procedure SetFDisabledDaysText(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFInvalidText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
    procedure SetFShowToday(Value : Boolean);
    procedure SetFStartDay(Value : Integer);
    procedure SetFSubmitFormat(Value : String);
    procedure SetFTriggerCls(Value : String);
    procedure SetFUseStrict(Value : Boolean);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors(Value : TExtObject = nil) : TExtFunction;
    function SetDisabledDates(DisabledDates : TArrayOfString) : TExtFunction;
    function SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction;
    function SetMaxValue(Value : TDateTime) : TExtFunction;
    function SetMinValue(Value : TDateTime) : TExtFunction;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property DisabledDates : TArrayOfString read FDisabledDates write SetFDisabledDates;
    property DisabledDatesText : String read FDisabledDatesText write SetFDisabledDatesText;
    property DisabledDays : TArrayOfInteger read FDisabledDays write SetFDisabledDays;
    property DisabledDaysText : String read FDisabledDaysText write SetFDisabledDaysText;
    property Format : String read FFormat write SetFFormat;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
    property ShowToday : Boolean read FShowToday write SetFShowToday;
    property StartDay : Integer read FStartDay write SetFStartDay;
    property SubmitFormat : String read FSubmitFormat write SetFSubmitFormat;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property UseStrict : Boolean read FUseStrict write SetFUseStrict;
  end;

  TExtFormFieldNumber = class(TExtFormFieldSpinner)
  private
    FAllowDecimals : Boolean;
    FAutoStripChars : Boolean;
    FBaseChars : String;
    FDecimalPrecision : Integer;
    FDecimalSeparator : String;
    FMaxText : String;
    FMaxValue : Integer;
    FMinText : String;
    FMinValue : Integer;
    FNanText : String;
    FNegativeText : String;
    FStep : Integer;
    FSubmitLocaleSeparator : Boolean;
    procedure SetFAllowDecimals(Value : Boolean);
    procedure SetFAutoStripChars(Value : Boolean);
    procedure SetFBaseChars(Value : String);
    procedure SetFDecimalPrecision(Value : Integer);
    procedure SetFDecimalSeparator(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : Integer);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : Integer);
    procedure SetFNanText(Value : String);
    procedure SetFNegativeText(Value : String);
    procedure SetFStep(Value : Integer);
    procedure SetFSubmitLocaleSeparator(Value : Boolean);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function GetErrors(Value : TExtObject = nil) : TExtFunction;
    function SetMaxValue(Value : Integer) : TExtFunction;
    function SetMinValue(Value : Integer) : TExtFunction;
    property AllowDecimals : Boolean read FAllowDecimals write SetFAllowDecimals;
    property AutoStripChars : Boolean read FAutoStripChars write SetFAutoStripChars;
    property BaseChars : String read FBaseChars write SetFBaseChars;
    property DecimalPrecision : Integer read FDecimalPrecision write SetFDecimalPrecision;
    property DecimalSeparator : String read FDecimalSeparator write SetFDecimalSeparator;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : Integer read FMaxValue write SetFMaxValue;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : Integer read FMinValue write SetFMinValue;
    property NanText : String read FNanText write SetFNanText;
    property NegativeText : String read FNegativeText write SetFNegativeText;
    property Step : Integer read FStep write SetFStep;
    property SubmitLocaleSeparator : Boolean read FSubmitLocaleSeparator write SetFSubmitLocaleSeparator;
  end;

  TExtContainerButtonGroup = class(TExtPanel)
  private
    FBaseCls : String;
    FColumns : Integer;
    FDefaultButtonUI : String;
    FFrame : Boolean;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    procedure SetFBaseCls(Value : String);
    procedure SetFColumns(Value : Integer);
    procedure SetFDefaultButtonUI(Value : String);
    procedure SetFFrame(Value : Boolean);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property BaseCls : String read FBaseCls write SetFBaseCls;
    property Columns : Integer read FColumns write SetFColumns;
    property DefaultButtonUI : String read FDefaultButtonUI write SetFDefaultButtonUI;
    property Frame : Boolean read FFrame write SetFFrame;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
  end;

  // Procedural types for events TExtFormFieldComboBox
  TExtFormFieldComboBoxOnBeforedeselect = procedure(Combo : TExtFormFieldComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;
  TExtFormFieldComboBoxOnBeforequery = procedure(QueryEvent : TExtObject) of object;
  TExtFormFieldComboBoxOnBeforeselect = procedure(Combo : TExtFormFieldComboBox; RecordJS : TExtDataRecord; Index : Integer) of object;
  TExtFormFieldComboBoxOnSelect = procedure(Combo : TExtFormFieldComboBox; Records : TExtObjectList) of object;

  TExtFormFieldComboBox = class(TExtFormFieldPicker)
  private
    FAllQuery : String;
    FAutoSelect : Boolean;
    FDefaultListConfig : TExtObject;
    FDelimiter : String;
    FDisplayField : String;
    FEnableRegEx : Boolean;
    FForceSelection : Boolean;
    FGrowToLongestValue : Boolean;
    FHiddenName : String;
    FLastQuery : String;
    FListConfig : TExtObject;
    FMultiSelect : Boolean;
    FPageSize : Integer;
    FQueryCaching : Boolean;
    FQueryDelay : Integer; // 500
    FQueryMode : String;
    FQueryParam : String;
    FSelectOnTab : Boolean;
    FStore : TExtDataStore;
    FStoreList : TExtObjectList;
    FStoreString : String;
    FTransform : String;
    FTransformElement : TExtElement;
    FTransformTHTMLElement : THTMLElement;
    FTriggerAction : String;
    FTriggerCls : String;
    FTypeAhead : Boolean;
    FTypeAheadDelay : Integer;
    FValueField : String;
    FValueNotFoundText : String;
    FOnBeforedeselect : TExtFormFieldComboBoxOnBeforedeselect;
    FOnBeforequery : TExtFormFieldComboBoxOnBeforequery;
    FOnBeforeselect : TExtFormFieldComboBoxOnBeforeselect;
    FOnSelect : TExtFormFieldComboBoxOnSelect;
    procedure SetFAllQuery(Value : String);
    procedure SetFAutoSelect(Value : Boolean);
    procedure SetFDefaultListConfig(Value : TExtObject);
    procedure SetFDelimiter(Value : String);
    procedure SetFDisplayField(Value : String);
    procedure SetFEnableRegEx(Value : Boolean);
    procedure SetFForceSelection(Value : Boolean);
    procedure SetFGrowToLongestValue(Value : Boolean);
    procedure SetFHiddenName(Value : String);
    procedure SetFLastQuery(Value : String);
    procedure SetFListConfig(Value : TExtObject);
    procedure SetFMultiSelect(Value : Boolean);
    procedure SetFPageSize(Value : Integer);
    procedure SetFQueryCaching(Value : Boolean);
    procedure SetFQueryDelay(Value : Integer);
    procedure SetFQueryMode(Value : String);
    procedure SetFQueryParam(Value : String);
    procedure SetFSelectOnTab(Value : Boolean);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFStoreList(Value : TExtObjectList);
    procedure SetFStoreString(Value : String);
    procedure SetFTransform(Value : String);
    procedure SetFTransformElement(Value : TExtElement);
    procedure SetFTransformTHTMLElement(Value : THTMLElement);
    procedure SetFTriggerAction(Value : String);
    procedure SetFTriggerCls(Value : String);
    procedure SetFTypeAhead(Value : Boolean);
    procedure SetFTypeAheadDelay(Value : Integer);
    procedure SetFValueField(Value : String);
    procedure SetFValueNotFoundText(Value : String);
    procedure SetFOnBeforedeselect(Value : TExtFormFieldComboBoxOnBeforedeselect);
    procedure SetFOnBeforequery(Value : TExtFormFieldComboBoxOnBeforequery);
    procedure SetFOnBeforeselect(Value : TExtFormFieldComboBoxOnBeforeselect);
    procedure SetFOnSelect(Value : TExtFormFieldComboBoxOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function BindStore(Store : String = '') : TExtFunction; overload;
    function BindStore(Store : TExtDataAbstractStore) : TExtFunction; overload;
    function ClearValue : TExtFunction;
    constructor Create;
    function DoQuery(QueryString : String; ForceAll : Boolean = false; RawQuery : Boolean = false) : TExtFunction;
    function FindRecord(Field : String; Value : TExtObject) : TExtFunction;
    function FindRecordByDisplay(Value : TExtObject) : TExtFunction;
    function FindRecordByValue(Value : TExtObject) : TExtFunction;
    function GetStore : TExtFunction;
    function Select(R : TExtObject) : TExtFunction;
    function SetValue(Value : TArrayOfString) : TExtFunction; overload;
    function SetValue(Value : String) : TExtFunction; overload;
    destructor Destroy; override;
    property AllQuery : String read FAllQuery write SetFAllQuery;
    property AutoSelect : Boolean read FAutoSelect write SetFAutoSelect;
    property DefaultListConfig : TExtObject read FDefaultListConfig write SetFDefaultListConfig;
    property Delimiter : String read FDelimiter write SetFDelimiter;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property EnableRegEx : Boolean read FEnableRegEx write SetFEnableRegEx;
    property ForceSelection : Boolean read FForceSelection write SetFForceSelection;
    property GrowToLongestValue : Boolean read FGrowToLongestValue write SetFGrowToLongestValue;
    property HiddenName : String read FHiddenName write SetFHiddenName;
    property LastQuery : String read FLastQuery write SetFLastQuery;
    property ListConfig : TExtObject read FListConfig write SetFListConfig;
    property MultiSelect : Boolean read FMultiSelect write SetFMultiSelect;
    property PageSize : Integer read FPageSize write SetFPageSize;
    property QueryCaching : Boolean read FQueryCaching write SetFQueryCaching;
    property QueryDelay : Integer read FQueryDelay write SetFQueryDelay;
    property QueryMode : String read FQueryMode write SetFQueryMode;
    property QueryParam : String read FQueryParam write SetFQueryParam;
    property SelectOnTab : Boolean read FSelectOnTab write SetFSelectOnTab;
    property Store : TExtDataStore read FStore write SetFStore;
    property StoreList : TExtObjectList read FStoreList write SetFStoreList;
    property StoreString : String read FStoreString write SetFStoreString;
    property Transform : String read FTransform write SetFTransform;
    property TransformElement : TExtElement read FTransformElement write SetFTransformElement;
    property TransformTHTMLElement : THTMLElement read FTransformTHTMLElement write SetFTransformTHTMLElement;
    property TriggerAction : String read FTriggerAction write SetFTriggerAction;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
    property TypeAhead : Boolean read FTypeAhead write SetFTypeAhead;
    property TypeAheadDelay : Integer read FTypeAheadDelay write SetFTypeAheadDelay;
    property ValueField : String read FValueField write SetFValueField;
    property ValueNotFoundText : String read FValueNotFoundText write SetFValueNotFoundText;
    property OnBeforedeselect : TExtFormFieldComboBoxOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforequery : TExtFormFieldComboBoxOnBeforequery read FOnBeforequery write SetFOnBeforequery;
    property OnBeforeselect : TExtFormFieldComboBoxOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnSelect : TExtFormFieldComboBoxOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtGridColumnAction = class(TExtGridColumn)
  private
    FAltText : String;
    FDisabled : Boolean;
    FGetClass : TExtFunction;
    FGetClassColIndex : Integer;
    FGetClassMetadata : TExtObject;
    FGetClassMetadataAttr : String;
    FGetClassMetadataCss : String;
    FGetClassR : TExtDataModel;
    FGetClassRowIndex : Integer;
    FGetClassStore : TExtDataStore;
    FGetClassV : TExtObject;
    FGetTip : TExtFunction;
    FGetTipColIndex : Integer;
    FGetTipMetadata : TExtObject;
    FGetTipMetadataAttr : String;
    FGetTipMetadataCss : String;
    FGetTipR : TExtDataModel;
    FGetTipRowIndex : Integer;
    FGetTipStore : TExtDataStore;
    FGetTipV : TExtObject;
    FHandler : TExtFunction;
    FHandlerColIndex : Integer;
    FHandlerE : TEvent;
    FHandlerItem : TExtObject;
    FHandlerRecord : TExtDataModel;
    FHandlerRow : THTMLElement;
    FHandlerRowIndex : Integer;
    FHandlerView : TExtViewTable;
    FIcon : String;
    FIconCls : String;
    FIsDisabled : TExtFunction;
    FIsDisabledColIndex : Integer;
    FIsDisabledItem : TExtObject;
    FIsDisabledRecord : TExtDataModel;
    FIsDisabledRowIndex : Integer;
    FIsDisabledView : TExtViewTable;
    FItems : TExtObjectList;
    FItemsDisabled : Boolean;
    FItemsGetClass : TExtFunction;
    FItemsGetClassColIndex : Integer;
    FItemsGetClassMetadata : TExtObject;
    FItemsGetClassMetadataAttr : String;
    FItemsGetClassMetadataCss : String;
    FItemsGetClassR : TExtDataModel;
    FItemsGetClassRowIndex : Integer;
    FItemsGetClassStore : TExtDataStore;
    FItemsGetClassV : TExtObject;
    FItemsGetTip : TExtFunction;
    FItemsGetTipColIndex : Integer;
    FItemsGetTipMetadata : TExtObject;
    FItemsGetTipMetadataAttr : String;
    FItemsGetTipMetadataCss : String;
    FItemsGetTipR : TExtDataModel;
    FItemsGetTipRowIndex : Integer;
    FItemsGetTipStore : TExtDataStore;
    FItemsGetTipV : TExtObject;
    FItemsHandler : TExtFunction;
    FItemsHandlerColIndex : Integer;
    FItemsHandlerE : TEvent;
    FItemsHandlerItem : TExtObject;
    FItemsHandlerRecord : TExtDataModel;
    FItemsHandlerRowIndex : Integer;
    FItemsHandlerView : TExtViewTable;
    FItemsIcon : String;
    FItemsIconCls : String;
    FItemsIsDisabled : TExtFunction;
    FItemsIsDisabledColIndex : Integer;
    FItemsIsDisabledItem : TExtObject;
    FItemsIsDisabledRecord : TExtDataModel;
    FItemsIsDisabledRowIndex : Integer;
    FItemsIsDisabledView : TExtViewTable;
    FItemsRow : THTMLElement;
    FItemsScope : TExtObject;
    FItemsTooltip : String;
    FMenuText : String;
    FScope : TExtObject;
    FStopSelection : Boolean;
    FTooltip : String;
    procedure SetFAltText(Value : String);
    procedure SetFDisabled(Value : Boolean);
    procedure SetFGetClass(Value : TExtFunction);
    procedure SetFGetClassColIndex(Value : Integer);
    procedure SetFGetClassMetadata(Value : TExtObject);
    procedure SetFGetClassMetadataAttr(Value : String);
    procedure SetFGetClassMetadataCss(Value : String);
    procedure SetFGetClassR(Value : TExtDataModel);
    procedure SetFGetClassRowIndex(Value : Integer);
    procedure SetFGetClassStore(Value : TExtDataStore);
    procedure SetFGetClassV(Value : TExtObject);
    procedure SetFGetTip(Value : TExtFunction);
    procedure SetFGetTipColIndex(Value : Integer);
    procedure SetFGetTipMetadata(Value : TExtObject);
    procedure SetFGetTipMetadataAttr(Value : String);
    procedure SetFGetTipMetadataCss(Value : String);
    procedure SetFGetTipR(Value : TExtDataModel);
    procedure SetFGetTipRowIndex(Value : Integer);
    procedure SetFGetTipStore(Value : TExtDataStore);
    procedure SetFGetTipV(Value : TExtObject);
    procedure SetFHandler(Value : TExtFunction);
    procedure SetFHandlerColIndex(Value : Integer);
    procedure SetFHandlerE(Value : TEvent);
    procedure SetFHandlerItem(Value : TExtObject);
    procedure SetFHandlerRecord(Value : TExtDataModel);
    procedure SetFHandlerRow(Value : THTMLElement);
    procedure SetFHandlerRowIndex(Value : Integer);
    procedure SetFHandlerView(Value : TExtViewTable);
    procedure SetFIcon(Value : String);
    procedure SetFIconCls(Value : String);
    procedure SetFIsDisabled(Value : TExtFunction);
    procedure SetFIsDisabledColIndex(Value : Integer);
    procedure SetFIsDisabledItem(Value : TExtObject);
    procedure SetFIsDisabledRecord(Value : TExtDataModel);
    procedure SetFIsDisabledRowIndex(Value : Integer);
    procedure SetFIsDisabledView(Value : TExtViewTable);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFItemsDisabled(Value : Boolean);
    procedure SetFItemsGetClass(Value : TExtFunction);
    procedure SetFItemsGetClassColIndex(Value : Integer);
    procedure SetFItemsGetClassMetadata(Value : TExtObject);
    procedure SetFItemsGetClassMetadataAttr(Value : String);
    procedure SetFItemsGetClassMetadataCss(Value : String);
    procedure SetFItemsGetClassR(Value : TExtDataModel);
    procedure SetFItemsGetClassRowIndex(Value : Integer);
    procedure SetFItemsGetClassStore(Value : TExtDataStore);
    procedure SetFItemsGetClassV(Value : TExtObject);
    procedure SetFItemsGetTip(Value : TExtFunction);
    procedure SetFItemsGetTipColIndex(Value : Integer);
    procedure SetFItemsGetTipMetadata(Value : TExtObject);
    procedure SetFItemsGetTipMetadataAttr(Value : String);
    procedure SetFItemsGetTipMetadataCss(Value : String);
    procedure SetFItemsGetTipR(Value : TExtDataModel);
    procedure SetFItemsGetTipRowIndex(Value : Integer);
    procedure SetFItemsGetTipStore(Value : TExtDataStore);
    procedure SetFItemsGetTipV(Value : TExtObject);
    procedure SetFItemsHandler(Value : TExtFunction);
    procedure SetFItemsHandlerColIndex(Value : Integer);
    procedure SetFItemsHandlerE(Value : TEvent);
    procedure SetFItemsHandlerItem(Value : TExtObject);
    procedure SetFItemsHandlerRecord(Value : TExtDataModel);
    procedure SetFItemsHandlerRowIndex(Value : Integer);
    procedure SetFItemsHandlerView(Value : TExtViewTable);
    procedure SetFItemsIcon(Value : String);
    procedure SetFItemsIconCls(Value : String);
    procedure SetFItemsIsDisabled(Value : TExtFunction);
    procedure SetFItemsIsDisabledColIndex(Value : Integer);
    procedure SetFItemsIsDisabledItem(Value : TExtObject);
    procedure SetFItemsIsDisabledRecord(Value : TExtDataModel);
    procedure SetFItemsIsDisabledRowIndex(Value : Integer);
    procedure SetFItemsIsDisabledView(Value : TExtViewTable);
    procedure SetFItemsRow(Value : THTMLElement);
    procedure SetFItemsScope(Value : TExtObject);
    procedure SetFItemsTooltip(Value : String);
    procedure SetFMenuText(Value : String);
    procedure SetFScope(Value : TExtObject);
    procedure SetFStopSelection(Value : Boolean);
    procedure SetFTooltip(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function DisableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; overload;
    function DisableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; overload;
    function EnableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; overload;
    function EnableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; overload;
    destructor Destroy; override;
    property AltText : String read FAltText write SetFAltText;
    property Disabled : Boolean read FDisabled write SetFDisabled;
    property GetClass : TExtFunction read FGetClass write SetFGetClass;
    property GetClassColIndex : Integer read FGetClassColIndex write SetFGetClassColIndex;
    property GetClassMetadata : TExtObject read FGetClassMetadata write SetFGetClassMetadata;
    property GetClassMetadataAttr : String read FGetClassMetadataAttr write SetFGetClassMetadataAttr;
    property GetClassMetadataCss : String read FGetClassMetadataCss write SetFGetClassMetadataCss;
    property GetClassR : TExtDataModel read FGetClassR write SetFGetClassR;
    property GetClassRowIndex : Integer read FGetClassRowIndex write SetFGetClassRowIndex;
    property GetClassStore : TExtDataStore read FGetClassStore write SetFGetClassStore;
    property GetClassV : TExtObject read FGetClassV write SetFGetClassV;
    property GetTip : TExtFunction read FGetTip write SetFGetTip;
    property GetTipColIndex : Integer read FGetTipColIndex write SetFGetTipColIndex;
    property GetTipMetadata : TExtObject read FGetTipMetadata write SetFGetTipMetadata;
    property GetTipMetadataAttr : String read FGetTipMetadataAttr write SetFGetTipMetadataAttr;
    property GetTipMetadataCss : String read FGetTipMetadataCss write SetFGetTipMetadataCss;
    property GetTipR : TExtDataModel read FGetTipR write SetFGetTipR;
    property GetTipRowIndex : Integer read FGetTipRowIndex write SetFGetTipRowIndex;
    property GetTipStore : TExtDataStore read FGetTipStore write SetFGetTipStore;
    property GetTipV : TExtObject read FGetTipV write SetFGetTipV;
    property Handler : TExtFunction read FHandler write SetFHandler;
    property HandlerColIndex : Integer read FHandlerColIndex write SetFHandlerColIndex;
    property HandlerE : TEvent read FHandlerE write SetFHandlerE;
    property HandlerItem : TExtObject read FHandlerItem write SetFHandlerItem;
    property HandlerRecord : TExtDataModel read FHandlerRecord write SetFHandlerRecord;
    property HandlerRow : THTMLElement read FHandlerRow write SetFHandlerRow;
    property HandlerRowIndex : Integer read FHandlerRowIndex write SetFHandlerRowIndex;
    property HandlerView : TExtViewTable read FHandlerView write SetFHandlerView;
    property Icon : String read FIcon write SetFIcon;
    property IconCls : String read FIconCls write SetFIconCls;
    property IsDisabled : TExtFunction read FIsDisabled write SetFIsDisabled;
    property IsDisabledColIndex : Integer read FIsDisabledColIndex write SetFIsDisabledColIndex;
    property IsDisabledItem : TExtObject read FIsDisabledItem write SetFIsDisabledItem;
    property IsDisabledRecord : TExtDataModel read FIsDisabledRecord write SetFIsDisabledRecord;
    property IsDisabledRowIndex : Integer read FIsDisabledRowIndex write SetFIsDisabledRowIndex;
    property IsDisabledView : TExtViewTable read FIsDisabledView write SetFIsDisabledView;
    property Items : TExtObjectList read FItems write SetFItems;
    property ItemsDisabled : Boolean read FItemsDisabled write SetFItemsDisabled;
    property ItemsGetClass : TExtFunction read FItemsGetClass write SetFItemsGetClass;
    property ItemsGetClassColIndex : Integer read FItemsGetClassColIndex write SetFItemsGetClassColIndex;
    property ItemsGetClassMetadata : TExtObject read FItemsGetClassMetadata write SetFItemsGetClassMetadata;
    property ItemsGetClassMetadataAttr : String read FItemsGetClassMetadataAttr write SetFItemsGetClassMetadataAttr;
    property ItemsGetClassMetadataCss : String read FItemsGetClassMetadataCss write SetFItemsGetClassMetadataCss;
    property ItemsGetClassR : TExtDataModel read FItemsGetClassR write SetFItemsGetClassR;
    property ItemsGetClassRowIndex : Integer read FItemsGetClassRowIndex write SetFItemsGetClassRowIndex;
    property ItemsGetClassStore : TExtDataStore read FItemsGetClassStore write SetFItemsGetClassStore;
    property ItemsGetClassV : TExtObject read FItemsGetClassV write SetFItemsGetClassV;
    property ItemsGetTip : TExtFunction read FItemsGetTip write SetFItemsGetTip;
    property ItemsGetTipColIndex : Integer read FItemsGetTipColIndex write SetFItemsGetTipColIndex;
    property ItemsGetTipMetadata : TExtObject read FItemsGetTipMetadata write SetFItemsGetTipMetadata;
    property ItemsGetTipMetadataAttr : String read FItemsGetTipMetadataAttr write SetFItemsGetTipMetadataAttr;
    property ItemsGetTipMetadataCss : String read FItemsGetTipMetadataCss write SetFItemsGetTipMetadataCss;
    property ItemsGetTipR : TExtDataModel read FItemsGetTipR write SetFItemsGetTipR;
    property ItemsGetTipRowIndex : Integer read FItemsGetTipRowIndex write SetFItemsGetTipRowIndex;
    property ItemsGetTipStore : TExtDataStore read FItemsGetTipStore write SetFItemsGetTipStore;
    property ItemsGetTipV : TExtObject read FItemsGetTipV write SetFItemsGetTipV;
    property ItemsHandler : TExtFunction read FItemsHandler write SetFItemsHandler;
    property ItemsHandlerColIndex : Integer read FItemsHandlerColIndex write SetFItemsHandlerColIndex;
    property ItemsHandlerE : TEvent read FItemsHandlerE write SetFItemsHandlerE;
    property ItemsHandlerItem : TExtObject read FItemsHandlerItem write SetFItemsHandlerItem;
    property ItemsHandlerRecord : TExtDataModel read FItemsHandlerRecord write SetFItemsHandlerRecord;
    property ItemsHandlerRowIndex : Integer read FItemsHandlerRowIndex write SetFItemsHandlerRowIndex;
    property ItemsHandlerView : TExtViewTable read FItemsHandlerView write SetFItemsHandlerView;
    property ItemsIcon : String read FItemsIcon write SetFItemsIcon;
    property ItemsIconCls : String read FItemsIconCls write SetFItemsIconCls;
    property ItemsIsDisabled : TExtFunction read FItemsIsDisabled write SetFItemsIsDisabled;
    property ItemsIsDisabledColIndex : Integer read FItemsIsDisabledColIndex write SetFItemsIsDisabledColIndex;
    property ItemsIsDisabledItem : TExtObject read FItemsIsDisabledItem write SetFItemsIsDisabledItem;
    property ItemsIsDisabledRecord : TExtDataModel read FItemsIsDisabledRecord write SetFItemsIsDisabledRecord;
    property ItemsIsDisabledRowIndex : Integer read FItemsIsDisabledRowIndex write SetFItemsIsDisabledRowIndex;
    property ItemsIsDisabledView : TExtViewTable read FItemsIsDisabledView write SetFItemsIsDisabledView;
    property ItemsRow : THTMLElement read FItemsRow write SetFItemsRow;
    property ItemsScope : TExtObject read FItemsScope write SetFItemsScope;
    property ItemsTooltip : String read FItemsTooltip write SetFItemsTooltip;
    property MenuText : String read FMenuText write SetFMenuText;
    property Scope : TExtObject read FScope write SetFScope;
    property StopSelection : Boolean read FStopSelection write SetFStopSelection;
    property Tooltip : String read FTooltip write SetFTooltip;
  end;

  TExtGridColumnBoolean = class(TExtGridColumn)
  private
    FFalseText : String;
    FTrueText : String;
    FUndefinedText : String;
    procedure SetFFalseText(Value : String);
    procedure SetFTrueText(Value : String);
    procedure SetFUndefinedText(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property FalseText : String read FFalseText write SetFFalseText;
    property TrueText : String read FTrueText write SetFTrueText;
    property UndefinedText : String read FUndefinedText write SetFUndefinedText;
  end;

  // Procedural types for events TExtFormPanel
  TExtFormPanelOnActioncomplete = procedure of object;
  TExtFormPanelOnActionfailed = procedure of object;
  TExtFormPanelOnBeforeaction = procedure of object;
  TExtFormPanelOnDirtychange = procedure of object;
  TExtFormPanelOnFielderrorchange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; Error : String) of object;
  TExtFormPanelOnFieldvaliditychange = procedure(This : TExtFormFieldAncestor; The : TExtFormLabelable; IsValid : String) of object;
  TExtFormPanelOnValiditychange = procedure of object;

  TExtFormPanel = class(TExtPanel)
  private
    FFieldDefaults : TExtObject;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    FPollForChanges : Boolean;
    FPollInterval : Integer; // 500
    FOnActioncomplete : TExtFormPanelOnActioncomplete;
    FOnActionfailed : TExtFormPanelOnActionfailed;
    FOnBeforeaction : TExtFormPanelOnBeforeaction;
    FOnDirtychange : TExtFormPanelOnDirtychange;
    FOnFielderrorchange : TExtFormPanelOnFielderrorchange;
    FOnFieldvaliditychange : TExtFormPanelOnFieldvaliditychange;
    FOnValiditychange : TExtFormPanelOnValiditychange;
    procedure SetFFieldDefaults(Value : TExtObject);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
    procedure SetFPollForChanges(Value : Boolean);
    procedure SetFPollInterval(Value : Integer);
    procedure SetFOnActioncomplete(Value : TExtFormPanelOnActioncomplete);
    procedure SetFOnActionfailed(Value : TExtFormPanelOnActionfailed);
    procedure SetFOnBeforeaction(Value : TExtFormPanelOnBeforeaction);
    procedure SetFOnDirtychange(Value : TExtFormPanelOnDirtychange);
    procedure SetFOnFielderrorchange(Value : TExtFormPanelOnFielderrorchange);
    procedure SetFOnFieldvaliditychange(Value : TExtFormPanelOnFieldvaliditychange);
    procedure SetFOnValiditychange(Value : TExtFormPanelOnValiditychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CheckChange : TExtFunction;
    constructor Create;
    function GetForm : TExtFunction;
    function GetRecord : TExtFunction;
    function GetValues : TExtFunction;
    function HasInvalidField : TExtFunction;
    function IsDirty : TExtFunction;
    function IsValid : TExtFunction;
    function Load(Options : TExtObject) : TExtFunction;
    function LoadRecord(RecordJS : TExtDataModel) : TExtFunction;
    function StartPolling(Interval : Integer) : TExtFunction;
    function StopPolling : TExtFunction;
    function Submit(Options : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property FieldDefaults : TExtObject read FFieldDefaults write SetFFieldDefaults;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
    property PollForChanges : Boolean read FPollForChanges write SetFPollForChanges;
    property PollInterval : Integer read FPollInterval write SetFPollInterval;
    property OnActioncomplete : TExtFormPanelOnActioncomplete read FOnActioncomplete write SetFOnActioncomplete;
    property OnActionfailed : TExtFormPanelOnActionfailed read FOnActionfailed write SetFOnActionfailed;
    property OnBeforeaction : TExtFormPanelOnBeforeaction read FOnBeforeaction write SetFOnBeforeaction;
    property OnDirtychange : TExtFormPanelOnDirtychange read FOnDirtychange write SetFOnDirtychange;
    property OnFielderrorchange : TExtFormPanelOnFielderrorchange read FOnFielderrorchange write SetFOnFielderrorchange;
    property OnFieldvaliditychange : TExtFormPanelOnFieldvaliditychange read FOnFieldvaliditychange write SetFOnFieldvaliditychange;
    property OnValiditychange : TExtFormPanelOnValiditychange read FOnValiditychange write SetFOnValiditychange;
  end;

  TExtFormRadioGroup = class(TExtFormCheckboxGroup)
  private
    FAllowBlank : Boolean;
    FBlankText : String;
    FItems : TExtObjectList;
    FItemsList : TExtObjectList;
    procedure SetFAllowBlank(Value : Boolean);
    procedure SetFBlankText(Value : String);
    procedure SetFItems(Value : TExtObjectList);
    procedure SetFItemsList(Value : TExtObjectList);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function SetValue(Value : TExtObject) : TExtFunction;
    destructor Destroy; override;
    property AllowBlank : Boolean read FAllowBlank write SetFAllowBlank;
    property BlankText : String read FBlankText write SetFBlankText;
    property Items : TExtObjectList read FItems write SetFItems;
    property ItemsList : TExtObjectList read FItemsList write SetFItemsList;
  end;

  // Procedural types for events TExtPanelTable
  TExtPanelTableOnBeforecellclick = procedure of object;
  TExtPanelTableOnBeforecellcontextmenu = procedure of object;
  TExtPanelTableOnBeforecelldblclick = procedure of object;
  TExtPanelTableOnBeforecellkeydown = procedure of object;
  TExtPanelTableOnBeforecellmousedown = procedure of object;
  TExtPanelTableOnBeforecellmouseup = procedure of object;
  TExtPanelTableOnBeforecontainerclick = procedure of object;
  TExtPanelTableOnBeforecontainercontextmenu = procedure of object;
  TExtPanelTableOnBeforecontainerdblclick = procedure of object;
  TExtPanelTableOnBeforecontainermousedown = procedure of object;
  TExtPanelTableOnBeforecontainermouseout = procedure of object;
  TExtPanelTableOnBeforecontainermouseover = procedure of object;
  TExtPanelTableOnBeforecontainermouseup = procedure of object;
  TExtPanelTableOnBeforedeselect = procedure of object;
  TExtPanelTableOnBeforeitemclick = procedure of object;
  TExtPanelTableOnBeforeitemcontextmenu = procedure of object;
  TExtPanelTableOnBeforeitemdblclick = procedure of object;
  TExtPanelTableOnBeforeitemmousedown = procedure of object;
  TExtPanelTableOnBeforeitemmouseenter = procedure of object;
  TExtPanelTableOnBeforeitemmouseleave = procedure of object;
  TExtPanelTableOnBeforeitemmouseup = procedure of object;
  TExtPanelTableOnBeforeselect = procedure of object;
  TExtPanelTableOnCellclick = procedure of object;
  TExtPanelTableOnCellcontextmenu = procedure of object;
  TExtPanelTableOnCelldblclick = procedure of object;
  TExtPanelTableOnCellkeydown = procedure of object;
  TExtPanelTableOnCellmousedown = procedure of object;
  TExtPanelTableOnCellmouseup = procedure of object;
  TExtPanelTableOnColumnhide = procedure of object;
  TExtPanelTableOnColumnmove = procedure of object;
  TExtPanelTableOnColumnresize = procedure of object;
  TExtPanelTableOnColumnschanged = procedure of object;
  TExtPanelTableOnColumnshow = procedure of object;
  TExtPanelTableOnContainerclick = procedure of object;
  TExtPanelTableOnContainercontextmenu = procedure of object;
  TExtPanelTableOnContainerdblclick = procedure of object;
  TExtPanelTableOnContainermouseout = procedure of object;
  TExtPanelTableOnContainermouseover = procedure of object;
  TExtPanelTableOnContainermouseup = procedure of object;
  TExtPanelTableOnDeselect = procedure of object;
  TExtPanelTableOnFilterchange = procedure of object;
  TExtPanelTableOnHeaderclick = procedure of object;
  TExtPanelTableOnHeadercontextmenu = procedure of object;
  TExtPanelTableOnHeadertriggerclick = procedure of object;
  TExtPanelTableOnItemclick = procedure of object;
  TExtPanelTableOnItemcontextmenu = procedure of object;
  TExtPanelTableOnItemdblclick = procedure of object;
  TExtPanelTableOnItemmousedown = procedure of object;
  TExtPanelTableOnItemmouseenter = procedure of object;
  TExtPanelTableOnItemmouseleave = procedure of object;
  TExtPanelTableOnItemmouseup = procedure of object;
  TExtPanelTableOnSelect = procedure of object;
  TExtPanelTableOnSelectionchange = procedure of object;
  TExtPanelTableOnSortchange = procedure of object;
  TExtPanelTableOnViewready = procedure(This : TExtPanelTable) of object;

  TExtPanelTable = class(TExtPanel)
  private
    FAllowDeselect : Boolean;
    FColumnLines : Boolean;
    FColumns : TExtObjectList;
    FColumnsObject : TExtObject;
    FDeferRowRender : Boolean; // true
    FDisableSelection : Boolean;
    FEmptyText : String;
    FEnableColumnHide : Boolean;
    FEnableColumnMove : Boolean;
    FEnableColumnResize : Boolean;
    FEnableLocking : Boolean;
    FFeatures : TExtObjectList;
    FFeaturesList : TExtObjectList;
    FForceFit : Boolean;
    FHasView : Boolean;
    FHideHeaders : Boolean;
    FOptimizedColumnMove : Boolean;
    FRowLines : Boolean;
    FScroll : String;
    FScrollBoolean : Boolean;
    FSealedColumns : Boolean;
    FSelModel : TExtSelectionModel;
    FSelModelObject : TExtObject;
    FSelType : String; // 'rowmodel'
    FSortableColumns : Boolean;
    FStore : TExtDataStore;
    FVerticalScroller : TExtObject;
    FView : TExtViewTable;
    FViewConfig : TExtObject;
    FOnBeforecellclick : TExtPanelTableOnBeforecellclick;
    FOnBeforecellcontextmenu : TExtPanelTableOnBeforecellcontextmenu;
    FOnBeforecelldblclick : TExtPanelTableOnBeforecelldblclick;
    FOnBeforecellkeydown : TExtPanelTableOnBeforecellkeydown;
    FOnBeforecellmousedown : TExtPanelTableOnBeforecellmousedown;
    FOnBeforecellmouseup : TExtPanelTableOnBeforecellmouseup;
    FOnBeforecontainerclick : TExtPanelTableOnBeforecontainerclick;
    FOnBeforecontainercontextmenu : TExtPanelTableOnBeforecontainercontextmenu;
    FOnBeforecontainerdblclick : TExtPanelTableOnBeforecontainerdblclick;
    FOnBeforecontainermousedown : TExtPanelTableOnBeforecontainermousedown;
    FOnBeforecontainermouseout : TExtPanelTableOnBeforecontainermouseout;
    FOnBeforecontainermouseover : TExtPanelTableOnBeforecontainermouseover;
    FOnBeforecontainermouseup : TExtPanelTableOnBeforecontainermouseup;
    FOnBeforedeselect : TExtPanelTableOnBeforedeselect;
    FOnBeforeitemclick : TExtPanelTableOnBeforeitemclick;
    FOnBeforeitemcontextmenu : TExtPanelTableOnBeforeitemcontextmenu;
    FOnBeforeitemdblclick : TExtPanelTableOnBeforeitemdblclick;
    FOnBeforeitemmousedown : TExtPanelTableOnBeforeitemmousedown;
    FOnBeforeitemmouseenter : TExtPanelTableOnBeforeitemmouseenter;
    FOnBeforeitemmouseleave : TExtPanelTableOnBeforeitemmouseleave;
    FOnBeforeitemmouseup : TExtPanelTableOnBeforeitemmouseup;
    FOnBeforeselect : TExtPanelTableOnBeforeselect;
    FOnCellclick : TExtPanelTableOnCellclick;
    FOnCellcontextmenu : TExtPanelTableOnCellcontextmenu;
    FOnCelldblclick : TExtPanelTableOnCelldblclick;
    FOnCellkeydown : TExtPanelTableOnCellkeydown;
    FOnCellmousedown : TExtPanelTableOnCellmousedown;
    FOnCellmouseup : TExtPanelTableOnCellmouseup;
    FOnColumnhide : TExtPanelTableOnColumnhide;
    FOnColumnmove : TExtPanelTableOnColumnmove;
    FOnColumnresize : TExtPanelTableOnColumnresize;
    FOnColumnschanged : TExtPanelTableOnColumnschanged;
    FOnColumnshow : TExtPanelTableOnColumnshow;
    FOnContainerclick : TExtPanelTableOnContainerclick;
    FOnContainercontextmenu : TExtPanelTableOnContainercontextmenu;
    FOnContainerdblclick : TExtPanelTableOnContainerdblclick;
    FOnContainermouseout : TExtPanelTableOnContainermouseout;
    FOnContainermouseover : TExtPanelTableOnContainermouseover;
    FOnContainermouseup : TExtPanelTableOnContainermouseup;
    FOnDeselect : TExtPanelTableOnDeselect;
    FOnFilterchange : TExtPanelTableOnFilterchange;
    FOnHeaderclick : TExtPanelTableOnHeaderclick;
    FOnHeadercontextmenu : TExtPanelTableOnHeadercontextmenu;
    FOnHeadertriggerclick : TExtPanelTableOnHeadertriggerclick;
    FOnItemclick : TExtPanelTableOnItemclick;
    FOnItemcontextmenu : TExtPanelTableOnItemcontextmenu;
    FOnItemdblclick : TExtPanelTableOnItemdblclick;
    FOnItemmousedown : TExtPanelTableOnItemmousedown;
    FOnItemmouseenter : TExtPanelTableOnItemmouseenter;
    FOnItemmouseleave : TExtPanelTableOnItemmouseleave;
    FOnItemmouseup : TExtPanelTableOnItemmouseup;
    FOnSelect : TExtPanelTableOnSelect;
    FOnSelectionchange : TExtPanelTableOnSelectionchange;
    FOnSortchange : TExtPanelTableOnSortchange;
    FOnViewready : TExtPanelTableOnViewready;
    procedure SetFAllowDeselect(Value : Boolean);
    procedure SetFColumnLines(Value : Boolean);
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFColumnsObject(Value : TExtObject);
    procedure SetFDeferRowRender(Value : Boolean);
    procedure SetFDisableSelection(Value : Boolean);
    procedure SetFEmptyText(Value : String);
    procedure SetFEnableColumnHide(Value : Boolean);
    procedure SetFEnableColumnMove(Value : Boolean);
    procedure SetFEnableColumnResize(Value : Boolean);
    procedure SetFEnableLocking(Value : Boolean);
    procedure SetFFeatures(Value : TExtObjectList);
    procedure SetFFeaturesList(Value : TExtObjectList);
    procedure SetFForceFit(Value : Boolean);
    procedure SetFHasView(Value : Boolean);
    procedure SetFHideHeaders(Value : Boolean);
    procedure SetFOptimizedColumnMove(Value : Boolean);
    procedure SetFRowLines(Value : Boolean);
    procedure SetFScroll(Value : String);
    procedure SetFScrollBoolean(Value : Boolean);
    procedure SetFSealedColumns(Value : Boolean);
    procedure SetFSelModel(Value : TExtSelectionModel);
    procedure SetFSelModelObject(Value : TExtObject);
    procedure SetFSelType(Value : String);
    procedure SetFSortableColumns(Value : Boolean);
    procedure SetFStore(Value : TExtDataStore);
    procedure SetFVerticalScroller(Value : TExtObject);
    procedure SetFView(Value : TExtViewTable);
    procedure SetFViewConfig(Value : TExtObject);
    procedure SetFOnBeforecellclick(Value : TExtPanelTableOnBeforecellclick);
    procedure SetFOnBeforecellcontextmenu(Value : TExtPanelTableOnBeforecellcontextmenu);
    procedure SetFOnBeforecelldblclick(Value : TExtPanelTableOnBeforecelldblclick);
    procedure SetFOnBeforecellkeydown(Value : TExtPanelTableOnBeforecellkeydown);
    procedure SetFOnBeforecellmousedown(Value : TExtPanelTableOnBeforecellmousedown);
    procedure SetFOnBeforecellmouseup(Value : TExtPanelTableOnBeforecellmouseup);
    procedure SetFOnBeforecontainerclick(Value : TExtPanelTableOnBeforecontainerclick);
    procedure SetFOnBeforecontainercontextmenu(Value : TExtPanelTableOnBeforecontainercontextmenu);
    procedure SetFOnBeforecontainerdblclick(Value : TExtPanelTableOnBeforecontainerdblclick);
    procedure SetFOnBeforecontainermousedown(Value : TExtPanelTableOnBeforecontainermousedown);
    procedure SetFOnBeforecontainermouseout(Value : TExtPanelTableOnBeforecontainermouseout);
    procedure SetFOnBeforecontainermouseover(Value : TExtPanelTableOnBeforecontainermouseover);
    procedure SetFOnBeforecontainermouseup(Value : TExtPanelTableOnBeforecontainermouseup);
    procedure SetFOnBeforedeselect(Value : TExtPanelTableOnBeforedeselect);
    procedure SetFOnBeforeitemclick(Value : TExtPanelTableOnBeforeitemclick);
    procedure SetFOnBeforeitemcontextmenu(Value : TExtPanelTableOnBeforeitemcontextmenu);
    procedure SetFOnBeforeitemdblclick(Value : TExtPanelTableOnBeforeitemdblclick);
    procedure SetFOnBeforeitemmousedown(Value : TExtPanelTableOnBeforeitemmousedown);
    procedure SetFOnBeforeitemmouseenter(Value : TExtPanelTableOnBeforeitemmouseenter);
    procedure SetFOnBeforeitemmouseleave(Value : TExtPanelTableOnBeforeitemmouseleave);
    procedure SetFOnBeforeitemmouseup(Value : TExtPanelTableOnBeforeitemmouseup);
    procedure SetFOnBeforeselect(Value : TExtPanelTableOnBeforeselect);
    procedure SetFOnCellclick(Value : TExtPanelTableOnCellclick);
    procedure SetFOnCellcontextmenu(Value : TExtPanelTableOnCellcontextmenu);
    procedure SetFOnCelldblclick(Value : TExtPanelTableOnCelldblclick);
    procedure SetFOnCellkeydown(Value : TExtPanelTableOnCellkeydown);
    procedure SetFOnCellmousedown(Value : TExtPanelTableOnCellmousedown);
    procedure SetFOnCellmouseup(Value : TExtPanelTableOnCellmouseup);
    procedure SetFOnColumnhide(Value : TExtPanelTableOnColumnhide);
    procedure SetFOnColumnmove(Value : TExtPanelTableOnColumnmove);
    procedure SetFOnColumnresize(Value : TExtPanelTableOnColumnresize);
    procedure SetFOnColumnschanged(Value : TExtPanelTableOnColumnschanged);
    procedure SetFOnColumnshow(Value : TExtPanelTableOnColumnshow);
    procedure SetFOnContainerclick(Value : TExtPanelTableOnContainerclick);
    procedure SetFOnContainercontextmenu(Value : TExtPanelTableOnContainercontextmenu);
    procedure SetFOnContainerdblclick(Value : TExtPanelTableOnContainerdblclick);
    procedure SetFOnContainermouseout(Value : TExtPanelTableOnContainermouseout);
    procedure SetFOnContainermouseover(Value : TExtPanelTableOnContainermouseover);
    procedure SetFOnContainermouseup(Value : TExtPanelTableOnContainermouseup);
    procedure SetFOnDeselect(Value : TExtPanelTableOnDeselect);
    procedure SetFOnFilterchange(Value : TExtPanelTableOnFilterchange);
    procedure SetFOnHeaderclick(Value : TExtPanelTableOnHeaderclick);
    procedure SetFOnHeadercontextmenu(Value : TExtPanelTableOnHeadercontextmenu);
    procedure SetFOnHeadertriggerclick(Value : TExtPanelTableOnHeadertriggerclick);
    procedure SetFOnItemclick(Value : TExtPanelTableOnItemclick);
    procedure SetFOnItemcontextmenu(Value : TExtPanelTableOnItemcontextmenu);
    procedure SetFOnItemdblclick(Value : TExtPanelTableOnItemdblclick);
    procedure SetFOnItemmousedown(Value : TExtPanelTableOnItemmousedown);
    procedure SetFOnItemmouseenter(Value : TExtPanelTableOnItemmouseenter);
    procedure SetFOnItemmouseleave(Value : TExtPanelTableOnItemmouseleave);
    procedure SetFOnItemmouseup(Value : TExtPanelTableOnItemmouseup);
    procedure SetFOnSelect(Value : TExtPanelTableOnSelect);
    procedure SetFOnSelectionchange(Value : TExtPanelTableOnSelectionchange);
    procedure SetFOnSortchange(Value : TExtPanelTableOnSortchange);
    procedure SetFOnViewready(Value : TExtPanelTableOnViewready);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetSelectionModel : TExtFunction;
    function GetStore : TExtFunction;
    function GetView : TExtFunction;
    destructor Destroy; override;
    property AllowDeselect : Boolean read FAllowDeselect write SetFAllowDeselect;
    property ColumnLines : Boolean read FColumnLines write SetFColumnLines;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property ColumnsObject : TExtObject read FColumnsObject write SetFColumnsObject;
    property DeferRowRender : Boolean read FDeferRowRender write SetFDeferRowRender;
    property DisableSelection : Boolean read FDisableSelection write SetFDisableSelection;
    property EmptyText : String read FEmptyText write SetFEmptyText;
    property EnableColumnHide : Boolean read FEnableColumnHide write SetFEnableColumnHide;
    property EnableColumnMove : Boolean read FEnableColumnMove write SetFEnableColumnMove;
    property EnableColumnResize : Boolean read FEnableColumnResize write SetFEnableColumnResize;
    property EnableLocking : Boolean read FEnableLocking write SetFEnableLocking;
    property Features : TExtObjectList read FFeatures write SetFFeatures;
    property FeaturesList : TExtObjectList read FFeaturesList write SetFFeaturesList;
    property ForceFit : Boolean read FForceFit write SetFForceFit;
    property HasView : Boolean read FHasView write SetFHasView;
    property HideHeaders : Boolean read FHideHeaders write SetFHideHeaders;
    property OptimizedColumnMove : Boolean read FOptimizedColumnMove write SetFOptimizedColumnMove;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property Scroll : String read FScroll write SetFScroll;
    property ScrollBoolean : Boolean read FScrollBoolean write SetFScrollBoolean;
    property SealedColumns : Boolean read FSealedColumns write SetFSealedColumns;
    property SelModel : TExtSelectionModel read FSelModel write SetFSelModel;
    property SelModelObject : TExtObject read FSelModelObject write SetFSelModelObject;
    property SelType : String read FSelType write SetFSelType;
    property SortableColumns : Boolean read FSortableColumns write SetFSortableColumns;
    property Store : TExtDataStore read FStore write SetFStore;
    property VerticalScroller : TExtObject read FVerticalScroller write SetFVerticalScroller;
    property View : TExtViewTable read FView write SetFView;
    property ViewConfig : TExtObject read FViewConfig write SetFViewConfig;
    property OnBeforecellclick : TExtPanelTableOnBeforecellclick read FOnBeforecellclick write SetFOnBeforecellclick;
    property OnBeforecellcontextmenu : TExtPanelTableOnBeforecellcontextmenu read FOnBeforecellcontextmenu write SetFOnBeforecellcontextmenu;
    property OnBeforecelldblclick : TExtPanelTableOnBeforecelldblclick read FOnBeforecelldblclick write SetFOnBeforecelldblclick;
    property OnBeforecellkeydown : TExtPanelTableOnBeforecellkeydown read FOnBeforecellkeydown write SetFOnBeforecellkeydown;
    property OnBeforecellmousedown : TExtPanelTableOnBeforecellmousedown read FOnBeforecellmousedown write SetFOnBeforecellmousedown;
    property OnBeforecellmouseup : TExtPanelTableOnBeforecellmouseup read FOnBeforecellmouseup write SetFOnBeforecellmouseup;
    property OnBeforecontainerclick : TExtPanelTableOnBeforecontainerclick read FOnBeforecontainerclick write SetFOnBeforecontainerclick;
    property OnBeforecontainercontextmenu : TExtPanelTableOnBeforecontainercontextmenu read FOnBeforecontainercontextmenu write SetFOnBeforecontainercontextmenu;
    property OnBeforecontainerdblclick : TExtPanelTableOnBeforecontainerdblclick read FOnBeforecontainerdblclick write SetFOnBeforecontainerdblclick;
    property OnBeforecontainermousedown : TExtPanelTableOnBeforecontainermousedown read FOnBeforecontainermousedown write SetFOnBeforecontainermousedown;
    property OnBeforecontainermouseout : TExtPanelTableOnBeforecontainermouseout read FOnBeforecontainermouseout write SetFOnBeforecontainermouseout;
    property OnBeforecontainermouseover : TExtPanelTableOnBeforecontainermouseover read FOnBeforecontainermouseover write SetFOnBeforecontainermouseover;
    property OnBeforecontainermouseup : TExtPanelTableOnBeforecontainermouseup read FOnBeforecontainermouseup write SetFOnBeforecontainermouseup;
    property OnBeforedeselect : TExtPanelTableOnBeforedeselect read FOnBeforedeselect write SetFOnBeforedeselect;
    property OnBeforeitemclick : TExtPanelTableOnBeforeitemclick read FOnBeforeitemclick write SetFOnBeforeitemclick;
    property OnBeforeitemcontextmenu : TExtPanelTableOnBeforeitemcontextmenu read FOnBeforeitemcontextmenu write SetFOnBeforeitemcontextmenu;
    property OnBeforeitemdblclick : TExtPanelTableOnBeforeitemdblclick read FOnBeforeitemdblclick write SetFOnBeforeitemdblclick;
    property OnBeforeitemmousedown : TExtPanelTableOnBeforeitemmousedown read FOnBeforeitemmousedown write SetFOnBeforeitemmousedown;
    property OnBeforeitemmouseenter : TExtPanelTableOnBeforeitemmouseenter read FOnBeforeitemmouseenter write SetFOnBeforeitemmouseenter;
    property OnBeforeitemmouseleave : TExtPanelTableOnBeforeitemmouseleave read FOnBeforeitemmouseleave write SetFOnBeforeitemmouseleave;
    property OnBeforeitemmouseup : TExtPanelTableOnBeforeitemmouseup read FOnBeforeitemmouseup write SetFOnBeforeitemmouseup;
    property OnBeforeselect : TExtPanelTableOnBeforeselect read FOnBeforeselect write SetFOnBeforeselect;
    property OnCellclick : TExtPanelTableOnCellclick read FOnCellclick write SetFOnCellclick;
    property OnCellcontextmenu : TExtPanelTableOnCellcontextmenu read FOnCellcontextmenu write SetFOnCellcontextmenu;
    property OnCelldblclick : TExtPanelTableOnCelldblclick read FOnCelldblclick write SetFOnCelldblclick;
    property OnCellkeydown : TExtPanelTableOnCellkeydown read FOnCellkeydown write SetFOnCellkeydown;
    property OnCellmousedown : TExtPanelTableOnCellmousedown read FOnCellmousedown write SetFOnCellmousedown;
    property OnCellmouseup : TExtPanelTableOnCellmouseup read FOnCellmouseup write SetFOnCellmouseup;
    property OnColumnhide : TExtPanelTableOnColumnhide read FOnColumnhide write SetFOnColumnhide;
    property OnColumnmove : TExtPanelTableOnColumnmove read FOnColumnmove write SetFOnColumnmove;
    property OnColumnresize : TExtPanelTableOnColumnresize read FOnColumnresize write SetFOnColumnresize;
    property OnColumnschanged : TExtPanelTableOnColumnschanged read FOnColumnschanged write SetFOnColumnschanged;
    property OnColumnshow : TExtPanelTableOnColumnshow read FOnColumnshow write SetFOnColumnshow;
    property OnContainerclick : TExtPanelTableOnContainerclick read FOnContainerclick write SetFOnContainerclick;
    property OnContainercontextmenu : TExtPanelTableOnContainercontextmenu read FOnContainercontextmenu write SetFOnContainercontextmenu;
    property OnContainerdblclick : TExtPanelTableOnContainerdblclick read FOnContainerdblclick write SetFOnContainerdblclick;
    property OnContainermouseout : TExtPanelTableOnContainermouseout read FOnContainermouseout write SetFOnContainermouseout;
    property OnContainermouseover : TExtPanelTableOnContainermouseover read FOnContainermouseover write SetFOnContainermouseover;
    property OnContainermouseup : TExtPanelTableOnContainermouseup read FOnContainermouseup write SetFOnContainermouseup;
    property OnDeselect : TExtPanelTableOnDeselect read FOnDeselect write SetFOnDeselect;
    property OnFilterchange : TExtPanelTableOnFilterchange read FOnFilterchange write SetFOnFilterchange;
    property OnHeaderclick : TExtPanelTableOnHeaderclick read FOnHeaderclick write SetFOnHeaderclick;
    property OnHeadercontextmenu : TExtPanelTableOnHeadercontextmenu read FOnHeadercontextmenu write SetFOnHeadercontextmenu;
    property OnHeadertriggerclick : TExtPanelTableOnHeadertriggerclick read FOnHeadertriggerclick write SetFOnHeadertriggerclick;
    property OnItemclick : TExtPanelTableOnItemclick read FOnItemclick write SetFOnItemclick;
    property OnItemcontextmenu : TExtPanelTableOnItemcontextmenu read FOnItemcontextmenu write SetFOnItemcontextmenu;
    property OnItemdblclick : TExtPanelTableOnItemdblclick read FOnItemdblclick write SetFOnItemdblclick;
    property OnItemmousedown : TExtPanelTableOnItemmousedown read FOnItemmousedown write SetFOnItemmousedown;
    property OnItemmouseenter : TExtPanelTableOnItemmouseenter read FOnItemmouseenter write SetFOnItemmouseenter;
    property OnItemmouseleave : TExtPanelTableOnItemmouseleave read FOnItemmouseleave write SetFOnItemmouseleave;
    property OnItemmouseup : TExtPanelTableOnItemmouseup read FOnItemmouseup write SetFOnItemmouseup;
    property OnSelect : TExtPanelTableOnSelect read FOnSelect write SetFOnSelect;
    property OnSelectionchange : TExtPanelTableOnSelectionchange read FOnSelectionchange write SetFOnSelectionchange;
    property OnSortchange : TExtPanelTableOnSortchange read FOnSortchange write SetFOnSortchange;
    property OnViewready : TExtPanelTableOnViewready read FOnViewready write SetFOnViewready;
  end;

  TExtTreeColumn = class(TExtGridColumn)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtTip = class(TExtPanel)
  private
    FClosable : Boolean;
    FCloseAction : String;
    FConstrainPosition : Boolean;
    FDefaultAlign : String;
    FMaxWidth : Integer;
    FMinWidth : Integer;
    FShadow : Boolean;
    FShadowString : String;
    FWidth : Integer;
    procedure SetFClosable(Value : Boolean);
    procedure SetFCloseAction(Value : String);
    procedure SetFConstrainPosition(Value : Boolean);
    procedure SetFDefaultAlign(Value : String);
    procedure SetFMaxWidth(Value : Integer);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFShadow(Value : Boolean);
    procedure SetFShadowString(Value : String);
    procedure SetFWidth(Value : Integer);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function ShowAt(Xy : TArrayOfInteger) : TExtFunction;
    function ShowBy(El : THTMLElement; Position : String = '') : TExtFunction; overload;
    function ShowBy(El : TExtElement; Position : String = '') : TExtFunction; overload;
    function ShowBy(El : String; Position : String = '') : TExtFunction; overload;
    property Closable : Boolean read FClosable write SetFClosable;
    property CloseAction : String read FCloseAction write SetFCloseAction;
    property ConstrainPosition : Boolean read FConstrainPosition write SetFConstrainPosition;
    property DefaultAlign : String read FDefaultAlign write SetFDefaultAlign;
    property MaxWidth : Integer read FMaxWidth write SetFMaxWidth;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property Shadow : Boolean read FShadow write SetFShadow;
    property ShadowString : String read FShadowString write SetFShadowString;
    property Width : Integer read FWidth write SetFWidth;
  end;

  // Procedural types for events TExtTabPanel
  TExtTabPanelOnBeforetabchange = procedure(TabPanel : TExtTabPanel; NewCard : TExtComponent; OldCard : TExtComponent) of object;
  TExtTabPanelOnTabchange = procedure(TabPanel : TExtTabPanel; NewCard : TExtComponent; OldCard : TExtComponent) of object;

  // Enumerated types for properties
  TTabPositionEnum = (taTop, taBottom, taLeft, taRight);

  TExtTabPanel = class(TExtPanel)
  private
    FActiveItem : Integer;
    FActiveItemString : String;
    FActiveTab : Integer;
    FActiveTabComponent : TExtComponent;
    FActiveTabString : String;
    FDeferredRender : Boolean;
    FItemCls : String;
    FLayout : TExtEnumsLayout;
    FLayoutObject : TExtObject;
    FMaxTabWidth : Integer;
    FMinTabWidth : Integer;
    FPlain : Boolean;
    FRemovePanelHeader : Boolean;
    FTabBar : TExtObject;
    FTabPosition : TTabPositionEnum;
    FOnBeforetabchange : TExtTabPanelOnBeforetabchange;
    FOnTabchange : TExtTabPanelOnTabchange;
    procedure SetFActiveItem(Value : Integer);
    procedure SetFActiveItemString(Value : String);
    procedure SetFActiveTab(Value : Integer);
    procedure SetFActiveTabComponent(Value : TExtComponent);
    procedure SetFActiveTabString(Value : String);
    procedure SetFDeferredRender(Value : Boolean);
    procedure SetFItemCls(Value : String);
    procedure SetFLayout(Value : TExtEnumsLayout);
    procedure SetFLayoutObject(Value : TExtObject);
    procedure SetFMaxTabWidth(Value : Integer);
    procedure SetFMinTabWidth(Value : Integer);
    procedure SetFPlain(Value : Boolean);
    procedure SetFRemovePanelHeader(Value : Boolean);
    procedure SetFTabBar(Value : TExtObject);
    procedure SetFTabPosition(Value : TTabPositionEnum);
    procedure SetFOnBeforetabchange(Value : TExtTabPanelOnBeforetabchange);
    procedure SetFOnTabchange(Value : TExtTabPanelOnTabchange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetActiveTab : TExtFunction;
    function GetTabBar : TExtFunction;
    function SetActiveTab(Card : TExtComponent) : TExtFunction; overload;
    function SetActiveTab(Card : String) : TExtFunction; overload;
    function SetActiveTab(Card : Integer) : TExtFunction; overload;
    destructor Destroy; override;
    property ActiveItem : Integer read FActiveItem write SetFActiveItem;
    property ActiveItemString : String read FActiveItemString write SetFActiveItemString;
    property ActiveTab : Integer read FActiveTab write SetFActiveTab;
    property ActiveTabComponent : TExtComponent read FActiveTabComponent write SetFActiveTabComponent;
    property ActiveTabString : String read FActiveTabString write SetFActiveTabString;
    property DeferredRender : Boolean read FDeferredRender write SetFDeferredRender;
    property ItemCls : String read FItemCls write SetFItemCls;
    property Layout : TExtEnumsLayout read FLayout write SetFLayout;
    property LayoutObject : TExtObject read FLayoutObject write SetFLayoutObject;
    property MaxTabWidth : Integer read FMaxTabWidth write SetFMaxTabWidth;
    property MinTabWidth : Integer read FMinTabWidth write SetFMinTabWidth;
    property Plain : Boolean read FPlain write SetFPlain;
    property RemovePanelHeader : Boolean read FRemovePanelHeader write SetFRemovePanelHeader;
    property TabBar : TExtObject read FTabBar write SetFTabBar;
    property TabPosition : TTabPositionEnum read FTabPosition write SetFTabPosition;
    property OnBeforetabchange : TExtTabPanelOnBeforetabchange read FOnBeforetabchange write SetFOnBeforetabchange;
    property OnTabchange : TExtTabPanelOnTabchange read FOnTabchange write SetFOnTabchange;
  end;

  TExtTreeViewDropZone = class(TExtViewDropZone)
  private
    FAllowContainerDrop : String;
    FAllowParentInserts : Boolean;
    FAppendOnly : String;
    FExpandDelay : String;
    procedure SetFAllowContainerDrop(Value : String);
    procedure SetFAllowParentInserts(Value : Boolean);
    procedure SetFAppendOnly(Value : String);
    procedure SetFExpandDelay(Value : String);
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    property AllowContainerDrop : String read FAllowContainerDrop write SetFAllowContainerDrop;
    property AllowParentInserts : Boolean read FAllowParentInserts write SetFAllowParentInserts;
    property AppendOnly : String read FAppendOnly write SetFAppendOnly;
    property ExpandDelay : String read FExpandDelay write SetFExpandDelay;
  end;

  // Procedural types for events TExtMenu
  TExtMenuOnClick = procedure(Menu : TExtMenu; Item : TExtComponent; E : TExtEventObject) of object;
  TExtMenuOnMouseenter = procedure(Menu : TExtMenu; E : TExtEventObject) of object;
  TExtMenuOnMouseleave = procedure(Menu : TExtMenu; E : TExtEventObject) of object;
  TExtMenuOnMouseover = procedure(Menu : TExtMenu; Item : TExtComponent; E : TExtEventObject) of object;

  TExtMenu = class(TExtPanel)
  private
    FAllowOtherMenus : Boolean;
    FEnableKeyNav : Boolean;
    FFloating : Boolean;
    FHidden : Boolean; // true
    FIgnoreParentClicks : Boolean;
    FIsMenu : Boolean;
    FMinWidth : Integer;
    FParentMenu : TExtMenu;
    FPlain : Boolean;
    FShowSeparator : Boolean;
    FOnClick : TExtMenuOnClick;
    FOnMouseenter : TExtMenuOnMouseenter;
    FOnMouseleave : TExtMenuOnMouseleave;
    FOnMouseover : TExtMenuOnMouseover;
    procedure SetFAllowOtherMenus(Value : Boolean);
    procedure SetFEnableKeyNav(Value : Boolean);
    procedure SetFFloating(Value : Boolean);
    procedure SetFHidden(Value : Boolean);
    procedure SetFIgnoreParentClicks(Value : Boolean);
    procedure SetFIsMenu(Value : Boolean);
    procedure SetFMinWidth(Value : Integer);
    procedure SetFParentMenu(Value : TExtMenu);
    procedure SetFPlain(Value : Boolean);
    procedure SetFShowSeparator(Value : Boolean);
    procedure SetFOnClick(Value : TExtMenuOnClick);
    procedure SetFOnMouseenter(Value : TExtMenuOnMouseenter);
    procedure SetFOnMouseleave(Value : TExtMenuOnMouseleave);
    procedure SetFOnMouseover(Value : TExtMenuOnMouseover);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CanActivateItem : TExtFunction;
    constructor Create;
    function DeactivateActiveItem : TExtFunction;
    destructor Destroy; override;
    property AllowOtherMenus : Boolean read FAllowOtherMenus write SetFAllowOtherMenus;
    property EnableKeyNav : Boolean read FEnableKeyNav write SetFEnableKeyNav;
    property Floating : Boolean read FFloating write SetFFloating;
    property Hidden : Boolean read FHidden write SetFHidden;
    property IgnoreParentClicks : Boolean read FIgnoreParentClicks write SetFIgnoreParentClicks;
    property IsMenu : Boolean read FIsMenu write SetFIsMenu;
    property MinWidth : Integer read FMinWidth write SetFMinWidth;
    property ParentMenu : TExtMenu read FParentMenu write SetFParentMenu;
    property Plain : Boolean read FPlain write SetFPlain;
    property ShowSeparator : Boolean read FShowSeparator write SetFShowSeparator;
    property OnClick : TExtMenuOnClick read FOnClick write SetFOnClick;
    property OnMouseenter : TExtMenuOnMouseenter read FOnMouseenter write SetFOnMouseenter;
    property OnMouseleave : TExtMenuOnMouseleave read FOnMouseleave write SetFOnMouseleave;
    property OnMouseover : TExtMenuOnMouseover read FOnMouseover write SetFOnMouseover;
  end;

  TExtLayoutComponentFieldHtmlEditor = class(TExtLayoutComponentFieldFieldContainer)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtLayoutComponentFieldTextArea = class(TExtLayoutComponentFieldText)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtTipToolTip = class(TExtTip)
  private
    FAnchor : String;
    FAnchorOffset : Integer;
    FAnchorToTarget : Boolean;
    FAutoHide : Boolean;
    FDelegate : String;
    FDismissDelay : Integer;
    FHideDelay : Integer;
    FMouseOffset : TArrayOfInteger;
    FShowDelay : Integer;
    FTarget : THTMLElement;
    FTargetElement : TExtElement;
    FTargetString : String;
    FTrackMouse : Boolean;
    FTriggerElement : THTMLElement;
    procedure SetFAnchor(Value : String);
    procedure SetFAnchorOffset(Value : Integer);
    procedure SetFAnchorToTarget(Value : Boolean);
    procedure SetFAutoHide(Value : Boolean);
    procedure SetFDelegate(Value : String);
    procedure SetFDismissDelay(Value : Integer);
    procedure SetFHideDelay(Value : Integer);
    procedure SetFMouseOffset(Value : TArrayOfInteger);
    procedure SetFShowDelay(Value : Integer);
    procedure SetFTarget(Value : THTMLElement);
    procedure SetFTargetElement(Value : TExtElement);
    procedure SetFTargetString(Value : String);
    procedure SetFTrackMouse(Value : Boolean);
    procedure SetFTriggerElement(Value : THTMLElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function Hide : TExtFunction;
    function SetTarget(T : THTMLElement) : TExtFunction; overload;
    function SetTarget(T : TExtElement) : TExtFunction; overload;
    function SetTarget(T : String) : TExtFunction; overload;
    function Show : TExtFunction;
    destructor Destroy; override;
    property Anchor : String read FAnchor write SetFAnchor;
    property AnchorOffset : Integer read FAnchorOffset write SetFAnchorOffset;
    property AnchorToTarget : Boolean read FAnchorToTarget write SetFAnchorToTarget;
    property AutoHide : Boolean read FAutoHide write SetFAutoHide;
    property Delegate : String read FDelegate write SetFDelegate;
    property DismissDelay : Integer read FDismissDelay write SetFDismissDelay;
    property HideDelay : Integer read FHideDelay write SetFHideDelay;
    property MouseOffset : TArrayOfInteger read FMouseOffset write SetFMouseOffset;
    property ShowDelay : Integer read FShowDelay write SetFShowDelay;
    property Target : THTMLElement read FTarget write SetFTarget;
    property TargetElement : TExtElement read FTargetElement write SetFTargetElement;
    property TargetString : String read FTargetString write SetFTargetString;
    property TrackMouse : Boolean read FTrackMouse write SetFTrackMouse;
    property TriggerElement : THTMLElement read FTriggerElement write SetFTriggerElement;
  end;

  // Procedural types for events TExtTreePanel
  TExtTreePanelOnAfteritemcollapse = procedure of object;
  TExtTreePanelOnAfteritemexpand = procedure of object;
  TExtTreePanelOnBeforeitemappend = procedure of object;
  TExtTreePanelOnBeforeitemcollapse = procedure of object;
  TExtTreePanelOnBeforeitemexpand = procedure of object;
  TExtTreePanelOnBeforeiteminsert = procedure of object;
  TExtTreePanelOnBeforeitemmove = procedure of object;
  TExtTreePanelOnBeforeitemremove = procedure of object;
  TExtTreePanelOnBeforeload = procedure of object;
  TExtTreePanelOnCheckchange = procedure(Node : TExtDataNodeInterface; Checked : Boolean) of object;
  TExtTreePanelOnItemappend = procedure of object;
  TExtTreePanelOnItemcollapse = procedure of object;
  TExtTreePanelOnItemexpand = procedure of object;
  TExtTreePanelOnIteminsert = procedure of object;
  TExtTreePanelOnItemmove = procedure of object;
  TExtTreePanelOnItemremove = procedure of object;
  TExtTreePanelOnLoad = procedure of object;

  TExtTreePanel = class(TExtPanelTable)
  private
    FAnimate : Boolean;
    FDisplayField : String;
    FFolderSort : Boolean;
    FHideHeaders : Boolean;
    FLines : Boolean;
    FRoot : TExtDataModel;
    FRootInterface : TExtDataNodeInterface;
    FRootObject : TExtObject;
    FRootVisible : Boolean;
    FRowLines : Boolean;
    FSingleExpand : Boolean;
    FStore : TExtDataTreeStore;
    FUseArrows : Boolean;
    FOnAfteritemcollapse : TExtTreePanelOnAfteritemcollapse;
    FOnAfteritemexpand : TExtTreePanelOnAfteritemexpand;
    FOnBeforeitemappend : TExtTreePanelOnBeforeitemappend;
    FOnBeforeitemcollapse : TExtTreePanelOnBeforeitemcollapse;
    FOnBeforeitemexpand : TExtTreePanelOnBeforeitemexpand;
    FOnBeforeiteminsert : TExtTreePanelOnBeforeiteminsert;
    FOnBeforeitemmove : TExtTreePanelOnBeforeitemmove;
    FOnBeforeitemremove : TExtTreePanelOnBeforeitemremove;
    FOnBeforeload : TExtTreePanelOnBeforeload;
    FOnCheckchange : TExtTreePanelOnCheckchange;
    FOnItemappend : TExtTreePanelOnItemappend;
    FOnItemcollapse : TExtTreePanelOnItemcollapse;
    FOnItemexpand : TExtTreePanelOnItemexpand;
    FOnIteminsert : TExtTreePanelOnIteminsert;
    FOnItemmove : TExtTreePanelOnItemmove;
    FOnItemremove : TExtTreePanelOnItemremove;
    FOnLoad : TExtTreePanelOnLoad;
    procedure SetFAnimate(Value : Boolean);
    procedure SetFDisplayField(Value : String);
    procedure SetFFolderSort(Value : Boolean);
    procedure SetFHideHeaders(Value : Boolean);
    procedure SetFLines(Value : Boolean);
    procedure SetFRoot(Value : TExtDataModel);
    procedure SetFRootInterface(Value : TExtDataNodeInterface);
    procedure SetFRootObject(Value : TExtObject);
    procedure SetFRootVisible(Value : Boolean);
    procedure SetFRowLines(Value : Boolean);
    procedure SetFSingleExpand(Value : Boolean);
    procedure SetFStore(Value : TExtDataTreeStore);
    procedure SetFUseArrows(Value : Boolean);
    procedure SetFOnAfteritemcollapse(Value : TExtTreePanelOnAfteritemcollapse);
    procedure SetFOnAfteritemexpand(Value : TExtTreePanelOnAfteritemexpand);
    procedure SetFOnBeforeitemappend(Value : TExtTreePanelOnBeforeitemappend);
    procedure SetFOnBeforeitemcollapse(Value : TExtTreePanelOnBeforeitemcollapse);
    procedure SetFOnBeforeitemexpand(Value : TExtTreePanelOnBeforeitemexpand);
    procedure SetFOnBeforeiteminsert(Value : TExtTreePanelOnBeforeiteminsert);
    procedure SetFOnBeforeitemmove(Value : TExtTreePanelOnBeforeitemmove);
    procedure SetFOnBeforeitemremove(Value : TExtTreePanelOnBeforeitemremove);
    procedure SetFOnBeforeload(Value : TExtTreePanelOnBeforeload);
    procedure SetFOnCheckchange(Value : TExtTreePanelOnCheckchange);
    procedure SetFOnItemappend(Value : TExtTreePanelOnItemappend);
    procedure SetFOnItemcollapse(Value : TExtTreePanelOnItemcollapse);
    procedure SetFOnItemexpand(Value : TExtTreePanelOnItemexpand);
    procedure SetFOnIteminsert(Value : TExtTreePanelOnIteminsert);
    procedure SetFOnItemmove(Value : TExtTreePanelOnItemmove);
    procedure SetFOnItemremove(Value : TExtTreePanelOnItemremove);
    procedure SetFOnLoad(Value : TExtTreePanelOnLoad);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CollapseAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function CollapseNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    constructor Create;
    function ExpandAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function ExpandPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function GetChecked : TExtFunction;
    function GetRootNode : TExtFunction;
    function SelectPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function SetRootNode(Root : TExtObject) : TExtFunction; overload;
    function SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; overload;
    function SetRootNode(Root : TExtDataModel) : TExtFunction; overload;
    destructor Destroy; override;
    property Animate : Boolean read FAnimate write SetFAnimate;
    property DisplayField : String read FDisplayField write SetFDisplayField;
    property FolderSort : Boolean read FFolderSort write SetFFolderSort;
    property HideHeaders : Boolean read FHideHeaders write SetFHideHeaders;
    property Lines : Boolean read FLines write SetFLines;
    property Root : TExtDataModel read FRoot write SetFRoot;
    property RootInterface : TExtDataNodeInterface read FRootInterface write SetFRootInterface;
    property RootObject : TExtObject read FRootObject write SetFRootObject;
    property RootVisible : Boolean read FRootVisible write SetFRootVisible;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property SingleExpand : Boolean read FSingleExpand write SetFSingleExpand;
    property Store : TExtDataTreeStore read FStore write SetFStore;
    property UseArrows : Boolean read FUseArrows write SetFUseArrows;
    property OnAfteritemcollapse : TExtTreePanelOnAfteritemcollapse read FOnAfteritemcollapse write SetFOnAfteritemcollapse;
    property OnAfteritemexpand : TExtTreePanelOnAfteritemexpand read FOnAfteritemexpand write SetFOnAfteritemexpand;
    property OnBeforeitemappend : TExtTreePanelOnBeforeitemappend read FOnBeforeitemappend write SetFOnBeforeitemappend;
    property OnBeforeitemcollapse : TExtTreePanelOnBeforeitemcollapse read FOnBeforeitemcollapse write SetFOnBeforeitemcollapse;
    property OnBeforeitemexpand : TExtTreePanelOnBeforeitemexpand read FOnBeforeitemexpand write SetFOnBeforeitemexpand;
    property OnBeforeiteminsert : TExtTreePanelOnBeforeiteminsert read FOnBeforeiteminsert write SetFOnBeforeiteminsert;
    property OnBeforeitemmove : TExtTreePanelOnBeforeitemmove read FOnBeforeitemmove write SetFOnBeforeitemmove;
    property OnBeforeitemremove : TExtTreePanelOnBeforeitemremove read FOnBeforeitemremove write SetFOnBeforeitemremove;
    property OnBeforeload : TExtTreePanelOnBeforeload read FOnBeforeload write SetFOnBeforeload;
    property OnCheckchange : TExtTreePanelOnCheckchange read FOnCheckchange write SetFOnCheckchange;
    property OnItemappend : TExtTreePanelOnItemappend read FOnItemappend write SetFOnItemappend;
    property OnItemcollapse : TExtTreePanelOnItemcollapse read FOnItemcollapse write SetFOnItemcollapse;
    property OnItemexpand : TExtTreePanelOnItemexpand read FOnItemexpand write SetFOnItemexpand;
    property OnIteminsert : TExtTreePanelOnIteminsert read FOnIteminsert write SetFOnIteminsert;
    property OnItemmove : TExtTreePanelOnItemmove read FOnItemmove write SetFOnItemmove;
    property OnItemremove : TExtTreePanelOnItemremove read FOnItemremove write SetFOnItemremove;
    property OnLoad : TExtTreePanelOnLoad read FOnLoad write SetFOnLoad;
  end;

  TExtTreeViewDragZone = class(TExtViewDragZone)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

  TExtFormFieldTime = class(TExtFormFieldComboBox)
  private
    FAltFormats : String;
    FFormat : String; // 'g:i A'
    FIncrement : Integer;
    FInvalidText : String;
    FMaxText : String;
    FMaxValue : TDateTime;
    FMaxValueString : String;
    FMinText : String;
    FMinValue : TDateTime;
    FMinValueString : String;
    FPickerMaxHeight : Integer;
    FSelectOnTab : Boolean;
    FSnapToIncrement : Boolean;
    FSubmitFormat : String;
    FTriggerCls : String;
    procedure SetFAltFormats(Value : String);
    procedure SetFFormat(Value : String);
    procedure SetFIncrement(Value : Integer);
    procedure SetFInvalidText(Value : String);
    procedure SetFMaxText(Value : String);
    procedure SetFMaxValue(Value : TDateTime);
    procedure SetFMaxValueString(Value : String);
    procedure SetFMinText(Value : String);
    procedure SetFMinValue(Value : TDateTime);
    procedure SetFMinValueString(Value : String);
    procedure SetFPickerMaxHeight(Value : Integer);
    procedure SetFSelectOnTab(Value : Boolean);
    procedure SetFSnapToIncrement(Value : Boolean);
    procedure SetFSubmitFormat(Value : String);
    procedure SetFTriggerCls(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetErrors(Value : TExtObject = nil) : TExtFunction;
    function SetMaxValue(Value : TDateTime) : TExtFunction; overload;
    function SetMaxValue(Value : String) : TExtFunction; overload;
    function SetMinValue(Value : TDateTime) : TExtFunction; overload;
    function SetMinValue(Value : String) : TExtFunction; overload;
    property AltFormats : String read FAltFormats write SetFAltFormats;
    property Format : String read FFormat write SetFFormat;
    property Increment : Integer read FIncrement write SetFIncrement;
    property InvalidText : String read FInvalidText write SetFInvalidText;
    property MaxText : String read FMaxText write SetFMaxText;
    property MaxValue : TDateTime read FMaxValue write SetFMaxValue;
    property MaxValueString : String read FMaxValueString write SetFMaxValueString;
    property MinText : String read FMinText write SetFMinText;
    property MinValue : TDateTime read FMinValue write SetFMinValue;
    property MinValueString : String read FMinValueString write SetFMinValueString;
    property PickerMaxHeight : Integer read FPickerMaxHeight write SetFPickerMaxHeight;
    property SelectOnTab : Boolean read FSelectOnTab write SetFSelectOnTab;
    property SnapToIncrement : Boolean read FSnapToIncrement write SetFSnapToIncrement;
    property SubmitFormat : String read FSubmitFormat write SetFSubmitFormat;
    property TriggerCls : String read FTriggerCls write SetFTriggerCls;
  end;

  TExtWindowMessageBox = class(TExtWindow)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function Alert(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Confirm(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction;
    function Progress(Title : String; Msg : String; ProgressText : String = '') : TExtFunction;
    function Prompt(Title : String; Msg : String; Fn : TExtFunction; Scope : TExtObject; Multiline : Integer; Value : String = '') : TExtFunction; overload;
    function Prompt(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Multiline : Boolean = false; Value : String = '') : TExtFunction; overload;
    function SetIcon(Icon : String; Width : Integer = 0; Height : Integer = 0) : TExtFunction;
    function Show(Config : TExtShowConfig) : TExtFunction;
    function UpdateProgress(Value : Integer = 0; ProgressText : String = ''; Msg : String = '') : TExtFunction;
    function Wait(Msg : String; Title : String = ''; Config : TExtObject = nil) : TExtFunction;
  end;

  // Procedural types for events TExtMenuColorPicker
  TExtMenuColorPickerOnSelect = procedure of object;

  TExtMenuColorPicker = class(TExtMenu)
  private
    FHideOnClick : Boolean;
    FPicker : TExtPickerColor;
    FPickerId : String;
    FOnSelect : TExtMenuColorPickerOnSelect;
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFPicker(Value : TExtPickerColor);
    procedure SetFPickerId(Value : String);
    procedure SetFOnSelect(Value : TExtMenuColorPickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property Picker : TExtPickerColor read FPicker write SetFPicker;
    property PickerId : String read FPickerId write SetFPickerId;
    property OnSelect : TExtMenuColorPickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  // Procedural types for events TExtGridPanel
  TExtGridPanelOnBeforereconfigure = procedure(This : TExtGridPanel; Store : TExtDataStore; Columns : TExtObjectList; OldStore : TExtDataStore; The : TExtObjectList) of object;
  TExtGridPanelOnReconfigure = procedure(This : TExtGridPanel; Store : TExtDataStore; Columns : TExtObjectList; OldStore : TExtDataStore; The : TExtObjectList) of object;

  TExtGridPanel = class(TExtPanelTable)
  private
    FColumns : TExtObjectList;
    FColumnsObject : TExtObject;
    FRowLines : Boolean;
    FOnBeforereconfigure : TExtGridPanelOnBeforereconfigure;
    FOnReconfigure : TExtGridPanelOnReconfigure;
    procedure SetFColumns(Value : TExtObjectList);
    procedure SetFColumnsObject(Value : TExtObject);
    procedure SetFRowLines(Value : Boolean);
    procedure SetFOnBeforereconfigure(Value : TExtGridPanelOnBeforereconfigure);
    procedure SetFOnReconfigure(Value : TExtGridPanelOnReconfigure);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Columns : TExtObjectList read FColumns write SetFColumns;
    property ColumnsObject : TExtObject read FColumnsObject write SetFColumnsObject;
    property RowLines : Boolean read FRowLines write SetFRowLines;
    property OnBeforereconfigure : TExtGridPanelOnBeforereconfigure read FOnBeforereconfigure write SetFOnBeforereconfigure;
    property OnReconfigure : TExtGridPanelOnReconfigure read FOnReconfigure write SetFOnReconfigure;
  end;

  TExtGridRowEditor = class(TExtFormPanel)
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction;
  end;

  // Procedural types for events TExtMenuDatePicker
  TExtMenuDatePickerOnSelect = procedure of object;

  TExtMenuDatePicker = class(TExtMenu)
  private
    FHideOnClick : Boolean;
    FPicker : TExtPickerDate;
    FPickerId : String;
    FOnSelect : TExtMenuDatePickerOnSelect;
    procedure SetFHideOnClick(Value : Boolean);
    procedure SetFPicker(Value : TExtPickerDate);
    procedure SetFPickerId(Value : String);
    procedure SetFOnSelect(Value : TExtMenuDatePickerOnSelect);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property HideOnClick : Boolean read FHideOnClick write SetFHideOnClick;
    property Picker : TExtPickerDate read FPicker write SetFPicker;
    property PickerId : String read FPickerId write SetFPickerId;
    property OnSelect : TExtMenuDatePickerOnSelect read FOnSelect write SetFOnSelect;
  end;

  TExtSliderTip = class(TExtTip)
  private
    FAlign : String;
    FOffsets : TExtObjectList;
    FPosition : String;
    procedure SetFAlign(Value : String);
    procedure SetFOffsets(Value : TExtObjectList);
    procedure SetFPosition(Value : String);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    destructor Destroy; override;
    property Align : String read FAlign write SetFAlign;
    property Offsets : TExtObjectList read FOffsets write SetFOffsets;
    property Position : String read FPosition write SetFPosition;
  end;

  TExtTipQuickTip = class(TExtTipToolTip)
  private
    FInterceptTitles : Boolean;
    FTarget : String;
    FTargetElement : TExtElement;
    FTargetTHTMLElement : THTMLElement;
    procedure SetFInterceptTitles(Value : Boolean);
    procedure SetFTarget(Value : String);
    procedure SetFTargetElement(Value : TExtElement);
    procedure SetFTargetTHTMLElement(Value : THTMLElement);
  protected
    procedure InitDefaults; override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    function CancelShow(El : THTMLElement) : TExtFunction; overload;
    function CancelShow(El : TExtElement) : TExtFunction; overload;
    function CancelShow(El : String) : TExtFunction; overload;
    constructor Create;
    function Register(Config : TExtObject) : TExtFunction;
    function Unregister(El : THTMLElement) : TExtFunction; overload;
    function Unregister(El : TExtElement) : TExtFunction; overload;
    function Unregister(El : String) : TExtFunction; overload;
    destructor Destroy; override;
    property InterceptTitles : Boolean read FInterceptTitles write SetFInterceptTitles;
    property Target : String read FTarget write SetFTarget;
    property TargetElement : TExtElement read FTargetElement write SetFTargetElement;
    property TargetTHTMLElement : THTMLElement read FTargetTHTMLElement write SetFTargetTHTMLElement;
  end;

  // Procedural types for events TExtGridPropertyGrid
  TExtGridPropertyGridOnBeforepropertychange = procedure(Source : TExtObject; RecordId : String; Value : TExtObject; OldValue : TExtObject) of object;
  TExtGridPropertyGridOnPropertychange = procedure(Source : TExtObject; RecordId : String; Value : TExtObject; OldValue : TExtObject) of object;

  TExtGridPropertyGrid = class(TExtGridPanel)
  private
    FInferTypes : Boolean;
    FNameColumnWidth : Integer;
    FNameColumnWidthString : String;
    FNameField : String;
    FSource : TExtObject;
    FSourceConfig : TExtObject;
    FValueField : String;
    FOnBeforepropertychange : TExtGridPropertyGridOnBeforepropertychange;
    FOnPropertychange : TExtGridPropertyGridOnPropertychange;
    procedure SetFInferTypes(Value : Boolean);
    procedure SetFNameColumnWidth(Value : Integer);
    procedure SetFNameColumnWidthString(Value : String);
    procedure SetFNameField(Value : String);
    procedure SetFSource(Value : TExtObject);
    procedure SetFSourceConfig(Value : TExtObject);
    procedure SetFValueField(Value : String);
    procedure SetFOnBeforepropertychange(Value : TExtGridPropertyGridOnBeforepropertychange);
    procedure SetFOnPropertychange(Value : TExtGridPropertyGridOnPropertychange);
  protected
    procedure InitDefaults; override;
    procedure HandleEvent(const AEvtName: string); override;
  public
    function JSClassName : string; override;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
    constructor Create;
    function GetSource : TExtFunction;
    function RemoveProperty(Prop : String) : TExtFunction;
    function SetProperty(Prop : String; Value : TExtObject; Create : Boolean = false) : TExtFunction;
    function SetSource(Source : TExtObject; SourceConfig : TExtObject = nil) : TExtFunction;
    destructor Destroy; override;
    property InferTypes : Boolean read FInferTypes write SetFInferTypes;
    property NameColumnWidth : Integer read FNameColumnWidth write SetFNameColumnWidth;
    property NameColumnWidthString : String read FNameColumnWidthString write SetFNameColumnWidthString;
    property NameField : String read FNameField write SetFNameField;
    property Source : TExtObject read FSource write SetFSource;
    property SourceConfig : TExtObject read FSourceConfig write SetFSourceConfig;
    property ValueField : String read FValueField write SetFValueField;
    property OnBeforepropertychange : TExtGridPropertyGridOnBeforepropertychange read FOnBeforepropertychange write SetFOnBeforepropertychange;
    property OnPropertychange : TExtGridPropertyGridOnPropertychange read FOnPropertychange write SetFOnPropertychange;
  end;

  TExtMessageBoxSingleton = class(TExtWindowMessageBox)
  private
  public
    function JSClassName : string; override;
    class function CANCEL : Integer;
    class function ERROR : String;
    class function INFO : String;
    class function NO : Integer;
    class function OK : Integer;
    class function OKCANCEL : Integer;
    class function QUESTION : String;
    class function WARNING : String;
    class function YES : Integer;
    class function YESNO : Integer;
    class function YESNOCANCEL : Integer;
    {$IFDEF FPC}constructor AddTo(List : TExtObjectList);{$ENDIF}
  end;

var
  ExtFormFieldVTypes : TExtFormFieldVTypesSingleton;
  ExtFxManager : TExtFxManagerSingleton;
  ExtFxCubicBezier : TExtFxCubicBezierSingleton;
  ExtFxEasing : TExtFxEasingSingleton;
  ExtMenuManager : TExtMenuManagerSingleton;
  ExtDomHelper : TExtDomHelperSingleton;
  ExtFocusManager : TExtFocusManagerSingleton;
  ExtEventObjectImpl : TExtEventObjectImplSingleton;
  ExtDrawEngineImageExporter : TExtDrawEngineImageExporterSingleton;
  ExtDrawEngineSvgExporter : TExtDrawEngineSvgExporterSingleton;
  ExtDraw : TExtDrawSingleton;
  ExtShadowPool : TExtShadowPoolSingleton;
  ExtStateManager : TExtStateManagerSingleton;
  ExtUtilCookies : TExtUtilCookiesSingleton;
  ExtUtilCSS : TExtUtilCSSSingleton;
  ExtTipQuickTipManager : TExtTipQuickTipManagerSingleton;
  ExtUtilInflector : TExtUtilInflectorSingleton;
  ExtUtilHistory : TExtUtilHistorySingleton;
  ExtPerfMonitor : TExtPerfMonitorSingleton;
  ExtDataSortTypes : TExtDataSortTypesSingleton;
  ExtDataJsonP : TExtDataJsonPSingleton;
  ExtButtonManager : TExtButtonManagerSingleton;
  ExtAppEventBus : TExtAppEventBusSingleton;
  ExtComponentQuery : TExtComponentQuerySingleton;
  ExtChartShape : TExtChartShapeSingleton;
  ExtDataValidations : TExtDataValidationsSingleton;
  ExtDataTypes : TExtDataTypesSingleton;
  ExtDdDragDropManager : TExtDdDragDropManagerSingleton;
  ExtDirectManager : TExtDirectManagerSingleton;
  ExtDdScrollManager : TExtDdScrollManagerSingleton;
  ExtDdRegistry : TExtDdRegistrySingleton;
  ExtUtilTaskManager : TExtUtilTaskManagerSingleton;
  ExtPluginManager : TExtPluginManagerSingleton;
  ExtComponentManager : TExtComponentManagerSingleton;
  ExtModelManager : TExtModelManagerSingleton;
  ExtAppDomainStore : TExtAppDomainStoreSingleton;
  ExtAppDomainGlobal : TExtAppDomainGlobalSingleton;
  ExtAjax : TExtAjaxSingleton;
  ExtAppDomainController : TExtAppDomainControllerSingleton;
  ExtAppDomainDirect : TExtAppDomainDirectSingleton;
  ExtAppDomainComponent : TExtAppDomainComponentSingleton;
  ExtFormCheckboxManager : TExtFormCheckboxManagerSingleton;
  ExtFormRadioManager : TExtFormRadioManagerSingleton;
  ExtDataStoreManager : TExtDataStoreManagerSingleton;
  ExtMessageBox : TExtMessageBoxSingleton;

implementation

procedure TExtShowConfig.SetFAnimTarget(Value : String); begin
  FAnimTarget := Value;
  JSCode('animTarget:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFButtons(Value : Integer); begin
  FButtons := Value;
  JSCode('buttons:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFDefaultFocus(Value : String); begin
  FDefaultFocus := Value;
  JSCode('defaultFocus:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFDefaultTextHeight(Value : Integer); begin
  FDefaultTextHeight := Value;
  JSCode('defaultTextHeight:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFFn(Value : TExtFunction); begin
  FFn := Value;
  JSCode('fn:' + VarToJSON([Value, true]));
end;

procedure TExtShowConfig.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFModal(Value : Boolean); begin
  FModal := Value;
  JSCode('modal:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFMsg(Value : String); begin
  FMsg := Value;
  JSCode('msg:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFMultiline(Value : Boolean); begin
  FMultiline := Value;
  JSCode('multiline:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFProgress(Value : Boolean); begin
  FProgress := Value;
  JSCode('progress:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFProgressText(Value : String); begin
  FProgressText := Value;
  JSCode('progressText:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFPrompt(Value : Boolean); begin
  FPrompt := Value;
  JSCode('prompt:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFProxyDrag(Value : Boolean); begin
  FProxyDrag := Value;
  JSCode('proxyDrag:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtShowConfig.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFValue(Value : String); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFWait(Value : Boolean); begin
  FWait := Value;
  JSCode('wait:' + VarToJSON([Value]));
end;

procedure TExtShowConfig.SetFWaitConfig(Value : TExtProgressWaitConfig); begin
  FWaitConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('waitConfig:' + VarToJSON([Value, false]));
end;

procedure TExtShowConfig.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

function TExtShowConfig.JSClassName : string; begin
  Result := 'Object';
end;

{$IFDEF FPC}constructor TExtShowConfig.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtProgressWaitConfig.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtProgressWaitConfig.SetFDuration(Value : Integer); begin
  FDuration := Value;
  JSCode('duration:' + VarToJSON([Value]));
end;

procedure TExtProgressWaitConfig.SetFFn(Value : TExtFunction); begin
  FFn := Value;
  JSCode('fn:' + VarToJSON([Value, true]));
end;

procedure TExtProgressWaitConfig.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtProgressWaitConfig.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

procedure TExtProgressWaitConfig.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtProgressWaitConfig.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

function TExtProgressWaitConfig.JSClassName : string; begin
  Result := 'Object';
end;

{$IFDEF FPC}constructor TExtProgressWaitConfig.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtAbstractComponent.SetFAutoEl(Value : String); begin
  FAutoEl := Value;
  JSCode('autoEl:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFAutoElObject(Value : TExtObject); begin
  FAutoElObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoEl:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFAutoRender(Value : Boolean); begin
  FAutoRender := Value;
  JSCode('autoRender:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFAutoRenderElement(Value : TExtElement); begin
  FAutoRenderElement := Value;
  Value.DeleteFromGarbage;
  JSCode('autoRender:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFAutoRenderString(Value : String); begin
  FAutoRenderString := Value;
  JSCode('autoRender:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFAutoRenderTHTMLElement(Value : THTMLElement); begin
  FAutoRenderTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('autoRender:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFAutoShow(Value : Boolean); begin
  FAutoShow := Value;
  JSCode('autoShow:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFBorder(Value : Integer); begin
  FBorder := Value;
  JSCode('border:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFBorderBoolean(Value : Boolean); begin
  FBorderBoolean := Value;
  JSCode('border:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFBorderString(Value : String); begin
  FBorderString := Value;
  JSCode('border:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFChildEls(Value : TExtObjectList); begin
  FChildEls := Value;
  Value.DeleteFromGarbage;
  JSCode('childEls:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFComponentCls(Value : String); begin
  FComponentCls := Value;
  JSCode('componentCls:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFComponentLayout(Value : String); begin
  FComponentLayout := Value;
  JSCode('componentLayout:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFComponentLayoutObject(Value : TExtObject); begin
  FComponentLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('componentLayout:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFContentEl(Value : String); begin
  FContentEl := Value;
  JSCode('contentEl:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFContentPaddingProperty(Value : String); begin
  FContentPaddingProperty := Value;
  JSCode(JSName + '.contentPaddingProperty=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFData(Value : TExtObject); begin
  FData := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  if not ConfigAvailable(JSName) then
    SetDisabled(Value)
  else
    JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFDisabledCls(Value : String); begin
  FDisabledCls := Value;
  JSCode('disabledCls:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFFloating(Value : Boolean); begin
  FFloating := Value;
  JSCode('floating:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFFrame(Value : Boolean); begin
  FFrame := Value;
  JSCode('frame:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFFrameSize(Value : TExtObject); begin
  FFrameSize := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.frameSize=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeBottom(Value : Integer); begin
  FFrameSizeBottom := Value;
  JSCode(JSName + '.frameSizeBottom=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeHeight(Value : Integer); begin
  FFrameSizeHeight := Value;
  JSCode(JSName + '.frameSizeHeight=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeLeft(Value : Integer); begin
  FFrameSizeLeft := Value;
  JSCode(JSName + '.frameSizeLeft=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeRight(Value : Integer); begin
  FFrameSizeRight := Value;
  JSCode(JSName + '.frameSizeRight=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeTop(Value : Integer); begin
  FFrameSizeTop := Value;
  JSCode(JSName + '.frameSizeTop=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFFrameSizeWidth(Value : Integer); begin
  FFrameSizeWidth := Value;
  JSCode(JSName + '.frameSizeWidth=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAbstractComponent.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAbstractComponent.SetFHeight(Value : Integer); begin
  FHeight := Value;
  if not ConfigAvailable(JSName) then
    SetHeight(Value)
  else
    JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFHideMode(Value : String); begin
  FHideMode := Value;
  JSCode('hideMode:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFHtml(Value : String); begin
  FHtml := Value;
  JSCode('html:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFHtmlObject(Value : TExtObject); begin
  FHtmlObject := Value;
  Value.DeleteFromGarbage;
  JSCode('html:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFIsComponent(Value : Boolean); begin
  FIsComponent := Value;
  JSCode(JSName + '.isComponent=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFItemId(Value : String); begin
  FItemId := Value;
  JSCode('itemId:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFLoader(Value : TExtComponentLoader); begin
  FLoader := Value;
  Value.DeleteFromGarbage;
  JSCode('loader:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFLoaderObject(Value : TExtObject); begin
  FLoaderObject := Value;
  Value.DeleteFromGarbage;
  JSCode('loader:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFMargin(Value : Integer); begin
  FMargin := Value;
  JSCode('margin:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFMarginString(Value : String); begin
  FMarginString := Value;
  JSCode('margin:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFMaskOnDisable(Value : Boolean); begin
  FMaskOnDisable := Value;
  JSCode(JSName + '.maskOnDisable=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFMaxHeight(Value : Integer); begin
  FMaxHeight := Value;
  JSCode('maxHeight:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFMinHeight(Value : Integer); begin
  FMinHeight := Value;
  JSCode('minHeight:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFOverCls(Value : String); begin
  FOverCls := Value;
  JSCode('overCls:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFOwnerCt(Value : TExtContainer); begin
  FOwnerCt := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.ownerCt=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAbstractComponent.SetFPadding(Value : Integer); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFPaddingString(Value : String); begin
  FPaddingString := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFPlugins(Value : TExtObjectList); begin
  FPlugins := Value;
  Value.DeleteFromGarbage;
  JSCode('plugins:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFPluginsList(Value : TExtObjectList); begin
  FPluginsList := Value;
  Value.DeleteFromGarbage;
  JSCode('plugins:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFPluginsObject(Value : TExtObject); begin
  FPluginsObject := Value;
  Value.DeleteFromGarbage;
  JSCode('plugins:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFPluginsPlugin(Value : TExtAbstractPlugin); begin
  FPluginsPlugin := Value;
  Value.DeleteFromGarbage;
  JSCode('plugins:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFRenderData(Value : TExtObject); begin
  FRenderData := Value;
  Value.DeleteFromGarbage;
  JSCode('renderData:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFRendered(Value : Boolean); begin
  FRendered := Value;
  JSCode(JSName + '.rendered=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFRenderSelectors(Value : TExtObject); begin
  FRenderSelectors := Value;
  Value.DeleteFromGarbage;
  JSCode('renderSelectors:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFRenderTo(Value : String); begin
  FRenderTo := Value;
  JSCode('renderTo:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFRenderToElement(Value : TExtElement); begin
  FRenderToElement := Value;
  Value.DeleteFromGarbage;
  JSCode('renderTo:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFRenderToTHTMLElement(Value : THTMLElement); begin
  FRenderToTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('renderTo:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFSaveDelay(Value : Integer); begin
  FSaveDelay := Value;
  JSCode('saveDelay:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFScrollFlags(Value : TExtObject); begin
  FScrollFlags := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.scrollFlags=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAbstractComponent.SetFScrollFlagsBoth(Value : Boolean); begin
  FScrollFlagsBoth := Value;
  JSCode(JSName + '.scrollFlagsBoth=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFScrollFlagsOverflowX(Value : String); begin
  FScrollFlagsOverflowX := Value;
  JSCode(JSName + '.scrollFlagsOverflowX=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFScrollFlagsOverflowY(Value : String); begin
  FScrollFlagsOverflowY := Value;
  JSCode(JSName + '.scrollFlagsOverflowY=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFScrollFlagsX(Value : Boolean); begin
  FScrollFlagsX := Value;
  JSCode(JSName + '.scrollFlagsX=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFScrollFlagsY(Value : Boolean); begin
  FScrollFlagsY := Value;
  JSCode(JSName + '.scrollFlagsY=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractComponent.SetFShrinkWrap(Value : Boolean); begin
  FShrinkWrap := Value;
  JSCode('shrinkWrap:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFShrinkWrapInteger(Value : Integer); begin
  FShrinkWrapInteger := Value;
  JSCode('shrinkWrap:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFStateEvents(Value : TArrayOfString); begin
  FStateEvents := Value;
  JSCode('stateEvents:' + ArrayToJSON(Value));
end;

procedure TExtAbstractComponent.SetFStateful(Value : Boolean); begin
  FStateful := Value;
  JSCode('stateful:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFStateId(Value : String); begin
  FStateId := Value;
  JSCode('stateId:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFStyle(Value : String); begin
  FStyle := Value;
  JSCode('style:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFStyleObject(Value : TExtObject); begin
  FStyleObject := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFTpl(Value : TExtXTemplate); begin
  FTpl := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFTplString(Value : String); begin
  FTplString := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFTplTArrayOfString(Value : TArrayOfString); begin
  FTplTArrayOfString := Value;
  JSCode('tpl:' + ArrayToJSON(Value));
end;

procedure TExtAbstractComponent.SetFTplTemplate(Value : TExtTemplate); begin
  FTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

procedure TExtAbstractComponent.SetFTplWriteMode(Value : String); begin
  FTplWriteMode := Value;
  JSCode('tplWriteMode:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFUi(Value : String); begin
  FUi := Value;
  if not ConfigAvailable(JSName) then
    SetUI(Value)
  else
    JSCode('ui:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFWidth(Value : Integer); begin
  FWidth := Value;
  if not ConfigAvailable(JSName) then
    SetWidth(Value)
  else
    JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFXtype(Value : TExtEnumsWidget); begin
  FXtype := Value;
  JSCode('xtype:' + VarToJSON([Value]));
end;

procedure TExtAbstractComponent.SetFOnActivate(Value : TExtAbstractComponentOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtAbstractComponent.SetFOnAdded(Value : TExtAbstractComponentOnAdded); begin
  if Assigned(FOnAdded) then
    JSCode(JSName+'.events ["added"].listeners=[];');
  if Assigned(Value) then
    AddListener('added', Ajax('added', ['This', '%0.nm','Container', '%1.nm','Pos', '%2'], true));
  FOnAdded := Value;
end;

procedure TExtAbstractComponent.SetFOnAfterrender(Value : TExtAbstractComponentOnAfterrender); begin
  if Assigned(FOnAfterrender) then
    JSCode(JSName+'.events ["afterrender"].listeners=[];');
  if Assigned(Value) then
    AddListener('afterrender', Ajax('afterrender', ['This', '%0.nm'], true));
  FOnAfterrender := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforeactivate(Value : TExtAbstractComponentOnBeforeactivate); begin
  if Assigned(FOnBeforeactivate) then
    JSCode(JSName+'.events ["beforeactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeactivate', Ajax('beforeactivate', ['This', '%0.nm'], true));
  FOnBeforeactivate := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforedeactivate(Value : TExtAbstractComponentOnBeforedeactivate); begin
  if Assigned(FOnBeforedeactivate) then
    JSCode(JSName+'.events ["beforedeactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeactivate', Ajax('beforedeactivate', ['This', '%0.nm'], true));
  FOnBeforedeactivate := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforedestroy(Value : TExtAbstractComponentOnBeforedestroy); begin
  if Assigned(FOnBeforedestroy) then
    JSCode(JSName+'.events ["beforedestroy"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedestroy', Ajax('beforedestroy', ['This', '%0.nm'], true));
  FOnBeforedestroy := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforehide(Value : TExtAbstractComponentOnBeforehide); begin
  if Assigned(FOnBeforehide) then
    JSCode(JSName+'.events ["beforehide"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforehide', Ajax('beforehide', ['This', '%0.nm'], true));
  FOnBeforehide := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforerender(Value : TExtAbstractComponentOnBeforerender); begin
  if Assigned(FOnBeforerender) then
    JSCode(JSName+'.events ["beforerender"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerender', Ajax('beforerender', ['This', '%0.nm'], true));
  FOnBeforerender := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforeshow(Value : TExtAbstractComponentOnBeforeshow); begin
  if Assigned(FOnBeforeshow) then
    JSCode(JSName+'.events ["beforeshow"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeshow', Ajax('beforeshow', ['This', '%0.nm'], true));
  FOnBeforeshow := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforestaterestore(Value : TExtAbstractComponentOnBeforestaterestore); begin
  if Assigned(FOnBeforestaterestore) then
    JSCode(JSName+'.events ["beforestaterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestaterestore', Ajax('beforestaterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestaterestore := Value;
end;

procedure TExtAbstractComponent.SetFOnBeforestatesave(Value : TExtAbstractComponentOnBeforestatesave); begin
  if Assigned(FOnBeforestatesave) then
    JSCode(JSName+'.events ["beforestatesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestatesave', Ajax('beforestatesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestatesave := Value;
end;

procedure TExtAbstractComponent.SetFOnBlur(Value : TExtAbstractComponentOnBlur); begin
  if Assigned(FOnBlur) then
    JSCode(JSName+'.events ["blur"].listeners=[];');
  if Assigned(Value) then
    AddListener('blur', Ajax('blur', ['This', '%0.nm','The', '%1.nm'], true));
  FOnBlur := Value;
end;

procedure TExtAbstractComponent.SetFOnBoxready(Value : TExtAbstractComponentOnBoxready); begin
  if Assigned(FOnBoxready) then
    JSCode(JSName+'.events ["boxready"].listeners=[];');
  if Assigned(Value) then
    AddListener('boxready', Ajax('boxready', ['This', '%0.nm','Width', '%1','Height', '%2'], true));
  FOnBoxready := Value;
end;

procedure TExtAbstractComponent.SetFOnDeactivate(Value : TExtAbstractComponentOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['This', '%0.nm'], true));
  FOnDeactivate := Value;
end;

procedure TExtAbstractComponent.SetFOnDestroy(Value : TExtAbstractComponentOnDestroy); begin
  if Assigned(FOnDestroy) then
    JSCode(JSName+'.events ["destroy"].listeners=[];');
  if Assigned(Value) then
    AddListener('destroy', Ajax('destroy', ['This', '%0.nm'], true));
  FOnDestroy := Value;
end;

procedure TExtAbstractComponent.SetFOnDisable(Value : TExtAbstractComponentOnDisable); begin
  if Assigned(FOnDisable) then
    JSCode(JSName+'.events ["disable"].listeners=[];');
  if Assigned(Value) then
    AddListener('disable', Ajax('disable', ['This', '%0.nm'], true));
  FOnDisable := Value;
end;

procedure TExtAbstractComponent.SetFOnEnable(Value : TExtAbstractComponentOnEnable); begin
  if Assigned(FOnEnable) then
    JSCode(JSName+'.events ["enable"].listeners=[];');
  if Assigned(Value) then
    AddListener('enable', Ajax('enable', ['This', '%0.nm'], true));
  FOnEnable := Value;
end;

procedure TExtAbstractComponent.SetFOnFocus(Value : TExtAbstractComponentOnFocus); begin
  if Assigned(FOnFocus) then
    JSCode(JSName+'.events ["focus"].listeners=[];');
  if Assigned(Value) then
    AddListener('focus', Ajax('focus', ['This', '%0.nm','The', '%1.nm'], true));
  FOnFocus := Value;
end;

procedure TExtAbstractComponent.SetFOnHide(Value : TExtAbstractComponentOnHide); begin
  if Assigned(FOnHide) then
    JSCode(JSName+'.events ["hide"].listeners=[];');
  if Assigned(Value) then
    AddListener('hide', Ajax('hide', ['This', '%0.nm'], true));
  FOnHide := Value;
end;

procedure TExtAbstractComponent.SetFOnMove(Value : TExtAbstractComponentOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', ['This', '%0.nm','X', '%1','Y', '%2'], true));
  FOnMove := Value;
end;

procedure TExtAbstractComponent.SetFOnRemoved(Value : TExtAbstractComponentOnRemoved); begin
  if Assigned(FOnRemoved) then
    JSCode(JSName+'.events ["removed"].listeners=[];');
  if Assigned(Value) then
    AddListener('removed', Ajax('removed', ['This', '%0.nm','OwnerCt', '%1.nm'], true));
  FOnRemoved := Value;
end;

procedure TExtAbstractComponent.SetFOnRender(Value : TExtAbstractComponentOnRender); begin
  if Assigned(FOnRender) then
    JSCode(JSName+'.events ["render"].listeners=[];');
  if Assigned(Value) then
    AddListener('render', Ajax('render', ['This', '%0.nm'], true));
  FOnRender := Value;
end;

procedure TExtAbstractComponent.SetFOnResize(Value : TExtAbstractComponentOnResize); begin
  if Assigned(FOnResize) then
    JSCode(JSName+'.events ["resize"].listeners=[];');
  if Assigned(Value) then
    AddListener('resize', Ajax('resize', ['This', '%0.nm','Width', '%1','Height', '%2','OldWidth', '%3','OldHeight', '%4'], true));
  FOnResize := Value;
end;

procedure TExtAbstractComponent.SetFOnShow(Value : TExtAbstractComponentOnShow); begin
  if Assigned(FOnShow) then
    JSCode(JSName+'.events ["show"].listeners=[];');
  if Assigned(Value) then
    AddListener('show', Ajax('show', ['This', '%0.nm'], true));
  FOnShow := Value;
end;

procedure TExtAbstractComponent.SetFOnStaterestore(Value : TExtAbstractComponentOnStaterestore); begin
  if Assigned(FOnStaterestore) then
    JSCode(JSName+'.events ["staterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('staterestore', Ajax('staterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStaterestore := Value;
end;

procedure TExtAbstractComponent.SetFOnStatesave(Value : TExtAbstractComponentOnStatesave); begin
  if Assigned(FOnStatesave) then
    JSCode(JSName+'.events ["statesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('statesave', Ajax('statesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStatesave := Value;
end;

function TExtAbstractComponent.JSClassName : string; begin
  Result := 'Ext.AbstractComponent';
end;

procedure TExtAbstractComponent.InitDefaults; begin
  inherited;
  FAutoElObject := TExtObject.CreateInternal(Self, 'autoEl');
  FAutoRenderElement := TExtElement.CreateInternal(Self, 'autoRender');
  FChildEls := TExtObjectList.Create(Self, 'childEls');
  FComponentLayoutObject := TExtObject.CreateInternal(Self, 'componentLayout');
  FData := TExtObject.CreateInternal(Self, 'data');
  FFrameSize := TExtObject.CreateInternal(Self, 'frameSize');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FHtmlObject := TExtObject.CreateInternal(Self, 'html');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FLoader := TExtComponentLoader.CreateInternal(Self, 'loader');
  FLoaderObject := TExtObject.CreateInternal(Self, 'loader');
  FOwnerCt := TExtContainer.CreateInternal(Self, 'ownerCt');
  FPlugins := TExtObjectList.Create(Self, 'plugins');
  FPluginsList := TExtObjectList.Create(Self, 'plugins');
  FPluginsObject := TExtObject.CreateInternal(Self, 'plugins');
  FPluginsPlugin := TExtAbstractPlugin.CreateInternal(Self, 'plugins');
  FRenderData := TExtObject.CreateInternal(Self, 'renderData');
  FRenderSelectors := TExtObject.CreateInternal(Self, 'renderSelectors');
  FRenderToElement := TExtElement.CreateInternal(Self, 'renderTo');
  FScrollFlags := TExtObject.CreateInternal(Self, 'scrollFlags');
  FStyleObject := TExtObject.CreateInternal(Self, 'style');
  FTpl := TExtXTemplate.CreateInternal(Self, 'tpl');
  FTplTemplate := TExtTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtAbstractComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAbstractComponent.AddChildEls : TExtFunction; begin
  JSCode(JSName + '.addChildEls();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddCls(Cls : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.AddCls(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddClsWithUI(Classes : TArrayOfString; Skip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddClsWithUI(' + VarToJSON([Classes, Skip, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddClsWithUI(Classes : String; Skip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addClsWithUI(' + VarToJSON([Classes, Skip, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddStateEvents(Events : String) : TExtFunction; begin
  JSCode(JSName + '.addStateEvents(' + VarToJSON([Events]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddStateEvents(Events : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.AddStateEvents(' + VarToJSON([Events]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AddUIClsToElement(Ui : String) : TExtFunction; begin
  JSCode(JSName + '.addUIClsToElement(' + VarToJSON([Ui]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.alignTo(' + VarToJSON([Element, Position, Offsets, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AlignTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, Position, Offsets, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.anchorTo(' + VarToJSON([Element, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ApplyState(State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyState(' + VarToJSON([State, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.CalculateConstrainedPosition(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.calculateConstrainedPosition(' + VarToJSON([ConstrainTo, ProposedPosition, Local, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.CalculateConstrainedPosition(ConstrainTo : TExtElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.CalculateConstrainedPosition(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.CalculateConstrainedPosition(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.CancelLayout(Comp : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.cancelLayout(' + VarToJSON([Comp, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtAbstractComponent');
  Result := Self;
end;

constructor TExtAbstractComponent.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtAbstractComponent.Disable(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.disable(' + VarToJSON([Silent]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.DoAutoRender : TExtFunction; begin
  JSCode(JSName + '.doAutoRender();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.DoComponentLayout : TExtFunction; begin
  JSCode(JSName + '.doComponentLayout();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Enable(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.enable(' + VarToJSON([Silent]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.EnsureAttachedToBody(RunLayout : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ensureAttachedToBody(' + VarToJSON([RunLayout]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.FlushLayouts : TExtFunction; begin
  JSCode(JSName + '.flushLayouts();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetActiveAnimation : TExtFunction; begin
  JSCode(JSName + '.getActiveAnimation();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetAlignToXY(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.getAlignToXY(' + VarToJSON([Element, Position, Offsets]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetAlignToXY(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetAlignToXY(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetAlignToXY(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetAlignToXY(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetAnchorXY(Anchor : String = ''; Local : Boolean = false; Size : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getAnchorXY(' + VarToJSON([Anchor, Local, Size, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetBox(ContentBox : Boolean = false; Local : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getBox(' + VarToJSON([ContentBox, Local]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetBubbleTarget : TExtFunction; begin
  JSCode(JSName + '.getBubbleTarget();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetConstrainVector(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.getConstrainVector(' + VarToJSON([ConstrainTo, ProposedPosition, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetConstrainVector(ConstrainTo : TExtUtilPositionable; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetConstrainVector(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetConstrainVector(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetHeight : TExtFunction; begin
  JSCode(JSName + '.getHeight();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetId : TExtFunction; begin
  JSCode(JSName + '.getId();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetInsertPosition(Position : Integer) : TExtFunction; begin
  JSCode(JSName + '.getInsertPosition(' + VarToJSON([Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetInsertPosition(Position : String) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetInsertPosition(Position : TExtDomElement) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetInsertPosition(Position : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetItemId : TExtFunction; begin
  JSCode(JSName + '.getItemId();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetLoader : TExtFunction; begin
  JSCode(JSName + '.getLoader();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetLocalX : TExtFunction; begin
  JSCode(JSName + '.getLocalX();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetLocalXY : TExtFunction; begin
  JSCode(JSName + '.getLocalXY();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetLocalY : TExtFunction; begin
  JSCode(JSName + '.getLocalY();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetOffsetsTo(OffsetsTo : String) : TExtFunction; begin
  JSCode(JSName + '.getOffsetsTo(' + VarToJSON([OffsetsTo]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetOffsetsTo(OffsetsTo : TExtUtilPositionable) : TExtFunction; begin
  JSCode(JSName + '.GetOffsetsTo(' + VarToJSON([OffsetsTo, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetOffsetsTo(OffsetsTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetOffsetsTo(' + VarToJSON([OffsetsTo, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetPlugin(PluginId : String) : TExtFunction; begin
  JSCode(JSName + '.getPlugin(' + VarToJSON([PluginId]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetRegion : TExtFunction; begin
  JSCode(JSName + '.getRegion();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetSize : TExtFunction; begin
  JSCode(JSName + '.getSize();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetSizeModel : TExtFunction; begin
  JSCode(JSName + '.getSizeModel();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetState : TExtFunction; begin
  JSCode(JSName + '.getState();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetViewRegion : TExtFunction; begin
  JSCode(JSName + '.getViewRegion();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetWidth : TExtFunction; begin
  JSCode(JSName + '.getWidth();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetX : TExtFunction; begin
  JSCode(JSName + '.getX();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetXTypes : TExtFunction; begin
  JSCode(JSName + '.getXTypes();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetXY : TExtFunction; begin
  JSCode(JSName + '.getXY();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.GetY : TExtFunction; begin
  JSCode(JSName + '.getY();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.HasCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.hasCls(' + VarToJSON([ClassName]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.HasUICls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.hasUICls(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsDescendantOf(Container : TExtContainer) : TExtFunction; begin
  JSCode(JSName + '.isDescendantOf(' + VarToJSON([Container, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsDisabled : TExtFunction; begin
  JSCode(JSName + '.isDisabled();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsDraggable : TExtFunction; begin
  JSCode(JSName + '.isDraggable();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsDroppable : TExtFunction; begin
  JSCode(JSName + '.isDroppable();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsFloating : TExtFunction; begin
  JSCode(JSName + '.isFloating();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsHidden : TExtFunction; begin
  JSCode(JSName + '.isHidden();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsJS(Selector : String) : TExtFunction; begin
  JSCode(JSName + '.is(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsLayoutSuspended : TExtFunction; begin
  JSCode(JSName + '.isLayoutSuspended();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsVisible(Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.isVisible(' + VarToJSON([Deep]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.IsXType(Xtype : String; Shallow : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.isXType(' + VarToJSON([Xtype, Shallow]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Move(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.move(' + VarToJSON([Direction, Distance, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Move(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Move(' + VarToJSON([Direction, Distance, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.NextNode(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.nextNode(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.NextSibling(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.nextSibling(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.PreviousNode(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.previousNode(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.PreviousSibling(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.previousSibling(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RegisterFloatingItem : TExtFunction; begin
  JSCode(JSName + '.registerFloatingItem();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveAnchor : TExtFunction; begin
  JSCode(JSName + '.removeAnchor();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveChildEls(TestFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.removeChildEls(' + VarToJSON([TestFn, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveCls(Cls : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.RemoveCls(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveClsWithUI(Cls : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.RemoveClsWithUI(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveClsWithUI(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeClsWithUI(' + VarToJSON([Cls]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.RemoveUIClsFromElement(Ui : String) : TExtFunction; begin
  JSCode(JSName + '.removeUIClsFromElement(' + VarToJSON([Ui]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : String = ''; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.render(' + VarToJSON([Container, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : TExtElement; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : TExtElement; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : THTMLElement; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : THTMLElement; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Render(Container : String; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, Position]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.ResumeLayouts(Flush : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.resumeLayouts(' + VarToJSON([Flush]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SavePropsToState(PropNames : String; State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.savePropsToState(' + VarToJSON([PropNames, State, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SavePropsToState(PropNames : TArrayOfString; State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SavePropsToState(' + VarToJSON([PropNames, State, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SavePropToState(PropName : String; State : TExtObject; StateName : String = '') : TExtFunction; begin
  JSCode(JSName + '.savePropToState(' + VarToJSON([PropName, State, false, StateName]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SaveState : TExtFunction; begin
  JSCode(JSName + '.saveState();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SequenceFx : TExtFunction; begin
  JSCode(JSName + '.sequenceFx();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetBorder(Border : String) : TExtFunction; begin
  JSCode(JSName + '.SetBorder(' + VarToJSON([Border]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetBorder(Border : Integer) : TExtFunction; begin
  JSCode(JSName + '.setBorder(' + VarToJSON([Border]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetBox(Box : TExtObject; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setBox(' + VarToJSON([Box, false, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetBox(Box : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetBox(' + VarToJSON([Box, false, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetDocked(Dock : TExtObject; LayoutParent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setDocked(' + VarToJSON([Dock, false, LayoutParent]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetHeight(Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.setHeight(' + VarToJSON([Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetLocalX(X : Integer) : TExtFunction; begin
  JSCode(JSName + '.setLocalX(' + VarToJSON([X]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetLocalXY(X : Integer; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setLocalXY(' + VarToJSON([X, Y]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetLocalXY(X : TExtObjectList; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.SetLocalXY(' + VarToJSON(X) + ',' + VarToJSON([Y]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetLocalY(Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.setLocalY(' + VarToJSON([Y]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetMargin(Margin : String) : TExtFunction; begin
  JSCode(JSName + '.SetMargin(' + VarToJSON([Margin]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetMargin(Margin : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMargin(' + VarToJSON([Margin]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPosition(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : TExtObject; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPosition(' + VarToJSON([X, false, Y, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : TExtObject; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetPosition(' + VarToJSON([X, false, Y, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPosition(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetPosition(' + VarToJSON([X, Y, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetPosition(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setPosition(' + VarToJSON([X, Y, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetRegion(Region : TExtUtilRegion; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setRegion(' + VarToJSON([Region, false, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetRegion(Region : TExtUtilRegion; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetRegion(' + VarToJSON([Region, false, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : Integer; Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : TExtObject; Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, false, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : TExtObject; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, false, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : String; Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : String; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetSize(Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.setSize(' + VarToJSON([Width, Height]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetUI(Ui : String) : TExtFunction; begin
  JSCode(JSName + '.setUI(' + VarToJSON([Ui]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetVisible(Visible : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setVisible(' + VarToJSON([Visible]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetWidth(Width : Integer) : TExtFunction; begin
  JSCode(JSName + '.setWidth(' + VarToJSON([Width]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetX(The : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setX(' + VarToJSON([The, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetX(The : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetX(' + VarToJSON([The, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetXY(Pos : TArrayOfInteger; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setXY(' + VarToJSON([Pos, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetXY(Pos : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetXY(' + VarToJSON([Pos, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetY(The : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setY(' + VarToJSON([The, Animate]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SetY(The : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetY(' + VarToJSON([The, Animate, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.StopAnimation : TExtFunction; begin
  JSCode(JSName + '.stopAnimation();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SuspendLayouts : TExtFunction; begin
  JSCode(JSName + '.suspendLayouts();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.SyncFx : TExtFunction; begin
  JSCode(JSName + '.syncFx();', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.TranslatePoints(X : Integer; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.translatePoints(' + VarToJSON([X, Y]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.TranslatePoints(X : TExtObjectList; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.TranslatePoints(' + VarToJSON(X) + ',' + VarToJSON([Y]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Up(Selector : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.Up(' + VarToJSON([Selector, false]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Up(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.up(' + VarToJSON([Selector]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Update(HtmlOrData : TExtObject; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.Update(' + VarToJSON([HtmlOrData, false, LoadScripts, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.Update(HtmlOrData : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([HtmlOrData, LoadScripts, Callback, true]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

function TExtAbstractComponent.UpdateLayout(Comp : TExtComponent; Defer : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.updateLayout(' + VarToJSON([Comp, false, Defer]) + ');', 'TExtAbstractComponent');
  Result := Self;
end;

destructor TExtAbstractComponent.Destroy; begin
  try
    FAutoElObject.Free;
    FAutoRenderElement.Free;
    FChildEls.Free;
    FComponentLayoutObject.Free;
    FData.Free;
    FFrameSize.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FHtmlObject.Free;
    FListeners.Free;
    FLoader.Free;
    FLoaderObject.Free;
    FOwnerCt.Free;
    FPlugins.Free;
    FPluginsList.Free;
    FPluginsObject.Free;
    FPluginsPlugin.Free;
    FRenderData.Free;
    FRenderSelectors.Free;
    FRenderToElement.Free;
    FScrollFlags.Free;
    FStyleObject.Free;
    FTpl.Free;
    FTplTemplate.Free;
  except end;
  inherited;
end;

procedure TExtAbstractComponent.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'added') and Assigned(FOnAdded) then
    FOnAdded(TExtAbstractComponent(ParamAsObject('This')), TExtContainer(ParamAsObject('Container')), ParamAsInteger('Pos'))
  else if (AEvtName = 'afterrender') and Assigned(FOnAfterrender) then
    FOnAfterrender(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforeactivate') and Assigned(FOnBeforeactivate) then
    FOnBeforeactivate(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforedeactivate') and Assigned(FOnBeforedeactivate) then
    FOnBeforedeactivate(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforedestroy') and Assigned(FOnBeforedestroy) then
    FOnBeforedestroy(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforehide') and Assigned(FOnBeforehide) then
    FOnBeforehide(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforerender') and Assigned(FOnBeforerender) then
    FOnBeforerender(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforeshow') and Assigned(FOnBeforeshow) then
    FOnBeforeshow(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'beforestaterestore') and Assigned(FOnBeforestaterestore) then
    FOnBeforestaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'beforestatesave') and Assigned(FOnBeforestatesave) then
    FOnBeforestatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'blur') and Assigned(FOnBlur) then
    FOnBlur(TExtAbstractComponent(ParamAsObject('This')), TExtEventObject(ParamAsObject('The')))
  else if (AEvtName = 'boxready') and Assigned(FOnBoxready) then
    FOnBoxready(TExtAbstractComponent(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'destroy') and Assigned(FOnDestroy) then
    FOnDestroy(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'disable') and Assigned(FOnDisable) then
    FOnDisable(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'enable') and Assigned(FOnEnable) then
    FOnEnable(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'focus') and Assigned(FOnFocus) then
    FOnFocus(TExtAbstractComponent(ParamAsObject('This')), TExtEventObject(ParamAsObject('The')))
  else if (AEvtName = 'hide') and Assigned(FOnHide) then
    FOnHide(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove(TExtAbstractComponent(ParamAsObject('This')), ParamAsInteger('X'), ParamAsInteger('Y'))
  else if (AEvtName = 'removed') and Assigned(FOnRemoved) then
    FOnRemoved(TExtAbstractComponent(ParamAsObject('This')), TExtContainer(ParamAsObject('OwnerCt')))
  else if (AEvtName = 'render') and Assigned(FOnRender) then
    FOnRender(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'resize') and Assigned(FOnResize) then
    FOnResize(TExtAbstractComponent(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'), ParamAsInteger('OldWidth'), ParamAsInteger('OldHeight'))
  else if (AEvtName = 'show') and Assigned(FOnShow) then
    FOnShow(TExtAbstractComponent(ParamAsObject('This')))
  else if (AEvtName = 'staterestore') and Assigned(FOnStaterestore) then
    FOnStaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'statesave') and Assigned(FOnStatesave) then
    FOnStatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')));
end;

function TExtViewNodeCache.JSClassName : string; begin
  Result := 'Ext.view.NodeCache';
end;

{$IFDEF FPC}constructor TExtViewNodeCache.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewNodeCache.Clear(RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([RemoveDom]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.Fill(Els : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fill(' + VarToJSON(Els) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.IndexOf(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.IndexOf(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.IndexOf(El : String) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.IndexOf(El : Integer) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([El]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.replaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtViewNodeCache.Scroll(NewRecords : TExtObjectList; Direction : Integer; RemoveCount : Integer) : TExtFunction; begin
  JSCode(JSName + '.scroll(' + VarToJSON(NewRecords) + ',' + VarToJSON([Direction, RemoveCount]) + ');', 'TExtViewNodeCache');
  Result := Self;
end;

function TExtFxTarget.JSClassName : string; begin
  Result := 'Ext.fx.target.Target';
end;

{$IFDEF FPC}constructor TExtFxTarget.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFxTarget.Create(Target : TExtElement); begin
  CreateVar(JSClassName + '(' + VarToJSON([Target, false]) + ');');
  InitDefaults;
end;

constructor TExtFxTarget.Create(Target : TExtDrawSprite); begin
  CreateVar(JSClassName + '(' + VarToJSON([Target, false]) + ');');
  InitDefaults;
end;

constructor TExtFxTarget.Create(Target : TExtComponent); begin
  CreateVar(JSClassName + '(' + VarToJSON([Target, false]) + ');');
  InitDefaults;
end;

function TExtFxQueue.JSClassName : string; begin
  Result := 'Ext.fx.Queue';
end;

{$IFDEF FPC}constructor TExtFxQueue.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridLockingLockable.SetFLockedGridConfig(Value : TExtObject); begin
  FLockedGridConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('lockedGridConfig:' + VarToJSON([Value, false]));
end;

procedure TExtGridLockingLockable.SetFLockedViewConfig(Value : TExtObject); begin
  FLockedViewConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('lockedViewConfig:' + VarToJSON([Value, false]));
end;

procedure TExtGridLockingLockable.SetFNormalGridConfig(Value : TExtObject); begin
  FNormalGridConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('normalGridConfig:' + VarToJSON([Value, false]));
end;

procedure TExtGridLockingLockable.SetFNormalViewConfig(Value : TExtObject); begin
  FNormalViewConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('normalViewConfig:' + VarToJSON([Value, false]));
end;

procedure TExtGridLockingLockable.SetFScrollDelta(Value : Integer); begin
  FScrollDelta := Value;
  JSCode('scrollDelta:' + VarToJSON([Value]));
end;

procedure TExtGridLockingLockable.SetFSubGridXType(Value : String); begin
  FSubGridXType := Value;
  JSCode('subGridXType:' + VarToJSON([Value]));
end;

procedure TExtGridLockingLockable.SetFSyncRowHeight(Value : Boolean); begin
  FSyncRowHeight := Value;
  JSCode('syncRowHeight:' + VarToJSON([Value]));
end;

procedure TExtGridLockingLockable.SetFOnFilterchange(Value : TExtGridLockingLockableOnFilterchange); begin
  if Assigned(FOnFilterchange) then
    JSCode(JSName+'.events ["filterchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('filterchange', Ajax('filterchange', [], true));
  FOnFilterchange := Value;
end;

procedure TExtGridLockingLockable.SetFOnLockcolumn(Value : TExtGridLockingLockableOnLockcolumn); begin
  if Assigned(FOnLockcolumn) then
    JSCode(JSName+'.events ["lockcolumn"].listeners=[];');
  if Assigned(Value) then
    AddListener('lockcolumn', Ajax('lockcolumn', ['This', '%0.nm','Column', '%1.nm'], true));
  FOnLockcolumn := Value;
end;

procedure TExtGridLockingLockable.SetFOnProcesscolumns(Value : TExtGridLockingLockableOnProcesscolumns); begin
  if Assigned(FOnProcesscolumns) then
    JSCode(JSName+'.events ["processcolumns"].listeners=[];');
  if Assigned(Value) then
    AddListener('processcolumns', Ajax('processcolumns', ['LockedColumns', '%0.nm','NormalColumns', '%1.nm'], true));
  FOnProcesscolumns := Value;
end;

procedure TExtGridLockingLockable.SetFOnUnlockcolumn(Value : TExtGridLockingLockableOnUnlockcolumn); begin
  if Assigned(FOnUnlockcolumn) then
    JSCode(JSName+'.events ["unlockcolumn"].listeners=[];');
  if Assigned(Value) then
    AddListener('unlockcolumn', Ajax('unlockcolumn', ['This', '%0.nm','Column', '%1.nm'], true));
  FOnUnlockcolumn := Value;
end;

function TExtGridLockingLockable.JSClassName : string; begin
  Result := 'Ext.grid.locking.Lockable';
end;

procedure TExtGridLockingLockable.InitDefaults; begin
  inherited;
  FLockedGridConfig := TExtObject.CreateInternal(Self, 'lockedGridConfig');
  FLockedViewConfig := TExtObject.CreateInternal(Self, 'lockedViewConfig');
  FNormalGridConfig := TExtObject.CreateInternal(Self, 'normalGridConfig');
  FNormalViewConfig := TExtObject.CreateInternal(Self, 'normalViewConfig');
end;

{$IFDEF FPC}constructor TExtGridLockingLockable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridLockingLockable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridLockingLockable.SyncRowHeights : TExtFunction; begin
  JSCode(JSName + '.syncRowHeights();', 'TExtGridLockingLockable');
  Result := Self;
end;

destructor TExtGridLockingLockable.Destroy; begin
  try
    FLockedGridConfig.Free;
    FLockedViewConfig.Free;
    FNormalGridConfig.Free;
    FNormalViewConfig.Free;
  except end;
  inherited;
end;

procedure TExtGridLockingLockable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'filterchange') and Assigned(FOnFilterchange) then
    FOnFilterchange()
  else if (AEvtName = 'lockcolumn') and Assigned(FOnLockcolumn) then
    FOnLockcolumn(TExtGridLockingLockable(ParamAsObject('This')), TExtGridColumn(ParamAsObject('Column')))
  else if (AEvtName = 'processcolumns') and Assigned(FOnProcesscolumns) then
    FOnProcesscolumns(TExtObjectList(ParamAsObject('LockedColumns')), TExtObjectList(ParamAsObject('NormalColumns')))
  else if (AEvtName = 'unlockcolumn') and Assigned(FOnUnlockcolumn) then
    FOnUnlockcolumn(TExtGridLockingLockable(ParamAsObject('This')), TExtGridColumn(ParamAsObject('Column')));
end;

procedure TExtGridLockingView.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridLockingView.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridLockingView.SetFIsLockingView(Value : Boolean); begin
  FIsLockingView := Value;
  JSCode(JSName + '.isLockingView=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridLockingView.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridLockingView.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

function TExtGridLockingView.JSClassName : string; begin
  Result := 'Ext.grid.locking.View';
end;

{$IFDEF FPC}constructor TExtGridLockingView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridLockingView.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridLockingView.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtGridLockingView');
  Result := Self;
end;

function TExtGridPluginBufferedRendererTableView.JSClassName : string; begin
  Result := 'Ext.grid.plugin.BufferedRendererTableView';
end;

{$IFDEF FPC}constructor TExtGridPluginBufferedRendererTableView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilTextMetrics.JSClassName : string; begin
  Result := 'Ext.util.TextMetrics';
end;

{$IFDEF FPC}constructor TExtUtilTextMetrics.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilTextMetrics.Bind(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Bind(' + VarToJSON([El, false]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Bind(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Bind(' + VarToJSON([El, false]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Bind(El : String) : TExtFunction; begin
  JSCode(JSName + '.bind(' + VarToJSON([El]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

constructor TExtUtilTextMetrics.Create(BindTo : THTMLElement; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, false, FixedWidth]) + ');');
  InitDefaults;
end;

constructor TExtUtilTextMetrics.Create(BindTo : TExtElement; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, false, FixedWidth]) + ');');
  InitDefaults;
end;

constructor TExtUtilTextMetrics.Create(BindTo : String; FixedWidth : Integer = 0); begin
  CreateVar(JSClassName + '(' + VarToJSON([BindTo, FixedWidth]) + ');');
  InitDefaults;
end;

function TExtUtilTextMetrics.GetHeight(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getHeight(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetSize(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getSize(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetTextWidth(Text : String; Min : Integer = 0; Max : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.getTextWidth(' + VarToJSON([Text, Min, Max]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.GetWidth(Text : String) : TExtFunction; begin
  JSCode(JSName + '.getWidth(' + VarToJSON([Text]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Measure(El : THTMLElement; Text : String; FixedWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Measure(' + VarToJSON([El, false, Text, FixedWidth]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.Measure(El : String; Text : String; FixedWidth : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.measure(' + VarToJSON([El, Text, FixedWidth]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

function TExtUtilTextMetrics.SetFixedWidth(Width : Integer) : TExtFunction; begin
  JSCode(JSName + '.setFixedWidth(' + VarToJSON([Width]) + ');', 'TExtUtilTextMetrics');
  Result := Self;
end;

procedure TExtFxAnim.SetFAlternate(Value : Boolean); begin
  FAlternate := Value;
  JSCode('alternate:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtFxAnim.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFDuration(Value : Integer); begin
  FDuration := Value;
  JSCode('duration:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFEasing(Value : String); begin
  FEasing := Value;
  JSCode('easing:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFFrom(Value : TExtObject); begin
  FFrom := Value;
  Value.DeleteFromGarbage;
  JSCode('from:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFxAnim.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFxAnim.SetFIsAnimation(Value : Boolean); begin
  FIsAnimation := Value;
  JSCode(JSName + '.isAnimation=' + VarToJSON([Value]) + ';');
end;

procedure TExtFxAnim.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFxAnim.SetFIterations(Value : Integer); begin
  FIterations := Value;
  JSCode('iterations:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFKeyframes(Value : TExtObject); begin
  FKeyframes := Value;
  Value.DeleteFromGarbage;
  JSCode('keyframes:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFReverse(Value : Boolean); begin
  FReverse := Value;
  JSCode('reverse:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFScope(Value : TExtFunction); begin
  FScope := Value;
  JSCode('scope:' + VarToJSON([Value, true]));
end;

procedure TExtFxAnim.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtFxAnim.SetFTargetObject(Value : TExtObject); begin
  FTargetObject := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFToJS(Value : TExtObject); begin
  FToJS := Value;
  Value.DeleteFromGarbage;
  JSCode('toJS:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnim.SetFOnAfteranimate(Value : TExtFxAnimOnAfteranimate); begin
  if Assigned(FOnAfteranimate) then
    JSCode(JSName+'.events ["afteranimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteranimate', Ajax('afteranimate', ['This', '%0.nm','StartTime', '%1'], true));
  FOnAfteranimate := Value;
end;

procedure TExtFxAnim.SetFOnBeforeanimate(Value : TExtFxAnimOnBeforeanimate); begin
  if Assigned(FOnBeforeanimate) then
    JSCode(JSName+'.events ["beforeanimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeanimate', Ajax('beforeanimate', ['This', '%0.nm'], true));
  FOnBeforeanimate := Value;
end;

procedure TExtFxAnim.SetFOnLastframe(Value : TExtFxAnimOnLastframe); begin
  if Assigned(FOnLastframe) then
    JSCode(JSName+'.events ["lastframe"].listeners=[];');
  if Assigned(Value) then
    AddListener('lastframe', Ajax('lastframe', ['This', '%0.nm','StartTime', '%1'], true));
  FOnLastframe := Value;
end;

function TExtFxAnim.JSClassName : string; begin
  Result := 'Ext.fx.Anim';
end;

procedure TExtFxAnim.InitDefaults; begin
  inherited;
  FFrom := TExtObject.CreateInternal(Self, 'from');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FKeyframes := TExtObject.CreateInternal(Self, 'keyframes');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FTargetObject := TExtObject.CreateInternal(Self, 'target');
  FToJS := TExtObject.CreateInternal(Self, 'toJS');
end;

{$IFDEF FPC}constructor TExtFxAnim.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxAnim.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtFxAnim');
  Result := Self;
end;

constructor TExtFxAnim.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFxAnim.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.EndJS : TExtFunction; begin
  JSCode(JSName + '.end();', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtFxAnim');
  Result := Self;
end;

function TExtFxAnim.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtFxAnim');
  Result := Self;
end;

destructor TExtFxAnim.Destroy; begin
  try
    FFrom.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FKeyframes.Free;
    FListeners.Free;
    FTargetObject.Free;
    FToJS.Free;
  except end;
  inherited;
end;

procedure TExtFxAnim.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'afteranimate') and Assigned(FOnAfteranimate) then
    FOnAfteranimate(TExtFxAnim(ParamAsObject('This')), ParamAsTDateTime('StartTime'))
  else if (AEvtName = 'beforeanimate') and Assigned(FOnBeforeanimate) then
    FOnBeforeanimate(TExtFxAnim(ParamAsObject('This')))
  else if (AEvtName = 'lastframe') and Assigned(FOnLastframe) then
    FOnLastframe(TExtFxAnim(ParamAsObject('This')), ParamAsTDateTime('StartTime'));
end;

procedure TExtFxAnimator.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFDuration(Value : Integer); begin
  FDuration := Value;
  JSCode('duration:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFEasing(Value : String); begin
  FEasing := Value;
  JSCode('easing:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFxAnimator.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFxAnimator.SetFIsAnimator(Value : Boolean); begin
  FIsAnimator := Value;
  JSCode(JSName + '.isAnimator=' + VarToJSON([Value]) + ';');
end;

procedure TExtFxAnimator.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFxAnimator.SetFIterations(Value : Integer); begin
  FIterations := Value;
  JSCode('iterations:' + VarToJSON([Value]));
end;

procedure TExtFxAnimator.SetFKeyframes(Value : TExtObject); begin
  FKeyframes := Value;
  Value.DeleteFromGarbage;
  JSCode('keyframes:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnimator.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnimator.SetFTarget(Value : TExtFxTarget); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtFxAnimator.SetFOnAfteranimate(Value : TExtFxAnimatorOnAfteranimate); begin
  if Assigned(FOnAfteranimate) then
    JSCode(JSName+'.events ["afteranimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteranimate', Ajax('afteranimate', ['This', '%0.nm','StartTime', '%1'], true));
  FOnAfteranimate := Value;
end;

procedure TExtFxAnimator.SetFOnBeforeanimate(Value : TExtFxAnimatorOnBeforeanimate); begin
  if Assigned(FOnBeforeanimate) then
    JSCode(JSName+'.events ["beforeanimate"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeanimate', Ajax('beforeanimate', ['This', '%0.nm'], true));
  FOnBeforeanimate := Value;
end;

procedure TExtFxAnimator.SetFOnKeyframe(Value : TExtFxAnimatorOnKeyframe); begin
  if Assigned(FOnKeyframe) then
    JSCode(JSName+'.events ["keyframe"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyframe', Ajax('keyframe', ['This', '%0.nm','Keyframe', '%1'], true));
  FOnKeyframe := Value;
end;

function TExtFxAnimator.JSClassName : string; begin
  Result := 'Ext.fx.Animator';
end;

procedure TExtFxAnimator.InitDefaults; begin
  inherited;
  FDelay := 0;
  FDuration := 250;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FIterations := 1;
  FKeyframes := TExtObject.CreateInternal(Self, 'keyframes');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FTarget := TExtFxTarget.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtFxAnimator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxAnimator.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtFxAnimator');
  Result := Self;
end;

constructor TExtFxAnimator.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFxAnimator.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.EndJS : TExtFunction; begin
  JSCode(JSName + '.end();', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

function TExtFxAnimator.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtFxAnimator');
  Result := Self;
end;

destructor TExtFxAnimator.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FKeyframes.Free;
    FListeners.Free;
    FTarget.Free;
  except end;
  inherited;
end;

procedure TExtFxAnimator.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'afteranimate') and Assigned(FOnAfteranimate) then
    FOnAfteranimate(TExtFxAnimator(ParamAsObject('This')), ParamAsTDateTime('StartTime'))
  else if (AEvtName = 'beforeanimate') and Assigned(FOnBeforeanimate) then
    FOnBeforeanimate(TExtFxAnimator(ParamAsObject('This')))
  else if (AEvtName = 'keyframe') and Assigned(FOnKeyframe) then
    FOnKeyframe(TExtFxAnimator(ParamAsObject('This')), ParamAsInteger('Keyframe'));
end;

procedure TExtFormFieldVTypesSingleton.SetFAlphanumText(Value : String); begin
  FAlphanumText := Value;
  JSCode(JSName + '.alphanumText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFAlphaText(Value : String); begin
  FAlphaText := Value;
  JSCode(JSName + '.alphaText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFEmailMask(Value : TRegExp); begin
  FEmailMask := Value;
  JSCode(JSName + '.emailMask=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFEmailText(Value : String); begin
  FEmailText := Value;
  JSCode(JSName + '.emailText=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldVTypesSingleton.SetFUrlText(Value : String); begin
  FUrlText := Value;
  JSCode(JSName + '.urlText=' + VarToJSON([Value]) + ';');
end;

function TExtFormFieldVTypesSingleton.JSClassName : string; begin
  Result := 'Ext.form.field.VTypes';
end;

procedure TExtFormFieldVTypesSingleton.InitDefaults; begin
  inherited;
  FAlphanumText := 'This field should only contain letters, numbers and _';
  FAlphaText := 'This field should only contain letters and _';
  FEmailText := 'This field should be an e-mail address in the format';
  FUrlText := 'This field should be a URL in the format';
end;

{$IFDEF FPC}constructor TExtFormFieldVTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldVTypesSingleton.Alpha(Value : String) : TExtFunction; begin
  JSCode(JSName + '.alpha(' + VarToJSON([Value]) + ');', 'TExtFormFieldVTypesSingleton');
  Result := Self;
end;

function TExtFormFieldVTypesSingleton.Alphanum(Value : String) : TExtFunction; begin
  JSCode(JSName + '.alphanum(' + VarToJSON([Value]) + ');', 'TExtFormFieldVTypesSingleton');
  Result := Self;
end;

function TExtFormFieldVTypesSingleton.Email(Value : String) : TExtFunction; begin
  JSCode(JSName + '.email(' + VarToJSON([Value]) + ');', 'TExtFormFieldVTypesSingleton');
  Result := Self;
end;

function TExtFormFieldVTypesSingleton.Url(Value : String) : TExtFunction; begin
  JSCode(JSName + '.url(' + VarToJSON([Value]) + ');', 'TExtFormFieldVTypesSingleton');
  Result := Self;
end;

procedure TExtFormLabelable.SetFActiveError(Value : String); begin
  FActiveError := Value;
  if not ConfigAvailable(JSName) then
    SetActiveError(Value)
  else
    JSCode('activeError:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFActiveErrorsTpl(Value : String); begin
  FActiveErrorsTpl := Value;
  JSCode('activeErrorsTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString); begin
  FActiveErrorsTplTArrayOfString := Value;
  JSCode('activeErrorsTpl:' + ArrayToJSON(Value));
end;

procedure TExtFormLabelable.SetFActiveErrorsTplTemplate(Value : TExtXTemplate); begin
  FActiveErrorsTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('activeErrorsTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterBodyEl(Value : String); begin
  FAfterBodyEl := Value;
  JSCode('afterBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterBodyElList(Value : TExtObjectList); begin
  FAfterBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterBodyElTemplate(Value : TExtXTemplate); begin
  FAfterBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTpl(Value : String); begin
  FAfterLabelTextTpl := Value;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTplList(Value : TExtObjectList); begin
  FAfterLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTextTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTpl(Value : String); begin
  FAfterLabelTpl := Value;
  JSCode('afterLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterLabelTplList(Value : TExtObjectList); begin
  FAfterLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterLabelTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterSubTpl(Value : String); begin
  FAfterSubTpl := Value;
  JSCode('afterSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFAfterSubTplList(Value : TExtObjectList); begin
  FAfterSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAfterSubTplTemplate(Value : TExtXTemplate); begin
  FAfterSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFAutoFitErrors(Value : Boolean); begin
  FAutoFitErrors := Value;
  JSCode('autoFitErrors:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBaseBodyCls(Value : String); begin
  FBaseBodyCls := Value;
  JSCode('baseBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeBodyEl(Value : String); begin
  FBeforeBodyEl := Value;
  JSCode('beforeBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeBodyElList(Value : TExtObjectList); begin
  FBeforeBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeBodyElTemplate(Value : TExtXTemplate); begin
  FBeforeBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTpl(Value : String); begin
  FBeforeLabelTextTpl := Value;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTplList(Value : TExtObjectList); begin
  FBeforeLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTpl(Value : String); begin
  FBeforeLabelTpl := Value;
  JSCode('beforeLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTplList(Value : TExtObjectList); begin
  FBeforeLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeLabelTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeSubTpl(Value : String); begin
  FBeforeSubTpl := Value;
  JSCode('beforeSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFBeforeSubTplList(Value : TExtObjectList); begin
  FBeforeSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBeforeSubTplTemplate(Value : TExtXTemplate); begin
  FBeforeSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFBodyEl(Value : TExtElement); begin
  FBodyEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.bodyEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormLabelable.SetFClearCls(Value : String); begin
  FClearCls := Value;
  JSCode('clearCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFErrorEl(Value : TExtElement); begin
  FErrorEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.errorEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormLabelable.SetFErrorMsgCls(Value : String); begin
  FErrorMsgCls := Value;
  JSCode('errorMsgCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFFieldLabel(Value : String); begin
  FFieldLabel := Value;
  if not ConfigAvailable(JSName) then
    SetFieldLabel(Value)
  else
    JSCode('fieldLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFFormItemCls(Value : String); begin
  FFormItemCls := Value;
  JSCode('formItemCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFHideEmptyLabel(Value : Boolean); begin
  FHideEmptyLabel := Value;
  JSCode('hideEmptyLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFHideLabel(Value : Boolean); begin
  FHideLabel := Value;
  JSCode('hideLabel:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFInvalidCls(Value : String); begin
  FInvalidCls := Value;
  JSCode('invalidCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFIsFieldLabelable(Value : Boolean); begin
  FIsFieldLabelable := Value;
  JSCode(JSName + '.isFieldLabelable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormLabelable.SetFLabelAlign(Value : TLabelAlignEnum); begin
  FLabelAlign := Value;
  JSCode('labelAlign:"' + EnumToJSString(TypeInfo(TLabelAlignEnum), ord(Value)) + '"');
end;

procedure TExtFormLabelable.SetFLabelAttrTpl(Value : String); begin
  FLabelAttrTpl := Value;
  JSCode('labelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelAttrTplList(Value : TExtObjectList); begin
  FLabelAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFLabelAttrTplTemplate(Value : TExtXTemplate); begin
  FLabelAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormLabelable.SetFLabelCell(Value : TExtElement); begin
  FLabelCell := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelCell=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormLabelable.SetFLabelCls(Value : String); begin
  FLabelCls := Value;
  JSCode('labelCls:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelClsExtra(Value : String); begin
  FLabelClsExtra := Value;
  JSCode('labelClsExtra:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelEl(Value : TExtElement); begin
  FLabelEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormLabelable.SetFLabelPad(Value : Integer); begin
  FLabelPad := Value;
  JSCode('labelPad:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelSeparator(Value : String); begin
  FLabelSeparator := Value;
  JSCode('labelSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelStyle(Value : String); begin
  FLabelStyle := Value;
  JSCode('labelStyle:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFMsgTarget(Value : String); begin
  FMsgTarget := Value;
  JSCode('msgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFPreventMark(Value : Boolean); begin
  FPreventMark := Value;
  JSCode('preventMark:' + VarToJSON([Value]));
end;

procedure TExtFormLabelable.SetFOnErrorchange(Value : TExtFormLabelableOnErrorchange); begin
  if Assigned(FOnErrorchange) then
    JSCode(JSName+'.events ["errorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('errorchange', Ajax('errorchange', ['This', '%0.nm','Error', '%1'], true));
  FOnErrorchange := Value;
end;

function TExtFormLabelable.JSClassName : string; begin
  Result := 'Ext.form.Labelable';
end;

procedure TExtFormLabelable.InitDefaults; begin
  inherited;
  FActiveErrorsTplTemplate := TExtXTemplate.CreateInternal(Self, 'activeErrorsTpl');
  FAfterBodyElList := TExtObjectList.Create(Self, 'afterBodyEl');
  FAfterBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'afterBodyEl');
  FAfterLabelTextTplList := TExtObjectList.Create(Self, 'afterLabelTextTpl');
  FAfterLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTextTpl');
  FAfterLabelTplList := TExtObjectList.Create(Self, 'afterLabelTpl');
  FAfterLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTpl');
  FAfterSubTplList := TExtObjectList.Create(Self, 'afterSubTpl');
  FAfterSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterSubTpl');
  FBeforeBodyElList := TExtObjectList.Create(Self, 'beforeBodyEl');
  FBeforeBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBodyEl');
  FBeforeLabelTextTplList := TExtObjectList.Create(Self, 'beforeLabelTextTpl');
  FBeforeLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTextTpl');
  FBeforeLabelTplList := TExtObjectList.Create(Self, 'beforeLabelTpl');
  FBeforeLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTpl');
  FBeforeSubTplList := TExtObjectList.Create(Self, 'beforeSubTpl');
  FBeforeSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeSubTpl');
  FBodyEl := TExtElement.CreateInternal(Self, 'bodyEl');
  FErrorEl := TExtElement.CreateInternal(Self, 'errorEl');
  FLabelAttrTplList := TExtObjectList.Create(Self, 'labelAttrTpl');
  FLabelAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'labelAttrTpl');
  FLabelCell := TExtElement.CreateInternal(Self, 'labelCell');
  FLabelEl := TExtElement.CreateInternal(Self, 'labelEl');
end;

{$IFDEF FPC}constructor TExtFormLabelable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormLabelable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormLabelable.GetActiveError : TExtFunction; begin
  JSCode(JSName + '.getActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetActiveErrors : TExtFunction; begin
  JSCode(JSName + '.getActiveErrors();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetInputId : TExtFunction; begin
  JSCode(JSName + '.getInputId();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.GetLabelWidth : TExtFunction; begin
  JSCode(JSName + '.getLabelWidth();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.HasActiveError : TExtFunction; begin
  JSCode(JSName + '.hasActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.HasVisibleLabel : TExtFunction; begin
  JSCode(JSName + '.hasVisibleLabel();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.InitLabelable : TExtFunction; begin
  JSCode(JSName + '.initLabelable();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetActiveError(Msg : String) : TExtFunction; begin
  JSCode(JSName + '.setActiveError(' + VarToJSON([Msg]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetActiveErrors(Errors : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.setActiveErrors(' + VarToJSON([Errors]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetFieldDefaults(Defaults : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setFieldDefaults(' + VarToJSON([Defaults, false]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.SetFieldLabel(LabelJS : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldLabel(' + VarToJSON([LabelJS]) + ');', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.TrimLabelSeparator : TExtFunction; begin
  JSCode(JSName + '.trimLabelSeparator();', 'TExtFormLabelable');
  Result := Self;
end;

function TExtFormLabelable.UnsetActiveError : TExtFunction; begin
  JSCode(JSName + '.unsetActiveError();', 'TExtFormLabelable');
  Result := Self;
end;

destructor TExtFormLabelable.Destroy; begin
  try
    FActiveErrorsTplTemplate.Free;
    FAfterBodyElList.Free;
    FAfterBodyElTemplate.Free;
    FAfterLabelTextTplList.Free;
    FAfterLabelTextTplTemplate.Free;
    FAfterLabelTplList.Free;
    FAfterLabelTplTemplate.Free;
    FAfterSubTplList.Free;
    FAfterSubTplTemplate.Free;
    FBeforeBodyElList.Free;
    FBeforeBodyElTemplate.Free;
    FBeforeLabelTextTplList.Free;
    FBeforeLabelTextTplTemplate.Free;
    FBeforeLabelTplList.Free;
    FBeforeLabelTplTemplate.Free;
    FBeforeSubTplList.Free;
    FBeforeSubTplTemplate.Free;
    FBodyEl.Free;
    FErrorEl.Free;
    FLabelAttrTplList.Free;
    FLabelAttrTplTemplate.Free;
    FLabelCell.Free;
    FLabelEl.Free;
  except end;
  inherited;
end;

procedure TExtFormLabelable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'errorchange') and Assigned(FOnErrorchange) then
    FOnErrorchange(TExtFormLabelable(ParamAsObject('This')), ParamAsString('Error'));
end;

procedure TExtFxManagerSingleton.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

function TExtFxManagerSingleton.JSClassName : string; begin
  Result := 'Ext.fx.Manager';
end;

procedure TExtFxManagerSingleton.InitDefaults; begin
  inherited;
  FInterval := 16;
end;

{$IFDEF FPC}constructor TExtFxManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxManagerSingleton.AddAnim(Anim : TExtFxAnim) : TExtFunction; begin
  JSCode(JSName + '.addAnim(' + VarToJSON([Anim, false]) + ');', 'TExtFxManagerSingleton');
  Result := Self;
end;

function TExtFxManagerSingleton.RemoveAnim(Anim : TExtFxAnim) : TExtFunction; begin
  JSCode(JSName + '.removeAnim(' + VarToJSON([Anim, false]) + ');', 'TExtFxManagerSingleton');
  Result := Self;
end;

function TExtFxPropertyHandler.JSClassName : string; begin
  Result := 'Ext.fx.PropertyHandler';
end;

{$IFDEF FPC}constructor TExtFxPropertyHandler.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxCubicBezierSingleton.JSClassName : string; begin
  Result := 'Ext.fx.CubicBezier';
end;

{$IFDEF FPC}constructor TExtFxCubicBezierSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxEasingSingleton.JSClassName : string; begin
  Result := 'Ext.fx.Easing';
end;

{$IFDEF FPC}constructor TExtFxEasingSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginBufferedRendererTreeView.JSClassName : string; begin
  Result := 'Ext.grid.plugin.BufferedRendererTreeView';
end;

{$IFDEF FPC}constructor TExtGridPluginBufferedRendererTreeView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContextItem.SetFState(Value : TExtObject); begin
  FState := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.state=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutContextItem.SetFWrapsComponent(Value : Boolean); begin
  FWrapsComponent := Value;
  JSCode(JSName + '.wrapsComponent=' + VarToJSON([Value]) + ';');
end;

function TExtLayoutContextItem.JSClassName : string; begin
  Result := 'Ext.layout.ContextItem';
end;

procedure TExtLayoutContextItem.InitDefaults; begin
  inherited;
  FState := TExtObject.CreateInternal(Self, 'state');
end;

{$IFDEF FPC}constructor TExtLayoutContextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContextItem.AddCls : TExtFunction; begin
  JSCode(JSName + '.addCls();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.Block(Layout : TExtLayout; PropName : String) : TExtFunction; begin
  JSCode(JSName + '.block(' + VarToJSON([Layout, false, PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.ClearMarginCache : TExtFunction; begin
  JSCode(JSName + '.clearMarginCache();', 'TExtLayoutContextItem');
  Result := Self;
end;

constructor TExtLayoutContextItem.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtLayoutContextItem.DomBlock(Layout : TExtLayout; PropName : String) : TExtFunction; begin
  JSCode(JSName + '.domBlock(' + VarToJSON([Layout, false, PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.Flush : TExtFunction; begin
  JSCode(JSName + '.flush();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetBorderInfo : TExtFunction; begin
  JSCode(JSName + '.getBorderInfo();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetClassList : TExtFunction; begin
  JSCode(JSName + '.getClassList();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetDomProp(PropName : String) : TExtFunction; begin
  JSCode(JSName + '.getDomProp(' + VarToJSON([PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetEl(NameOrEl : String; Owner : TExtLayoutContainer) : TExtFunction; begin
  JSCode(JSName + '.GetEl(' + VarToJSON([NameOrEl, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetEl(NameOrEl : TExtDomElement; Owner : TExtLayoutContainer) : TExtFunction; begin
  JSCode(JSName + '.GetEl(' + VarToJSON([NameOrEl, false, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetEl(NameOrEl : TExtDomElement; Owner : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.GetEl(' + VarToJSON([NameOrEl, false, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetEl(NameOrEl : String; Owner : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.getEl(' + VarToJSON([NameOrEl, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetFrameInfo : TExtFunction; begin
  JSCode(JSName + '.getFrameInfo();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetMarginInfo : TExtFunction; begin
  JSCode(JSName + '.getMarginInfo();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetPaddingInfo : TExtFunction; begin
  JSCode(JSName + '.getPaddingInfo();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetProp(PropName : String) : TExtFunction; begin
  JSCode(JSName + '.getProp(' + VarToJSON([PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetStyle(StyleName : String) : TExtFunction; begin
  JSCode(JSName + '.getStyle(' + VarToJSON([StyleName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.GetStyles(StyleNames : TArrayOfString; AltNames : TArrayOfString = nil) : TExtFunction; begin
  JSCode(JSName + '.getStyles(' + VarToJSON([StyleNames, AltNames]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.HasDomProp(PropName : String) : TExtFunction; begin
  JSCode(JSName + '.hasDomProp(' + VarToJSON([PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.HasProp(PropName : String) : TExtFunction; begin
  JSCode(JSName + '.hasProp(' + VarToJSON([PropName]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.Invalidate(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.invalidate(' + VarToJSON([Options, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RecoverProp(PropName : String; OldProps : TExtObject; OldDirty : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.recoverProp(' + VarToJSON([PropName, OldProps, false, OldDirty, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RemoveCls : TExtFunction; begin
  JSCode(JSName + '.removeCls();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RemoveEl(NameOrEl : String; Owner : TExtLayoutContainer) : TExtFunction; begin
  JSCode(JSName + '.RemoveEl(' + VarToJSON([NameOrEl, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RemoveEl(NameOrEl : TExtDomElement; Owner : TExtLayoutContainer) : TExtFunction; begin
  JSCode(JSName + '.RemoveEl(' + VarToJSON([NameOrEl, false, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RemoveEl(NameOrEl : TExtDomElement; Owner : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveEl(' + VarToJSON([NameOrEl, false, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.RemoveEl(NameOrEl : String; Owner : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.removeEl(' + VarToJSON([NameOrEl, Owner, false]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetAttribute : TExtFunction; begin
  JSCode(JSName + '.setAttribute();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetContentHeight : TExtFunction; begin
  JSCode(JSName + '.setContentHeight();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetContentSize : TExtFunction; begin
  JSCode(JSName + '.setContentSize();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetContentWidth : TExtFunction; begin
  JSCode(JSName + '.setContentWidth();', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetHeight(Height : Integer; Dirty : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setHeight(' + VarToJSON([Height, Dirty]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetProp(PropName : String; Value : TExtObject; Dirty : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setProp(' + VarToJSON([PropName, Value, false, Dirty]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

function TExtLayoutContextItem.SetWidth(Width : Integer; Dirty : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setWidth(' + VarToJSON([Width, Dirty]) + ');', 'TExtLayoutContextItem');
  Result := Self;
end;

destructor TExtLayoutContextItem.Destroy; begin
  try
    FState.Free;
  except end;
  inherited;
end;

procedure TExtLayoutSizeModel.SetFAuto(Value : Boolean); begin
  FAuto := Value;
  JSCode(JSName + '.auto=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFCalculated(Value : Boolean); begin
  FCalculated := Value;
  JSCode(JSName + '.calculated=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFCalculatedFromConfigured(Value : Boolean); begin
  FCalculatedFromConfigured := Value;
  JSCode(JSName + '.calculatedFromConfigured=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFCalculatedFromNatural(Value : Boolean); begin
  FCalculatedFromNatural := Value;
  JSCode(JSName + '.calculatedFromNatural=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFCalculatedFromShrinkWrap(Value : Boolean); begin
  FCalculatedFromShrinkWrap := Value;
  JSCode(JSName + '.calculatedFromShrinkWrap=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFConfigured(Value : Boolean); begin
  FConfigured := Value;
  JSCode(JSName + '.configured=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFConstrainedMax(Value : Boolean); begin
  FConstrainedMax := Value;
  JSCode(JSName + '.constrainedMax=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFConstrainedMin(Value : Boolean); begin
  FConstrainedMin := Value;
  JSCode(JSName + '.constrainedMin=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode(JSName + '.fixed=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFName(Value : String); begin
  FName := Value;
  JSCode(JSName + '.name=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFNames(Value : TExtObject); begin
  FNames := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.names=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutSizeModel.SetFNamesHeight(Value : String); begin
  FNamesHeight := Value;
  JSCode(JSName + '.namesHeight=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFNamesWidth(Value : String); begin
  FNamesWidth := Value;
  JSCode(JSName + '.namesWidth=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFNatural(Value : Boolean); begin
  FNatural := Value;
  JSCode(JSName + '.natural=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFOrdinal(Value : Integer); begin
  FOrdinal := Value;
  JSCode(JSName + '.ordinal=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutSizeModel.SetFPairsByHeightOrdinal(Value : TExtObjectList); begin
  FPairsByHeightOrdinal := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.pairsByHeightOrdinal=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutSizeModel.SetFPairsByHeightOrdinalHeight(Value : TExtLayoutSizeModel); begin
  FPairsByHeightOrdinalHeight := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.pairsByHeightOrdinalHeight=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutSizeModel.SetFPairsByHeightOrdinalWidth(Value : TExtLayoutSizeModel); begin
  FPairsByHeightOrdinalWidth := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.pairsByHeightOrdinalWidth=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutSizeModel.SetFShrinkWrap(Value : Boolean); begin
  FShrinkWrap := Value;
  JSCode(JSName + '.shrinkWrap=' + VarToJSON([Value]) + ';');
end;

function TExtLayoutSizeModel.JSClassName : string; begin
  Result := 'Ext.layout.SizeModel';
end;

procedure TExtLayoutSizeModel.InitDefaults; begin
  inherited;
  FNames := TExtObject.CreateInternal(Self, 'names');
  FPairsByHeightOrdinal := TExtObjectList.Create(Self, 'pairsByHeightOrdinal');
  FPairsByHeightOrdinalHeight := TExtLayoutSizeModel.CreateInternal(Self, 'pairsByHeightOrdinalHeight');
  FPairsByHeightOrdinalWidth := TExtLayoutSizeModel.CreateInternal(Self, 'pairsByHeightOrdinalWidth');
end;

{$IFDEF FPC}constructor TExtLayoutSizeModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutSizeModel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutSizeModel.Destroy; begin
  try
    FNames.Free;
    FPairsByHeightOrdinal.Free;
    FPairsByHeightOrdinalHeight.Free;
    FPairsByHeightOrdinalWidth.Free;
  except end;
  inherited;
end;

function TExtUtilQueue.JSClassName : string; begin
  Result := 'Ext.util.Queue';
end;

{$IFDEF FPC}constructor TExtUtilQueue.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilQueue.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtUtilQueue');
  Result := Self;
end;

function TExtUtilQueue.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtUtilQueue');
  Result := Self;
end;

function TExtUtilQueue.Remove(Obj : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Obj, false]) + ');', 'TExtUtilQueue');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowNone.JSClassName : string; begin
  Result := 'Ext.layout.container.boxOverflow.None';
end;

{$IFDEF FPC}constructor TExtLayoutContainerBoxOverflowNone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtMenuManagerSingleton.JSClassName : string; begin
  Result := 'Ext.menu.Manager';
end;

{$IFDEF FPC}constructor TExtMenuManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtMenuManagerSingleton.Get(Menu : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Menu, false]) + ');', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtMenuManagerSingleton.Get(Menu : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Menu]) + ');', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtMenuManagerSingleton.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtMenuManagerSingleton');
  Result := Self;
end;

function TExtUtilOffset.JSClassName : string; begin
  Result := 'Ext.util.Offset';
end;

{$IFDEF FPC}constructor TExtUtilOffset.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilProtoElement.JSClassName : string; begin
  Result := 'Ext.util.ProtoElement';
end;

{$IFDEF FPC}constructor TExtUtilProtoElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilProtoElement.AddCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([Cls]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.Flush : TExtFunction; begin
  JSCode(JSName + '.flush();', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.HasCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.hasCls(' + VarToJSON([Cls]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.RemoveCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([Cls]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.SetStyle(Prop : TExtObject; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.SetStyle(' + VarToJSON([Prop, false, Value]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.SetStyle(Prop : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([Prop, Value]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilProtoElement.WriteTo(ToJS : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.writeTo(' + VarToJSON([ToJS, false]) + ');', 'TExtUtilProtoElement');
  Result := Self;
end;

function TExtUtilPositionable.JSClassName : string; begin
  Result := 'Ext.util.Positionable';
end;

{$IFDEF FPC}constructor TExtUtilPositionable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilPositionable.AlignTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, Position, Offsets, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AlignTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AlignTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AlignTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AlignTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AlignTo(' + VarToJSON([Element, false, Position, Offsets, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AlignTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.alignTo(' + VarToJSON([Element, Position, Offsets, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : String; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : THTMLElement; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : Boolean; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Integer; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : TExtUtilPositionable; Position : String; Offsets : TArrayOfInteger; Animate : TExtObject; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, false, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.AnchorTo(' + VarToJSON([Element, false, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.AnchorTo(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil; Animate : Boolean = false; MonitorScroll : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.anchorTo(' + VarToJSON([Element, Position, Offsets, Animate, MonitorScroll, Callback, true]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.CalculateConstrainedPosition(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.CalculateConstrainedPosition(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.CalculateConstrainedPosition(ConstrainTo : TExtElement; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.CalculateConstrainedPosition(' + VarToJSON([ConstrainTo, false, ProposedPosition, Local, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.CalculateConstrainedPosition(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; Local : Boolean = false; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.calculateConstrainedPosition(' + VarToJSON([ConstrainTo, ProposedPosition, Local, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetAlignToXY(Element : THTMLElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetAlignToXY(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetAlignToXY(Element : TExtUtilPositionable; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetAlignToXY(' + VarToJSON([Element, false, Position, Offsets]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetAlignToXY(Element : String; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.getAlignToXY(' + VarToJSON([Element, Position, Offsets]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetAnchorXY(Anchor : String = ''; Local : Boolean = false; Size : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getAnchorXY(' + VarToJSON([Anchor, Local, Size, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetBox(ContentBox : Boolean = false; Local : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getBox(' + VarToJSON([ContentBox, Local]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetConstrainVector(ConstrainTo : THTMLElement; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetConstrainVector(ConstrainTo : TExtUtilRegion; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetConstrainVector(ConstrainTo : TExtUtilPositionable; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.GetConstrainVector(' + VarToJSON([ConstrainTo, false, ProposedPosition, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetConstrainVector(ConstrainTo : String = ''; ProposedPosition : TArrayOfInteger = nil; ProposedSize : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.getConstrainVector(' + VarToJSON([ConstrainTo, ProposedPosition, ProposedSize]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetLocalX : TExtFunction; begin
  JSCode(JSName + '.getLocalX();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetLocalXY : TExtFunction; begin
  JSCode(JSName + '.getLocalXY();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetLocalY : TExtFunction; begin
  JSCode(JSName + '.getLocalY();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetOffsetsTo(OffsetsTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetOffsetsTo(' + VarToJSON([OffsetsTo, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetOffsetsTo(OffsetsTo : TExtUtilPositionable) : TExtFunction; begin
  JSCode(JSName + '.GetOffsetsTo(' + VarToJSON([OffsetsTo, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetOffsetsTo(OffsetsTo : String) : TExtFunction; begin
  JSCode(JSName + '.getOffsetsTo(' + VarToJSON([OffsetsTo]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetRegion : TExtFunction; begin
  JSCode(JSName + '.getRegion();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetViewRegion : TExtFunction; begin
  JSCode(JSName + '.getViewRegion();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetX : TExtFunction; begin
  JSCode(JSName + '.getX();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetXY : TExtFunction; begin
  JSCode(JSName + '.getXY();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.GetY : TExtFunction; begin
  JSCode(JSName + '.getY();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.Move(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Move(' + VarToJSON([Direction, Distance, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.Move(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.move(' + VarToJSON([Direction, Distance, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.RemoveAnchor : TExtFunction; begin
  JSCode(JSName + '.removeAnchor();', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetBox(Box : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetBox(' + VarToJSON([Box, false, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetBox(Box : TExtObject; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setBox(' + VarToJSON([Box, false, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetLocalX(X : Integer) : TExtFunction; begin
  JSCode(JSName + '.setLocalX(' + VarToJSON([X]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetLocalXY(X : TExtObjectList; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.SetLocalXY(' + VarToJSON(X) + ',' + VarToJSON([Y]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetLocalXY(X : Integer; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setLocalXY(' + VarToJSON([X, Y]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetLocalY(Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.setLocalY(' + VarToJSON([Y]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetRegion(Region : TExtUtilRegion; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetRegion(' + VarToJSON([Region, false, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetRegion(Region : TExtUtilRegion; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setRegion(' + VarToJSON([Region, false, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetX(The : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetX(' + VarToJSON([The, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetX(The : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setX(' + VarToJSON([The, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetXY(Pos : TArrayOfInteger; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetXY(' + VarToJSON([Pos, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetXY(Pos : TArrayOfInteger; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setXY(' + VarToJSON([Pos, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetY(The : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetY(' + VarToJSON([The, Animate, false]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.SetY(The : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setY(' + VarToJSON([The, Animate]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.TranslatePoints(X : TExtObjectList; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.TranslatePoints(' + VarToJSON(X) + ',' + VarToJSON([Y]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtUtilPositionable.TranslatePoints(X : Integer; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.translatePoints(' + VarToJSON([X, Y]) + ');', 'TExtUtilPositionable');
  Result := Self;
end;

function TExtGridScroller.JSClassName : string; begin
  Result := 'Ext.grid.Scroller';
end;

{$IFDEF FPC}constructor TExtGridScroller.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtUtilSortable.SetFDefaultSortDirection(Value : String); begin
  FDefaultSortDirection := Value;
  JSCode('defaultSortDirection:' + VarToJSON([Value]));
end;

procedure TExtUtilSortable.SetFIsSortable(Value : Boolean); begin
  FIsSortable := Value;
  JSCode(JSName + '.isSortable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilSortable.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtUtilSortable.SetFSortersList(Value : TExtObjectList); begin
  FSortersList := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtUtilSortable.SetFSortRoot(Value : String); begin
  FSortRoot := Value;
  JSCode('sortRoot:' + VarToJSON([Value]));
end;

function TExtUtilSortable.JSClassName : string; begin
  Result := 'Ext.util.Sortable';
end;

procedure TExtUtilSortable.InitDefaults; begin
  inherited;
  FSorters := TExtObjectList.Create(Self, 'sorters');
  FSortersList := TExtObjectList.Create(Self, 'sorters');
end;

{$IFDEF FPC}constructor TExtUtilSortable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilSortable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilSortable.CreateComparator(Sorters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.createComparator(' + VarToJSON(Sorters) + ');', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.GenerateComparator : TExtFunction; begin
  JSCode(JSName + '.generateComparator();', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.InitSortable : TExtFunction; begin
  JSCode(JSName + '.initSortable();', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.Sort(' + VarToJSON(Sorters) + ',' + VarToJSON([Direction]) + ');', 'TExtUtilSortable');
  Result := Self;
end;

function TExtUtilSortable.Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Sorters, Direction]) + ');', 'TExtUtilSortable');
  Result := Self;
end;

destructor TExtUtilSortable.Destroy; begin
  try
    FSorters.Free;
    FSortersList.Free;
  except end;
  inherited;
end;

procedure TExtUtilTaskRunner.SetFFireIdleEvent(Value : Boolean); begin
  FFireIdleEvent := Value;
  JSCode('fireIdleEvent:' + VarToJSON([Value]));
end;

function TExtUtilTaskRunner.JSClassName : string; begin
  Result := 'Ext.util.TaskRunner';
end;

{$IFDEF FPC}constructor TExtUtilTaskRunner.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilTaskRunner.NewTask(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.newTask(' + VarToJSON([Config, false]) + ');', 'TExtUtilTaskRunner');
  Result := Self;
end;

function TExtUtilTaskRunner.Restart(Interval : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.restart(' + VarToJSON([Interval]) + ');', 'TExtUtilTaskRunner');
  Result := Self;
end;

function TExtUtilTaskRunner.Start(Task : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.start(' + VarToJSON([Task, false]) + ');', 'TExtUtilTaskRunner');
  Result := Self;
end;

function TExtUtilTaskRunner.Stop(Task : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.stop(' + VarToJSON([Task, false]) + ');', 'TExtUtilTaskRunner');
  Result := Self;
end;

function TExtUtilTaskRunner.StopAll : TExtFunction; begin
  JSCode(JSName + '.stopAll();', 'TExtUtilTaskRunner');
  Result := Self;
end;

procedure TExtUtilSorter.SetFDirection(Value : String); begin
  FDirection := Value;
  if not ConfigAvailable(JSName) then
    SetDirection(Value)
  else
    JSCode('direction:' + VarToJSON([Value]));
end;

procedure TExtUtilSorter.SetFPropertyJS(Value : String); begin
  FPropertyJS := Value;
  JSCode('propertyJS:' + VarToJSON([Value]));
end;

procedure TExtUtilSorter.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtUtilSorter.SetFSorterFn(Value : TExtFunction); begin
  FSorterFn := Value;
  JSCode('sorterFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilSorter.SetFTransform(Value : TExtFunction); begin
  FTransform := Value;
  JSCode('transform:' + VarToJSON([Value, true]));
end;

function TExtUtilSorter.JSClassName : string; begin
  Result := 'Ext.util.Sorter';
end;

{$IFDEF FPC}constructor TExtUtilSorter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilSorter.SetDirection(Direction : String) : TExtFunction; begin
  JSCode(JSName + '.setDirection(' + VarToJSON([Direction]) + ');', 'TExtUtilSorter');
  Result := Self;
end;

function TExtUtilSorter.Toggle : TExtFunction; begin
  JSCode(JSName + '.toggle();', 'TExtUtilSorter');
  Result := Self;
end;

function TExtUtilSorter.UpdateSortFunction(Fn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.updateSortFunction(' + VarToJSON([Fn, true]) + ');', 'TExtUtilSorter');
  Result := Self;
end;

function TExtUtilRenderable.JSClassName : string; begin
  Result := 'Ext.util.Renderable';
end;

{$IFDEF FPC}constructor TExtUtilRenderable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilRenderable.DoAutoRender : TExtFunction; begin
  JSCode(JSName + '.doAutoRender();', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.EnsureAttachedToBody(RunLayout : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ensureAttachedToBody(' + VarToJSON([RunLayout]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.GetInsertPosition(Position : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position, false]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.GetInsertPosition(Position : TExtDomElement) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position, false]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.GetInsertPosition(Position : String) : TExtFunction; begin
  JSCode(JSName + '.GetInsertPosition(' + VarToJSON([Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.GetInsertPosition(Position : Integer) : TExtFunction; begin
  JSCode(JSName + '.getInsertPosition(' + VarToJSON([Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : String; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : THTMLElement; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : THTMLElement; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : TExtElement; Position : String) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : TExtElement; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.Render(' + VarToJSON([Container, false, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRenderable.Render(Container : String = ''; Position : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.render(' + VarToJSON([Container, Position]) + ');', 'TExtUtilRenderable');
  Result := Self;
end;

function TExtUtilRegion.JSClassName : string; begin
  Result := 'Ext.util.Region';
end;

{$IFDEF FPC}constructor TExtUtilRegion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilRegion.Adjust(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer) : TExtFunction; begin
  JSCode(JSName + '.adjust(' + VarToJSON([Top, Right, Bottom, Left]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.ConstrainTo(TargetRegion : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.constrainTo(' + VarToJSON([TargetRegion, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Contains(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Copy : TExtFunction; begin
  JSCode(JSName + '.copy();', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.CopyFrom(P : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.copyFrom(' + VarToJSON([P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

constructor TExtUtilRegion.Create(Top : Integer; Right : Integer; Bottom : Integer; Left : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([Top, Right, Bottom, Left]) + ');');
  InitDefaults;
end;

function TExtUtilRegion.Equals(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.equals(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.From(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.from(' + VarToJSON([O, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffset(Axis : String = ''; P : TExtUtilPoint = nil) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffset(' + VarToJSON([Axis, P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffsetX(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffsetX(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetOutOfBoundOffsetY(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.getOutOfBoundOffsetY(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetRegion(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetRegion(' + VarToJSON([El, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetRegion(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.GetRegion(' + VarToJSON([El, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.GetRegion(El : String) : TExtFunction; begin
  JSCode(JSName + '.getRegion(' + VarToJSON([El]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Intersect(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.intersect(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBound(Axis : String; P : TExtUtilPoint) : TExtFunction; begin
  JSCode(JSName + '.IsOutOfBound(' + VarToJSON([Axis, P, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBound(Axis : String = ''; P : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBound(' + VarToJSON([Axis, P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBoundX(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBoundX(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.IsOutOfBoundY(P : Integer) : TExtFunction; begin
  JSCode(JSName + '.isOutOfBoundY(' + VarToJSON([P]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Round : TExtFunction; begin
  JSCode(JSName + '.round();', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.TranslateBy(X : TExtUtilOffset; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.TranslateBy(' + VarToJSON([X, false, Y]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.TranslateBy(X : TExtObject; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.translateBy(' + VarToJSON([X, false, Y]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

function TExtUtilRegion.Union(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.union(' + VarToJSON([Region, false]) + ');', 'TExtUtilRegion');
  Result := Self;
end;

procedure TExtLayout.SetFDone(Value : Boolean); begin
  FDone := Value;
  JSCode(JSName + '.done=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayout.SetFIsLayout(Value : Boolean); begin
  FIsLayout := Value;
  JSCode(JSName + '.isLayout=' + VarToJSON([Value]) + ';');
end;

function TExtLayout.JSClassName : string; begin
  Result := 'Ext.layout.Layout';
end;

{$IFDEF FPC}constructor TExtLayout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayout.OnContentChange(Child : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.onContentChange(' + VarToJSON([Child, false]) + ');', 'TExtLayout');
  Result := Self;
end;

function TExtLayoutClassList.JSClassName : string; begin
  Result := 'Ext.layout.ClassList';
end;

{$IFDEF FPC}constructor TExtLayoutClassList.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutClassList.Add : TExtFunction; begin
  JSCode(JSName + '.add();', 'TExtLayoutClassList');
  Result := Self;
end;

function TExtLayoutClassList.AddMany : TExtFunction; begin
  JSCode(JSName + '.addMany();', 'TExtLayoutClassList');
  Result := Self;
end;

function TExtLayoutClassList.Remove : TExtFunction; begin
  JSCode(JSName + '.remove();', 'TExtLayoutClassList');
  Result := Self;
end;

function TExtLayoutClassList.RemoveMany : TExtFunction; begin
  JSCode(JSName + '.removeMany();', 'TExtLayoutClassList');
  Result := Self;
end;

function TExtDomElement_anim.JSClassName : string; begin
  Result := 'Ext.dom.Element_anim';
end;

{$IFDEF FPC}constructor TExtDomElement_anim.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_anim.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.FadeIn(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.fadeIn(' + VarToJSON([Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.FadeOut(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.fadeOut(' + VarToJSON([Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.Frame(Color : String = ''; Count : Integer = 0; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.frame(' + VarToJSON([Color, Count, Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.Ghost(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.ghost(' + VarToJSON([Anchor, Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.Highlight(Color : String = ''; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.highlight(' + VarToJSON([Color, Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.Puff(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.puff(' + VarToJSON([Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.SlideIn(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.slideIn(' + VarToJSON([Anchor, Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.SlideOut(Anchor : String = ''; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.slideOut(' + VarToJSON([Anchor, Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_anim.SwitchOff(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.switchOff(' + VarToJSON([Options, false]) + ');', 'TExtDomElement_anim');
  Result := Self;
end;

function TExtDomElement_dd.JSClassName : string; begin
  Result := 'Ext.dom.Element_dd';
end;

{$IFDEF FPC}constructor TExtDomElement_dd.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_dd.InitDD(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.initDD(' + VarToJSON([Group, Config, false, Overrides, false]) + ');', 'TExtDomElement_dd');
  Result := Self;
end;

function TExtDomElement_dd.InitDDProxy(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.initDDProxy(' + VarToJSON([Group, Config, false, Overrides, false]) + ');', 'TExtDomElement_dd');
  Result := Self;
end;

function TExtDomElement_dd.InitDDTarget(Group : String; Config : TExtObject; Overrides : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.initDDTarget(' + VarToJSON([Group, Config, false, Overrides, false]) + ');', 'TExtDomElement_dd');
  Result := Self;
end;

function TExtDomAbstractQuery.JSClassName : string; begin
  Result := 'Ext.dom.AbstractQuery';
end;

{$IFDEF FPC}constructor TExtDomAbstractQuery.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractQuery.IsJS(El : THTMLElement; Selector : String) : TExtFunction; begin
  JSCode(JSName + '.IsJS(' + VarToJSON([El, false, Selector]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.IsJS(El : TExtObjectList; Selector : String) : TExtFunction; begin
  JSCode(JSName + '.IsJS(' + VarToJSON(El) + ',' + VarToJSON([Selector]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.IsJS(El : String; Selector : String) : TExtFunction; begin
  JSCode(JSName + '.is(' + VarToJSON([El, Selector]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.Select(Selector : String; Root : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Select(' + VarToJSON([Selector, Root, false]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.Select(Selector : String; Root : String = '') : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Selector, Root]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.SelectNode(Selector : String; Root : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.SelectNode(' + VarToJSON([Selector, Root, false]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

function TExtDomAbstractQuery.SelectNode(Selector : String; Root : String = '') : TExtFunction; begin
  JSCode(JSName + '.selectNode(' + VarToJSON([Selector, Root]) + ');', 'TExtDomAbstractQuery');
  Result := Self;
end;

procedure TExtDomCompositeElementLite.SetFElements(Value : TExtObjectList); begin
  FElements := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.elements=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDomCompositeElementLite.SetFIsComposite(Value : Boolean); begin
  FIsComposite := Value;
  JSCode(JSName + '.isComposite=' + VarToJSON([Value]) + ';');
end;

function TExtDomCompositeElementLite.JSClassName : string; begin
  Result := 'Ext.dom.CompositeElementLite';
end;

procedure TExtDomCompositeElementLite.InitDefaults; begin
  inherited;
  FElements := TExtObjectList.Create(Self, 'elements');
end;

{$IFDEF FPC}constructor TExtDomCompositeElementLite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomCompositeElementLite.Add(Els : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON(Els) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Add(Els : TExtDomCompositeElement) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Els, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Clear(RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : String) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Contains(El : Integer) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

constructor TExtDomCompositeElementLite.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDomCompositeElementLite.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Fill(Els : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Fill(' + VarToJSON(Els) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Fill(Els : TExtDomCompositeElement) : TExtFunction; begin
  JSCode(JSName + '.fill(' + VarToJSON([Els, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Filter(Selector : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON([Selector, true]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Filter(Selector : String) : TExtFunction; begin
  JSCode(JSName + '.filter(' + VarToJSON([Selector]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.First : TExtFunction; begin
  JSCode(JSName + '.first();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El, false]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : String) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.IndexOf(El : Integer) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([El]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Item(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.item(' + VarToJSON([Index]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Last : TExtFunction; begin
  JSCode(JSName + '.last();', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : THTMLElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : TExtElement; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, false, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : String; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.RemoveElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.RemoveElement(El : Integer; RemoveDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeElement(' + VarToJSON([El, RemoveDom]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : Integer; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : THTMLElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : THTMLElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : TExtElement; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : TExtElement; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, false, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : String; Replacement : TExtElement; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, false, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : String; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ReplaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.ReplaceElement(El : Integer; Replacement : String; DomReplace : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.replaceElement(' + VarToJSON([El, Replacement, DomReplace]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

function TExtDomCompositeElementLite.Slice(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.slice(' + VarToJSON([Start, EndJS]) + ');', 'TExtDomCompositeElementLite');
  Result := Self;
end;

destructor TExtDomCompositeElementLite.Destroy; begin
  try
    FElements.Free;
  except end;
  inherited;
end;

function TExtDomElement_scroll.JSClassName : string; begin
  Result := 'Ext.dom.Element_scroll';
end;

{$IFDEF FPC}constructor TExtDomElement_scroll.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_scroll.GetScroll : TExtFunction; begin
  JSCode(JSName + '.getScroll();', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.GetScrollLeft : TExtFunction; begin
  JSCode(JSName + '.getScrollLeft();', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.GetScrollTop : TExtFunction; begin
  JSCode(JSName + '.getScrollTop();', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.IsScrollable : TExtFunction; begin
  JSCode(JSName + '.isScrollable();', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.Scroll(Direction : String; Distance : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Scroll(' + VarToJSON([Direction, Distance, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.Scroll(Direction : String; Distance : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.scroll(' + VarToJSON([Direction, Distance, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.scrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollIntoView(Hscroll : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollIntoView(' + VarToJSON([Hscroll, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollIntoView(Hscroll : Boolean = false; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.scrollIntoView(' + VarToJSON([Hscroll, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollTo(Side : String; Value : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollTo(' + VarToJSON([Side, Value, Animate, false]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.ScrollTo(Side : String; Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.scrollTo(' + VarToJSON([Side, Value, Animate]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.SetScrollLeft(Left : Integer) : TExtFunction; begin
  JSCode(JSName + '.setScrollLeft(' + VarToJSON([Left]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_scroll.SetScrollTop(Top : Integer) : TExtFunction; begin
  JSCode(JSName + '.setScrollTop(' + VarToJSON([Top]) + ');', 'TExtDomElement_scroll');
  Result := Self;
end;

function TExtDomElement_style.JSClassName : string; begin
  Result := 'Ext.dom.Element_style';
end;

{$IFDEF FPC}constructor TExtDomElement_style.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_style.AddClsOnClick(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addClsOnClick(' + VarToJSON([ClassName, TestFn, true, Scope, false]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.AddClsOnFocus(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addClsOnFocus(' + VarToJSON([ClassName, TestFn, true, Scope, false]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.AddClsOnOver(ClassName : String; TestFn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addClsOnOver(' + VarToJSON([ClassName, TestFn, true, Scope, false]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.BoxWrap(ClassJS : String = '') : TExtFunction; begin
  JSCode(JSName + '.boxWrap(' + VarToJSON([ClassJS]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.ClearOpacity : TExtFunction; begin
  JSCode(JSName + '.clearOpacity();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.Clip : TExtFunction; begin
  JSCode(JSName + '.clip();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.GetColor(Attr : String; DefaultValue : String; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.getColor(' + VarToJSON([Attr, DefaultValue, Prefix]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.GetComputedHeight : TExtFunction; begin
  JSCode(JSName + '.getComputedHeight();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.GetComputedWidth : TExtFunction; begin
  JSCode(JSName + '.getComputedWidth();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.GetFrameWidth(Sides : String) : TExtFunction; begin
  JSCode(JSName + '.getFrameWidth(' + VarToJSON([Sides]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.GetStyleSize : TExtFunction; begin
  JSCode(JSName + '.getStyleSize();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.Selectable : TExtFunction; begin
  JSCode(JSName + '.selectable();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.SetOpacity(Opacity : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetOpacity(' + VarToJSON([Opacity, Animate, false]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.SetOpacity(Opacity : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setOpacity(' + VarToJSON([Opacity, Animate]) + ');', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.Unclip : TExtFunction; begin
  JSCode(JSName + '.unclip();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_style.Unselectable : TExtFunction; begin
  JSCode(JSName + '.unselectable();', 'TExtDomElement_style');
  Result := Self;
end;

function TExtDomElement_fx.JSClassName : string; begin
  Result := 'Ext.dom.Element_fx';
end;

{$IFDEF FPC}constructor TExtDomElement_fx.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_fx.Hide(Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([Animate, false]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.Hide(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Animate]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.SetDisplayed(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetDisplayed(' + VarToJSON([Value]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.SetDisplayed(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisplayed(' + VarToJSON([Value]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.Show(Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([Animate, false]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.Show(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Animate]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.Toggle(Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Toggle(' + VarToJSON([Animate, false]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_fx.Toggle(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([Animate]) + ');', 'TExtDomElement_fx');
  Result := Self;
end;

function TExtDomElement_position.JSClassName : string; begin
  Result := 'Ext.dom.Element_position';
end;

{$IFDEF FPC}constructor TExtDomElement_position.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement_position.Center(CenterIn : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Center(' + VarToJSON([CenterIn, false]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.Center(CenterIn : TExtDomElement) : TExtFunction; begin
  JSCode(JSName + '.Center(' + VarToJSON([CenterIn, false]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.Center(CenterIn : String) : TExtFunction; begin
  JSCode(JSName + '.center(' + VarToJSON([CenterIn]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.ClearPositioning(Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.clearPositioning(' + VarToJSON([Value]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetLocalX : TExtFunction; begin
  JSCode(JSName + '.getLocalX();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetLocalXY : TExtFunction; begin
  JSCode(JSName + '.getLocalXY();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetLocalY : TExtFunction; begin
  JSCode(JSName + '.getLocalY();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetPositioning(AutoPx : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getPositioning(' + VarToJSON([AutoPx]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetX : TExtFunction; begin
  JSCode(JSName + '.getX();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetXY : TExtFunction; begin
  JSCode(JSName + '.getXY();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.GetY : TExtFunction; begin
  JSCode(JSName + '.getY();', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.Position(Pos : String = ''; ZIndex : Integer = 0; X : Integer = 0; Y : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.position(' + VarToJSON([Pos, ZIndex, X, Y]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

function TExtDomElement_position.SetPositioning(PosCfg : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setPositioning(' + VarToJSON([PosCfg, false]) + ');', 'TExtDomElement_position');
  Result := Self;
end;

procedure TExtDomAbstractElement.SetFDefaultUnit(Value : String); begin
  FDefaultUnit := Value;
  JSCode(JSName + '.defaultUnit=' + VarToJSON([Value]) + ';');
end;

procedure TExtDomAbstractElement.SetFDom(Value : THTMLElement); begin
  FDom := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dom=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDomAbstractElement.SetFId(Value : String); begin
  FId := Value;
  JSCode(JSName + '.id=' + VarToJSON([Value]) + ';');
end;

procedure TExtDomAbstractElement.SetFIsFly(Value : Boolean); begin
  FIsFly := Value;
  JSCode(JSName + '.isFly=' + VarToJSON([Value]) + ';');
end;

function TExtDomAbstractElement.JSClassName : string; begin
  Result := 'Ext.dom.AbstractElement';
end;

{$IFDEF FPC}constructor TExtDomAbstractElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractElement.Contains(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Contains(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Contains(El : String) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Fly(Dom : THTMLElement; Named : String = '') : TExtFunction; begin
  JSCode(JSName + '.Fly(' + VarToJSON([Dom, false, Named]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Fly(Dom : String; Named : String = '') : TExtFunction; begin
  JSCode(JSName + '.fly(' + VarToJSON([Dom, Named]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Get(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Get(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Get(El : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.GetAttribute(Name : String; Namespace : String = '') : TExtFunction; begin
  JSCode(JSName + '.getAttribute(' + VarToJSON([Name, Namespace]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.GetHTML : TExtFunction; begin
  JSCode(JSName + '.getHTML();', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.GetValue(AsNumber : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getValue(' + VarToJSON([AsNumber]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Hide(Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([Animate, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Hide(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Animate]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.IsJS(Selector : String) : TExtFunction; begin
  JSCode(JSName + '.is(' + VarToJSON([Selector]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.MergeClsList(ClsList1 : String; ClsList2 : String) : TExtFunction; begin
  JSCode(JSName + '.mergeClsList(' + VarToJSON([ClsList1, ClsList2]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Remove : TExtFunction; begin
  JSCode(JSName + '.remove();', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.RemoveCls(ExistingClsList : String; RemoveClsList : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([ExistingClsList, RemoveClsList]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.SetHTML(Html : String) : TExtFunction; begin
  JSCode(JSName + '.setHTML(' + VarToJSON([Html]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.SetJS(O : TExtObject; UseSet : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([O, false, UseSet]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.SetVisibilityMode : TExtFunction; begin
  JSCode(JSName + '.setVisibilityMode();', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.SetVisible(Visible : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetVisible(' + VarToJSON([Visible, Animate, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.SetVisible(Visible : Boolean; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setVisible(' + VarToJSON([Visible, Animate]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Show(Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([Animate, false]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Show(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Animate]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement.Update(Html : String) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Html]) + ');', 'TExtDomAbstractElement');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.JSClassName : string; begin
  Result := 'Ext.dom.AbstractElement_insertion';
end;

{$IFDEF FPC}constructor TExtDomAbstractElement_insertion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractElement_insertion.AppendChild(El : THTMLElement; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AppendChild(' + VarToJSON([El, false, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendChild(El : TExtObject; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AppendChild(' + VarToJSON([El, false, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendChild(El : TExtDomAbstractElement; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.AppendChild(' + VarToJSON([El, false, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendChild(El : String; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.appendChild(' + VarToJSON([El, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendTo(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.AppendTo(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendTo(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.AppendTo(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.AppendTo(El : String) : TExtFunction; begin
  JSCode(JSName + '.appendTo(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.CreateChild(Config : TExtObject; InsertBefore : THTMLElement = nil; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.createChild(' + VarToJSON([Config, false, InsertBefore, false, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertAfter(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertAfter(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertAfter(El : String) : TExtFunction; begin
  JSCode(JSName + '.insertAfter(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertBefore(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertBefore(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertBefore(El : String) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertFirst(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertFirst(El : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertFirst(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertFirst(El : String) : TExtFunction; begin
  JSCode(JSName + '.insertFirst(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertHtml(Where : String; Html : String; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertHtml(' + VarToJSON([Where, Html, ReturnEl]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertSibling(El : THTMLElement; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertSibling(' + VarToJSON([El, false, Where, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertSibling(El : TExtObjectList; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertSibling(' + VarToJSON(El) + ',' + VarToJSON([Where, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertSibling(El : TExtObject; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertSibling(' + VarToJSON([El, false, Where, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertSibling(El : TExtDomAbstractElement; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertSibling(' + VarToJSON([El, false, Where, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.InsertSibling(El : String; Where : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertSibling(' + VarToJSON([El, Where, ReturnDom]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.Replace(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Replace(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.Replace(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.Replace(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.Replace(El : String) : TExtFunction; begin
  JSCode(JSName + '.replace(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.ReplaceWith(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.ReplaceWith(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.ReplaceWith(El : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ReplaceWith(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.ReplaceWith(El : TExtDomAbstractElement) : TExtFunction; begin
  JSCode(JSName + '.ReplaceWith(' + VarToJSON([El, false]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.ReplaceWith(El : String) : TExtFunction; begin
  JSCode(JSName + '.replaceWith(' + VarToJSON([El]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDomAbstractElement_insertion.Wrap(Config : TExtObject = nil; ReturnDom : Boolean = false; Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.wrap(' + VarToJSON([Config, false, ReturnDom, Selector]) + ');', 'TExtDomAbstractElement_insertion');
  Result := Self;
end;

function TExtDirectRemotingMethod.JSClassName : string; begin
  Result := 'Ext.direct.RemotingMethod';
end;

{$IFDEF FPC}constructor TExtDirectRemotingMethod.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectRemotingMethod.GetCallData(Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.getCallData(' + VarToJSON(Args) + ');', 'TExtDirectRemotingMethod');
  Result := Self;
end;

procedure TExtDirectTransaction.SetFProvider(Value : TExtDirectProvider); begin
  FProvider := Value;
  Value.DeleteFromGarbage;
  JSCode('provider:' + VarToJSON([Value, false]));
end;

function TExtDirectTransaction.JSClassName : string; begin
  Result := 'Ext.direct.Transaction';
end;

procedure TExtDirectTransaction.InitDefaults; begin
  inherited;
  FProvider := TExtDirectProvider.CreateInternal(Self, 'provider');
end;

{$IFDEF FPC}constructor TExtDirectTransaction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectTransaction.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtDirectTransaction.Destroy; begin
  try
    FProvider.Free;
  except end;
  inherited;
end;

function TExtDomAbstractElement_traversal.JSClassName : string; begin
  Result := 'Ext.dom.AbstractElement_traversal';
end;

{$IFDEF FPC}constructor TExtDomAbstractElement_traversal.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractElement_traversal.Child(Selector : String; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.child(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Down(Selector : String; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.down(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParent(Selector : String; Limit : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParent(' + VarToJSON([Selector, Limit, false, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParent(Selector : String; Limit : TExtElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParent(' + VarToJSON([Selector, Limit, false, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParent(Selector : String; Limit : String; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParent(' + VarToJSON([Selector, Limit, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParent(Selector : String; Limit : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findParent(' + VarToJSON([Selector, Limit, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParentNode(Selector : String; Limit : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParentNode(' + VarToJSON([Selector, Limit, false, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParentNode(Selector : String; Limit : TExtElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParentNode(' + VarToJSON([Selector, Limit, false, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParentNode(Selector : String; Limit : String; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindParentNode(' + VarToJSON([Selector, Limit, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.FindParentNode(Selector : String; Limit : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findParentNode(' + VarToJSON([Selector, Limit, ReturnEl]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.First(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.first(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Last(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.last(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Next(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.next(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Parent(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.parent(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Prev(Selector : String = ''; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.prev(' + VarToJSON([Selector, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Query(Selector : String) : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([Selector]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Select(Selector : String; Unique : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Selector, Unique]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Up(Selector : String; Limit : THTMLElement; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Up(' + VarToJSON([Selector, Limit, false, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Up(Selector : String; Limit : TExtElement; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Up(' + VarToJSON([Selector, Limit, false, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Up(Selector : String; Limit : String; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Up(' + VarToJSON([Selector, Limit, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractElement_traversal.Up(Selector : String; Limit : Integer = 0; ReturnDom : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.up(' + VarToJSON([Selector, Limit, ReturnDom]) + ');', 'TExtDomAbstractElement_traversal');
  Result := Self;
end;

function TExtDomAbstractHelper.JSClassName : string; begin
  Result := 'Ext.dom.AbstractHelper';
end;

{$IFDEF FPC}constructor TExtDomAbstractHelper.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractHelper.Append(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Append(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Append(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Append(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Append(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Append(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.append(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : String; Styles : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([El, Styles, false]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : String; Styles : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([El, Styles, true]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : THTMLElement; Styles : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([El, false, Styles, false]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : THTMLElement; Styles : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([El, false, Styles, true]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : THTMLElement; Styles : String) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([El, false, Styles]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.ApplyStyles(El : String; Styles : String) : TExtFunction; begin
  JSCode(JSName + '.applyStyles(' + VarToJSON([El, Styles]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.GenerateStyles(Styles : TExtObject; Buffer : TArrayOfString = nil) : TExtFunction; begin
  JSCode(JSName + '.generateStyles(' + VarToJSON([Styles, false, Buffer]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertAfter(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertAfter(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertAfter(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertAfter(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertBefore(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertFirst(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertFirst(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertHtml(Where : String; El : TTextNode; Html : String) : TExtFunction; begin
  JSCode(JSName + '.InsertHtml(' + VarToJSON([Where, El, false, Html]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.InsertHtml(Where : String; El : THTMLElement; Html : String) : TExtFunction; begin
  JSCode(JSName + '.insertHtml(' + VarToJSON([Where, El, false, Html]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Markup(Spec : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.markup(' + VarToJSON([Spec, false]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractHelper.Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.overwrite(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomAbstractHelper');
  Result := Self;
end;

function TExtDomAbstractElement_static.JSClassName : string; begin
  Result := 'Ext.dom.AbstractElement_static';
end;

{$IFDEF FPC}constructor TExtDomAbstractElement_static.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractElement_static.FromPoint(X : Integer; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.fromPoint(' + VarToJSON([X, Y]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetActiveElement : TExtFunction; begin
  JSCode(JSName + '.getActiveElement();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetDocumentHeight : TExtFunction; begin
  JSCode(JSName + '.getDocumentHeight();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetDocumentWidth : TExtFunction; begin
  JSCode(JSName + '.getDocumentWidth();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetOrientation : TExtFunction; begin
  JSCode(JSName + '.getOrientation();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetViewportHeight : TExtFunction; begin
  JSCode(JSName + '.getViewportHeight();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetViewportWidth : TExtFunction; begin
  JSCode(JSName + '.getViewportWidth();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.GetViewSize : TExtFunction; begin
  JSCode(JSName + '.getViewSize();', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.Normalize(Prop : String) : TExtFunction; begin
  JSCode(JSName + '.normalize(' + VarToJSON([Prop]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.ParseBox(Box : String) : TExtFunction; begin
  JSCode(JSName + '.ParseBox(' + VarToJSON([Box]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.ParseBox(Box : Integer) : TExtFunction; begin
  JSCode(JSName + '.parseBox(' + VarToJSON([Box]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.ParseStyles(Styles : String) : TExtFunction; begin
  JSCode(JSName + '.parseStyles(' + VarToJSON([Styles]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.SerializeForm(Form : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.serializeForm(' + VarToJSON([Form, false]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.UnitizeBox(Box : TExtObject; Units : String) : TExtFunction; begin
  JSCode(JSName + '.UnitizeBox(' + VarToJSON([Box, false, Units]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.UnitizeBox(Box : String; Units : String) : TExtFunction; begin
  JSCode(JSName + '.UnitizeBox(' + VarToJSON([Box, Units]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_static.UnitizeBox(Box : Integer; Units : String) : TExtFunction; begin
  JSCode(JSName + '.unitizeBox(' + VarToJSON([Box, Units]) + ');', 'TExtDomAbstractElement_static');
  Result := Self;
end;

function TExtDomAbstractElement_style.JSClassName : string; begin
  Result := 'Ext.dom.AbstractElement_style';
end;

{$IFDEF FPC}constructor TExtDomAbstractElement_style.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomAbstractElement_style.ApplyStyles(Styles : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([Styles, false]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.ApplyStyles(Styles : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.ApplyStyles(' + VarToJSON([Styles, true]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.ApplyStyles(Styles : String) : TExtFunction; begin
  JSCode(JSName + '.applyStyles(' + VarToJSON([Styles]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetBorderWidth(Side : String) : TExtFunction; begin
  JSCode(JSName + '.getBorderWidth(' + VarToJSON([Side]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetHeight(ContentHeight : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getHeight(' + VarToJSON([ContentHeight]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetMargin(Sides : String = '') : TExtFunction; begin
  JSCode(JSName + '.getMargin(' + VarToJSON([Sides]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetPadding(Side : String) : TExtFunction; begin
  JSCode(JSName + '.getPadding(' + VarToJSON([Side]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetSize(ContentSize : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getSize(' + VarToJSON([ContentSize]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetStyle(PropertyJS : TArrayOfString; InlineJS : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetStyle(' + VarToJSON([PropertyJS, InlineJS]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetStyle(PropertyJS : String; InlineJS : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getStyle(' + VarToJSON([PropertyJS, InlineJS]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetViewSize : TExtFunction; begin
  JSCode(JSName + '.getViewSize();', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.GetWidth(ContentWidth : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getWidth(' + VarToJSON([ContentWidth]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.IsStyle(Style : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.isStyle(' + VarToJSON([Style, Value]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.IsTransparent(Prop : String) : TExtFunction; begin
  JSCode(JSName + '.isTransparent(' + VarToJSON([Prop]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.Mask(Msg : String = ''; MsgCls : String = '') : TExtFunction; begin
  JSCode(JSName + '.mask(' + VarToJSON([Msg, MsgCls]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.RadioCls(ClassName : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.RadioCls(' + VarToJSON([ClassName]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.RadioCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.radioCls(' + VarToJSON([ClassName]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.Repaint : TExtFunction; begin
  JSCode(JSName + '.repaint();', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetHeight(Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetHeight(' + VarToJSON([Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetHeight(Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.setHeight(' + VarToJSON([Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetSize(Width : Integer; Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetSize(Width : String; Height : String) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetSize(Width : String; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetSize(' + VarToJSON([Width, Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetSize(Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.setSize(' + VarToJSON([Width, Height]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.SetStyle(' + VarToJSON([PropertyJS, false, Value]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([PropertyJS, Value]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetWidth(Width : String) : TExtFunction; begin
  JSCode(JSName + '.SetWidth(' + VarToJSON([Width]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.SetWidth(Width : Integer) : TExtFunction; begin
  JSCode(JSName + '.setWidth(' + VarToJSON([Width]) + ');', 'TExtDomAbstractElement_style');
  Result := Self;
end;

function TExtDomAbstractElement_style.Unmask : TExtFunction; begin
  JSCode(JSName + '.unmask();', 'TExtDomAbstractElement_style');
  Result := Self;
end;

procedure TExtDomHelperSingleton.SetFUseDom(Value : Boolean); begin
  FUseDom := Value;
  JSCode(JSName + '.useDom=' + VarToJSON([Value]) + ';');
end;

function TExtDomHelperSingleton.JSClassName : string; begin
  Result := 'Ext.dom.Helper';
end;

{$IFDEF FPC}constructor TExtDomHelperSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomHelperSingleton.CreateDom(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.CreateDom(' + VarToJSON([O, false]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateDom(O : String) : TExtFunction; begin
  JSCode(JSName + '.createDom(' + VarToJSON([O]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateHtml : TExtFunction; begin
  JSCode(JSName + '.createHtml();', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.CreateTemplate(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.createTemplate(' + VarToJSON([O, false]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : String; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : THTMLElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : THTMLElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : TExtElement; O : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, false, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : TExtElement; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

function TExtDomHelperSingleton.Overwrite(El : String; O : String; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.overwrite(' + VarToJSON([El, O, ReturnElement]) + ');', 'TExtDomHelperSingleton');
  Result := Self;
end;

procedure TExtFocusManagerSingleton.SetFEnabled(Value : Boolean); begin
  FEnabled := Value;
  JSCode(JSName + '.enabled=' + VarToJSON([Value]) + ';');
end;

procedure TExtFocusManagerSingleton.SetFFocusedCmp(Value : TExtComponent); begin
  FFocusedCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.focusedCmp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFocusManagerSingleton.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFocusManagerSingleton.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFocusManagerSingleton.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFocusManagerSingleton.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtFocusManagerSingleton.SetFWhitelist(Value : TArrayOfString); begin
  FWhitelist := Value;
  JSCode(JSName + '.whitelist=' + ArrayToJSON(Value) + ';');
end;

procedure TExtFocusManagerSingleton.SetFOnBeforecomponentfocus(Value : TExtFocusManagerSingletonOnBeforecomponentfocus); begin
  if Assigned(FOnBeforecomponentfocus) then
    JSCode(JSName+'.events ["beforecomponentfocus"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecomponentfocus', Ajax('beforecomponentfocus', ['Fm', '%0.nm','Cmp', '%1.nm','PreviousCmp', '%2.nm'], true));
  FOnBeforecomponentfocus := Value;
end;

procedure TExtFocusManagerSingleton.SetFOnComponentfocus(Value : TExtFocusManagerSingletonOnComponentfocus); begin
  if Assigned(FOnComponentfocus) then
    JSCode(JSName+'.events ["componentfocus"].listeners=[];');
  if Assigned(Value) then
    AddListener('componentfocus', Ajax('componentfocus', ['Fm', '%0.nm','Cmp', '%1.nm','PreviousCmp', '%2.nm'], true));
  FOnComponentfocus := Value;
end;

procedure TExtFocusManagerSingleton.SetFOnDisable(Value : TExtFocusManagerSingletonOnDisable); begin
  if Assigned(FOnDisable) then
    JSCode(JSName+'.events ["disable"].listeners=[];');
  if Assigned(Value) then
    AddListener('disable', Ajax('disable', ['Fm', '%0.nm'], true));
  FOnDisable := Value;
end;

procedure TExtFocusManagerSingleton.SetFOnEnable(Value : TExtFocusManagerSingletonOnEnable); begin
  if Assigned(FOnEnable) then
    JSCode(JSName+'.events ["enable"].listeners=[];');
  if Assigned(Value) then
    AddListener('enable', Ajax('enable', ['Fm', '%0.nm'], true));
  FOnEnable := Value;
end;

function TExtFocusManagerSingleton.JSClassName : string; begin
  Result := 'Ext.FocusManager';
end;

procedure TExtFocusManagerSingleton.InitDefaults; begin
  inherited;
  FFocusedCmp := TExtComponent.CreateInternal(Self, 'focusedCmp');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtFocusManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFocusManagerSingleton.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddXTypeToWhitelist(Xtype : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.AddXTypeToWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.AddXTypeToWhitelist(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.addXTypeToWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.Enable(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Enable(' + VarToJSON([Options, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.Enable(Options : Boolean) : TExtFunction; begin
  JSCode(JSName + '.enable(' + VarToJSON([Options]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveXTypeFromWhitelist(Xtype : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.RemoveXTypeFromWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.RemoveXTypeFromWhitelist(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.removeXTypeFromWhitelist(' + VarToJSON([Xtype]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

function TExtFocusManagerSingleton.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtFocusManagerSingleton');
  Result := Self;
end;

destructor TExtFocusManagerSingleton.Destroy; begin
  try
    FFocusedCmp.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtFocusManagerSingleton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecomponentfocus') and Assigned(FOnBeforecomponentfocus) then
    FOnBeforecomponentfocus(TExtFocusManager(ParamAsObject('Fm')), TExtComponent(ParamAsObject('Cmp')), TExtComponent(ParamAsObject('PreviousCmp')))
  else if (AEvtName = 'componentfocus') and Assigned(FOnComponentfocus) then
    FOnComponentfocus(TExtFocusManager(ParamAsObject('Fm')), TExtComponent(ParamAsObject('Cmp')), TExtComponent(ParamAsObject('PreviousCmp')))
  else if (AEvtName = 'disable') and Assigned(FOnDisable) then
    FOnDisable(TExtFocusManager(ParamAsObject('Fm')))
  else if (AEvtName = 'enable') and Assigned(FOnEnable) then
    FOnEnable(TExtFocusManager(ParamAsObject('Fm')));
end;

function TExtFoo.JSClassName : string; begin
  Result := 'Ext.Foo';
end;

{$IFDEF FPC}constructor TExtFoo.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFoo.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

constructor TExtFoo.Create(Config : String); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config]) + ');');
  InitDefaults;
end;

function TExtFoo.Handle(Err : TExtError) : TExtFunction; begin
  JSCode(JSName + '.handle(' + VarToJSON([Err, false]) + ');', 'TExtFoo');
  Result := Self;
end;

function TExtFoo.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtFoo');
  Result := Self;
end;

procedure TExtElementLoader.SetFAjaxOptions(Value : TExtObject); begin
  FAjaxOptions := Value;
  Value.DeleteFromGarbage;
  JSCode('ajaxOptions:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFAutoLoad(Value : Boolean); begin
  FAutoLoad := Value;
  JSCode('autoLoad:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFAutoLoadObject(Value : TExtObject); begin
  FAutoLoadObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoLoad:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFFailure(Value : TExtFunction); begin
  FFailure := Value;
  JSCode('failure:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtElementLoader.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtElementLoader.SetFIsLoader(Value : Boolean); begin
  FIsLoader := Value;
  JSCode(JSName + '.isLoader=' + VarToJSON([Value]) + ';');
end;

procedure TExtElementLoader.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtElementLoader.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFLoadMask(Value : Boolean); begin
  FLoadMask := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFLoadMaskString(Value : String); begin
  FLoadMaskString := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFScripts(Value : Boolean); begin
  FScripts := Value;
  JSCode('scripts:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFSuccess(Value : TExtFunction); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value, true]));
end;

procedure TExtElementLoader.SetFTarget(Value : THTMLElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetTarget(Value)
  else
    JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFTargetElement(Value : TExtElement); begin
  FTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtElementLoader.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtElementLoader.SetFOnBeforeload(Value : TExtElementLoaderOnBeforeload); begin
  if Assigned(FOnBeforeload) then
    JSCode(JSName+'.events ["beforeload"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeload', Ajax('beforeload', ['This', '%0.nm','Options', '%1.nm'], true));
  FOnBeforeload := Value;
end;

procedure TExtElementLoader.SetFOnException(Value : TExtElementLoaderOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['This', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnException := Value;
end;

procedure TExtElementLoader.SetFOnLoad(Value : TExtElementLoaderOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['This', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnLoad := Value;
end;

function TExtElementLoader.JSClassName : string; begin
  Result := 'Ext.ElementLoader';
end;

procedure TExtElementLoader.InitDefaults; begin
  inherited;
  FAjaxOptions := TExtObject.CreateInternal(Self, 'ajaxOptions');
  FAutoLoadObject := TExtObject.CreateInternal(Self, 'autoLoad');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FTargetElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtElementLoader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtElementLoader.Abort : TExtFunction; begin
  JSCode(JSName + '.abort();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtElementLoader');
  Result := Self;
end;

constructor TExtElementLoader.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtElementLoader.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.IsAutoRefreshing : TExtFunction; begin
  JSCode(JSName + '.isAutoRefreshing();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SetTarget(Target : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SetTarget(Target : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SetTarget(Target : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([Target]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.StartAutoRefresh(Interval : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.startAutoRefresh(' + VarToJSON([Interval, Options, false]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.StopAutoRefresh : TExtFunction; begin
  JSCode(JSName + '.stopAutoRefresh();', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtElementLoader');
  Result := Self;
end;

function TExtElementLoader.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtElementLoader');
  Result := Self;
end;

destructor TExtElementLoader.Destroy; begin
  try
    FAjaxOptions.Free;
    FAutoLoadObject.Free;
    FBaseParams.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FParams.Free;
    FScope.Free;
    FTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtElementLoader.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeload') and Assigned(FOnBeforeload) then
    FOnBeforeload(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtElementLoader(ParamAsObject('This')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')));
end;

procedure TExtEventObjectImplSingleton.SetFAltKey(Value : Boolean); begin
  FAltKey := Value;
  JSCode(JSName + '.altKey=' + VarToJSON([Value]) + ';');
end;

procedure TExtEventObjectImplSingleton.SetFCtrlKey(Value : Boolean); begin
  FCtrlKey := Value;
  JSCode(JSName + '.ctrlKey=' + VarToJSON([Value]) + ';');
end;

procedure TExtEventObjectImplSingleton.SetFShiftKey(Value : Boolean); begin
  FShiftKey := Value;
  JSCode(JSName + '.shiftKey=' + VarToJSON([Value]) + ';');
end;

function TExtEventObjectImplSingleton.JSClassName : string; begin
  Result := 'Ext.EventObjectImpl';
end;

{$IFDEF FPC}constructor TExtEventObjectImplSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtEventObjectImplSingleton.CorrectWheelDelta(Delta : Integer) : TExtFunction; begin
  JSCode(JSName + '.correctWheelDelta(' + VarToJSON([Delta]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetCharCode : TExtFunction; begin
  JSCode(JSName + '.getCharCode();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetKey : TExtFunction; begin
  JSCode(JSName + '.getKey();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetPoint : TExtFunction; begin
  JSCode(JSName + '.getPoint();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetRelatedTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetRelatedTarget(' + VarToJSON([Selector, MaxDepth, false, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetRelatedTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getRelatedTarget(' + VarToJSON([Selector, MaxDepth, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetTarget(Selector : String; MaxDepth : THTMLElement; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetTarget(' + VarToJSON([Selector, MaxDepth, false, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetTarget(Selector : String = ''; MaxDepth : Integer = 0; ReturnEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getTarget(' + VarToJSON([Selector, MaxDepth, ReturnEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetWheelDelta : TExtFunction; begin
  JSCode(JSName + '.getWheelDelta();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetWheelDeltas : TExtFunction; begin
  JSCode(JSName + '.getWheelDeltas();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetX : TExtFunction; begin
  JSCode(JSName + '.getX();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetXY : TExtFunction; begin
  JSCode(JSName + '.getXY();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.GetY : TExtFunction; begin
  JSCode(JSName + '.getY();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.HasModifier : TExtFunction; begin
  JSCode(JSName + '.hasModifier();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.IsNavKeyPress : TExtFunction; begin
  JSCode(JSName + '.isNavKeyPress();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.IsSpecialKey : TExtFunction; begin
  JSCode(JSName + '.isSpecialKey();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.PreventDefault : TExtFunction; begin
  JSCode(JSName + '.preventDefault();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.StopEvent : TExtFunction; begin
  JSCode(JSName + '.stopEvent();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.StopPropagation : TExtFunction; begin
  JSCode(JSName + '.stopPropagation();', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : THTMLElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Within(' + VarToJSON([El, false, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : TExtElement; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Within(' + VarToJSON([El, false, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

function TExtEventObjectImplSingleton.Within(El : String; Related : Boolean = false; AllowEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.within(' + VarToJSON([El, Related, AllowEl]) + ');', 'TExtEventObjectImplSingleton');
  Result := Self;
end;

procedure TExtFormFieldAncestor.SetFFieldDefaults(Value : TExtObject); begin
  FFieldDefaults := Value;
  Value.DeleteFromGarbage;
  JSCode('fieldDefaults:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldAncestor.SetFOnFielderrorchange(Value : TExtFormFieldAncestorOnFielderrorchange); begin
  if Assigned(FOnFielderrorchange) then
    JSCode(JSName+'.events ["fielderrorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fielderrorchange', Ajax('fielderrorchange', ['This', '%0.nm','The', '%1.nm','Error', '%2'], true));
  FOnFielderrorchange := Value;
end;

procedure TExtFormFieldAncestor.SetFOnFieldvaliditychange(Value : TExtFormFieldAncestorOnFieldvaliditychange); begin
  if Assigned(FOnFieldvaliditychange) then
    JSCode(JSName+'.events ["fieldvaliditychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fieldvaliditychange', Ajax('fieldvaliditychange', ['This', '%0.nm','The', '%1.nm','IsValid', '%2'], true));
  FOnFieldvaliditychange := Value;
end;

function TExtFormFieldAncestor.JSClassName : string; begin
  Result := 'Ext.form.FieldAncestor';
end;

procedure TExtFormFieldAncestor.InitDefaults; begin
  inherited;
  FFieldDefaults := TExtObject.CreateInternal(Self, 'fieldDefaults');
end;

{$IFDEF FPC}constructor TExtFormFieldAncestor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldAncestor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldAncestor.Destroy; begin
  try
    FFieldDefaults.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldAncestor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'fielderrorchange') and Assigned(FOnFielderrorchange) then
    FOnFielderrorchange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('Error'))
  else if (AEvtName = 'fieldvaliditychange') and Assigned(FOnFieldvaliditychange) then
    FOnFieldvaliditychange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('IsValid'));
end;

procedure TExtXTemplateParser.SetFLevel(Value : Integer); begin
  FLevel := Value;
  JSCode(JSName + '.level=' + VarToJSON([Value]) + ';');
end;

function TExtXTemplateParser.JSClassName : string; begin
  Result := 'Ext.XTemplateParser';
end;

{$IFDEF FPC}constructor TExtXTemplateParser.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtXTemplateParser.DoCase(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doCase(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoDefault : TExtFunction; begin
  JSCode(JSName + '.// doDefault();', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoElse : TExtFunction; begin
  JSCode(JSName + '.// doElse();', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoElseIf(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doElseIf(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoEnd(TypeJS : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doEnd(' + VarToJSON([TypeJS, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoEval(Text : String) : TExtFunction; begin
  JSCode(JSName + '.// doEval(' + VarToJSON([Text]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoExec(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doExec(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoExpr(Expr : String) : TExtFunction; begin
  JSCode(JSName + '.// doExpr(' + VarToJSON([Expr]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoFor(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doFor(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoForEach(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doForEach(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoIf(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doIf(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoSwitch(Action : String; Actions : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.// doSwitch(' + VarToJSON([Action, Actions, false]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoTag : TExtFunction; begin
  JSCode(JSName + '.// doTag();', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.// doText(' + VarToJSON([Text]) + ');', 'TExtXTemplateParser');
  Result := Self;
end;

function TExtXTemplateParser.DoTplExtEmptyFnParse : TExtFunction; begin
  JSCode(JSName + '.doTpl: Ext.emptyFn, parse();', 'TExtXTemplateParser');
  Result := Self;
end;

procedure TExtFormAction.SetFFailure(Value : TExtFunction); begin
  FFailure := Value;
  JSCode('failure:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFFailureAction(Value : TExtFormAction); begin
  FFailureAction := Value;
  Value.DeleteFromGarbage;
  JSCode('failureAction:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFFailureForm(Value : TExtFormBasic); begin
  FFailureForm := Value;
  Value.DeleteFromGarbage;
  JSCode('failureForm:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFFailureType(Value : String); begin
  FFailureType := Value;
  JSCode(JSName + '.failureType=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormAction.SetFForm(Value : TExtFormBasic); begin
  FForm := Value;
  Value.DeleteFromGarbage;
  JSCode('form:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFHeaders(Value : TExtObject); begin
  FHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('headers:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFParamsString(Value : String); begin
  FParamsString := Value;
  JSCode('params:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFReset(Value : Boolean); begin
  FReset := Value;
  JSCode('reset:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFResponse(Value : TExtObject); begin
  FResponse := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.response=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormAction.SetFResultJS(Value : TExtObject); begin
  FResultJS := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.resultJS=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFSubmitEmptyText(Value : Boolean); begin
  FSubmitEmptyText := Value;
  JSCode('submitEmptyText:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFSuccess(Value : TExtFunction); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value, true]));
end;

procedure TExtFormAction.SetFSuccessAction(Value : TExtFormAction); begin
  FSuccessAction := Value;
  Value.DeleteFromGarbage;
  JSCode('successAction:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFSuccessForm(Value : TExtFormBasic); begin
  FSuccessForm := Value;
  Value.DeleteFromGarbage;
  JSCode('successForm:' + VarToJSON([Value, false]));
end;

procedure TExtFormAction.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode(JSName + '.typeJS=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormAction.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFWaitMsg(Value : String); begin
  FWaitMsg := Value;
  JSCode('waitMsg:' + VarToJSON([Value]));
end;

procedure TExtFormAction.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

function TExtFormAction.JSClassName : string; begin
  Result := 'Ext.form.action.Action';
end;

procedure TExtFormAction.InitDefaults; begin
  inherited;
  FFailureAction := TExtFormAction.CreateInternal(Self, 'failureAction');
  FFailureForm := TExtFormBasic.CreateInternal(Self, 'failureForm');
  FForm := TExtFormBasic.CreateInternal(Self, 'form');
  FHeaders := TExtObject.CreateInternal(Self, 'headers');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FResponse := TExtObject.CreateInternal(Self, 'response');
  FResultJS := TExtObject.CreateInternal(Self, 'resultJS');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FSuccessAction := TExtFormAction.CreateInternal(Self, 'successAction');
  FSuccessForm := TExtFormBasic.CreateInternal(Self, 'successForm');
end;

{$IFDEF FPC}constructor TExtFormAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormAction.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtFormAction.Destroy; begin
  try
    FFailureAction.Free;
    FFailureForm.Free;
    FForm.Free;
    FHeaders.Free;
    FParams.Free;
    FResponse.Free;
    FResultJS.Free;
    FScope.Free;
    FSuccessAction.Free;
    FSuccessForm.Free;
  except end;
  inherited;
end;

procedure TExtFormField.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFIsFormField(Value : Boolean); begin
  FIsFormField := Value;
  JSCode(JSName + '.isFormField=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormField.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormField.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValidateOnChange(Value : Boolean); begin
  FValidateOnChange := Value;
  JSCode('validateOnChange:' + VarToJSON([Value]));
end;

procedure TExtFormField.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtFormField.SetFOnChange(Value : TExtFormFieldOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','NewValue', '%1.nm','OldValue', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtFormField.SetFOnDirtychange(Value : TExtFormFieldOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', ['This', '%0.nm','IsDirty', '%1'], true));
  FOnDirtychange := Value;
end;

procedure TExtFormField.SetFOnValiditychange(Value : TExtFormFieldOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', ['This', '%0.nm','IsValid', '%1'], true));
  FOnValiditychange := Value;
end;

function TExtFormField.JSClassName : string; begin
  Result := 'Ext.form.field.Field';
end;

procedure TExtFormField.InitDefaults; begin
  inherited;
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
  FValue := TExtObject.CreateInternal(Self, 'value');
end;

{$IFDEF FPC}constructor TExtFormField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormField.BatchChanges(Fn : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.batchChanges(' + VarToJSON([Fn, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormField');
  Result := Self;
end;

constructor TExtFormField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormField.ExtractFileInput : TExtFunction; begin
  JSCode(JSName + '.extractFileInput();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetModelData : TExtFunction; begin
  JSCode(JSName + '.getModelData();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetSubmitData : TExtFunction; begin
  JSCode(JSName + '.getSubmitData();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.InitField : TExtFunction; begin
  JSCode(JSName + '.initField();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.InitValue : TExtFunction; begin
  JSCode(JSName + '.initValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isEqual(' + VarToJSON([Value1, false, Value2, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsFileUpload : TExtFunction; begin
  JSCode(JSName + '.isFileUpload();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.ResetOriginalValue : TExtFunction; begin
  JSCode(JSName + '.resetOriginalValue();', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormField');
  Result := Self;
end;

function TExtFormField.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormField');
  Result := Self;
end;

destructor TExtFormField.Destroy; begin
  try
    FOriginalValue.Free;
    FValue.Free;
  except end;
  inherited;
end;

procedure TExtFormField.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormField(ParamAsObject('This')), TExtObject(ParamAsObject('NewValue')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsDirty'))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsValid'));
end;

procedure TExtDrawEngineImageExporterSingleton.SetFDefaultUrl(Value : String); begin
  FDefaultUrl := Value;
  JSCode(JSName + '.defaultUrl=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporterSingleton.SetFHeightParam(Value : String); begin
  FHeightParam := Value;
  JSCode(JSName + '.heightParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporterSingleton.SetFSupportedTypes(Value : TExtObjectList); begin
  FSupportedTypes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.supportedTypes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawEngineImageExporterSingleton.SetFSvgParam(Value : String); begin
  FSvgParam := Value;
  JSCode(JSName + '.svgParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporterSingleton.SetFTypeParam(Value : String); begin
  FTypeParam := Value;
  JSCode(JSName + '.typeParam=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawEngineImageExporterSingleton.SetFWidthParam(Value : String); begin
  FWidthParam := Value;
  JSCode(JSName + '.widthParam=' + VarToJSON([Value]) + ';');
end;

function TExtDrawEngineImageExporterSingleton.JSClassName : string; begin
  Result := 'Ext.draw.engine.ImageExporter';
end;

procedure TExtDrawEngineImageExporterSingleton.InitDefaults; begin
  inherited;
  FSupportedTypes := TExtObjectList.Create(Self, 'supportedTypes');
end;

{$IFDEF FPC}constructor TExtDrawEngineImageExporterSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineImageExporterSingleton.Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.generate(' + VarToJSON([Surface, false, Config, false]) + ');', 'TExtDrawEngineImageExporterSingleton');
  Result := Self;
end;

destructor TExtDrawEngineImageExporterSingleton.Destroy; begin
  try
    FSupportedTypes.Free;
  except end;
  inherited;
end;

function TExtDrawEngineSvgExporterSingleton.JSClassName : string; begin
  Result := 'Ext.draw.engine.SvgExporter';
end;

{$IFDEF FPC}constructor TExtDrawEngineSvgExporterSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineSvgExporterSingleton.Generate(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.generate(' + VarToJSON([Surface, false, Config, false]) + ');', 'TExtDrawEngineSvgExporterSingleton');
  Result := Self;
end;

procedure TExtDomLayer.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFDh(Value : TExtObject); begin
  FDh := Value;
  Value.DeleteFromGarbage;
  JSCode('dh:' + VarToJSON([Value, false]));
end;

procedure TExtDomLayer.SetFHideMode(Value : String); begin
  FHideMode := Value;
  JSCode('hideMode:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFShadowOffset(Value : Integer); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFShim(Value : Boolean); begin
  FShim := Value;
  JSCode('shim:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFUseDisplay(Value : Boolean); begin
  FUseDisplay := Value;
  JSCode('useDisplay:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFVisibilityCls(Value : String); begin
  FVisibilityCls := Value;
  JSCode('visibilityCls:' + VarToJSON([Value]));
end;

procedure TExtDomLayer.SetFZindex(Value : Integer); begin
  FZindex := Value;
  if not ConfigAvailable(JSName) then
    SetZIndex(Value)
  else
    JSCode('zindex:' + VarToJSON([Value]));
end;

function TExtDomLayer.JSClassName : string; begin
  Result := 'Ext.dom.Layer';
end;

procedure TExtDomLayer.InitDefaults; begin
  inherited;
  FDh := TExtObject.CreateInternal(Self, 'dh');
end;

{$IFDEF FPC}constructor TExtDomLayer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDomLayer.Create(Config : TExtObject; ExistingEl : THTMLElement); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false, ExistingEl, false]) + ');');
  InitDefaults;
end;

constructor TExtDomLayer.Create(Config : TExtObject = nil; ExistingEl : String = ''); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false, ExistingEl]) + ');');
  InitDefaults;
end;

function TExtDomLayer.SetZIndex(Zindex : Integer) : TExtFunction; begin
  JSCode(JSName + '.setZIndex(' + VarToJSON([Zindex]) + ');', 'TExtDomLayer');
  Result := Self;
end;

destructor TExtDomLayer.Destroy; begin
  try
    FDh.Free;
  except end;
  inherited;
end;

procedure TExtDrawColor.SetFLightnessFactor(Value : Integer); begin
  FLightnessFactor := Value;
  JSCode('lightnessFactor:' + VarToJSON([Value]));
end;

function TExtDrawColor.JSClassName : string; begin
  Result := 'Ext.draw.Color';
end;

procedure TExtDrawColor.InitDefaults; begin
  inherited;
  FLightnessFactor := 0;
end;

{$IFDEF FPC}constructor TExtDrawColor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawColor.Create(Red : Integer; Green : Integer; Blue : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([Red, Green, Blue]) + ');');
  InitDefaults;
end;

constructor TExtDrawColor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDrawColor.FromHSL(H : Integer; S : Integer; L : Integer) : TExtFunction; begin
  JSCode(JSName + '.fromHSL(' + VarToJSON([H, S, L]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.FromString(Str : String) : TExtFunction; begin
  JSCode(JSName + '.fromString(' + VarToJSON([Str]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetBlue : TExtFunction; begin
  JSCode(JSName + '.getBlue();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetDarker(Factor : Integer) : TExtFunction; begin
  JSCode(JSName + '.getDarker(' + VarToJSON([Factor]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetGrayscale : TExtFunction; begin
  JSCode(JSName + '.getGrayscale();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetGreen : TExtFunction; begin
  JSCode(JSName + '.getGreen();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetHSL : TExtFunction; begin
  JSCode(JSName + '.getHSL();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetLighter(Factor : Integer) : TExtFunction; begin
  JSCode(JSName + '.getLighter(' + VarToJSON([Factor]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetRed : TExtFunction; begin
  JSCode(JSName + '.getRed();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.GetRGB : TExtFunction; begin
  JSCode(JSName + '.getRGB();', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToHex(Color : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.ToHex(' + VarToJSON([Color]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToHex(Color : String) : TExtFunction; begin
  JSCode(JSName + '.toHex(' + VarToJSON([Color]) + ');', 'TExtDrawColor');
  Result := Self;
end;

function TExtDrawColor.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtDrawColor');
  Result := Self;
end;

procedure TExtDrawSprite.SetFDd(Value : TExtDdDragSource); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawSprite.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFFill(Value : String); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFFont(Value : String); begin
  FFont := Value;
  JSCode('font:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawSprite.SetFGroup(Value : String); begin
  FGroup := Value;
  JSCode('group:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFGroupTArrayOfString(Value : TArrayOfString); begin
  FGroupTArrayOfString := Value;
  JSCode('group:' + ArrayToJSON(Value));
end;

procedure TExtDrawSprite.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawSprite.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawSprite.SetFIsSprite(Value : Boolean); begin
  FIsSprite := Value;
  JSCode(JSName + '.isSprite=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawSprite.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDrawSprite.SetFOpacity(Value : Integer); begin
  FOpacity := Value;
  JSCode('opacity:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFPath(Value : String); begin
  FPath := Value;
  JSCode('path:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadius(Value : Integer); begin
  FRadius := Value;
  JSCode('radius:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadiusX(Value : Integer); begin
  FRadiusX := Value;
  JSCode('radiusX:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFRadiusY(Value : Integer); begin
  FRadiusY := Value;
  JSCode('radiusY:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFSrc(Value : String); begin
  FSrc := Value;
  JSCode('src:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFStroke(Value : String); begin
  FStroke := Value;
  JSCode('stroke:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFStrokeWidth(Value : Integer); begin
  FStrokeWidth := Value;
  JSCode('strokeWidth:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtDrawSprite.SetFOnBeforedestroy(Value : TExtDrawSpriteOnBeforedestroy); begin
  if Assigned(FOnBeforedestroy) then
    JSCode(JSName+'.events ["beforedestroy"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedestroy', Ajax('beforedestroy', ['This', '%0.nm'], true));
  FOnBeforedestroy := Value;
end;

procedure TExtDrawSprite.SetFOnClick(Value : TExtDrawSpriteOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', [], true));
  FOnClick := Value;
end;

procedure TExtDrawSprite.SetFOnDestroy(Value : TExtDrawSpriteOnDestroy); begin
  if Assigned(FOnDestroy) then
    JSCode(JSName+'.events ["destroy"].listeners=[];');
  if Assigned(Value) then
    AddListener('destroy', Ajax('destroy', ['This', '%0.nm'], true));
  FOnDestroy := Value;
end;

procedure TExtDrawSprite.SetFOnMousedown(Value : TExtDrawSpriteOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', [], true));
  FOnMousedown := Value;
end;

procedure TExtDrawSprite.SetFOnMousemove(Value : TExtDrawSpriteOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', [], true));
  FOnMousemove := Value;
end;

procedure TExtDrawSprite.SetFOnMouseout(Value : TExtDrawSpriteOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', [], true));
  FOnMouseout := Value;
end;

procedure TExtDrawSprite.SetFOnMouseover(Value : TExtDrawSpriteOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', [], true));
  FOnMouseover := Value;
end;

procedure TExtDrawSprite.SetFOnMouseup(Value : TExtDrawSpriteOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', [], true));
  FOnMouseup := Value;
end;

procedure TExtDrawSprite.SetFOnRender(Value : TExtDrawSpriteOnRender); begin
  if Assigned(FOnRender) then
    JSCode(JSName+'.events ["render"].listeners=[];');
  if Assigned(Value) then
    AddListener('render', Ajax('render', ['This', '%0.nm'], true));
  FOnRender := Value;
end;

function TExtDrawSprite.JSClassName : string; begin
  Result := 'Ext.draw.Sprite';
end;

procedure TExtDrawSprite.InitDefaults; begin
  inherited;
  FDd := TExtDdDragSource.CreateInternal(Self, 'dd');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtDrawSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawSprite.AddCls(ClassName : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.AddCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDrawSprite');
  Result := Self;
end;

constructor TExtDrawSprite.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDrawSprite.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.GetActiveAnimation : TExtFunction; begin
  JSCode(JSName + '.getActiveAnimation();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.GetBBox : TExtFunction; begin
  JSCode(JSName + '.getBBox();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Hide(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Redraw : TExtFunction; begin
  JSCode(JSName + '.redraw();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Remove : TExtFunction; begin
  JSCode(JSName + '.remove();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveCls(ClassName : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.RemoveCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveCls(ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([ClassName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SequenceFx : TExtFunction; begin
  JSCode(JSName + '.sequenceFx();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAttributes(' + VarToJSON([Attrs, false, Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SetStyle(PropertyJS : TExtObject; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.SetStyle(' + VarToJSON([PropertyJS, false, Value]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SetStyle(PropertyJS : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([PropertyJS, Value]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.Show(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Redraw]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.StopAnimation : TExtFunction; begin
  JSCode(JSName + '.stopAnimation();', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDrawSprite');
  Result := Self;
end;

function TExtDrawSprite.SyncFx : TExtFunction; begin
  JSCode(JSName + '.syncFx();', 'TExtDrawSprite');
  Result := Self;
end;

destructor TExtDrawSprite.Destroy; begin
  try
    FDd.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtDrawSprite.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedestroy') and Assigned(FOnBeforedestroy) then
    FOnBeforedestroy(TExtDrawSprite(ParamAsObject('This')))
  else if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick()
  else if (AEvtName = 'destroy') and Assigned(FOnDestroy) then
    FOnDestroy(TExtDrawSprite(ParamAsObject('This')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown()
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove()
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout()
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover()
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup()
  else if (AEvtName = 'render') and Assigned(FOnRender) then
    FOnRender(TExtDrawSprite(ParamAsObject('This')));
end;

procedure TExtDrawSurface.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawSurface.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawSurface.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtDrawSurface.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDrawSurface.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtDrawSurface.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDrawSurface.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtDrawSurface.SetFOnClick(Value : TExtDrawSurfaceOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['E', '%0.nm'], true));
  FOnClick := Value;
end;

procedure TExtDrawSurface.SetFOnDblclick(Value : TExtDrawSurfaceOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', ['E', '%0.nm'], true));
  FOnDblclick := Value;
end;

procedure TExtDrawSurface.SetFOnMousedown(Value : TExtDrawSurfaceOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['E', '%0.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtDrawSurface.SetFOnMouseenter(Value : TExtDrawSurfaceOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', ['E', '%0.nm'], true));
  FOnMouseenter := Value;
end;

procedure TExtDrawSurface.SetFOnMouseleave(Value : TExtDrawSurfaceOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', ['E', '%0.nm'], true));
  FOnMouseleave := Value;
end;

procedure TExtDrawSurface.SetFOnMousemove(Value : TExtDrawSurfaceOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', ['E', '%0.nm'], true));
  FOnMousemove := Value;
end;

procedure TExtDrawSurface.SetFOnMouseout(Value : TExtDrawSurfaceOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['E', '%0.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtDrawSurface.SetFOnMouseover(Value : TExtDrawSurfaceOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['E', '%0.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtDrawSurface.SetFOnMouseup(Value : TExtDrawSurfaceOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['E', '%0.nm'], true));
  FOnMouseup := Value;
end;

function TExtDrawSurface.JSClassName : string; begin
  Result := 'Ext.draw.Surface';
end;

procedure TExtDrawSurface.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FItems := TExtObjectList.Create(Self, 'items');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtDrawSurface.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawSurface.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDrawSurface');
  Result := Self;
end;

constructor TExtDrawSurface.Create(Config : TExtObject; EnginePriority : TArrayOfString = nil); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, EnginePriority]) + ');');
  InitDefaults;
end;

function TExtDrawSurface.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.GetGroup(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getGroup(' + VarToJSON([Id]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.Remove(Sprite : TExtDrawSprite; DestroySprite : Boolean) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Sprite, false, DestroySprite]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveAll(DestroySprites : Boolean) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([DestroySprites]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.Save(Surface : TExtDrawSurface; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.save(' + VarToJSON([Surface, false, Config, false]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.SetSize(W : Integer; H : Integer) : TExtFunction; begin
  JSCode(JSName + '.setSize(' + VarToJSON([W, H]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

function TExtDrawSurface.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDrawSurface');
  Result := Self;
end;

destructor TExtDrawSurface.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FItems.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtDrawSurface.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtEventObject(ParamAsObject('E')));
end;

function TExtDrawMatrix.JSClassName : string; begin
  Result := 'Ext.draw.Matrix';
end;

{$IFDEF FPC}constructor TExtDrawMatrix.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawSingleton.JSClassName : string; begin
  Result := 'Ext.draw.Draw';
end;

{$IFDEF FPC}constructor TExtDrawSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawSingleton.SnapEndsByDate(From : TDateTime; ToJS : TDateTime; StepsMax : Integer; LockEnds : Boolean) : TExtFunction; begin
  JSCode(JSName + '.snapEndsByDate(' + VarToJSON([From, ToJS, StepsMax, LockEnds]) + ');', 'TExtDrawSingleton');
  Result := Self;
end;

function TExtDrawSingleton.SnapEndsByDateAndStep(From : TDateTime; ToJS : TDateTime; Step : TExtObjectList; LockEnds : Boolean) : TExtFunction; begin
  JSCode(JSName + '.snapEndsByDateAndStep(' + VarToJSON([From, ToJS]) + ',' + VarToJSON(Step) + ',' + VarToJSON([LockEnds]) + ');', 'TExtDrawSingleton');
  Result := Self;
end;

function TExtShadowPoolSingleton.JSClassName : string; begin
  Result := 'Ext.ShadowPool';
end;

{$IFDEF FPC}constructor TExtShadowPoolSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSliderThumb.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtSliderThumb.SetFSlider(Value : TExtSliderMultiSlider); begin
  FSlider := Value;
  Value.DeleteFromGarbage;
  JSCode('slider:' + VarToJSON([Value, false]));
end;

function TExtSliderThumb.JSClassName : string; begin
  Result := 'Ext.slider.Thumb';
end;

procedure TExtSliderThumb.InitDefaults; begin
  inherited;
  FSlider := TExtSliderMultiSlider.CreateInternal(Self, 'slider');
end;

{$IFDEF FPC}constructor TExtSliderThumb.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtSliderThumb.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtSliderThumb.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtSliderThumb');
  Result := Self;
end;

function TExtSliderThumb.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtSliderThumb');
  Result := Self;
end;

function TExtSliderThumb.InitEvents : TExtFunction; begin
  JSCode(JSName + '.initEvents();', 'TExtSliderThumb');
  Result := Self;
end;

function TExtSliderThumb.Render : TExtFunction; begin
  JSCode(JSName + '.render();', 'TExtSliderThumb');
  Result := Self;
end;

destructor TExtSliderThumb.Destroy; begin
  try
    FSlider.Free;
  except end;
  inherited;
end;

function TExtRtlViewTable.JSClassName : string; begin
  Result := 'Ext.rtl.view.Table';
end;

{$IFDEF FPC}constructor TExtRtlViewTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtShadow.SetFMode(Value : String); begin
  FMode := Value;
  JSCode('mode:' + VarToJSON([Value]));
end;

procedure TExtShadow.SetFOffset(Value : Integer); begin
  FOffset := Value;
  JSCode('offset:' + VarToJSON([Value]));
end;

function TExtShadow.JSClassName : string; begin
  Result := 'Ext.Shadow';
end;

{$IFDEF FPC}constructor TExtShadow.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtShadow.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtShadow.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.IsVisible : TExtFunction; begin
  JSCode(JSName + '.isVisible();', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Realign(Left : Integer; Top : Integer; Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.realign(' + VarToJSON([Left, Top, Width, Height]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.SetOpacity(Opacity : Integer) : TExtFunction; begin
  JSCode(JSName + '.setOpacity(' + VarToJSON([Opacity]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.SetZIndex(Zindex : Integer) : TExtFunction; begin
  JSCode(JSName + '.setZIndex(' + VarToJSON([Zindex]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Show(TargetEl : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([TargetEl, false]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Show(TargetEl : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([TargetEl, false]) + ');', 'TExtShadow');
  Result := Self;
end;

function TExtShadow.Show(TargetEl : String) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([TargetEl]) + ');', 'TExtShadow');
  Result := Self;
end;

procedure TExtStateStateful.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtStateStateful.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtStateStateful.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtStateStateful.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtStateStateful.SetFSaveDelay(Value : Integer); begin
  FSaveDelay := Value;
  JSCode('saveDelay:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFStateEvents(Value : TArrayOfString); begin
  FStateEvents := Value;
  JSCode('stateEvents:' + ArrayToJSON(Value));
end;

procedure TExtStateStateful.SetFStateful(Value : Boolean); begin
  FStateful := Value;
  JSCode('stateful:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFStateId(Value : String); begin
  FStateId := Value;
  JSCode('stateId:' + VarToJSON([Value]));
end;

procedure TExtStateStateful.SetFOnBeforestaterestore(Value : TExtStateStatefulOnBeforestaterestore); begin
  if Assigned(FOnBeforestaterestore) then
    JSCode(JSName+'.events ["beforestaterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestaterestore', Ajax('beforestaterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestaterestore := Value;
end;

procedure TExtStateStateful.SetFOnBeforestatesave(Value : TExtStateStatefulOnBeforestatesave); begin
  if Assigned(FOnBeforestatesave) then
    JSCode(JSName+'.events ["beforestatesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestatesave', Ajax('beforestatesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnBeforestatesave := Value;
end;

procedure TExtStateStateful.SetFOnStaterestore(Value : TExtStateStatefulOnStaterestore); begin
  if Assigned(FOnStaterestore) then
    JSCode(JSName+'.events ["staterestore"].listeners=[];');
  if Assigned(Value) then
    AddListener('staterestore', Ajax('staterestore', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStaterestore := Value;
end;

procedure TExtStateStateful.SetFOnStatesave(Value : TExtStateStatefulOnStatesave); begin
  if Assigned(FOnStatesave) then
    JSCode(JSName+'.events ["statesave"].listeners=[];');
  if Assigned(Value) then
    AddListener('statesave', Ajax('statesave', ['This', '%0.nm','State', '%1.nm'], true));
  FOnStatesave := Value;
end;

function TExtStateStateful.JSClassName : string; begin
  Result := 'Ext.state.Stateful';
end;

{$IFDEF FPC}constructor TExtStateStateful.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtStateStateful.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddStateEvents(Events : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.AddStateEvents(' + VarToJSON([Events]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.AddStateEvents(Events : String) : TExtFunction; begin
  JSCode(JSName + '.addStateEvents(' + VarToJSON([Events]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ApplyState(State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyState(' + VarToJSON([State, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.GetState : TExtFunction; begin
  JSCode(JSName + '.getState();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SavePropsToState(PropNames : TArrayOfString; State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SavePropsToState(' + VarToJSON([PropNames, State, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SavePropsToState(PropNames : String; State : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.savePropsToState(' + VarToJSON([PropNames, State, false]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SavePropToState(PropName : String; State : TExtObject; StateName : String = '') : TExtFunction; begin
  JSCode(JSName + '.savePropToState(' + VarToJSON([PropName, State, false, StateName]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SaveState : TExtFunction; begin
  JSCode(JSName + '.saveState();', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtStateStateful');
  Result := Self;
end;

function TExtStateStateful.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtStateStateful');
  Result := Self;
end;

procedure TExtStateStateful.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforestaterestore') and Assigned(FOnBeforestaterestore) then
    FOnBeforestaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'beforestatesave') and Assigned(FOnBeforestatesave) then
    FOnBeforestatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'staterestore') and Assigned(FOnStaterestore) then
    FOnStaterestore(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')))
  else if (AEvtName = 'statesave') and Assigned(FOnStatesave) then
    FOnStatesave(TExtStateStateful(ParamAsObject('This')), TExtObject(ParamAsObject('State')));
end;

function TExtUtilMemento.JSClassName : string; begin
  Result := 'Ext.util.Memento';
end;

{$IFDEF FPC}constructor TExtUtilMemento.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilMemento.Capture(Props : TArrayOfString; Target : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Capture(' + VarToJSON([Props, Target, false]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtUtilMemento.Capture(Props : String; Target : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([Props, Target, false]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

constructor TExtUtilMemento.Create(Target : TExtObject; Props : TArrayOfString); begin
  CreateVar(JSClassName + '(' + VarToJSON([Target, false, Props]) + ');');
  InitDefaults;
end;

constructor TExtUtilMemento.Create(Target : TExtObject; Props : String); begin
  CreateVar(JSClassName + '(' + VarToJSON([Target, false, Props]) + ');');
  InitDefaults;
end;

function TExtUtilMemento.Remove(Props : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.Remove(' + VarToJSON([Props]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtUtilMemento.Remove(Props : String) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Props]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtUtilMemento.Restore(Props : TArrayOfString; Clear : Boolean; Target : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Restore(' + VarToJSON([Props, Clear, Target, false]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtUtilMemento.Restore(Props : String; Clear : Boolean; Target : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.restore(' + VarToJSON([Props, Clear, Target, false]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtUtilMemento.RestoreAll(Clear : Boolean; Target : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.restoreAll(' + VarToJSON([Clear, Target, false]) + ');', 'TExtUtilMemento');
  Result := Self;
end;

function TExtStateManagerSingleton.JSClassName : string; begin
  Result := 'Ext.state.Manager';
end;

{$IFDEF FPC}constructor TExtStateManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtStateManagerSingleton.Clear(Name : String) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.Get(Name : String; DefaultValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name, DefaultValue, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.GetProvider : TExtFunction; begin
  JSCode(JSName + '.getProvider();', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.SetJS(Name : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

function TExtStateManagerSingleton.SetProvider(StateProvider : TExtStateProvider) : TExtFunction; begin
  JSCode(JSName + '.setProvider(' + VarToJSON([StateProvider, false]) + ');', 'TExtStateManagerSingleton');
  Result := Self;
end;

procedure TExtStateProvider.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtStateProvider.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtStateProvider.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtStateProvider.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtStateProvider.SetFPrefix(Value : String); begin
  FPrefix := Value;
  JSCode('prefix:' + VarToJSON([Value]));
end;

procedure TExtStateProvider.SetFOnStatechange(Value : TExtStateProviderOnStatechange); begin
  if Assigned(FOnStatechange) then
    JSCode(JSName+'.events ["statechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('statechange', Ajax('statechange', ['This', '%0.nm','Key', '%1','Value', '%2'], true));
  FOnStatechange := Value;
end;

function TExtStateProvider.JSClassName : string; begin
  Result := 'Ext.state.Provider';
end;

procedure TExtStateProvider.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FPrefix := 'ext-';
end;

{$IFDEF FPC}constructor TExtStateProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtStateProvider.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.Clear(Name : String) : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtStateProvider');
  Result := Self;
end;

constructor TExtStateProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtStateProvider.DecodeValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.decodeValue(' + VarToJSON([Value]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.EncodeValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.encodeValue(' + VarToJSON([Value, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.Get(Name : String; DefaultValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name, DefaultValue, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.SetJS(Name : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtStateProvider');
  Result := Self;
end;

function TExtStateProvider.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtStateProvider');
  Result := Self;
end;

procedure TExtStateProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'statechange') and Assigned(FOnStatechange) then
    FOnStatechange(TExtStateProvider(ParamAsObject('This')), ParamAsString('Key'), ParamAsString('Value'));
end;

function TExtRtlResizerSplitterTracker.JSClassName : string; begin
  Result := 'Ext.rtl.resizer.SplitterTracker';
end;

{$IFDEF FPC}constructor TExtRtlResizerSplitterTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlSliderMulti.JSClassName : string; begin
  Result := 'Ext.rtl.slider.Multi';
end;

{$IFDEF FPC}constructor TExtRtlSliderMulti.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlResizerBorderSplitterTracker.JSClassName : string; begin
  Result := 'Ext.rtl.resizer.BorderSplitterTracker';
end;

{$IFDEF FPC}constructor TExtRtlResizerBorderSplitterTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlResizerResizeTracker.JSClassName : string; begin
  Result := 'Ext.rtl.resizer.ResizeTracker';
end;

{$IFDEF FPC}constructor TExtRtlResizerResizeTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlUtilFloating.JSClassName : string; begin
  Result := 'Ext.rtl.util.Floating';
end;

{$IFDEF FPC}constructor TExtRtlUtilFloating.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlUtilRenderable.JSClassName : string; begin
  Result := 'Ext.rtl.util.Renderable';
end;

{$IFDEF FPC}constructor TExtRtlUtilRenderable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlTabBar.JSClassName : string; begin
  Result := 'Ext.rtl.tab.Bar';
end;

{$IFDEF FPC}constructor TExtRtlTabBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlTreeColumn.JSClassName : string; begin
  Result := 'Ext.rtl.tree.Column';
end;

{$IFDEF FPC}constructor TExtRtlTreeColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilCookiesSingleton.JSClassName : string; begin
  Result := 'Ext.util.Cookies';
end;

{$IFDEF FPC}constructor TExtUtilCookiesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilCookiesSingleton.Clear(Name : String; Path : String = '') : TExtFunction; begin
  JSCode(JSName + '.clear(' + VarToJSON([Name, Path]) + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

function TExtUtilCookiesSingleton.Get(Name : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Name]) + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

function TExtUtilCookiesSingleton.SetJS(Name : String; Value : TExtObject; Expires : TExtObject = nil; Path : String = ''; Domain : String = ''; Secure : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Name, Value, false, Expires, false, Path, Domain, Secure]) + ');', 'TExtUtilCookiesSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.JSClassName : string; begin
  Result := 'Ext.util.CSS';
end;

{$IFDEF FPC}constructor TExtUtilCSSSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilCSSSingleton.CreateRule(StyleSheet : TCSSStyleSheet; Selector : String; PropertyJS : String) : TExtFunction; begin
  JSCode(JSName + '.createRule(' + VarToJSON([StyleSheet, false, Selector, PropertyJS]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.CreateStyleSheet(CssText : String; Id : String) : TExtFunction; begin
  JSCode(JSName + '.createStyleSheet(' + VarToJSON([CssText, Id]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector : TArrayOfString; RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetRule(' + VarToJSON([Selector, RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRule(Selector : String; RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getRule(' + VarToJSON([Selector, RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.GetRules(RefreshCache : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getRules(' + VarToJSON([RefreshCache]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RefreshCache : TExtFunction; begin
  JSCode(JSName + '.refreshCache();', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.RemoveStyleSheet(Id : String) : TExtFunction; begin
  JSCode(JSName + '.removeStyleSheet(' + VarToJSON([Id]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.SwapStyleSheet(Id : String; Url : String) : TExtFunction; begin
  JSCode(JSName + '.swapStyleSheet(' + VarToJSON([Id, Url]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector : TArrayOfString; PropertyJS : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.UpdateRule(' + VarToJSON([Selector, PropertyJS, Value]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilCSSSingleton.UpdateRule(Selector : String; PropertyJS : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.updateRule(' + VarToJSON([Selector, PropertyJS, Value]) + ');', 'TExtUtilCSSSingleton');
  Result := Self;
end;

function TExtUtilAnimate.JSClassName : string; begin
  Result := 'Ext.util.Animate';
end;

{$IFDEF FPC}constructor TExtUtilAnimate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilAnimate.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.GetActiveAnimation : TExtFunction; begin
  JSCode(JSName + '.getActiveAnimation();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.SequenceFx : TExtFunction; begin
  JSCode(JSName + '.sequenceFx();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.StopAnimation : TExtFunction; begin
  JSCode(JSName + '.stopAnimation();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilAnimate.SyncFx : TExtFunction; begin
  JSCode(JSName + '.syncFx();', 'TExtUtilAnimate');
  Result := Self;
end;

function TExtUtilBindable.JSClassName : string; begin
  Result := 'Ext.util.Bindable';
end;

{$IFDEF FPC}constructor TExtUtilBindable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilBindable.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtUtilBindable');
  Result := Self;
end;

function TExtUtilBindable.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtUtilBindable');
  Result := Self;
end;

function TExtUtilBindable.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtUtilBindable');
  Result := Self;
end;

procedure TExtUtilFilter.SetFAnyMatch(Value : Boolean); begin
  FAnyMatch := Value;
  JSCode('anyMatch:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFCaseSensitive(Value : Boolean); begin
  FCaseSensitive := Value;
  JSCode('caseSensitive:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode(JSName + '.disabled=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilFilter.SetFExactMatch(Value : Boolean); begin
  FExactMatch := Value;
  JSCode('exactMatch:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFFilterFn(Value : TExtFunction); begin
  FFilterFn := Value;
  if not ConfigAvailable(JSName) then
    SetFilterFn(Value)
  else
    JSCode('filterFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilFilter.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFOperator(Value : String); begin
  FOperator := Value;
  JSCode('operator:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFPropertyJS(Value : String); begin
  FPropertyJS := Value;
  JSCode('propertyJS:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtUtilFilter.SetFValue(Value : String); begin
  FValue := Value;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value]));
end;

function TExtUtilFilter.JSClassName : string; begin
  Result := 'Ext.util.Filter';
end;

{$IFDEF FPC}constructor TExtUtilFilter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilFilter.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtUtilFilter.CreateFilterFn(Filters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.createFilterFn(' + VarToJSON(Filters) + ');', 'TExtUtilFilter');
  Result := Self;
end;

function TExtUtilFilter.SetFilterFn(FilterFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.setFilterFn(' + VarToJSON([FilterFn, true]) + ');', 'TExtUtilFilter');
  Result := Self;
end;

function TExtUtilFilter.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtUtilFilter');
  Result := Self;
end;

procedure TExtUtilFloating.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode('fixed:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFFocusOnToFront(Value : Boolean); begin
  FFocusOnToFront := Value;
  JSCode('focusOnToFront:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtUtilFloating.SetFShadowOffset(Value : Integer); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

function TExtUtilFloating.JSClassName : string; begin
  Result := 'Ext.util.Floating';
end;

{$IFDEF FPC}constructor TExtUtilFloating.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilFloating.Center : TExtFunction; begin
  JSCode(JSName + '.center();', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.DoConstrain(ConstrainTo : String = '') : TExtFunction; begin
  JSCode(JSName + '.doConstrain(' + VarToJSON([ConstrainTo]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.setActive(' + VarToJSON([Active, NewActive, false]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.ToBack : TExtFunction; begin
  JSCode(JSName + '.toBack();', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilFloating.ToFront(PreventFocus : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toFront(' + VarToJSON([PreventFocus]) + ');', 'TExtUtilFloating');
  Result := Self;
end;

function TExtUtilElementContainer.JSClassName : string; begin
  Result := 'Ext.util.ElementContainer';
end;

{$IFDEF FPC}constructor TExtUtilElementContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilElementContainer.AddChildEls : TExtFunction; begin
  JSCode(JSName + '.addChildEls();', 'TExtUtilElementContainer');
  Result := Self;
end;

function TExtUtilElementContainer.RemoveChildEls(TestFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.removeChildEls(' + VarToJSON([TestFn, true]) + ');', 'TExtUtilElementContainer');
  Result := Self;
end;

procedure TExtUtilEvent.SetFIsEvent(Value : Boolean); begin
  FIsEvent := Value;
  JSCode(JSName + '.isEvent=' + VarToJSON([Value]) + ';');
end;

function TExtUtilEvent.JSClassName : string; begin
  Result := 'Ext.util.Event';
end;

{$IFDEF FPC}constructor TExtUtilEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTipQuickTipManagerSingleton.JSClassName : string; begin
  Result := 'Ext.tip.QuickTipManager';
end;

{$IFDEF FPC}constructor TExtTipQuickTipManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTipQuickTipManagerSingleton.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.GetQuickTip : TExtFunction; begin
  JSCode(JSName + '.getQuickTip();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Init(AutoRender : Boolean = false; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.init(' + VarToJSON([AutoRender, Config, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.IsEnabled : TExtFunction; begin
  JSCode(JSName + '.isEnabled();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Register(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Config, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Tips : TExtFunction; begin
  JSCode(JSName + '.tips();', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

function TExtTipQuickTipManagerSingleton.Unregister(El : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([El]) + ');', 'TExtTipQuickTipManagerSingleton');
  Result := Self;
end;

procedure TExtUtilKeyMap.SetFBinding(Value : TExtObjectList); begin
  FBinding := Value;
  Value.DeleteFromGarbage;
  JSCode('binding:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFBindingFn(Value : TExtFunction); begin
  FBindingFn := Value;
  JSCode('bindingFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilKeyMap.SetFBindingHandler(Value : TExtFunction); begin
  FBindingHandler := Value;
  JSCode('bindingHandler:' + VarToJSON([Value, true]));
end;

procedure TExtUtilKeyMap.SetFBindingKey(Value : String); begin
  FBindingKey := Value;
  JSCode('bindingKey:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFBindingKeyTArrayOfString(Value : TArrayOfString); begin
  FBindingKeyTArrayOfString := Value;
  JSCode('bindingKey:' + ArrayToJSON(Value));
end;

procedure TExtUtilKeyMap.SetFEventName(Value : String); begin
  FEventName := Value;
  JSCode('eventName:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFIgnoreInputFields(Value : Boolean); begin
  FIgnoreInputFields := Value;
  JSCode('ignoreInputFields:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFProcessEvent(Value : TExtFunction); begin
  FProcessEvent := Value;
  JSCode('processEvent:' + VarToJSON([Value, true]));
end;

procedure TExtUtilKeyMap.SetFProcessEventScope(Value : TExtObject); begin
  FProcessEventScope := Value;
  Value.DeleteFromGarbage;
  JSCode('processEventScope:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTargetElement(Value : TExtElement); begin
  FTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyMap.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyMap.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

function TExtUtilKeyMap.JSClassName : string; begin
  Result := 'Ext.util.KeyMap';
end;

procedure TExtUtilKeyMap.InitDefaults; begin
  inherited;
  FBinding := TExtObjectList.Create(Self, 'binding');
  FProcessEventScope := TExtObject.CreateInternal(Self, 'processEventScope');
  FTarget := TExtComponent.CreateInternal(Self, 'target');
  FTargetElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtUtilKeyMap.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilKeyMap.AddBinding(Binding : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddBinding(' + VarToJSON(Binding) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.AddBinding(Binding : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addBinding(' + VarToJSON([Binding, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

constructor TExtUtilKeyMap.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilKeyMap.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.IsEnabled : TExtFunction; begin
  JSCode(JSName + '.isEnabled();', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.On(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.On(' + VarToJSON([Key, false, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.On(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.On(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.On(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.on(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.RemoveBinding(Binding : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.removeBinding(' + VarToJSON([Binding, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Un(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Un(' + VarToJSON([Key, false, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Un(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Un(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

function TExtUtilKeyMap.Un(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.un(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtUtilKeyMap');
  Result := Self;
end;

destructor TExtUtilKeyMap.Destroy; begin
  try
    FBinding.Free;
    FProcessEventScope.Free;
    FTarget.Free;
    FTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtTemplate.SetFCompiled(Value : Boolean); begin
  FCompiled := Value;
  JSCode('compiled:' + VarToJSON([Value]));
end;

procedure TExtTemplate.SetFDisableFormats(Value : Boolean); begin
  FDisableFormats := Value;
  JSCode('disableFormats:' + VarToJSON([Value]));
end;

procedure TExtTemplate.SetFIsTemplate(Value : Boolean); begin
  FIsTemplate := Value;
  JSCode(JSName + '.isTemplate=' + VarToJSON([Value]) + ';');
end;

function TExtTemplate.JSClassName : string; begin
  Result := 'Ext.Template';
end;

{$IFDEF FPC}constructor TExtTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTemplate.Append(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Append(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Append(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.append(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Apply(Values : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Apply(' + VarToJSON(Values) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Apply(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.apply(' + VarToJSON([Values, false]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.ApplyOut(Values : TExtObjectList; OutJS : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.ApplyOut(' + VarToJSON(Values) + ',' + VarToJSON(OutJS) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.ApplyOut(Values : TExtObject; OutJS : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.applyOut(' + VarToJSON([Values, false]) + ',' + VarToJSON(OutJS) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.ApplyTemplate : TExtFunction; begin
  JSCode(JSName + '.applyTemplate();', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Compile : TExtFunction; begin
  JSCode(JSName + '.compile();', 'TExtTemplate');
  Result := Self;
end;

constructor TExtTemplate.Create(Html : String; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Html, Config, false]) + ');');
  InitDefaults;
end;

function TExtTemplate.From(El : THTMLElement; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.From(' + VarToJSON([El, false, Config, false]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.From(El : String; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.from(' + VarToJSON([El, Config, false]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertAfter(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertAfter(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertAfter(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertBefore(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertBefore(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.InsertFirst(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.InsertFirst(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.insertFirst(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : String; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : THTMLElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : THTMLElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : TExtElement; Values : TExtObjectList; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false]) + ',' + VarToJSON(Values) + ',' + VarToJSON([ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : TExtElement; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Overwrite(' + VarToJSON([El, false, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.Overwrite(El : String; Values : TExtObject; ReturnElement : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.overwrite(' + VarToJSON([El, Values, false, ReturnElement]) + ');', 'TExtTemplate');
  Result := Self;
end;

function TExtTemplate.SetJS(Html : String; Compile : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([Html, Compile]) + ');', 'TExtTemplate');
  Result := Self;
end;

procedure TExtUtilKeyNav.SetFDefaultEventAction(Value : String); begin
  FDefaultEventAction := Value;
  JSCode('defaultEventAction:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  if not ConfigAvailable(JSName) then
    SetDisabled(Value)
  else
    JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFEventName(Value : String); begin
  FEventName := Value;
  JSCode('eventName:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFForceKeyDown(Value : Boolean); begin
  FForceKeyDown := Value;
  JSCode('forceKeyDown:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFIgnoreInputFields(Value : Boolean); begin
  FIgnoreInputFields := Value;
  JSCode('ignoreInputFields:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFKeyMap(Value : TExtUtilKeyMap); begin
  FKeyMap := Value;
  Value.DeleteFromGarbage;
  JSCode('keyMap:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFProcessEvent(Value : TExtFunction); begin
  FProcessEvent := Value;
  JSCode('processEvent:' + VarToJSON([Value, true]));
end;

procedure TExtUtilKeyNav.SetFProcessEventScope(Value : TExtObject); begin
  FProcessEventScope := Value;
  Value.DeleteFromGarbage;
  JSCode('processEventScope:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTargetElement(Value : TExtElement); begin
  FTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtUtilKeyNav.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtUtilKeyNav.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

function TExtUtilKeyNav.JSClassName : string; begin
  Result := 'Ext.util.KeyNav';
end;

procedure TExtUtilKeyNav.InitDefaults; begin
  inherited;
  FKeyMap := TExtUtilKeyMap.CreateInternal(Self, 'keyMap');
  FProcessEventScope := TExtObject.CreateInternal(Self, 'processEventScope');
  FTarget := TExtComponent.CreateInternal(Self, 'target');
  FTargetElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtUtilKeyNav.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilKeyNav.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilKeyNav.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilKeyNav');
  Result := Self;
end;

function TExtUtilKeyNav.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilKeyNav');
  Result := Self;
end;

function TExtUtilKeyNav.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilKeyNav');
  Result := Self;
end;

destructor TExtUtilKeyNav.Destroy; begin
  try
    FKeyMap.Free;
    FProcessEventScope.Free;
    FTarget.Free;
    FTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtUtilHashMap.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilHashMap.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilHashMap.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilHashMap.SetFKeyFn(Value : TExtFunction); begin
  FKeyFn := Value;
  JSCode('keyFn:' + VarToJSON([Value, true]));
end;

procedure TExtUtilHashMap.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtUtilHashMap.SetFOnAdd(Value : TExtUtilHashMapOnAdd); begin
  if Assigned(FOnAdd) then
    JSCode(JSName+'.events ["add"].listeners=[];');
  if Assigned(Value) then
    AddListener('add', Ajax('add', ['This', '%0.nm','Key', '%1','Value', '%2.nm'], true));
  FOnAdd := Value;
end;

procedure TExtUtilHashMap.SetFOnClear(Value : TExtUtilHashMapOnClear); begin
  if Assigned(FOnClear) then
    JSCode(JSName+'.events ["clear"].listeners=[];');
  if Assigned(Value) then
    AddListener('clear', Ajax('clear', ['This', '%0.nm'], true));
  FOnClear := Value;
end;

procedure TExtUtilHashMap.SetFOnRemove(Value : TExtUtilHashMapOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['This', '%0.nm','Key', '%1','Value', '%2.nm'], true));
  FOnRemove := Value;
end;

procedure TExtUtilHashMap.SetFOnReplace(Value : TExtUtilHashMapOnReplace); begin
  if Assigned(FOnReplace) then
    JSCode(JSName+'.events ["replace"].listeners=[];');
  if Assigned(Value) then
    AddListener('replace', Ajax('replace', ['This', '%0.nm','Key', '%1','Value', '%2.nm','Old', '%3.nm'], true));
  FOnReplace := Value;
end;

function TExtUtilHashMap.JSClassName : string; begin
  Result := 'Ext.util.HashMap';
end;

{$IFDEF FPC}constructor TExtUtilHashMap.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilHashMap.Add(Key : TExtObject; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON([Key, false, O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Add(Key : String; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Key, O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Clone : TExtFunction; begin
  JSCode(JSName + '.clone();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Contains(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Value, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ContainsKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.containsKey(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

constructor TExtUtilHashMap.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtUtilHashMap.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Get(Key : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetKey(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getKey(' + VarToJSON([O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetKeys : TExtFunction; begin
  JSCode(JSName + '.getKeys();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Remove(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([O, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveAtKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.removeAtKey(' + VarToJSON([Key]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.Replace(Key : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.replace(' + VarToJSON([Key, Value, false]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

function TExtUtilHashMap.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtUtilHashMap');
  Result := Self;
end;

procedure TExtUtilHashMap.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'clear') and Assigned(FOnClear) then
    FOnClear(TExtUtilHashMap(ParamAsObject('This')))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'replace') and Assigned(FOnReplace) then
    FOnReplace(TExtUtilHashMap(ParamAsObject('This')), ParamAsString('Key'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('Old')));
end;

procedure TExtUtilAbstractMixedCollection.SetFAllowFunctions(Value : Boolean); begin
  FAllowFunctions := Value;
  JSCode('allowFunctions:' + VarToJSON([Value]));
end;

procedure TExtUtilAbstractMixedCollection.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilAbstractMixedCollection.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilAbstractMixedCollection.SetFIsMixedCollection(Value : Boolean); begin
  FIsMixedCollection := Value;
  JSCode(JSName + '.isMixedCollection=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilAbstractMixedCollection.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilAbstractMixedCollection.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtUtilAbstractMixedCollection.SetFOnAdd(Value : TExtUtilAbstractMixedCollectionOnAdd); begin
  if Assigned(FOnAdd) then
    JSCode(JSName+'.events ["add"].listeners=[];');
  if Assigned(Value) then
    AddListener('add', Ajax('add', ['Index', '%0','O', '%1.nm','Key', '%2'], true));
  FOnAdd := Value;
end;

procedure TExtUtilAbstractMixedCollection.SetFOnClear(Value : TExtUtilAbstractMixedCollectionOnClear); begin
  if Assigned(FOnClear) then
    JSCode(JSName+'.events ["clear"].listeners=[];');
  if Assigned(Value) then
    AddListener('clear', Ajax('clear', [], true));
  FOnClear := Value;
end;

procedure TExtUtilAbstractMixedCollection.SetFOnRemove(Value : TExtUtilAbstractMixedCollectionOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['O', '%0.nm','Key', '%1'], true));
  FOnRemove := Value;
end;

procedure TExtUtilAbstractMixedCollection.SetFOnReplace(Value : TExtUtilAbstractMixedCollectionOnReplace); begin
  if Assigned(FOnReplace) then
    JSCode(JSName+'.events ["replace"].listeners=[];');
  if Assigned(Value) then
    AddListener('replace', Ajax('replace', ['Key', '%0','Old', '%1.nm','New', '%2.nm'], true));
  FOnReplace := Value;
end;

function TExtUtilAbstractMixedCollection.JSClassName : string; begin
  Result := 'Ext.util.AbstractMixedCollection';
end;

{$IFDEF FPC}constructor TExtUtilAbstractMixedCollection.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilAbstractMixedCollection.Add(Key : TExtObject; Obj : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON([Key, false, Obj, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Add(Key : String; Obj : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Key, Obj, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddAll(Objs : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddAll(' + VarToJSON(Objs) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddAll(Objs : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addAll(' + VarToJSON([Objs, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Clone : TExtFunction; begin
  JSCode(JSName + '.clone();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Collect(PropertyJS : String; Root : String = ''; AllowBlank : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.collect(' + VarToJSON([PropertyJS, Root, AllowBlank]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Contains(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ContainsKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.containsKey(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.EachKey(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.eachKey(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Filter(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON([PropertyJS, #3 + Value, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Filter(PropertyJS : TExtObjectList; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON(PropertyJS) + ',' + VarToJSON([#3 + Value, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Filter(PropertyJS : TExtObjectList; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON(PropertyJS) + ',' + VarToJSON([Value, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Filter(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.filter(' + VarToJSON([PropertyJS, Value, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FilterBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.filterBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FindBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.findBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FindIndex(PropertyJS : String; Value : TRegExp; Start : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindIndex(' + VarToJSON([PropertyJS, #3 + Value, Start, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FindIndex(PropertyJS : String; Value : String; Start : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findIndex(' + VarToJSON([PropertyJS, Value, Start, AnyMatch, CaseSensitive]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FindIndexBy(Fn : TExtFunction; Scope : TExtObject = nil; Start : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.findIndexBy(' + VarToJSON([Fn, true, Scope, false, Start]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.First : TExtFunction; begin
  JSCode(JSName + '.first();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Get(Key : String) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Get(Key : Integer) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.GetAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getAt(' + VarToJSON([Index]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.GetByKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.GetByKey(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.GetByKey(Key : Integer) : TExtFunction; begin
  JSCode(JSName + '.getByKey(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.GetRange(StartIndex : Integer = 0; EndIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.getRange(' + VarToJSON([StartIndex, EndIndex]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.IndexOf(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.IndexOfKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.indexOfKey(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : String; O : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Key]) + ',' + VarToJSON(O) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TExtObjectList; O : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index]) + ',' + VarToJSON(Key) + ',' + VarToJSON(O) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TExtObjectList; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index]) + ',' + VarToJSON(Key) + ',' + VarToJSON([O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TExtObject; O : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Key, false]) + ',' + VarToJSON(O) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TExtObject; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Key, false, O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TArrayOfString; O : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Key]) + ',' + VarToJSON(O) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : TArrayOfString; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Key, O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Insert(Index : Integer; Key : String; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.insert(' + VarToJSON([Index, Key, O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Last : TExtFunction; begin
  JSCode(JSName + '.last();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Remove(O : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveAll(Items : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON(Items) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.removeAt(' + VarToJSON([Index]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveAtKey(Key : String) : TExtFunction; begin
  JSCode(JSName + '.removeAtKey(' + VarToJSON([Key]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.RemoveRange(Index : Integer; RemoveCount : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.removeRange(' + VarToJSON([Index, RemoveCount]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Replace(Key : String; O : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.replace(' + VarToJSON([Key, O, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.Sum(PropertyJS : String; Root : String = ''; Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.sum(' + VarToJSON([PropertyJS, Root, Start, EndJS]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

function TExtUtilAbstractMixedCollection.UpdateKey(OldKey : TExtObject; NewKey : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.updateKey(' + VarToJSON([OldKey, false, NewKey, false]) + ');', 'TExtUtilAbstractMixedCollection');
  Result := Self;
end;

procedure TExtUtilAbstractMixedCollection.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(ParamAsInteger('Index'), TExtObject(ParamAsObject('O')), ParamAsString('Key'))
  else if (AEvtName = 'clear') and Assigned(FOnClear) then
    FOnClear()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtObject(ParamAsObject('O')), ParamAsString('Key'))
  else if (AEvtName = 'replace') and Assigned(FOnReplace) then
    FOnReplace(ParamAsString('Key'), TExtObject(ParamAsObject('Old')), TExtObject(ParamAsObject('New')));
end;

function TExtUtilInflectorSingleton.JSClassName : string; begin
  Result := 'Ext.util.Inflector';
end;

{$IFDEF FPC}constructor TExtUtilInflectorSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilInflectorSingleton.Classify(Word : String) : TExtFunction; begin
  JSCode(JSName + '.classify(' + VarToJSON([Word]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.ClearPlurals : TExtFunction; begin
  JSCode(JSName + '.clearPlurals();', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.ClearSingulars : TExtFunction; begin
  JSCode(JSName + '.clearSingulars();', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.IsTransnumeral(Word : String) : TExtFunction; begin
  JSCode(JSName + '.isTransnumeral(' + VarToJSON([Word]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.Ordinalize(Number : Integer) : TExtFunction; begin
  JSCode(JSName + '.ordinalize(' + VarToJSON([Number]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.Plural(Matcher : TRegExp; Replacer : String) : TExtFunction; begin
  JSCode(JSName + '.plural(' + VarToJSON([#3 + Matcher, Replacer]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.Pluralize(Word : String) : TExtFunction; begin
  JSCode(JSName + '.pluralize(' + VarToJSON([Word]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.Singular(Matcher : TRegExp; Replacer : String) : TExtFunction; begin
  JSCode(JSName + '.singular(' + VarToJSON([#3 + Matcher, Replacer]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

function TExtUtilInflectorSingleton.Singularize(Word : String) : TExtFunction; begin
  JSCode(JSName + '.singularize(' + VarToJSON([Word]) + ');', 'TExtUtilInflectorSingleton');
  Result := Self;
end;

procedure TExtUtilHistorySingleton.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilHistorySingleton.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilHistorySingleton.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilHistorySingleton.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtUtilHistorySingleton.SetFOnChange(Value : TExtUtilHistorySingletonOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['Token', '%0'], true));
  FOnChange := Value;
end;

procedure TExtUtilHistorySingleton.SetFOnReady(Value : TExtUtilHistorySingletonOnReady); begin
  if Assigned(FOnReady) then
    JSCode(JSName+'.events ["ready"].listeners=[];');
  if Assigned(Value) then
    AddListener('ready', Ajax('ready', ['The', '%0.nm'], true));
  FOnReady := Value;
end;

function TExtUtilHistorySingleton.JSClassName : string; begin
  Result := 'Ext.util.History';
end;

{$IFDEF FPC}constructor TExtUtilHistorySingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilHistorySingleton.Add(Token : String; PreventDuplicates : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Token, PreventDuplicates]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.Back : TExtFunction; begin
  JSCode(JSName + '.back();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.Forward : TExtFunction; begin
  JSCode(JSName + '.forward();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.GetToken : TExtFunction; begin
  JSCode(JSName + '.getToken();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.Init(OnReady : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.init(' + VarToJSON([OnReady, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

function TExtUtilHistorySingleton.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtUtilHistorySingleton');
  Result := Self;
end;

procedure TExtUtilHistorySingleton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(ParamAsString('Token'))
  else if (AEvtName = 'ready') and Assigned(FOnReady) then
    FOnReady(TExtUtilHistory(ParamAsObject('The')));
end;

function TExtRtlPanelHeader.JSClassName : string; begin
  Result := 'Ext.rtl.panel.Header';
end;

{$IFDEF FPC}constructor TExtRtlPanelHeader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomElement_position.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Element_position';
end;

{$IFDEF FPC}constructor TExtRtlDomElement_position.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomElement_scroll.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Element_scroll';
end;

{$IFDEF FPC}constructor TExtRtlDomElement_scroll.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomElement_anim.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Element_anim';
end;

{$IFDEF FPC}constructor TExtRtlDomElement_anim.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomElement_insertion.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Element_insertion';
end;

{$IFDEF FPC}constructor TExtRtlDomElement_insertion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlEventObjectImpl.JSClassName : string; begin
  Result := 'Ext.rtl.EventObjectImpl';
end;

{$IFDEF FPC}constructor TExtRtlEventObjectImpl.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlFormFieldSpinner.JSClassName : string; begin
  Result := 'Ext.rtl.form.field.Spinner';
end;

{$IFDEF FPC}constructor TExtRtlFormFieldSpinner.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomElement_static.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Element_static';
end;

{$IFDEF FPC}constructor TExtRtlDomElement_static.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDomLayer.JSClassName : string; begin
  Result := 'Ext.rtl.dom.Layer';
end;

{$IFDEF FPC}constructor TExtRtlDomLayer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPerfAccumulator.JSClassName : string; begin
  Result := 'Ext.perf.Accumulator';
end;

{$IFDEF FPC}constructor TExtPerfAccumulator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPerfMonitorSingleton.JSClassName : string; begin
  Result := 'Ext.perf.Monitor';
end;

{$IFDEF FPC}constructor TExtPerfMonitorSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtPanelProxy.SetFInsertProxy(Value : Boolean); begin
  FInsertProxy := Value;
  JSCode('insertProxy:' + VarToJSON([Value]));
end;

procedure TExtPanelProxy.SetFMoveOnDrag(Value : Boolean); begin
  FMoveOnDrag := Value;
  JSCode('moveOnDrag:' + VarToJSON([Value]));
end;

function TExtPanelProxy.JSClassName : string; begin
  Result := 'Ext.panel.Proxy';
end;

{$IFDEF FPC}constructor TExtPanelProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanelProxy.Create(Panel : TExtPanel; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Panel, false, Config, false]) + ');');
  InitDefaults;
end;

function TExtPanelProxy.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtPanelProxy');
  Result := Self;
end;

function TExtPanelProxy.GetGhost : TExtFunction; begin
  JSCode(JSName + '.getGhost();', 'TExtPanelProxy');
  Result := Self;
end;

function TExtPanelProxy.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtPanelProxy');
  Result := Self;
end;

function TExtPanelProxy.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtPanelProxy');
  Result := Self;
end;

function TExtPanelProxy.MoveProxy(ParentNode : THTMLElement; Before : THTMLElement = nil) : TExtFunction; begin
  JSCode(JSName + '.moveProxy(' + VarToJSON([ParentNode, false, Before, false]) + ');', 'TExtPanelProxy');
  Result := Self;
end;

function TExtPanelProxy.Show : TExtFunction; begin
  JSCode(JSName + '.show();', 'TExtPanelProxy');
  Result := Self;
end;

procedure TExtUtilObservable.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilObservable.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtUtilObservable.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilObservable.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

function TExtUtilObservable.JSClassName : string; begin
  Result := 'Ext.util.Observable';
end;

procedure TExtUtilObservable.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtUtilObservable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilObservable.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtUtilObservable');
  Result := Self;
end;

constructor TExtUtilObservable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtUtilObservable.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

function TExtUtilObservable.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtUtilObservable');
  Result := Self;
end;

destructor TExtUtilObservable.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
  except end;
  inherited;
end;

function TExtRtlButton.JSClassName : string; begin
  Result := 'Ext.rtl.button.Button';
end;

{$IFDEF FPC}constructor TExtRtlButton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlDdDD.JSClassName : string; begin
  Result := 'Ext.rtl.dd.DD';
end;

{$IFDEF FPC}constructor TExtRtlDdDD.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtResizer.SetFConstrainTo(Value : TExtElement); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFConstrainToRegion(Value : TExtUtilRegion); begin
  FConstrainToRegion := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFEl(Value : TExtElement); begin
  FEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.el=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFHandles(Value : String); begin
  FHandles := Value;
  JSCode('handles:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFHeight(Value : Integer); begin
  FHeight := Value;
  JSCode('height:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFHeightIncrement(Value : Integer); begin
  FHeightIncrement := Value;
  JSCode('heightIncrement:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtResizer.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFMaxHeight(Value : Integer); begin
  FMaxHeight := Value;
  JSCode('maxHeight:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMinHeight(Value : Integer); begin
  FMinHeight := Value;
  JSCode('minHeight:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFOriginalTarget(Value : TExtElement); begin
  FOriginalTarget := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalTarget=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFOriginalTargetComponent(Value : TExtComponent); begin
  FOriginalTargetComponent := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalTarget=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFPinned(Value : Boolean); begin
  FPinned := Value;
  JSCode('pinned:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFPreserveRatio(Value : Boolean); begin
  FPreserveRatio := Value;
  JSCode('preserveRatio:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFResizeTracker(Value : TExtResizerResizeTracker); begin
  FResizeTracker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.resizeTracker=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtResizer.SetFTarget(Value : TExtElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFTargetComponent(Value : TExtComponent); begin
  FTargetComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtResizer.SetFTransparent(Value : Boolean); begin
  FTransparent := Value;
  JSCode('transparent:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFWidthIncrement(Value : Integer); begin
  FWidthIncrement := Value;
  JSCode('widthIncrement:' + VarToJSON([Value]));
end;

procedure TExtResizer.SetFOnBeforeresize(Value : TExtResizerOnBeforeresize); begin
  if Assigned(FOnBeforeresize) then
    JSCode(JSName+'.events ["beforeresize"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeresize', Ajax('beforeresize', ['This', '%0.nm','Width', '%1','Height', '%2','E', '%3.nm'], true));
  FOnBeforeresize := Value;
end;

procedure TExtResizer.SetFOnResize(Value : TExtResizerOnResize); begin
  if Assigned(FOnResize) then
    JSCode(JSName+'.events ["resize"].listeners=[];');
  if Assigned(Value) then
    AddListener('resize', Ajax('resize', ['This', '%0.nm','Width', '%1','Height', '%2','E', '%3.nm'], true));
  FOnResize := Value;
end;

procedure TExtResizer.SetFOnResizedrag(Value : TExtResizerOnResizedrag); begin
  if Assigned(FOnResizedrag) then
    JSCode(JSName+'.events ["resizedrag"].listeners=[];');
  if Assigned(Value) then
    AddListener('resizedrag', Ajax('resizedrag', ['This', '%0.nm','Width', '%1','Height', '%2','E', '%3.nm'], true));
  FOnResizedrag := Value;
end;

function TExtResizer.JSClassName : string; begin
  Result := 'Ext.resizer.Resizer';
end;

procedure TExtResizer.InitDefaults; begin
  inherited;
  FConstrainTo := TExtElement.CreateInternal(Self, 'constrainTo');
  FConstrainToRegion := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FEl := TExtElement.CreateInternal(Self, 'el');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHandles := 's e se';
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FOriginalTarget := TExtElement.CreateInternal(Self, 'originalTarget');
  FOriginalTargetComponent := TExtComponent.CreateInternal(Self, 'originalTarget');
  FResizeTracker := TExtResizerResizeTracker.CreateInternal(Self, 'resizeTracker');
  FTarget := TExtElement.CreateInternal(Self, 'target');
  FTargetComponent := TExtComponent.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtResizer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtResizer.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtResizer');
  Result := Self;
end;

constructor TExtResizer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtResizer.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ResizeTo(Width : Integer; Height : Integer) : TExtFunction; begin
  JSCode(JSName + '.resizeTo(' + VarToJSON([Width, Height]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtResizer');
  Result := Self;
end;

function TExtResizer.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtResizer');
  Result := Self;
end;

destructor TExtResizer.Destroy; begin
  try
    FConstrainTo.Free;
    FConstrainToRegion.Free;
    FEl.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FOriginalTarget.Free;
    FOriginalTargetComponent.Free;
    FResizeTracker.Free;
    FTarget.Free;
    FTargetComponent.Free;
  except end;
  inherited;
end;

procedure TExtResizer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeresize') and Assigned(FOnBeforeresize) then
    FOnBeforeresize(TExtResizer(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'resize') and Assigned(FOnResize) then
    FOnResize(TExtResizer(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'resizedrag') and Assigned(FOnResizedrag) then
    FOnResizedrag(TExtResizer(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtRtlAbstractComponent.SetFRtl(Value : Boolean); begin
  FRtl := Value;
  JSCode('rtl:' + VarToJSON([Value]));
end;

function TExtRtlAbstractComponent.JSClassName : string; begin
  Result := 'Ext.rtl.AbstractComponent';
end;

{$IFDEF FPC}constructor TExtRtlAbstractComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerBoxOverflowScroller.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.boxOverflow.Scroller';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerBoxOverflowScroller.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerColumn.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.Column';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerAbsolute.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.Absolute';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerAbsolute.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerBox.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.Box';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContextItem.JSClassName : string; begin
  Result := 'Ext.rtl.layout.ContextItem';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlPanel.JSClassName : string; begin
  Result := 'Ext.rtl.panel.Panel';
end;

{$IFDEF FPC}constructor TExtRtlPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerHBox.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.HBox';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerHBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutContainerVBox.JSClassName : string; begin
  Result := 'Ext.rtl.layout.container.VBox';
end;

{$IFDEF FPC}constructor TExtRtlLayoutContainerVBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlGridPluginHeaderResizer.JSClassName : string; begin
  Result := 'Ext.rtl.grid.plugin.HeaderResizer';
end;

{$IFDEF FPC}constructor TExtRtlGridPluginHeaderResizer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlGridPluginRowEditing.JSClassName : string; begin
  Result := 'Ext.rtl.grid.plugin.RowEditing';
end;

{$IFDEF FPC}constructor TExtRtlGridPluginRowEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlFormFieldTrigger.JSClassName : string; begin
  Result := 'Ext.rtl.form.field.Trigger';
end;

{$IFDEF FPC}constructor TExtRtlFormFieldTrigger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlGridColumn.JSClassName : string; begin
  Result := 'Ext.rtl.grid.column.Column';
end;

{$IFDEF FPC}constructor TExtRtlGridColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutComponentFieldText.JSClassName : string; begin
  Result := 'Ext.rtl.layout.component.field.Text';
end;

{$IFDEF FPC}constructor TExtRtlLayoutComponentFieldText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutComponentFieldTrigger.JSClassName : string; begin
  Result := 'Ext.rtl.layout.component.field.Trigger';
end;

{$IFDEF FPC}constructor TExtRtlLayoutComponentFieldTrigger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlGridRowEditor.JSClassName : string; begin
  Result := 'Ext.rtl.grid.RowEditor';
end;

{$IFDEF FPC}constructor TExtRtlGridRowEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtRtlLayoutComponentDock.JSClassName : string; begin
  Result := 'Ext.rtl.layout.component.Dock';
end;

{$IFDEF FPC}constructor TExtRtlLayoutComponentDock.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataBatch.SetFAutoStart(Value : Boolean); begin
  FAutoStart := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDataBatch.SetFCurrent(Value : Integer); begin
  FCurrent := Value;
  JSCode(JSName + '.current=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFExceptions(Value : TExtObjectList); begin
  FExceptions := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.exceptions=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataBatch.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataBatch.SetFHasException(Value : Boolean); begin
  FHasException := Value;
  JSCode(JSName + '.hasException=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataBatch.SetFIsComplete(Value : Boolean); begin
  FIsComplete := Value;
  JSCode(JSName + '.isComplete=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFIsRunning(Value : Boolean); begin
  FIsRunning := Value;
  JSCode(JSName + '.isRunning=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataBatch.SetFOperations(Value : TExtObjectList); begin
  FOperations := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.operations=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataBatch.SetFPauseOnException(Value : Boolean); begin
  FPauseOnException := Value;
  JSCode('pauseOnException:' + VarToJSON([Value]));
end;

procedure TExtDataBatch.SetFTotal(Value : Integer); begin
  FTotal := Value;
  JSCode(JSName + '.total=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataBatch.SetFOnComplete(Value : TExtDataBatchOnComplete); begin
  if Assigned(FOnComplete) then
    JSCode(JSName+'.events ["complete"].listeners=[];');
  if Assigned(Value) then
    AddListener('complete', Ajax('complete', ['Batch', '%0.nm','Operation', '%1.nm'], true));
  FOnComplete := Value;
end;

procedure TExtDataBatch.SetFOnException(Value : TExtDataBatchOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['Batch', '%0.nm','Operation', '%1.nm'], true));
  FOnException := Value;
end;

procedure TExtDataBatch.SetFOnOperationcomplete(Value : TExtDataBatchOnOperationcomplete); begin
  if Assigned(FOnOperationcomplete) then
    JSCode(JSName+'.events ["operationcomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('operationcomplete', Ajax('operationcomplete', ['Batch', '%0.nm','Operation', '%1.nm'], true));
  FOnOperationcomplete := Value;
end;

function TExtDataBatch.JSClassName : string; begin
  Result := 'Ext.data.Batch';
end;

procedure TExtDataBatch.InitDefaults; begin
  inherited;
  FExceptions := TExtObjectList.Create(Self, 'exceptions');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FOperations := TExtObjectList.Create(Self, 'operations');
end;

{$IFDEF FPC}constructor TExtDataBatch.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataBatch.Add(Operation : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Operation, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataBatch');
  Result := Self;
end;

constructor TExtDataBatch.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataBatch.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Pause : TExtFunction; begin
  JSCode(JSName + '.pause();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Retry : TExtFunction; begin
  JSCode(JSName + '.retry();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.RunOperation(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.runOperation(' + VarToJSON([Index]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.Start : TExtFunction; begin
  JSCode(JSName + '.start();', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataBatch');
  Result := Self;
end;

function TExtDataBatch.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataBatch');
  Result := Self;
end;

destructor TExtDataBatch.Destroy; begin
  try
    FExceptions.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FOperations.Free;
  except end;
  inherited;
end;

procedure TExtDataBatch.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'complete') and Assigned(FOnComplete) then
    FOnComplete(TExtDataBatch(ParamAsObject('Batch')), TExtObject(ParamAsObject('Operation')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDataBatch(ParamAsObject('Batch')), TExtObject(ParamAsObject('Operation')))
  else if (AEvtName = 'operationcomplete') and Assigned(FOnOperationcomplete) then
    FOnOperationcomplete(TExtDataBatch(ParamAsObject('Batch')), TExtObject(ParamAsObject('Operation')));
end;

procedure TExtDataAssociationHasOne.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFGetterName(Value : String); begin
  FGetterName := Value;
  JSCode('getterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFSetterName(Value : String); begin
  FSetterName := Value;
  JSCode('setterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasOne.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationHasOne.JSClassName : string; begin
  Result := 'Ext.data.association.HasOne';
end;

procedure TExtDataAssociationHasOne.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FGetterName := 'get';
  FSetterName := 'set';
end;

{$IFDEF FPC}constructor TExtDataAssociationHasOne.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationHasOne.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtDataConnection.SetFAutoAbort(Value : Boolean); begin
  FAutoAbort := Value;
  JSCode('autoAbort:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFBinary(Value : Boolean); begin
  FBinary := Value;
  JSCode('binary:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFCors(Value : Boolean); begin
  FCors := Value;
  JSCode('cors:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFDefaultHeaders(Value : TExtObject); begin
  FDefaultHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultHeaders:' + VarToJSON([Value, false]));
end;

procedure TExtDataConnection.SetFDisableCaching(Value : Boolean); begin
  FDisableCaching := Value;
  JSCode('disableCaching:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFDisableCachingParam(Value : String); begin
  FDisableCachingParam := Value;
  JSCode('disableCachingParam:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode('extraParams:' + VarToJSON([Value, false]));
end;

procedure TExtDataConnection.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataConnection.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataConnection.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataConnection.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataConnection.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFWithCredentials(Value : Boolean); begin
  FWithCredentials := Value;
  JSCode('withCredentials:' + VarToJSON([Value]));
end;

procedure TExtDataConnection.SetFOnBeforerequest(Value : TExtDataConnectionOnBeforerequest); begin
  if Assigned(FOnBeforerequest) then
    JSCode(JSName+'.events ["beforerequest"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerequest', Ajax('beforerequest', ['Conn', '%0.nm','Options', '%1.nm'], true));
  FOnBeforerequest := Value;
end;

procedure TExtDataConnection.SetFOnRequestcomplete(Value : TExtDataConnectionOnRequestcomplete); begin
  if Assigned(FOnRequestcomplete) then
    JSCode(JSName+'.events ["requestcomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('requestcomplete', Ajax('requestcomplete', ['Conn', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnRequestcomplete := Value;
end;

procedure TExtDataConnection.SetFOnRequestexception(Value : TExtDataConnectionOnRequestexception); begin
  if Assigned(FOnRequestexception) then
    JSCode(JSName+'.events ["requestexception"].listeners=[];');
  if Assigned(Value) then
    AddListener('requestexception', Ajax('requestexception', ['Conn', '%0.nm','Response', '%1.nm','Options', '%2.nm'], true));
  FOnRequestexception := Value;
end;

function TExtDataConnection.JSClassName : string; begin
  Result := 'Ext.data.Connection';
end;

procedure TExtDataConnection.InitDefaults; begin
  inherited;
  FDefaultHeaders := TExtObject.CreateInternal(Self, 'defaultHeaders');
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtDataConnection.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataConnection.Abort(Request : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.abort(' + VarToJSON([Request, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AbortAll : TExtFunction; begin
  JSCode(JSName + '.abortAll();', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataConnection');
  Result := Self;
end;

constructor TExtDataConnection.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataConnection.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.IsLoading(Request : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.isLoading(' + VarToJSON([Request, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ParseStatus(Status : Integer) : TExtFunction; begin
  JSCode(JSName + '.parseStatus(' + VarToJSON([Status]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Request(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.request(' + VarToJSON([Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.SetOptions(Options : TExtObject; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setOptions(' + VarToJSON([Options, false, Scope, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : THTMLElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Upload(' + VarToJSON([Form, false, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : TExtElement; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Upload(' + VarToJSON([Form, false, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

function TExtDataConnection.Upload(Form : String; Url : String; Params : String; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.upload(' + VarToJSON([Form, Url, Params, Options, false]) + ');', 'TExtDataConnection');
  Result := Self;
end;

destructor TExtDataConnection.Destroy; begin
  try
    FDefaultHeaders.Free;
    FExtraParams.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtDataConnection.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforerequest') and Assigned(FOnBeforerequest) then
    FOnBeforerequest(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'requestcomplete') and Assigned(FOnRequestcomplete) then
    FOnRequestcomplete(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'requestexception') and Assigned(FOnRequestexception) then
    FOnRequestexception(TExtDataConnection(ParamAsObject('Conn')), TExtObject(ParamAsObject('Response')), TExtObject(ParamAsObject('Options')));
end;

procedure TExtDataFlashBinaryXhr.SetFReadyState(Value : Integer); begin
  FReadyState := Value;
  JSCode(JSName + '.readyState=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataFlashBinaryXhr.SetFResponseBytes(Value : TExtObjectList); begin
  FResponseBytes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.responseBytes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataFlashBinaryXhr.SetFStatus(Value : Integer); begin
  FStatus := Value;
  JSCode(JSName + '.status=' + VarToJSON([Value]) + ';');
end;

function TExtDataFlashBinaryXhr.JSClassName : string; begin
  Result := 'Ext.data.flash.BinaryXhr';
end;

procedure TExtDataFlashBinaryXhr.InitDefaults; begin
  inherited;
  FResponseBytes := TExtObjectList.Create(Self, 'responseBytes');
end;

{$IFDEF FPC}constructor TExtDataFlashBinaryXhr.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataFlashBinaryXhr.Abort : TExtFunction; begin
  JSCode(JSName + '.abort();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

constructor TExtDataFlashBinaryXhr.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataFlashBinaryXhr.GetAllResponseHeaders : TExtFunction; begin
  JSCode(JSName + '.getAllResponseHeaders();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

function TExtDataFlashBinaryXhr.GetResponseHeader : TExtFunction; begin
  JSCode(JSName + '.getResponseHeader();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

function TExtDataFlashBinaryXhr.Open : TExtFunction; begin
  JSCode(JSName + '.open();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

function TExtDataFlashBinaryXhr.OverrideMimeType : TExtFunction; begin
  JSCode(JSName + '.overrideMimeType();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

function TExtDataFlashBinaryXhr.Send(Body : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.send(' + VarToJSON(Body) + ');', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

function TExtDataFlashBinaryXhr.SetRequestHeader : TExtFunction; begin
  JSCode(JSName + '.setRequestHeader();', 'TExtDataFlashBinaryXhr');
  Result := Self;
end;

destructor TExtDataFlashBinaryXhr.Destroy; begin
  try
    FResponseBytes.Free;
  except end;
  inherited;
end;

procedure TExtDataField.SetFConvert(Value : TExtFunction); begin
  FConvert := Value;
  JSCode('convert:' + VarToJSON([Value, true]));
end;

procedure TExtDataField.SetFDateFormat(Value : String); begin
  FDateFormat := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFDateReadFormat(Value : String); begin
  FDateReadFormat := Value;
  JSCode('dateReadFormat:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFDateWriteFormat(Value : String); begin
  FDateWriteFormat := Value;
  JSCode('dateWriteFormat:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFDefaultValue(Value : TExtObject); begin
  FDefaultValue := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultValue:' + VarToJSON([Value, false]));
end;

procedure TExtDataField.SetFMapping(Value : Integer); begin
  FMapping := Value;
  JSCode('mapping:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFMappingString(Value : String); begin
  FMappingString := Value;
  JSCode('mapping:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFPersist(Value : Boolean); begin
  FPersist := Value;
  JSCode('persist:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFSerialize(Value : TExtFunction); begin
  FSerialize := Value;
  JSCode('serialize:' + VarToJSON([Value, true]));
end;

procedure TExtDataField.SetFSortDir(Value : String); begin
  FSortDir := Value;
  JSCode('sortDir:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFSortType(Value : TExtFunction); begin
  FSortType := Value;
  JSCode('sortType:' + VarToJSON([Value, true]));
end;

procedure TExtDataField.SetFSortTypeString(Value : String); begin
  FSortTypeString := Value;
  JSCode('sortType:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtDataField.SetFTypeJSObject(Value : TExtObject); begin
  FTypeJSObject := Value;
  Value.DeleteFromGarbage;
  JSCode('typeJS:' + VarToJSON([Value, false]));
end;

procedure TExtDataField.SetFUseNull(Value : Boolean); begin
  FUseNull := Value;
  JSCode('useNull:' + VarToJSON([Value]));
end;

function TExtDataField.JSClassName : string; begin
  Result := 'Ext.data.Field';
end;

procedure TExtDataField.InitDefaults; begin
  inherited;
  FDefaultValue := TExtObject.CreateInternal(Self, 'defaultValue');
  FPersist := true;
  FSortDir := 'ASC';
  FTypeJSObject := TExtObject.CreateInternal(Self, 'typeJS');
end;

{$IFDEF FPC}constructor TExtDataField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataField.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataField.Destroy; begin
  try
    FDefaultValue.Free;
    FTypeJSObject.Free;
  except end;
  inherited;
end;

procedure TExtDataAssociationHasMany.SetFFilterProperty(Value : String); begin
  FFilterProperty := Value;
  JSCode('filterProperty:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationHasMany.SetFStoreConfig(Value : TExtObject); begin
  FStoreConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('storeConfig:' + VarToJSON([Value, false]));
end;

procedure TExtDataAssociationHasMany.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationHasMany.JSClassName : string; begin
  Result := 'Ext.data.association.HasMany';
end;

procedure TExtDataAssociationHasMany.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FStoreConfig := TExtObject.CreateInternal(Self, 'storeConfig');
end;

{$IFDEF FPC}constructor TExtDataAssociationHasMany.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationHasMany.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataAssociationHasMany.Destroy; begin
  try
    FStoreConfig.Free;
  except end;
  inherited;
end;

function TExtContainerMonitor.JSClassName : string; begin
  Result := 'Ext.container.Monitor';
end;

{$IFDEF FPC}constructor TExtContainerMonitor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtContainerDockingContainer.SetFDefaultDockWeights(Value : TExtObject); begin
  FDefaultDockWeights := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultDockWeights:' + VarToJSON([Value, false]));
end;

procedure TExtContainerDockingContainer.SetFOnDockedadd(Value : TExtContainerDockingContainerOnDockedadd); begin
  if Assigned(FOnDockedadd) then
    JSCode(JSName+'.events ["dockedadd"].listeners=[];');
  if Assigned(Value) then
    AddListener('dockedadd', Ajax('dockedadd', ['This', '%0.nm','Component', '%1.nm','Index', '%2'], true));
  FOnDockedadd := Value;
end;

procedure TExtContainerDockingContainer.SetFOnDockedremove(Value : TExtContainerDockingContainerOnDockedremove); begin
  if Assigned(FOnDockedremove) then
    JSCode(JSName+'.events ["dockedremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('dockedremove', Ajax('dockedremove', ['This', '%0.nm','Component', '%1.nm'], true));
  FOnDockedremove := Value;
end;

function TExtContainerDockingContainer.JSClassName : string; begin
  Result := 'Ext.container.DockingContainer';
end;

procedure TExtContainerDockingContainer.InitDefaults; begin
  inherited;
  FDefaultDockWeights := TExtObject.CreateInternal(Self, 'defaultDockWeights');
end;

{$IFDEF FPC}constructor TExtContainerDockingContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtContainerDockingContainer.AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.AddDocked(' + VarToJSON(Component) + ',' + VarToJSON([Pos]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.addDocked(' + VarToJSON([Component, false, Pos]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

constructor TExtContainerDockingContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtContainerDockingContainer.GetDockedComponent(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.GetDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.GetDockedComponent(Comp : Integer) : TExtFunction; begin
  JSCode(JSName + '.getDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getDockedItems(' + VarToJSON([Selector, BeforeBody]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.InsertDocked(' + VarToJSON([Pos]) + ',' + VarToJSON(Component) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.insertDocked(' + VarToJSON([Pos, Component, false]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

function TExtContainerDockingContainer.RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeDocked(' + VarToJSON([Item, false, AutoDestroy]) + ');', 'TExtContainerDockingContainer');
  Result := Self;
end;

destructor TExtContainerDockingContainer.Destroy; begin
  try
    FDefaultDockWeights.Free;
  except end;
  inherited;
end;

procedure TExtContainerDockingContainer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'dockedadd') and Assigned(FOnDockedadd) then
    FOnDockedadd(TExtContainerDockingContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')), ParamAsInteger('Index'))
  else if (AEvtName = 'dockedremove') and Assigned(FOnDockedremove) then
    FOnDockedremove(TExtContainerDockingContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')));
end;

procedure TExtDataAbstractStore.SetFAutoLoad(Value : Boolean); begin
  FAutoLoad := Value;
  JSCode('autoLoad:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFAutoLoadObject(Value : TExtObject); begin
  FAutoLoadObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoLoad:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFAutoSync(Value : Boolean); begin
  FAutoSync := Value;
  JSCode('autoSync:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFBatchUpdateMode(Value : String); begin
  FBatchUpdateMode := Value;
  JSCode('batchUpdateMode:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFDefaultProxyType(Value : String); begin
  FDefaultProxyType := Value;
  JSCode(JSName + '.defaultProxyType=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAbstractStore.SetFDefaultSortDirection(Value : String); begin
  FDefaultSortDirection := Value;
  JSCode('defaultSortDirection:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFFields(Value : TExtObjectList); begin
  FFields := Value;
  Value.DeleteFromGarbage;
  JSCode('fields:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFFilterOnLoad(Value : Boolean); begin
  FFilterOnLoad := Value;
  JSCode('filterOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFFilters(Value : TExtObjectList); begin
  FFilters := Value;
  Value.DeleteFromGarbage;
  JSCode('filters:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFFiltersList(Value : TExtObjectList); begin
  FFiltersList := Value;
  Value.DeleteFromGarbage;
  JSCode('filters:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataAbstractStore.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataAbstractStore.SetFIsDestroyed(Value : Boolean); begin
  FIsDestroyed := Value;
  JSCode(JSName + '.isDestroyed=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAbstractStore.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAbstractStore.SetFIsSortable(Value : Boolean); begin
  FIsSortable := Value;
  JSCode(JSName + '.isSortable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAbstractStore.SetFIsStore(Value : Boolean); begin
  FIsStore := Value;
  JSCode(JSName + '.isStore=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAbstractStore.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFModel(Value : String); begin
  FModel := Value;
  JSCode('model:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFProxy(Value : String); begin
  FProxy := Value;
  JSCode('proxy:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFProxyObject(Value : TExtObject); begin
  FProxyObject := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFProxyProxy(Value : TExtDataProxy); begin
  FProxyProxy := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFRemoteFilter(Value : Boolean); begin
  FRemoteFilter := Value;
  JSCode('remoteFilter:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFRemoteSort(Value : Boolean); begin
  FRemoteSort := Value;
  JSCode('remoteSort:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFSortersList(Value : TExtObjectList); begin
  FSortersList := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtDataAbstractStore.SetFSortOnLoad(Value : Boolean); begin
  FSortOnLoad := Value;
  JSCode('sortOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFSortRoot(Value : String); begin
  FSortRoot := Value;
  JSCode('sortRoot:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFStatefulFilters(Value : Boolean); begin
  FStatefulFilters := Value;
  JSCode('statefulFilters:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFStoreId(Value : String); begin
  FStoreId := Value;
  JSCode('storeId:' + VarToJSON([Value]));
end;

procedure TExtDataAbstractStore.SetFOnAdd(Value : TExtDataAbstractStoreOnAdd); begin
  if Assigned(FOnAdd) then
    JSCode(JSName+'.events ["add"].listeners=[];');
  if Assigned(Value) then
    AddListener('add', Ajax('add', ['Store', '%0.nm','Records', '%1.nm','Index', '%2'], true));
  FOnAdd := Value;
end;

procedure TExtDataAbstractStore.SetFOnBeforeload(Value : TExtDataAbstractStoreOnBeforeload); begin
  if Assigned(FOnBeforeload) then
    JSCode(JSName+'.events ["beforeload"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeload', Ajax('beforeload', ['Store', '%0.nm','Operation', '%1.nm'], true));
  FOnBeforeload := Value;
end;

procedure TExtDataAbstractStore.SetFOnBeforesync(Value : TExtDataAbstractStoreOnBeforesync); begin
  if Assigned(FOnBeforesync) then
    JSCode(JSName+'.events ["beforesync"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforesync', Ajax('beforesync', ['Options', '%0.nm'], true));
  FOnBeforesync := Value;
end;

procedure TExtDataAbstractStore.SetFOnBulkremove(Value : TExtDataAbstractStoreOnBulkremove); begin
  if Assigned(FOnBulkremove) then
    JSCode(JSName+'.events ["bulkremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('bulkremove', Ajax('bulkremove', ['Store', '%0.nm','Records', '%1.nm','Indexes', '%2.nm','IsMove', '%3'], true));
  FOnBulkremove := Value;
end;

procedure TExtDataAbstractStore.SetFOnClear(Value : TExtDataAbstractStoreOnClear); begin
  if Assigned(FOnClear) then
    JSCode(JSName+'.events ["clear"].listeners=[];');
  if Assigned(Value) then
    AddListener('clear', Ajax('clear', ['This', '%0.nm'], true));
  FOnClear := Value;
end;

procedure TExtDataAbstractStore.SetFOnDatachanged(Value : TExtDataAbstractStoreOnDatachanged); begin
  if Assigned(FOnDatachanged) then
    JSCode(JSName+'.events ["datachanged"].listeners=[];');
  if Assigned(Value) then
    AddListener('datachanged', Ajax('datachanged', ['This', '%0.nm'], true));
  FOnDatachanged := Value;
end;

procedure TExtDataAbstractStore.SetFOnLoad(Value : TExtDataAbstractStoreOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['This', '%0.nm','Records', '%1.nm','Successful', '%2'], true));
  FOnLoad := Value;
end;

procedure TExtDataAbstractStore.SetFOnMetachange(Value : TExtDataAbstractStoreOnMetachange); begin
  if Assigned(FOnMetachange) then
    JSCode(JSName+'.events ["metachange"].listeners=[];');
  if Assigned(Value) then
    AddListener('metachange', Ajax('metachange', ['This', '%0.nm','Meta', '%1.nm'], true));
  FOnMetachange := Value;
end;

procedure TExtDataAbstractStore.SetFOnRefresh(Value : TExtDataAbstractStoreOnRefresh); begin
  if Assigned(FOnRefresh) then
    JSCode(JSName+'.events ["refresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('refresh', Ajax('refresh', ['This', '%0.nm'], true));
  FOnRefresh := Value;
end;

procedure TExtDataAbstractStore.SetFOnRemove(Value : TExtDataAbstractStoreOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['Store', '%0.nm','RecordJS', '%1.nm','Index', '%2','IsMove', '%3'], true));
  FOnRemove := Value;
end;

procedure TExtDataAbstractStore.SetFOnUpdate(Value : TExtDataAbstractStoreOnUpdate); begin
  if Assigned(FOnUpdate) then
    JSCode(JSName+'.events ["update"].listeners=[];');
  if Assigned(Value) then
    AddListener('update', Ajax('update', ['This', '%0.nm','RecordJS', '%1.nm','Operation', '%2','ModifiedFieldNames', '%3.nm'], true));
  FOnUpdate := Value;
end;

procedure TExtDataAbstractStore.SetFOnWrite(Value : TExtDataAbstractStoreOnWrite); begin
  if Assigned(FOnWrite) then
    JSCode(JSName+'.events ["write"].listeners=[];');
  if Assigned(Value) then
    AddListener('write', Ajax('write', ['Store', '%0.nm','Operation', '%1.nm'], true));
  FOnWrite := Value;
end;

function TExtDataAbstractStore.JSClassName : string; begin
  Result := 'Ext.data.AbstractStore';
end;

procedure TExtDataAbstractStore.InitDefaults; begin
  inherited;
  FAutoLoadObject := TExtObject.CreateInternal(Self, 'autoLoad');
  FFields := TExtObjectList.Create(Self, 'fields');
  FFilterOnLoad := true;
  FFilters := TExtObjectList.Create(Self, 'filters');
  FFiltersList := TExtObjectList.Create(Self, 'filters');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FProxyObject := TExtObject.CreateInternal(Self, 'proxy');
  FProxyProxy := TExtDataProxy.CreateInternal(Self, 'proxy');
  FSorters := TExtObjectList.Create(Self, 'sorters');
  FSortersList := TExtObjectList.Create(Self, 'sorters');
  FSortOnLoad := true;
end;

{$IFDEF FPC}constructor TExtDataAbstractStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataAbstractStore.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataAbstractStore');
  Result := Self;
end;

constructor TExtDataAbstractStore.Create(Store : TExtObject); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Store, false]) + ');');
  InitDefaults;
end;

constructor TExtDataAbstractStore.Create(Store : TExtDataAbstractStore); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Store, false]) + ');');
  InitDefaults;
end;

function TExtDataAbstractStore.CreateComparator(Sorters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.createComparator(' + VarToJSON(Sorters) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GenerateComparator : TExtFunction; begin
  JSCode(JSName + '.generateComparator();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetModifiedRecords : TExtFunction; begin
  JSCode(JSName + '.getModifiedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetNewRecords : TExtFunction; begin
  JSCode(JSName + '.getNewRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetRemovedRecords : TExtFunction; begin
  JSCode(JSName + '.getRemovedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.GetUpdatedRecords : TExtFunction; begin
  JSCode(JSName + '.getUpdatedRecords();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.InitSortable : TExtFunction; begin
  JSCode(JSName + '.initSortable();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Load(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Reload(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.reload(' + VarToJSON([Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ResumeAutoSync : TExtFunction; begin
  JSCode(JSName + '.resumeAutoSync();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SetProxy(Proxy : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SetProxy(Proxy : TExtDataProxy) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SetProxy(Proxy : String) : TExtFunction; begin
  JSCode(JSName + '.setProxy(' + VarToJSON([Proxy]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Sorters, Direction]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.Sort(' + VarToJSON(Sorters) + ',' + VarToJSON([Direction]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SuspendAutoSync : TExtFunction; begin
  JSCode(JSName + '.suspendAutoSync();', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

function TExtDataAbstractStore.Sync(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.sync(' + VarToJSON([Options, false]) + ');', 'TExtDataAbstractStore');
  Result := Self;
end;

destructor TExtDataAbstractStore.Destroy; begin
  try
    FAutoLoadObject.Free;
    FFields.Free;
    FFilters.Free;
    FFiltersList.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FProxyObject.Free;
    FProxyProxy.Free;
    FSorters.Free;
    FSortersList.Free;
  except end;
  inherited;
end;

procedure TExtDataAbstractStore.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Records')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeload') and Assigned(FOnBeforeload) then
    FOnBeforeload(TExtDataStore(ParamAsObject('Store')), TExtDataOperation(ParamAsObject('Operation')))
  else if (AEvtName = 'beforesync') and Assigned(FOnBeforesync) then
    FOnBeforesync(TExtObject(ParamAsObject('Options')))
  else if (AEvtName = 'bulkremove') and Assigned(FOnBulkremove) then
    FOnBulkremove(TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Records')), TArrayOfInteger(ParamAsObject('Indexes')), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'clear') and Assigned(FOnClear) then
    FOnClear(TExtDataAbstractStore(ParamAsObject('This')))
  else if (AEvtName = 'datachanged') and Assigned(FOnDatachanged) then
    FOnDatachanged(TExtDataAbstractStore(ParamAsObject('This')))
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtDataAbstractStore(ParamAsObject('This')), TExtObjectList(ParamAsObject('Records')), ParamAsBoolean('Successful'))
  else if (AEvtName = 'metachange') and Assigned(FOnMetachange) then
    FOnMetachange(TExtDataAbstractStore(ParamAsObject('This')), TExtObject(ParamAsObject('Meta')))
  else if (AEvtName = 'refresh') and Assigned(FOnRefresh) then
    FOnRefresh(TExtDataAbstractStore(ParamAsObject('This')))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtDataStore(ParamAsObject('Store')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'update') and Assigned(FOnUpdate) then
    FOnUpdate(TExtDataAbstractStore(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsString('Operation'), TArrayOfString(ParamAsObject('ModifiedFieldNames')))
  else if (AEvtName = 'write') and Assigned(FOnWrite) then
    FOnWrite(TExtDataStore(ParamAsObject('Store')), TExtDataOperation(ParamAsObject('Operation')));
end;

procedure TExtDataAssociationBelongsTo.SetFForeignKey(Value : String); begin
  FForeignKey := Value;
  JSCode('foreignKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFGetterName(Value : String); begin
  FGetterName := Value;
  JSCode('getterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFSetterName(Value : String); begin
  FSetterName := Value;
  JSCode('setterName:' + VarToJSON([Value]));
end;

procedure TExtDataAssociationBelongsTo.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

function TExtDataAssociationBelongsTo.JSClassName : string; begin
  Result := 'Ext.data.association.BelongsTo';
end;

procedure TExtDataAssociationBelongsTo.InitDefaults; begin
  inherited;
  FForeignKey := '_id';
  FGetterName := 'get';
  FSetterName := 'set';
end;

{$IFDEF FPC}constructor TExtDataAssociationBelongsTo.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociationBelongsTo.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtDataAssociation.SetFAssociatedModel(Value : String); begin
  FAssociatedModel := Value;
  JSCode('associatedModel:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFAssociatedName(Value : String); begin
  FAssociatedName := Value;
  JSCode(JSName + '.associatedName=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAssociation.SetFAssociationKey(Value : String); begin
  FAssociationKey := Value;
  JSCode('associationKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFModel(Value : String); begin
  FModel := Value;
  JSCode('model:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFOwnerModel(Value : String); begin
  FOwnerModel := Value;
  JSCode('ownerModel:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFOwnerName(Value : String); begin
  FOwnerName := Value;
  JSCode(JSName + '.ownerName=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataAssociation.SetFPrimaryKey(Value : String); begin
  FPrimaryKey := Value;
  JSCode('primaryKey:' + VarToJSON([Value]));
end;

procedure TExtDataAssociation.SetFReader(Value : TExtDataReader); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

function TExtDataAssociation.JSClassName : string; begin
  Result := 'Ext.data.association.Association';
end;

procedure TExtDataAssociation.InitDefaults; begin
  inherited;
  FReader := TExtDataReader.CreateInternal(Self, 'reader');
end;

{$IFDEF FPC}constructor TExtDataAssociation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataAssociation.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataAssociation.GetReader : TExtFunction; begin
  JSCode(JSName + '.getReader();', 'TExtDataAssociation');
  Result := Self;
end;

destructor TExtDataAssociation.Destroy; begin
  try
    FReader.Free;
  except end;
  inherited;
end;

procedure TExtDataRequest.SetFAction(Value : String); begin
  FAction := Value;
  JSCode('action:' + VarToJSON([Value]));
end;

procedure TExtDataRequest.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtDataRequest.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtDataRequest.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

function TExtDataRequest.JSClassName : string; begin
  Result := 'Ext.data.Request';
end;

procedure TExtDataRequest.InitDefaults; begin
  inherited;
  FParams := TExtObject.CreateInternal(Self, 'params');
end;

{$IFDEF FPC}constructor TExtDataRequest.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataRequest.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtDataRequest.Destroy; begin
  try
    FParams.Free;
  except end;
  inherited;
end;

procedure TExtDataReader.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataReader.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataReader.SetFIdProperty(Value : String); begin
  FIdProperty := Value;
  JSCode('idProperty:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFImplicitIncludes(Value : Boolean); begin
  FImplicitIncludes := Value;
  JSCode('implicitIncludes:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataReader.SetFIsReader(Value : Boolean); begin
  FIsReader := Value;
  JSCode(JSName + '.isReader=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataReader.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataReader.SetFMessageProperty(Value : String); begin
  FMessageProperty := Value;
  JSCode('messageProperty:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFMetaData(Value : TExtObject); begin
  FMetaData := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.metaData=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataReader.SetFRawData(Value : TExtObject); begin
  FRawData := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.rawData=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataReader.SetFReadRecordsOnFailure(Value : Boolean); begin
  FReadRecordsOnFailure := Value;
  JSCode('readRecordsOnFailure:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFSuccessProperty(Value : String); begin
  FSuccessProperty := Value;
  JSCode('successProperty:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFTotalProperty(Value : String); begin
  FTotalProperty := Value;
  JSCode('totalProperty:' + VarToJSON([Value]));
end;

procedure TExtDataReader.SetFOnException(Value : TExtDataReaderOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['Reader', '%0.nm','Response', '%1.nm','Error', '%2.nm'], true));
  FOnException := Value;
end;

function TExtDataReader.JSClassName : string; begin
  Result := 'Ext.data.reader.Reader';
end;

procedure TExtDataReader.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FMetaData := TExtObject.CreateInternal(Self, 'metaData');
  FRawData := TExtObject.CreateInternal(Self, 'rawData');
end;

{$IFDEF FPC}constructor TExtDataReader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataReader.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataReader');
  Result := Self;
end;

constructor TExtDataReader.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataReader.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.GetResponseData(Response : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getResponseData(' + VarToJSON([Response, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.Read(Response : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.read(' + VarToJSON([Response, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ReadRecords(Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.readRecords(' + VarToJSON([Data, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataReader');
  Result := Self;
end;

function TExtDataReader.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataReader');
  Result := Self;
end;

destructor TExtDataReader.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FMetaData.Free;
    FRawData.Free;
  except end;
  inherited;
end;

procedure TExtDataReader.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDataReader(ParamAsObject('Reader')), TXMLHttpRequest(ParamAsObject('Response')), TExtDataResultSet(ParamAsObject('Error')));
end;

procedure TExtDataResultSet.SetFCount(Value : Integer); begin
  FCount := Value;
  JSCode('count:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFLoaded(Value : Boolean); begin
  FLoaded := Value;
  JSCode('loaded:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFRecords(Value : TExtObjectList); begin
  FRecords := Value;
  Value.DeleteFromGarbage;
  JSCode('records:' + VarToJSON([Value, false]));
end;

procedure TExtDataResultSet.SetFSuccess(Value : Boolean); begin
  FSuccess := Value;
  JSCode('success:' + VarToJSON([Value]));
end;

procedure TExtDataResultSet.SetFTotal(Value : Integer); begin
  FTotal := Value;
  JSCode('total:' + VarToJSON([Value]));
end;

function TExtDataResultSet.JSClassName : string; begin
  Result := 'Ext.data.ResultSet';
end;

procedure TExtDataResultSet.InitDefaults; begin
  inherited;
  FRecords := TExtObjectList.Create(Self, 'records');
end;

{$IFDEF FPC}constructor TExtDataResultSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataResultSet.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtDataResultSet.Destroy; begin
  try
    FRecords.Free;
  except end;
  inherited;
end;

procedure TExtDataTree.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataTree.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataTree.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataTree.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataTree.SetFOnAppend(Value : TExtDataTreeOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', [], true));
  FOnAppend := Value;
end;

procedure TExtDataTree.SetFOnBeforeappend(Value : TExtDataTreeOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', [], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataTree.SetFOnBeforecollapse(Value : TExtDataTreeOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', [], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataTree.SetFOnBeforeexpand(Value : TExtDataTreeOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', [], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataTree.SetFOnBeforeinsert(Value : TExtDataTreeOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', [], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataTree.SetFOnBeforemove(Value : TExtDataTreeOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', [], true));
  FOnBeforemove := Value;
end;

procedure TExtDataTree.SetFOnBeforeremove(Value : TExtDataTreeOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', [], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataTree.SetFOnCollapse(Value : TExtDataTreeOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', [], true));
  FOnCollapse := Value;
end;

procedure TExtDataTree.SetFOnExpand(Value : TExtDataTreeOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', [], true));
  FOnExpand := Value;
end;

procedure TExtDataTree.SetFOnInsert(Value : TExtDataTreeOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', [], true));
  FOnInsert := Value;
end;

procedure TExtDataTree.SetFOnMove(Value : TExtDataTreeOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', [], true));
  FOnMove := Value;
end;

procedure TExtDataTree.SetFOnRemove(Value : TExtDataTreeOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', [], true));
  FOnRemove := Value;
end;

procedure TExtDataTree.SetFOnRootchange(Value : TExtDataTreeOnRootchange); begin
  if Assigned(FOnRootchange) then
    JSCode(JSName+'.events ["rootchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('rootchange', Ajax('rootchange', ['Root', '%0.nm'], true));
  FOnRootchange := Value;
end;

procedure TExtDataTree.SetFOnSort(Value : TExtDataTreeOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', [], true));
  FOnSort := Value;
end;

function TExtDataTree.JSClassName : string; begin
  Result := 'Ext.data.Tree';
end;

{$IFDEF FPC}constructor TExtDataTree.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataTree.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataTree');
  Result := Self;
end;

constructor TExtDataTree.Create(Root : TExtDataNodeInterface = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Root, false]) + ');');
  InitDefaults;
end;

function TExtDataTree.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.GetNodeById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getNodeById(' + VarToJSON([Id]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.GetRootNode : TExtFunction; begin
  JSCode(JSName + '.getRootNode();', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.RemoveRootNode : TExtFunction; begin
  JSCode(JSName + '.removeRootNode();', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.SetRootNode(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.setRootNode(' + VarToJSON([Node, false]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataTree');
  Result := Self;
end;

function TExtDataTree.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataTree');
  Result := Self;
end;

procedure TExtDataTree.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend()
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend()
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse()
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand()
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert()
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove()
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove()
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse()
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand()
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert()
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove()
  else if (AEvtName = 'rootchange') and Assigned(FOnRootchange) then
    FOnRootchange(TExtDataModel(ParamAsObject('Root')))
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort();
end;

function TExtDataSortTypesSingleton.JSClassName : string; begin
  Result := 'Ext.data.SortTypes';
end;

{$IFDEF FPC}constructor TExtDataSortTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataSortTypesSingleton.AsDate(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asDate(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsFloat(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asFloat(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsInt(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asInt(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsText(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asText(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsUCString(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asUCString(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

function TExtDataSortTypesSingleton.AsUCText(S : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.asUCText(' + VarToJSON([S, false]) + ');', 'TExtDataSortTypesSingleton');
  Result := Self;
end;

procedure TExtDataProxy.SetFBatchActions(Value : Boolean); begin
  FBatchActions := Value;
  JSCode('batchActions:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFBatchOrder(Value : String); begin
  FBatchOrder := Value;
  JSCode('batchOrder:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataProxy.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataProxy.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataProxy.SetFIsProxy(Value : Boolean); begin
  FIsProxy := Value;
  JSCode(JSName + '.isProxy=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataProxy.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFModel(Value : String); begin
  FModel := Value;
  JSCode('model:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFModelModel(Value : TExtDataModel); begin
  FModelModel := Value;
  Value.DeleteFromGarbage;
  JSCode('model:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFReader(Value : TExtObject); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetReader(Value)
  else
    JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFReaderReader(Value : TExtDataReader); begin
  FReaderReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFReaderString(Value : String); begin
  FReaderString := Value;
  JSCode('reader:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFWriter(Value : TExtObject); begin
  FWriter := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetWriter(Value)
  else
    JSCode('writer:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFWriterString(Value : String); begin
  FWriterString := Value;
  JSCode('writer:' + VarToJSON([Value]));
end;

procedure TExtDataProxy.SetFWriterWriter(Value : TExtDataWriter); begin
  FWriterWriter := Value;
  Value.DeleteFromGarbage;
  JSCode('writer:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxy.SetFOnMetachange(Value : TExtDataProxyOnMetachange); begin
  if Assigned(FOnMetachange) then
    JSCode(JSName+'.events ["metachange"].listeners=[];');
  if Assigned(Value) then
    AddListener('metachange', Ajax('metachange', ['This', '%0.nm','Meta', '%1.nm'], true));
  FOnMetachange := Value;
end;

function TExtDataProxy.JSClassName : string; begin
  Result := 'Ext.data.proxy.Proxy';
end;

procedure TExtDataProxy.InitDefaults; begin
  inherited;
  FBatchActions := true;
  FBatchOrder := 'create,update,destroy';
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FModelModel := TExtDataModel.CreateInternal(Self, 'model');
  FReader := TExtObject.CreateInternal(Self, 'reader');
  FReaderReader := TExtDataReader.CreateInternal(Self, 'reader');
  FWriter := TExtObject.CreateInternal(Self, 'writer');
  FWriterWriter := TExtDataWriter.CreateInternal(Self, 'writer');
end;

{$IFDEF FPC}constructor TExtDataProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxy.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataProxy');
  Result := Self;
end;

constructor TExtDataProxy.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxy.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetModel : TExtFunction; begin
  JSCode(JSName + '.getModel();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetReader : TExtFunction; begin
  JSCode(JSName + '.getReader();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.GetWriter : TExtFunction; begin
  JSCode(JSName + '.getWriter();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetModel(Model : TExtDataModel; SetOnStore : Boolean) : TExtFunction; begin
  JSCode(JSName + '.SetModel(' + VarToJSON([Model, false, SetOnStore]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetModel(Model : String; SetOnStore : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setModel(' + VarToJSON([Model, SetOnStore]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetReader(' + VarToJSON([Reader, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : TExtDataReader) : TExtFunction; begin
  JSCode(JSName + '.SetReader(' + VarToJSON([Reader, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetReader(Reader : String) : TExtFunction; begin
  JSCode(JSName + '.setReader(' + VarToJSON([Reader]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetWriter(' + VarToJSON([Writer, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : TExtDataWriter) : TExtFunction; begin
  JSCode(JSName + '.SetWriter(' + VarToJSON([Writer, false]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SetWriter(Writer : String) : TExtFunction; begin
  JSCode(JSName + '.setWriter(' + VarToJSON([Writer]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataProxy');
  Result := Self;
end;

function TExtDataProxy.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataProxy');
  Result := Self;
end;

destructor TExtDataProxy.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FModelModel.Free;
    FReader.Free;
    FReaderReader.Free;
    FWriter.Free;
    FWriterWriter.Free;
  except end;
  inherited;
end;

procedure TExtDataProxy.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'metachange') and Assigned(FOnMetachange) then
    FOnMetachange(TExtDataProxy(ParamAsObject('This')), TExtObject(ParamAsObject('Meta')));
end;

function TExtDataJsonPSingleton.JSClassName : string; begin
  Result := 'Ext.data.JsonP';
end;

{$IFDEF FPC}constructor TExtDataJsonPSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataJsonPSingleton.Abort(Request : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Abort(' + VarToJSON([Request, false]) + ');', 'TExtDataJsonPSingleton');
  Result := Self;
end;

function TExtDataJsonPSingleton.Abort(Request : String = '') : TExtFunction; begin
  JSCode(JSName + '.abort(' + VarToJSON([Request]) + ');', 'TExtDataJsonPSingleton');
  Result := Self;
end;

function TExtDataJsonPSingleton.Request(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.request(' + VarToJSON([Options, false]) + ');', 'TExtDataJsonPSingleton');
  Result := Self;
end;

procedure TExtDataIdGenerator.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtDataIdGenerator.SetFIsGenerator(Value : Boolean); begin
  FIsGenerator := Value;
  JSCode(JSName + '.isGenerator=' + VarToJSON([Value]) + ';');
end;

function TExtDataIdGenerator.JSClassName : string; begin
  Result := 'Ext.data.IdGenerator';
end;

class function TExtDataIdGenerator.All : TExtObject;
const
  lAll : TExtObject = nil;
begin
  if lAll = nil then lAll := TExtObject.CreateSingleton('Ext.data.IdGenerator.All');
  Result := lAll
end;

{$IFDEF FPC}constructor TExtDataIdGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataIdGenerator.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataIdGenerator.Get(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Config, false]) + ');', 'TExtDataIdGenerator');
  Result := Self;
end;

function TExtDataIdGenerator.Get(Config : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Config]) + ');', 'TExtDataIdGenerator');
  Result := Self;
end;

procedure TExtDataModel.SetFAssociations(Value : TExtObjectList); begin
  FAssociations := Value;
  Value.DeleteFromGarbage;
  JSCode('associations:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFBelongsTo(Value : String); begin
  FBelongsTo := Value;
  JSCode('belongsTo:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFBelongsToList(Value : TExtObjectList); begin
  FBelongsToList := Value;
  Value.DeleteFromGarbage;
  JSCode('belongsTo:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFBelongsToObject(Value : TExtObject); begin
  FBelongsToObject := Value;
  Value.DeleteFromGarbage;
  JSCode('belongsTo:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFBelongsToTArrayOfString(Value : TArrayOfString); begin
  FBelongsToTArrayOfString := Value;
  JSCode('belongsTo:' + ArrayToJSON(Value));
end;

procedure TExtDataModel.SetFClientIdProperty(Value : String); begin
  FClientIdProperty := Value;
  JSCode('clientIdProperty:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFDefaultProxyType(Value : String); begin
  FDefaultProxyType := Value;
  JSCode('defaultProxyType:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFDirty(Value : Boolean); begin
  FDirty := Value;
  JSCode(JSName + '.dirty=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFEditing(Value : Boolean); begin
  FEditing := Value;
  JSCode(JSName + '.editing=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFFields(Value : TExtObjectList); begin
  FFields := Value;
  Value.DeleteFromGarbage;
  JSCode('fields:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFFieldsTArrayOfString(Value : TArrayOfString); begin
  FFieldsTArrayOfString := Value;
  JSCode('fields:' + ArrayToJSON(Value));
end;

procedure TExtDataModel.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFHasMany(Value : String); begin
  FHasMany := Value;
  JSCode('hasMany:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFHasManyList(Value : TExtObjectList); begin
  FHasManyList := Value;
  Value.DeleteFromGarbage;
  JSCode('hasMany:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFHasManyObject(Value : TExtObject); begin
  FHasManyObject := Value;
  Value.DeleteFromGarbage;
  JSCode('hasMany:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFHasManyTArrayOfString(Value : TArrayOfString); begin
  FHasManyTArrayOfString := Value;
  JSCode('hasMany:' + ArrayToJSON(Value));
end;

procedure TExtDataModel.SetFIdProperty(Value : String); begin
  FIdProperty := Value;
  JSCode('idProperty:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFIdPropertyField(Value : TExtDataField); begin
  FIdPropertyField := Value;
  Value.DeleteFromGarbage;
  JSCode('idProperty:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFIdPropertyObject(Value : TExtObject); begin
  FIdPropertyObject := Value;
  Value.DeleteFromGarbage;
  JSCode('idProperty:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFIsModel(Value : Boolean); begin
  FIsModel := Value;
  JSCode(JSName + '.isModel=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFModified(Value : TExtObject); begin
  FModified := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.modified=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFPhantom(Value : Boolean); begin
  FPhantom := Value;
  JSCode(JSName + '.phantom=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataModel.SetFProxy(Value : String); begin
  FProxy := Value;
  JSCode('proxy:' + VarToJSON([Value]));
end;

procedure TExtDataModel.SetFProxyObject(Value : TExtObject); begin
  FProxyObject := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFProxyProxy(Value : TExtDataProxy); begin
  FProxyProxy := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFRaw(Value : TExtObject); begin
  FRaw := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.raw=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.store=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFStores(Value : TExtObjectList); begin
  FStores := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.stores=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataModel.SetFValidations(Value : TExtObjectList); begin
  FValidations := Value;
  Value.DeleteFromGarbage;
  JSCode('validations:' + VarToJSON([Value, false]));
end;

procedure TExtDataModel.SetFOnIdchanged(Value : TExtDataModelOnIdchanged); begin
  if Assigned(FOnIdchanged) then
    JSCode(JSName+'.events ["idchanged"].listeners=[];');
  if Assigned(Value) then
    AddListener('idchanged', Ajax('idchanged', ['This', '%0.nm','OldId', '%1','NewId', '%2'], true));
  FOnIdchanged := Value;
end;

function TExtDataModel.JSClassName : string; begin
  Result := 'Ext.data.Model';
end;

procedure TExtDataModel.InitDefaults; begin
  inherited;
  FAssociations := TExtObjectList.Create(Self, 'associations');
  FBelongsToList := TExtObjectList.Create(Self, 'belongsTo');
  FBelongsToObject := TExtObject.CreateInternal(Self, 'belongsTo');
  FDefaultProxyType := 'ajax';
  FFields := TExtObjectList.Create(Self, 'fields');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FHasManyList := TExtObjectList.Create(Self, 'hasMany');
  FHasManyObject := TExtObject.CreateInternal(Self, 'hasMany');
  FIdProperty := 'id';
  FIdPropertyField := TExtDataField.CreateInternal(Self, 'idProperty');
  FIdPropertyObject := TExtObject.CreateInternal(Self, 'idProperty');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FModified := TExtObject.CreateInternal(Self, 'modified');
  FProxyObject := TExtObject.CreateInternal(Self, 'proxy');
  FProxyProxy := TExtDataProxy.CreateInternal(Self, 'proxy');
  FRaw := TExtObject.CreateInternal(Self, 'raw');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FStores := TExtObjectList.Create(Self, 'stores');
  FValidations := TExtObjectList.Create(Self, 'validations');
end;

{$IFDEF FPC}constructor TExtDataModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataModel.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.BeginEdit : TExtFunction; begin
  JSCode(JSName + '.beginEdit();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.CancelEdit : TExtFunction; begin
  JSCode(JSName + '.cancelEdit();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Commit(Silent : Boolean = false; ModifiedFieldNames : TArrayOfString = nil) : TExtFunction; begin
  JSCode(JSName + '.commit(' + VarToJSON([Silent, ModifiedFieldNames]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Copy(Id : String = '') : TExtFunction; begin
  JSCode(JSName + '.copy(' + VarToJSON([Id]) + ');', 'TExtDataModel');
  Result := Self;
end;

constructor TExtDataModel.Create(Data : TExtObjectList); begin
  CreateVar(JSClassName + '(' + VarToJSON(Data) + ');');
  InitDefaults;
end;

constructor TExtDataModel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataModel.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.EndEdit(Silent : Boolean = false; ModifiedFieldNames : TArrayOfString = nil) : TExtFunction; begin
  JSCode(JSName + '.endEdit(' + VarToJSON([Silent, ModifiedFieldNames]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Get(FieldName : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([FieldName]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetAssociatedData : TExtFunction; begin
  JSCode(JSName + '.getAssociatedData();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetChanges : TExtFunction; begin
  JSCode(JSName + '.getChanges();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetData(IncludeAssociated : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getData(' + VarToJSON([IncludeAssociated]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetFields : TExtFunction; begin
  JSCode(JSName + '.getFields();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetId : TExtFunction; begin
  JSCode(JSName + '.getId();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.IsModified(FieldName : String) : TExtFunction; begin
  JSCode(JSName + '.isModified(' + VarToJSON([FieldName]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Join(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.join(' + VarToJSON([Store, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Load(Id : String; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Load(' + VarToJSON([Id, Config, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Load(Id : Integer; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Id, Config, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Reject(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.reject(' + VarToJSON([Silent]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Save(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.save(' + VarToJSON([Options, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetDirty : TExtFunction; begin
  JSCode(JSName + '.setDirty();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetFields : TExtFunction; begin
  JSCode(JSName + '.setFields();', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.SetId(' + VarToJSON([Id]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetId(Id : Integer) : TExtFunction; begin
  JSCode(JSName + '.setId(' + VarToJSON([Id]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetJS(FieldName : TExtObject; NewValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetJS(' + VarToJSON([FieldName, false, NewValue, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetJS(FieldName : String; NewValue : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.set(' + VarToJSON([FieldName, NewValue, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetProxy(Proxy : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetProxy(Proxy : TExtDataProxy) : TExtFunction; begin
  JSCode(JSName + '.SetProxy(' + VarToJSON([Proxy, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SetProxy(Proxy : String) : TExtFunction; begin
  JSCode(JSName + '.setProxy(' + VarToJSON([Proxy]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Unjoin(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.unjoin(' + VarToJSON([Store, false]) + ');', 'TExtDataModel');
  Result := Self;
end;

function TExtDataModel.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtDataModel');
  Result := Self;
end;

destructor TExtDataModel.Destroy; begin
  try
    FAssociations.Free;
    FBelongsToList.Free;
    FBelongsToObject.Free;
    FFields.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FHasManyList.Free;
    FHasManyObject.Free;
    FIdPropertyField.Free;
    FIdPropertyObject.Free;
    FListeners.Free;
    FModified.Free;
    FProxyObject.Free;
    FProxyProxy.Free;
    FRaw.Free;
    FStore.Free;
    FStores.Free;
    FValidations.Free;
  except end;
  inherited;
end;

procedure TExtDataModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'idchanged') and Assigned(FOnIdchanged) then
    FOnIdchanged(TExtDataModel(ParamAsObject('This')), ParamAsInteger('OldId'), ParamAsInteger('NewId'));
end;

procedure TExtDataOperation.SetFAction(Value : String); begin
  FAction := Value;
  JSCode('action:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFActionCommitRecordsRe(Value : TRegExp); begin
  FActionCommitRecordsRe := Value;
  JSCode(JSName + '.actionCommitRecordsRe=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtDataOperation.SetFActionSkipSyncRe(Value : TRegExp); begin
  FActionSkipSyncRe := Value;
  JSCode(JSName + '.actionSkipSyncRe=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtDataOperation.SetFBatch(Value : TExtDataBatch); begin
  FBatch := Value;
  Value.DeleteFromGarbage;
  JSCode('batch:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFCallback(Value : TExtFunction); begin
  FCallback := Value;
  JSCode('callback:' + VarToJSON([Value, true]));
end;

procedure TExtDataOperation.SetFCallbackOperation(Value : TExtDataOperation); begin
  FCallbackOperation := Value;
  Value.DeleteFromGarbage;
  JSCode('callbackOperation:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFCallbackRecords(Value : TExtObjectList); begin
  FCallbackRecords := Value;
  Value.DeleteFromGarbage;
  JSCode('callbackRecords:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFCallbackSuccess(Value : Boolean); begin
  FCallbackSuccess := Value;
  JSCode('callbackSuccess:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFFilters(Value : TExtObjectList); begin
  FFilters := Value;
  Value.DeleteFromGarbage;
  JSCode('filters:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFGroupers(Value : TExtObjectList); begin
  FGroupers := Value;
  Value.DeleteFromGarbage;
  JSCode('groupers:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFLimit(Value : Integer); begin
  FLimit := Value;
  JSCode('limit:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtDataOperation.SetFStart(Value : Integer); begin
  FStart := Value;
  JSCode('start:' + VarToJSON([Value]));
end;

procedure TExtDataOperation.SetFSynchronous(Value : Boolean); begin
  FSynchronous := Value;
  JSCode('synchronous:' + VarToJSON([Value]));
end;

function TExtDataOperation.JSClassName : string; begin
  Result := 'Ext.data.Operation';
end;

procedure TExtDataOperation.InitDefaults; begin
  inherited;
  FBatch := TExtDataBatch.CreateInternal(Self, 'batch');
  FCallbackOperation := TExtDataOperation.CreateInternal(Self, 'callbackOperation');
  FCallbackRecords := TExtObjectList.Create(Self, 'callbackRecords');
  FFilters := TExtObjectList.Create(Self, 'filters');
  FGroupers := TExtObjectList.Create(Self, 'groupers');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FSorters := TExtObjectList.Create(Self, 'sorters');
end;

{$IFDEF FPC}constructor TExtDataOperation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataOperation.AllowWrite : TExtFunction; begin
  JSCode(JSName + '.allowWrite();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.CommitRecords(ServerRecords : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.commitRecords(' + VarToJSON(ServerRecords) + ');', 'TExtDataOperation');
  Result := Self;
end;

constructor TExtDataOperation.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataOperation.GetError : TExtFunction; begin
  JSCode(JSName + '.getError();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.GetRecords : TExtFunction; begin
  JSCode(JSName + '.getRecords();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.GetResultSet : TExtFunction; begin
  JSCode(JSName + '.getResultSet();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.HasException : TExtFunction; begin
  JSCode(JSName + '.hasException();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsComplete : TExtFunction; begin
  JSCode(JSName + '.isComplete();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsRunning : TExtFunction; begin
  JSCode(JSName + '.isRunning();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.IsStarted : TExtFunction; begin
  JSCode(JSName + '.isStarted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetCompleted : TExtFunction; begin
  JSCode(JSName + '.setCompleted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetException(Error : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetException(' + VarToJSON([Error, false]) + ');', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetException(Error : String = '') : TExtFunction; begin
  JSCode(JSName + '.setException(' + VarToJSON([Error]) + ');', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetStarted : TExtFunction; begin
  JSCode(JSName + '.setStarted();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.SetSuccessful : TExtFunction; begin
  JSCode(JSName + '.setSuccessful();', 'TExtDataOperation');
  Result := Self;
end;

function TExtDataOperation.WasSuccessful : TExtFunction; begin
  JSCode(JSName + '.wasSuccessful();', 'TExtDataOperation');
  Result := Self;
end;

destructor TExtDataOperation.Destroy; begin
  try
    FBatch.Free;
    FCallbackOperation.Free;
    FCallbackRecords.Free;
    FFilters.Free;
    FGroupers.Free;
    FParams.Free;
    FScope.Free;
    FSorters.Free;
  except end;
  inherited;
end;

procedure TExtDataNodeInterface.SetFAllowDrag(Value : Boolean); begin
  FAllowDrag := Value;
  JSCode('allowDrag:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFAllowDrop(Value : Boolean); begin
  FAllowDrop := Value;
  JSCode('allowDrop:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFChildNodes(Value : TExtObjectList); begin
  FChildNodes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.childNodes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFChildren(Value : TExtObjectList); begin
  FChildren := Value;
  Value.DeleteFromGarbage;
  JSCode('children:' + VarToJSON([Value, false]));
end;

procedure TExtDataNodeInterface.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFDepth(Value : Integer); begin
  FDepth := Value;
  JSCode('depth:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFExpandable(Value : Boolean); begin
  FExpandable := Value;
  JSCode('expandable:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFExpanded(Value : Boolean); begin
  FExpanded := Value;
  JSCode('expanded:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFFirstChild(Value : TExtDataNodeInterface); begin
  FFirstChild := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.firstChild=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFHref(Value : String); begin
  FHref := Value;
  JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIndex(Value : Integer); begin
  FIndex := Value;
  JSCode('index:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIsFirst(Value : Boolean); begin
  FIsFirst := Value;
  JSCode('isFirst:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIsLast(Value : Boolean); begin
  FIsLast := Value;
  JSCode('isLast:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFIsNode(Value : Boolean); begin
  FIsNode := Value;
  JSCode(JSName + '.isNode=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataNodeInterface.SetFLastChild(Value : TExtDataNodeInterface); begin
  FLastChild := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.lastChild=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFLeaf(Value : Boolean); begin
  FLeaf := Value;
  JSCode('leaf:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFLoaded(Value : Boolean); begin
  FLoaded := Value;
  JSCode('loaded:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFLoading(Value : Boolean); begin
  FLoading := Value;
  JSCode('loading:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFNextSibling(Value : TExtDataNodeInterface); begin
  FNextSibling := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.nextSibling=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFParentId(Value : String); begin
  FParentId := Value;
  JSCode('parentId:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFParentNode(Value : TExtDataNodeInterface); begin
  FParentNode := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.parentNode=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFPreviousSibling(Value : TExtDataNodeInterface); begin
  FPreviousSibling := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.previousSibling=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataNodeInterface.SetFQshowDelay(Value : Integer); begin
  FQshowDelay := Value;
  JSCode('qshowDelay:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFQtip(Value : String); begin
  FQtip := Value;
  JSCode('qtip:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFQtitle(Value : String); begin
  FQtitle := Value;
  JSCode('qtitle:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFRoot(Value : Boolean); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtDataNodeInterface.SetFOnAppend(Value : TExtDataNodeInterfaceOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', ['This', '%0.nm','Node', '%1.nm','Index', '%2'], true));
  FOnAppend := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeappend(Value : TExtDataNodeInterfaceOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', ['This', '%0.nm','Node', '%1.nm'], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforecollapse(Value : TExtDataNodeInterfaceOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', ['This', '%0.nm'], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeexpand(Value : TExtDataNodeInterfaceOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', ['This', '%0.nm'], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeinsert(Value : TExtDataNodeInterfaceOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', ['This', '%0.nm','Node', '%1.nm','RefNode', '%2.nm'], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforemove(Value : TExtDataNodeInterfaceOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', ['This', '%0.nm','OldParent', '%1.nm','NewParent', '%2.nm','Index', '%3'], true));
  FOnBeforemove := Value;
end;

procedure TExtDataNodeInterface.SetFOnBeforeremove(Value : TExtDataNodeInterfaceOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', ['This', '%0.nm','Node', '%1.nm','IsMove', '%2'], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataNodeInterface.SetFOnCollapse(Value : TExtDataNodeInterfaceOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['This', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtDataNodeInterface.SetFOnExpand(Value : TExtDataNodeInterfaceOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['This', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtDataNodeInterface.SetFOnInsert(Value : TExtDataNodeInterfaceOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', ['This', '%0.nm','Node', '%1.nm','RefNode', '%2.nm'], true));
  FOnInsert := Value;
end;

procedure TExtDataNodeInterface.SetFOnMove(Value : TExtDataNodeInterfaceOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', ['This', '%0.nm','OldParent', '%1.nm','NewParent', '%2.nm','Index', '%3'], true));
  FOnMove := Value;
end;

procedure TExtDataNodeInterface.SetFOnRemove(Value : TExtDataNodeInterfaceOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['This', '%0.nm','Node', '%1.nm','IsMove', '%2'], true));
  FOnRemove := Value;
end;

procedure TExtDataNodeInterface.SetFOnSort(Value : TExtDataNodeInterfaceOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', ['This', '%0.nm','ChildNodes', '%1.nm'], true));
  FOnSort := Value;
end;

function TExtDataNodeInterface.JSClassName : string; begin
  Result := 'Ext.data.NodeInterface';
end;

procedure TExtDataNodeInterface.InitDefaults; begin
  inherited;
  FChildNodes := TExtObjectList.Create(Self, 'childNodes');
  FChildren := TExtObjectList.Create(Self, 'children');
  FFirstChild := TExtDataNodeInterface.CreateInternal(Self, 'firstChild');
  FLastChild := TExtDataNodeInterface.CreateInternal(Self, 'lastChild');
  FNextSibling := TExtDataNodeInterface.CreateInternal(Self, 'nextSibling');
  FParentNode := TExtDataNodeInterface.CreateInternal(Self, 'parentNode');
  FPreviousSibling := TExtDataNodeInterface.CreateInternal(Self, 'previousSibling');
end;

{$IFDEF FPC}constructor TExtDataNodeInterface.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataNodeInterface.AppendChild(Node : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AppendChild(' + VarToJSON(Node) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.AppendChild(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.appendChild(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.bubble(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.CascadeBy(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.cascadeBy(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Collapse(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.CollapseChildren(Recursive : TExtFunction = nil; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseChildren(' + VarToJSON([Recursive, true, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Contains(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Copy(Id : String = ''; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.copy(' + VarToJSON([Id, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

constructor TExtDataNodeInterface.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataNodeInterface.CreateNode : TExtFunction; begin
  JSCode(JSName + '.createNode();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Decorate(ModelClass : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.Decorate(' + VarToJSON([ModelClass, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Decorate(ModelClass : TExtClass) : TExtFunction; begin
  JSCode(JSName + '.decorate(' + VarToJSON([ModelClass, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.EachChild(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.eachChild(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Expand(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.ExpandChildren(Recursive : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandChildren(' + VarToJSON([Recursive, Callback, true, Scope, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.FindChild(Attribute : String; Value : TExtObject; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findChild(' + VarToJSON([Attribute, Value, false, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.FindChildBy(Fn : TExtFunction; Scope : TExtObject = nil; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findChildBy(' + VarToJSON([Fn, true, Scope, false, Deep]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetChildAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getChildAt(' + VarToJSON([Index]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetDepth : TExtFunction; begin
  JSCode(JSName + '.getDepth();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetOwnerTree : TExtFunction; begin
  JSCode(JSName + '.getOwnerTree();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.GetPath(Field : String = ''; Separator : String = '') : TExtFunction; begin
  JSCode(JSName + '.getPath(' + VarToJSON([Field, Separator]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.HasChildNodes : TExtFunction; begin
  JSCode(JSName + '.hasChildNodes();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IndexOf(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IndexOfId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.indexOfId(' + VarToJSON([Id]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.InsertBefore(Node : TExtDataNodeInterface; RefNode : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.insertBefore(' + VarToJSON([Node, false, RefNode, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.InsertChild(Index : Integer; Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.insertChild(' + VarToJSON([Index, Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsAncestor(Node : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.isAncestor(' + VarToJSON([Node, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsExpandable : TExtFunction; begin
  JSCode(JSName + '.isExpandable();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsExpanded : TExtFunction; begin
  JSCode(JSName + '.isExpanded();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsFirst_ : TExtFunction; begin
  JSCode(JSName + '.isFirst();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLast_ : TExtFunction; begin
  JSCode(JSName + '.isLast();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLeaf : TExtFunction; begin
  JSCode(JSName + '.isLeaf();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLoaded : TExtFunction; begin
  JSCode(JSName + '.isLoaded();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsLoading : TExtFunction; begin
  JSCode(JSName + '.isLoading();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsRoot : TExtFunction; begin
  JSCode(JSName + '.isRoot();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.IsVisible : TExtFunction; begin
  JSCode(JSName + '.isVisible();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Remove(Destroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Destroy]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.RemoveAll(Destroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([Destroy]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.RemoveChild(Node : TExtDataNodeInterface; Destroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeChild(' + VarToJSON([Node, false, Destroy]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.ReplaceChild(NewChild : TExtDataNodeInterface; OldChild : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.replaceChild(' + VarToJSON([NewChild, false, OldChild, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Serialize : TExtFunction; begin
  JSCode(JSName + '.serialize();', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.Sort(Fn : TExtFunction; Recursive : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Fn, true, Recursive, SuppressEvent]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

function TExtDataNodeInterface.UpdateInfo(Commit : Boolean; Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.updateInfo(' + VarToJSON([Commit, Info, false]) + ');', 'TExtDataNodeInterface');
  Result := Self;
end;

destructor TExtDataNodeInterface.Destroy; begin
  try
    FChildNodes.Free;
    FChildren.Free;
    FFirstChild.Free;
    FLastChild.Free;
    FNextSibling.Free;
    FParentNode.Free;
    FPreviousSibling.Free;
  except end;
  inherited;
end;

procedure TExtDataNodeInterface.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')))
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtDataNodeInterface(ParamAsObject('RefNode')))
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('OldParent')), TExtDataNodeInterface(ParamAsObject('NewParent')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtDataNodeInterface(ParamAsObject('This')))
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtDataNodeInterface(ParamAsObject('RefNode')))
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('OldParent')), TExtDataNodeInterface(ParamAsObject('NewParent')), ParamAsInteger('Index'))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtDataNodeInterface(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('IsMove'))
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort(TExtDataNodeInterface(ParamAsObject('This')), TExtObjectList(ParamAsObject('ChildNodes')));
end;

procedure TExtChartAxisAbstract.SetFFields(Value : TArrayOfString); begin
  FFields := Value;
  JSCode('fields:' + ArrayToJSON(Value));
end;

procedure TExtChartAxisAbstract.SetFLabelJS(Value : TExtChartLabel); begin
  FLabelJS := Value;
  Value.DeleteFromGarbage;
  JSCode('labelJS:' + VarToJSON([Value, false]));
end;

function TExtChartAxisAbstract.JSClassName : string; begin
  Result := 'Ext.chart.axis.Abstract';
end;

procedure TExtChartAxisAbstract.InitDefaults; begin
  inherited;
  FLabelJS := TExtChartLabel.CreateInternal(Self, 'labelJS');
end;

{$IFDEF FPC}constructor TExtChartAxisAbstract.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartAxisAbstract.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtChartAxisAbstract.Destroy; begin
  try
    FLabelJS.Free;
  except end;
  inherited;
end;

function TExtButtonManagerSingleton.JSClassName : string; begin
  Result := 'Ext.button.Manager';
end;

{$IFDEF FPC}constructor TExtButtonManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartCallout.JSClassName : string; begin
  Result := 'Ext.chart.Callout';
end;

{$IFDEF FPC}constructor TExtChartCallout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartLabel.SetFLabelColor(Value : String); begin
  FLabelColor := Value;
  JSCode('labelColor:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelContrast(Value : Boolean); begin
  FLabelContrast := Value;
  JSCode('labelContrast:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelDisplay(Value : String); begin
  FLabelDisplay := Value;
  JSCode('labelDisplay:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelField(Value : String); begin
  FLabelField := Value;
  JSCode('labelField:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelFont(Value : String); begin
  FLabelFont := Value;
  JSCode('labelFont:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelJS(Value : TExtObject); begin
  FLabelJS := Value;
  Value.DeleteFromGarbage;
  JSCode('labelJS:' + VarToJSON([Value, false]));
end;

procedure TExtChartLabel.SetFLabelMinMargin(Value : Integer); begin
  FLabelMinMargin := Value;
  JSCode('labelMinMargin:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelOrientation(Value : String); begin
  FLabelOrientation := Value;
  JSCode('labelOrientation:' + VarToJSON([Value]));
end;

procedure TExtChartLabel.SetFLabelRenderer(Value : TExtFunction); begin
  FLabelRenderer := Value;
  JSCode('labelRenderer:' + VarToJSON([Value, true]));
end;

procedure TExtChartLabel.SetFLabelStackedDisplay(Value : String); begin
  FLabelStackedDisplay := Value;
  JSCode('labelStackedDisplay:' + VarToJSON([Value]));
end;

function TExtChartLabel.JSClassName : string; begin
  Result := 'Ext.chart.Label';
end;

procedure TExtChartLabel.InitDefaults; begin
  inherited;
  FLabelJS := TExtObject.CreateInternal(Self, 'labelJS');
end;

{$IFDEF FPC}constructor TExtChartLabel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartLabel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartLabel.Destroy; begin
  try
    FLabelJS.Free;
  except end;
  inherited;
end;

procedure TExtChartHighlight.SetFHighlight(Value : Boolean); begin
  FHighlight := Value;
  JSCode('highlight:' + VarToJSON([Value]));
end;

procedure TExtChartHighlight.SetFHighlightCfg(Value : TExtObject); begin
  FHighlightCfg := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.highlightCfg=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChartHighlight.SetFHighlightObject(Value : TExtObject); begin
  FHighlightObject := Value;
  Value.DeleteFromGarbage;
  JSCode('highlight:' + VarToJSON([Value, false]));
end;

function TExtChartHighlight.JSClassName : string; begin
  Result := 'Ext.chart.Highlight';
end;

procedure TExtChartHighlight.InitDefaults; begin
  inherited;
  FHighlightCfg := TExtObject.CreateInternal(Self, 'highlightCfg');
  FHighlightObject := TExtObject.CreateInternal(Self, 'highlight');
end;

{$IFDEF FPC}constructor TExtChartHighlight.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartHighlight.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartHighlight.HighlightItem(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Item, false]) + ');', 'TExtChartHighlight');
  Result := Self;
end;

function TExtChartHighlight.UnHighlightItem : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem();', 'TExtChartHighlight');
  Result := Self;
end;

destructor TExtChartHighlight.Destroy; begin
  try
    FHighlightCfg.Free;
    FHighlightObject.Free;
  except end;
  inherited;
end;

procedure TExtAppEventDomain.SetFIdProperty(Value : String); begin
  FIdProperty := Value;
  JSCode('idProperty:' + VarToJSON([Value]));
end;

function TExtAppEventDomain.JSClassName : string; begin
  Result := 'Ext.app.EventDomain';
end;

{$IFDEF FPC}constructor TExtAppEventDomain.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtAbstractPlugin.SetFIsPlugin(Value : Boolean); begin
  FIsPlugin := Value;
  JSCode(JSName + '.isPlugin=' + VarToJSON([Value]) + ';');
end;

procedure TExtAbstractPlugin.SetFPluginId(Value : String); begin
  FPluginId := Value;
  JSCode('pluginId:' + VarToJSON([Value]));
end;

function TExtAbstractPlugin.JSClassName : string; begin
  Result := 'Ext.AbstractPlugin';
end;

{$IFDEF FPC}constructor TExtAbstractPlugin.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAbstractPlugin.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtAbstractPlugin');
  Result := Self;
end;

procedure TExtAbstractManager.SetFAll(Value : TExtUtilHashMap); begin
  FAll := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.all=' + VarToJSON([Value, false]) + ';');
end;

function TExtAbstractManager.JSClassName : string; begin
  Result := 'Ext.AbstractManager';
end;

procedure TExtAbstractManager.InitDefaults; begin
  inherited;
  FAll := TExtUtilHashMap.CreateInternal(Self, 'all');
end;

{$IFDEF FPC}constructor TExtAbstractManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAbstractManager.Create(Config : TExtObject; DefaultType : String); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, DefaultType]) + ');');
  InitDefaults;
end;

function TExtAbstractManager.Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Get(Id : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Id]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.IsRegistered(TypeJS : String) : TExtFunction; begin
  JSCode(JSName + '.isRegistered(' + VarToJSON([TypeJS]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.OnAvailable(Id : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.onAvailable(' + VarToJSON([Id, Fn, true, Scope, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Register(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Item, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.RegisterType(TypeJS : String; Cls : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.registerType(' + VarToJSON([TypeJS, Cls, true]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

function TExtAbstractManager.Unregister(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Item, false]) + ');', 'TExtAbstractManager');
  Result := Self;
end;

destructor TExtAbstractManager.Destroy; begin
  try
    FAll.Free;
  except end;
  inherited;
end;

procedure TExtAction.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  if not ConfigAvailable(JSName) then
    SetDisabled(Value)
  else
    JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value, nil)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtAction.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  if not ConfigAvailable(JSName) then
    SetHidden(Value)
  else
    JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFIsAction(Value : Boolean); begin
  FIsAction := Value;
  JSCode(JSName + '.isAction=' + VarToJSON([Value]) + ';');
end;

procedure TExtAction.SetFItemId(Value : String); begin
  FItemId := Value;
  JSCode('itemId:' + VarToJSON([Value]));
end;

procedure TExtAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtAction.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtAction.JSClassName : string; begin
  Result := 'Ext.Action';
end;

procedure TExtAction.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAction.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtAction.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtAction');
  Result := Self;
end;

function TExtAction.Each(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtAction');
  Result := Self;
end;

function TExtAction.Execute(Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.execute(' + VarToJSON(Args) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.GetIconCls : TExtFunction; begin
  JSCode(JSName + '.getIconCls();', 'TExtAction');
  Result := Self;
end;

function TExtAction.GetText : TExtFunction; begin
  JSCode(JSName + '.getText();', 'TExtAction');
  Result := Self;
end;

function TExtAction.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtAction');
  Result := Self;
end;

function TExtAction.IsDisabled : TExtFunction; begin
  JSCode(JSName + '.isDisabled();', 'TExtAction');
  Result := Self;
end;

function TExtAction.IsHidden : TExtFunction; begin
  JSCode(JSName + '.isHidden();', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetHandler(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetHidden(Hidden : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setHidden(' + VarToJSON([Hidden]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtAction');
  Result := Self;
end;

function TExtAction.Show : TExtFunction; begin
  JSCode(JSName + '.show();', 'TExtAction');
  Result := Self;
end;

destructor TExtAction.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

function TExtAppEventBusSingleton.JSClassName : string; begin
  Result := 'Ext.app.EventBus';
end;

{$IFDEF FPC}constructor TExtAppEventBusSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAppEventBusSingleton.Control(Selectors : TExtObject; Controller : TExtAppController) : TExtFunction; begin
  JSCode(JSName + '.control(' + VarToJSON([Selectors, false, Controller, false]) + ');', 'TExtAppEventBusSingleton');
  Result := Self;
end;

function TExtAppEventBusSingleton.Listen(ToJS : TExtObject; Controller : TExtAppController) : TExtFunction; begin
  JSCode(JSName + '.listen(' + VarToJSON([ToJS, false, Controller, false]) + ');', 'TExtAppEventBusSingleton');
  Result := Self;
end;

function TExtAppEventBusSingleton.Unlisten(ControllerId : String) : TExtFunction; begin
  JSCode(JSName + '.unlisten(' + VarToJSON([ControllerId]) + ');', 'TExtAppEventBusSingleton');
  Result := Self;
end;

procedure TExtAppController.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAppController.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAppController.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtAppController.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtAppController.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtAppController.SetFModels(Value : TArrayOfString); begin
  FModels := Value;
  JSCode('models:' + ArrayToJSON(Value));
end;

procedure TExtAppController.SetFRefs(Value : TExtObjectList); begin
  FRefs := Value;
  Value.DeleteFromGarbage;
  JSCode('refs:' + VarToJSON([Value, false]));
end;

procedure TExtAppController.SetFStores(Value : TArrayOfString); begin
  FStores := Value;
  JSCode('stores:' + ArrayToJSON(Value));
end;

procedure TExtAppController.SetFViews(Value : TArrayOfString); begin
  FViews := Value;
  JSCode('views:' + ArrayToJSON(Value));
end;

function TExtAppController.JSClassName : string; begin
  Result := 'Ext.app.Controller';
end;

procedure TExtAppController.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FRefs := TExtObjectList.Create(Self, 'refs');
end;

{$IFDEF FPC}constructor TExtAppController.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAppController.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddRef(Refs : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddRef(' + VarToJSON(Refs) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.AddRef(Refs : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addRef(' + VarToJSON([Refs, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Control(Selectors : TExtObject; Listeners : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Control(' + VarToJSON([Selectors, false, Listeners, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Control(Selectors : String; Listeners : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.control(' + VarToJSON([Selectors, Listeners, false]) + ');', 'TExtAppController');
  Result := Self;
end;

constructor TExtAppController.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtAppController.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetApplication : TExtFunction; begin
  JSCode(JSName + '.getApplication();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetController(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getController(' + VarToJSON([Id]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetModel(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getModel(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetStore(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getStore(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.GetView(Name : String) : TExtFunction; begin
  JSCode(JSName + '.getView(' + VarToJSON([Name]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.HasRef : TExtFunction; begin
  JSCode(JSName + '.hasRef();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Listen(ToJS : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.listen(' + VarToJSON([ToJS, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtAppController');
  Result := Self;
end;

function TExtAppController.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtAppController');
  Result := Self;
end;

destructor TExtAppController.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
    FRefs.Free;
  except end;
  inherited;
end;

function TExtChartTip.JSClassName : string; begin
  Result := 'Ext.chart.Tip';
end;

{$IFDEF FPC}constructor TExtChartTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartThemeBase.JSClassName : string; begin
  Result := 'Ext.chart.theme.Base';
end;

{$IFDEF FPC}constructor TExtChartThemeBase.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtComponent.SetFAnchor(Value : String); begin
  FAnchor := Value;
  JSCode('anchor:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFAutoScroll(Value : Boolean); begin
  FAutoScroll := Value;
  if not ConfigAvailable(JSName) then
    SetAutoScroll(Value)
  else
    JSCode('autoScroll:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFColumnWidth(Value : Integer); begin
  FColumnWidth := Value;
  JSCode('columnWidth:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFColumnWidthString(Value : String); begin
  FColumnWidthString := Value;
  JSCode('columnWidth:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFConstrainTo(Value : TExtUtilRegion); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFConstrainToElement(Value : TExtElement); begin
  FConstrainToElement := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFDefaultAlign(Value : String); begin
  FDefaultAlign := Value;
  JSCode('defaultAlign:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFDraggableObject(Value : TExtObject); begin
  FDraggableObject := Value;
  Value.DeleteFromGarbage;
  JSCode('draggable:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode('fixed:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFFloating(Value : Boolean); begin
  FFloating := Value;
  JSCode('floating:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFFloatParent(Value : TExtContainer); begin
  FFloatParent := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.floatParent=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtComponent.SetFFocusOnToFront(Value : Boolean); begin
  FFocusOnToFront := Value;
  JSCode('focusOnToFront:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFFormBind(Value : Boolean); begin
  FFormBind := Value;
  JSCode('formBind:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFMargins(Value : String); begin
  FMargins := Value;
  JSCode('margins:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFMaxSize(Value : Integer); begin
  FMaxSize := Value;
  JSCode('maxSize:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFMinSize(Value : Integer); begin
  FMinSize := Value;
  JSCode('minSize:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFOverflowX(Value : String); begin
  FOverflowX := Value;
  JSCode('overflowX:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFOverflowY(Value : String); begin
  FOverflowY := Value;
  JSCode('overflowY:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFRegion(Value : TRegionEnum); begin
  FRegion := Value;
  JSCode('region:"' + EnumToJSString(TypeInfo(TRegionEnum), ord(Value)) + '"');
end;

procedure TExtComponent.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFResizableObject(Value : TExtObject); begin
  FResizableObject := Value;
  Value.DeleteFromGarbage;
  JSCode('resizable:' + VarToJSON([Value, false]));
end;

procedure TExtComponent.SetFResizeHandles(Value : String); begin
  FResizeHandles := Value;
  JSCode('resizeHandles:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFShadowOffset(Value : Integer); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFSplit(Value : Boolean); begin
  FSplit := Value;
  JSCode('split:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFToFrontOnShow(Value : Boolean); begin
  FToFrontOnShow := Value;
  JSCode('toFrontOnShow:' + VarToJSON([Value]));
end;

procedure TExtComponent.SetFZIndexManager(Value : TExtZIndexManager); begin
  FZIndexManager := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.zIndexManager=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtComponent.SetFZIndexParent(Value : TExtContainer); begin
  FZIndexParent := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.zIndexParent=' + VarToJSON([Value, false]) + ';');
end;

function TExtComponent.JSClassName : string; begin
  Result := 'Ext.Component';
end;

procedure TExtComponent.InitDefaults; begin
  inherited;
  FConstrainTo := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FConstrainToElement := TExtElement.CreateInternal(Self, 'constrainTo');
  FDraggableObject := TExtObject.CreateInternal(Self, 'draggable');
  FFloatParent := TExtContainer.CreateInternal(Self, 'floatParent');
  FResizableObject := TExtObject.CreateInternal(Self, 'resizable');
  FZIndexManager := TExtZIndexManager.CreateInternal(Self, 'zIndexManager');
  FZIndexParent := TExtContainer.CreateInternal(Self, 'zIndexParent');
end;

{$IFDEF FPC}constructor TExtComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtComponent.Bubble(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.bubble(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Center : TExtFunction; begin
  JSCode(JSName + '.center();', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.CloneConfig(Overrides : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.cloneConfig(' + VarToJSON([Overrides, false]) + ');', 'TExtComponent');
  Result := Self;
end;

constructor TExtComponent.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

constructor TExtComponent.Create(Config : TExtElement); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

constructor TExtComponent.Create(Config : String); begin
  CreateVar(JSClassName + '(' + VarToJSON([Config]) + ');');
  InitDefaults;
end;

function TExtComponent.DoConstrain(ConstrainTo : String = '') : TExtFunction; begin
  JSCode(JSName + '.doConstrain(' + VarToJSON([ConstrainTo]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.DoConstrain(ConstrainTo : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentBy(Fn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.findParentBy(' + VarToJSON([Fn, true]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentByType(Xtype : TExtClass) : TExtFunction; begin
  JSCode(JSName + '.FindParentByType(' + VarToJSON([Xtype, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.FindParentByType(Xtype : String) : TExtFunction; begin
  JSCode(JSName + '.findParentByType(' + VarToJSON([Xtype]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Focus(SelectText : Boolean; Delay : Integer) : TExtFunction; begin
  JSCode(JSName + '.Focus(' + VarToJSON([SelectText, Delay]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Focus(SelectText : Boolean = false; Delay : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.focus(' + VarToJSON([SelectText, Delay]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.GetPosition(Local : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getPosition(' + VarToJSON([Local]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.GetXType : TExtFunction; begin
  JSCode(JSName + '.getXType();', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : TExtComponent; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Hide(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Hide(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([AnimateTarget, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TExtObject; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, false, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : TExtObject; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, false, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : TArrayOfInteger; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ScrollBy(DeltaX : Integer; DeltaY : Boolean; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.scrollBy(' + VarToJSON([DeltaX, DeltaY, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.setActive(' + VarToJSON([Active, NewActive, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetAutoScroll(Scroll : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAutoScroll(' + VarToJSON([Scroll]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : TExtObject; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetLoading(' + VarToJSON([Load, false, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : String; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetLoading(' + VarToJSON([Load, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetLoading(Load : Boolean; TargetEl : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setLoading(' + VarToJSON([Load, TargetEl]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetOverflowXY(OverflowX : String; OverflowY : String) : TExtFunction; begin
  JSCode(JSName + '.setOverflowXY(' + VarToJSON([OverflowX, OverflowY]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPagePosition(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetPagePosition(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetPagePosition(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.SetPagePosition(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setPagePosition(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Show(AnimateTarget : TExtElement; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.Show(' + VarToJSON([AnimateTarget, false, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.Show(AnimateTarget : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([AnimateTarget, Callback, true, Scope, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : Integer; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ShowAt(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : TArrayOfInteger; Y : Integer; Animate : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.ShowAt(' + VarToJSON([X, Y, Animate, false]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : TArrayOfInteger; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ShowAt(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowAt(X : Integer; Y : Integer = 0; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.showAt(' + VarToJSON([X, Y, Animate]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowBy(Component : TExtElement; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([Component, false, Position, Offsets]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ShowBy(Component : TExtComponent; Position : String = ''; Offsets : TArrayOfInteger = nil) : TExtFunction; begin
  JSCode(JSName + '.showBy(' + VarToJSON([Component, false, Position, Offsets]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ToBack : TExtFunction; begin
  JSCode(JSName + '.toBack();', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.ToFront(PreventFocus : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toFront(' + VarToJSON([PreventFocus]) + ');', 'TExtComponent');
  Result := Self;
end;

function TExtComponent.UpdateBox(Box : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.updateBox(' + VarToJSON([Box, false]) + ');', 'TExtComponent');
  Result := Self;
end;

destructor TExtComponent.Destroy; begin
  try
    FConstrainTo.Free;
    FConstrainToElement.Free;
    FDraggableObject.Free;
    FFloatParent.Free;
    FResizableObject.Free;
    FZIndexManager.Free;
    FZIndexParent.Free;
  except end;
  inherited;
end;

function TExtZIndexManager.JSClassName : string; begin
  Result := 'Ext.ZIndexManager';
end;

{$IFDEF FPC}constructor TExtZIndexManager.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtZIndexManager.BringToFront(Comp : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.BringToFront(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.BringToFront(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.bringToFront(' + VarToJSON([Comp]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.EachBottomUp(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.eachBottomUp(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.EachTopDown(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.eachTopDown(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Get(Id : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Get(' + VarToJSON([Id, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Get(Id : String) : TExtFunction; begin
  JSCode(JSName + '.get(' + VarToJSON([Id]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.GetActive : TExtFunction; begin
  JSCode(JSName + '.getActive();', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.GetBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Register(Comp : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.SendToBack(Comp : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SendToBack(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.SendToBack(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.sendToBack(' + VarToJSON([Comp]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtZIndexManager.Unregister(Comp : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Comp, false]) + ');', 'TExtZIndexManager');
  Result := Self;
end;

function TExtComponentQuerySingleton.JSClassName : string; begin
  Result := 'Ext.ComponentQuery';
end;

{$IFDEF FPC}constructor TExtComponentQuerySingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtComponentQuerySingleton.IsJS(Component : TExtComponent; Selector : String) : TExtFunction; begin
  JSCode(JSName + '.is(' + VarToJSON([Component, false, Selector]) + ');', 'TExtComponentQuerySingleton');
  Result := Self;
end;

function TExtComponentQuerySingleton.Query(Selector : String; Root : TExtContainer = nil) : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([Selector, Root, false]) + ');', 'TExtComponentQuerySingleton');
  Result := Self;
end;

function TExtChartTheme.JSClassName : string; begin
  Result := 'Ext.chart.theme.Theme';
end;

{$IFDEF FPC}constructor TExtChartTheme.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartMask.SetFMask(Value : Boolean); begin
  FMask := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

procedure TExtChartMask.SetFMaskString(Value : String); begin
  FMaskString := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

function TExtChartMask.JSClassName : string; begin
  Result := 'Ext.chart.Mask';
end;

{$IFDEF FPC}constructor TExtChartMask.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartMask.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

procedure TExtChartLegend.SetFBoxFill(Value : String); begin
  FBoxFill := Value;
  JSCode('boxFill:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxStroke(Value : String); begin
  FBoxStroke := Value;
  JSCode('boxStroke:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxStrokeWidth(Value : String); begin
  FBoxStrokeWidth := Value;
  JSCode('boxStrokeWidth:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFBoxZIndex(Value : Integer); begin
  FBoxZIndex := Value;
  JSCode('boxZIndex:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFItemSpacing(Value : Integer); begin
  FItemSpacing := Value;
  JSCode('itemSpacing:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFLabelColor(Value : String); begin
  FLabelColor := Value;
  JSCode('labelColor:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFLabelFont(Value : String); begin
  FLabelFont := Value;
  JSCode('labelFont:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFPadding(Value : Integer); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFUpdate(Value : Boolean); begin
  FUpdate := Value;
  JSCode('update:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFVisible(Value : Boolean); begin
  FVisible := Value;
  JSCode('visible:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtChartLegend.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

function TExtChartLegend.JSClassName : string; begin
  Result := 'Ext.chart.Legend';
end;

procedure TExtChartLegend.InitDefaults; begin
  inherited;
  FBoxZIndex := 100;
end;

{$IFDEF FPC}constructor TExtChartLegend.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartLegend.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

constructor TExtChartLegend.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartLegend.Toggle(Show : Boolean) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([Show]) + ');', 'TExtChartLegend');
  Result := Self;
end;

function TExtChartNavigation.JSClassName : string; begin
  Result := 'Ext.chart.Navigation';
end;

{$IFDEF FPC}constructor TExtChartNavigation.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartNavigation.RestoreZoom : TExtFunction; begin
  JSCode(JSName + '.restoreZoom();', 'TExtChartNavigation');
  Result := Self;
end;

function TExtChartNavigation.SetZoom : TExtFunction; begin
  JSCode(JSName + '.setZoom();', 'TExtChartNavigation');
  Result := Self;
end;

function TExtChartShapeSingleton.JSClassName : string; begin
  Result := 'Ext.chart.Shape';
end;

{$IFDEF FPC}constructor TExtChartShapeSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartSeries.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChartSeries.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChartSeries.SetFHighlight(Value : Boolean); begin
  FHighlight := Value;
  JSCode('highlight:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFHighlightCfg(Value : TExtObject); begin
  FHighlightCfg := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.highlightCfg=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChartSeries.SetFHighlightObject(Value : TExtObject); begin
  FHighlightObject := Value;
  Value.DeleteFromGarbage;
  JSCode('highlight:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtChartSeries.SetFLabelColor(Value : String); begin
  FLabelColor := Value;
  JSCode('labelColor:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelContrast(Value : Boolean); begin
  FLabelContrast := Value;
  JSCode('labelContrast:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelDisplay(Value : String); begin
  FLabelDisplay := Value;
  JSCode('labelDisplay:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelField(Value : String); begin
  FLabelField := Value;
  JSCode('labelField:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelFont(Value : String); begin
  FLabelFont := Value;
  JSCode('labelFont:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelJS(Value : TExtObject); begin
  FLabelJS := Value;
  Value.DeleteFromGarbage;
  JSCode('labelJS:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFLabelMinMargin(Value : Integer); begin
  FLabelMinMargin := Value;
  JSCode('labelMinMargin:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelOrientation(Value : String); begin
  FLabelOrientation := Value;
  JSCode('labelOrientation:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFLabelRenderer(Value : TExtFunction); begin
  FLabelRenderer := Value;
  JSCode('labelRenderer:' + VarToJSON([Value, true]));
end;

procedure TExtChartSeries.SetFLabelStackedDisplay(Value : String); begin
  FLabelStackedDisplay := Value;
  JSCode('labelStackedDisplay:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtChartSeries.SetFShadowAttributes(Value : TExtObjectList); begin
  FShadowAttributes := Value;
  Value.DeleteFromGarbage;
  JSCode('shadowAttributes:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFTips(Value : TExtObject); begin
  FTips := Value;
  Value.DeleteFromGarbage;
  JSCode('tips:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeries.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtChartSeries.SetFOnTitlechange(Value : TExtChartSeriesOnTitlechange); begin
  if Assigned(FOnTitlechange) then
    JSCode(JSName+'.events ["titlechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('titlechange', Ajax('titlechange', ['Title', '%0','Index', '%1'], true));
  FOnTitlechange := Value;
end;

function TExtChartSeries.JSClassName : string; begin
  Result := 'Ext.chart.series.Series';
end;

procedure TExtChartSeries.InitDefaults; begin
  inherited;
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FHighlightCfg := TExtObject.CreateInternal(Self, 'highlightCfg');
  FHighlightObject := TExtObject.CreateInternal(Self, 'highlight');
  FLabelJS := TExtObject.CreateInternal(Self, 'labelJS');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FShadowAttributes := TExtObjectList.Create(Self, 'shadowAttributes');
  FTips := TExtObject.CreateInternal(Self, 'tips');
end;

{$IFDEF FPC}constructor TExtChartSeries.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartSeries.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtChartSeries');
  Result := Self;
end;

constructor TExtChartSeries.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeries.EachRecord(Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.eachRecord(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetItemForPoint(X : Integer; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.getItemForPoint(' + VarToJSON([X, Y]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetLegendColor : TExtFunction; begin
  JSCode(JSName + '.getLegendColor();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.GetRecordCount : TExtFunction; begin
  JSCode(JSName + '.getRecordCount();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.HideAll : TExtFunction; begin
  JSCode(JSName + '.hideAll();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.HighlightItem(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Item, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.IsExcluded : TExtFunction; begin
  JSCode(JSName + '.isExcluded();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.SetTitle(Index : Integer; Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Index, Title]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.ShowAll : TExtFunction; begin
  JSCode(JSName + '.showAll();', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtChartSeries');
  Result := Self;
end;

function TExtChartSeries.UnHighlightItem : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem();', 'TExtChartSeries');
  Result := Self;
end;

destructor TExtChartSeries.Destroy; begin
  try
    FGlobalEvents.Free;
    FHasListeners.Free;
    FHighlightCfg.Free;
    FHighlightObject.Free;
    FLabelJS.Free;
    FListeners.Free;
    FShadowAttributes.Free;
    FTips.Free;
  except end;
  inherited;
end;

procedure TExtChartSeries.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'titlechange') and Assigned(FOnTitlechange) then
    FOnTitlechange(ParamAsString('Title'), ParamAsInteger('Index'));
end;

procedure TExtDataValidationsSingleton.SetFEmailMessage(Value : String); begin
  FEmailMessage := Value;
  JSCode(JSName + '.emailMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFEmailRe(Value : TRegExp); begin
  FEmailRe := Value;
  JSCode(JSName + '.emailRe=' + VarToJSON([#3 +Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFExclusionMessage(Value : String); begin
  FExclusionMessage := Value;
  JSCode(JSName + '.exclusionMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFFormatMessage(Value : String); begin
  FFormatMessage := Value;
  JSCode(JSName + '.formatMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFInclusionMessage(Value : String); begin
  FInclusionMessage := Value;
  JSCode(JSName + '.inclusionMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFLengthMessage(Value : String); begin
  FLengthMessage := Value;
  JSCode(JSName + '.lengthMessage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataValidationsSingleton.SetFPresenceMessage(Value : String); begin
  FPresenceMessage := Value;
  JSCode(JSName + '.presenceMessage=' + VarToJSON([Value]) + ';');
end;

function TExtDataValidationsSingleton.JSClassName : string; begin
  Result := 'Ext.data.validations';
end;

{$IFDEF FPC}constructor TExtDataValidationsSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataValidationsSingleton.Email(Config : TExtObject; Email : String) : TExtFunction; begin
  JSCode(JSName + '.email(' + VarToJSON([Config, false, Email]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

function TExtDataValidationsSingleton.Exclusion(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.exclusion(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

function TExtDataValidationsSingleton.Format(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.format(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

function TExtDataValidationsSingleton.Inclusion(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.inclusion(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

function TExtDataValidationsSingleton.Length(Config : TExtObject; Value : String) : TExtFunction; begin
  JSCode(JSName + '.length(' + VarToJSON([Config, false, Value]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

function TExtDataValidationsSingleton.Presence(Config : TExtObject; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.presence(' + VarToJSON([Config, false, Value, false]) + ');', 'TExtDataValidationsSingleton');
  Result := Self;
end;

procedure TExtDataTypesSingleton.SetFStripRe(Value : TRegExp); begin
  FStripRe := Value;
  JSCode(JSName + '.stripRe=' + VarToJSON([#3 +Value]) + ';');
end;

function TExtDataTypesSingleton.JSClassName : string; begin
  Result := 'Ext.data.Types';
end;

class function TExtDataTypesSingleton.AUTO : TExtObject;
const
  lAUTO : TExtObject = nil;
begin
  if lAUTO = nil then lAUTO := TExtObject.CreateSingleton('Ext.data.Types.AUTO');
  Result := lAUTO
end;

class function TExtDataTypesSingleton.BOOL : TExtObject;
const
  lBOOL : TExtObject = nil;
begin
  if lBOOL = nil then lBOOL := TExtObject.CreateSingleton('Ext.data.Types.BOOL');
  Result := lBOOL
end;

class function TExtDataTypesSingleton.BOOLEAN : TExtObject;
const
  lBOOLEAN : TExtObject = nil;
begin
  if lBOOLEAN = nil then lBOOLEAN := TExtObject.CreateSingleton('Ext.data.Types.BOOLEAN');
  Result := lBOOLEAN
end;

class function TExtDataTypesSingleton.DATE : TExtObject;
const
  lDATE : TExtObject = nil;
begin
  if lDATE = nil then lDATE := TExtObject.CreateSingleton('Ext.data.Types.DATE');
  Result := lDATE
end;

class function TExtDataTypesSingleton.FLOAT : TExtObject;
const
  lFLOAT : TExtObject = nil;
begin
  if lFLOAT = nil then lFLOAT := TExtObject.CreateSingleton('Ext.data.Types.FLOAT');
  Result := lFLOAT
end;

class function TExtDataTypesSingleton.INT : TExtObject;
const
  lINT : TExtObject = nil;
begin
  if lINT = nil then lINT := TExtObject.CreateSingleton('Ext.data.Types.INT');
  Result := lINT
end;

class function TExtDataTypesSingleton.INTEGER : TExtObject;
const
  lINTEGER : TExtObject = nil;
begin
  if lINTEGER = nil then lINTEGER := TExtObject.CreateSingleton('Ext.data.Types.INTEGER');
  Result := lINTEGER
end;

class function TExtDataTypesSingleton.NUMBER : TExtObject;
const
  lNUMBER : TExtObject = nil;
begin
  if lNUMBER = nil then lNUMBER := TExtObject.CreateSingleton('Ext.data.Types.NUMBER');
  Result := lNUMBER
end;

class function TExtDataTypesSingleton.STRINGJS : TExtObject;
const
  lSTRINGJS : TExtObject = nil;
begin
  if lSTRINGJS = nil then lSTRINGJS := TExtObject.CreateSingleton('Ext.data.Types.STRINGJS');
  Result := lSTRINGJS
end;

{$IFDEF FPC}constructor TExtDataTypesSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdDragDropManagerSingleton.SetFClickPixelThresh(Value : Integer); begin
  FClickPixelThresh := Value;
  JSCode(JSName + '.clickPixelThresh=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFClickTimeThresh(Value : Integer); begin
  FClickTimeThresh := Value;
  JSCode(JSName + '.clickTimeThresh=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFDragCls(Value : String); begin
  FDragCls := Value;
  JSCode(JSName + '.dragCls=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFMode(Value : Integer); begin
  FMode := Value;
  JSCode(JSName + '.mode=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFNotifyOccluded(Value : Boolean); begin
  FNotifyOccluded := Value;
  JSCode(JSName + '.notifyOccluded=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode(JSName + '.preventDefault=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFStopPropagation(Value : Boolean); begin
  FStopPropagation := Value;
  JSCode(JSName + '.stopPropagation=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDropManagerSingleton.SetFUseCache(Value : Boolean); begin
  FUseCache := Value;
  JSCode(JSName + '.useCache=' + VarToJSON([Value]) + ';');
end;

function TExtDdDragDropManagerSingleton.JSClassName : string; begin
  Result := 'Ext.dd.DragDropManager';
end;

class function TExtDdDragDropManagerSingleton.INTERSECT : Integer; begin
  Result := 0
end;

class function TExtDdDragDropManagerSingleton.POINT : Integer; begin
  Result := 0
end;

{$IFDEF FPC}constructor TExtDdDragDropManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDragDropManagerSingleton.GetBestMatch(Dds : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.getBestMatch(' + VarToJSON(Dds) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetCss(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getCss(' + VarToJSON([Id]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetDDById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getDDById(' + VarToJSON([Id]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetLocation(ODD : TExtDdDragDrop) : TExtFunction; begin
  JSCode(JSName + '.getLocation(' + VarToJSON([ODD, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetPosY(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.getPosY(' + VarToJSON([El, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetRelated(P_oDD : TExtDdDragDrop; BTargetsOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getRelated(' + VarToJSON([P_oDD, false, BTargetsOnly]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetScrollLeft : TExtFunction; begin
  JSCode(JSName + '.getScrollLeft();', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetScrollTop : TExtFunction; begin
  JSCode(JSName + '.getScrollTop();', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.GetStyle(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.getStyle(' + VarToJSON([El, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.HandleWasClicked(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.handleWasClicked(' + VarToJSON([Node, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.IsDragDrop(Id : String) : TExtFunction; begin
  JSCode(JSName + '.isDragDrop(' + VarToJSON([Id]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.IsHandle(Id : String) : TExtFunction; begin
  JSCode(JSName + '.isHandle(' + VarToJSON([Id]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.IsLegalTarget(ODD : TExtDdDragDrop; OTargetDD : TExtDdDragDrop) : TExtFunction; begin
  JSCode(JSName + '.isLegalTarget(' + VarToJSON([ODD, false, OTargetDD, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.IsLocked : TExtFunction; begin
  JSCode(JSName + '.isLocked();', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.IsTypeOfDD(The : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isTypeOfDD(' + VarToJSON([The, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.Lock : TExtFunction; begin
  JSCode(JSName + '.lock();', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.MoveToEl(MoveEl : THTMLElement; TargetEl : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.moveToEl(' + VarToJSON([MoveEl, false, TargetEl, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.NumericSort(A : Integer; B : Integer) : TExtFunction; begin
  JSCode(JSName + '.numericSort(' + VarToJSON([A, B]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.RefreshCache(Groups : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.refreshCache(' + VarToJSON([Groups, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.RegDragDrop(ODD : TExtDdDragDrop; SGroup : String) : TExtFunction; begin
  JSCode(JSName + '.regDragDrop(' + VarToJSON([ODD, false, SGroup]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.RegHandle(SDDId : String; SHandleId : String) : TExtFunction; begin
  JSCode(JSName + '.regHandle(' + VarToJSON([SDDId, SHandleId]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.StartDrag(X : Integer; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.startDrag(' + VarToJSON([X, Y]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.StopEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.stopEvent(' + VarToJSON([E, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.SwapNode(N1 : THTMLElement; N2 : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.swapNode(' + VarToJSON([N1, false, N2, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.Unlock : TExtFunction; begin
  JSCode(JSName + '.unlock();', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

function TExtDdDragDropManagerSingleton.VerifyEl(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.verifyEl(' + VarToJSON([El, false]) + ');', 'TExtDdDragDropManagerSingleton');
  Result := Self;
end;

procedure TExtDirectManagerSingleton.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDirectManagerSingleton.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDirectManagerSingleton.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDirectManagerSingleton.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDirectManagerSingleton.SetFOnEvent(Value : TExtDirectManagerSingletonOnEvent); begin
  if Assigned(FOnEvent) then
    JSCode(JSName+'.events ["event"].listeners=[];');
  if Assigned(Value) then
    AddListener('event', Ajax('event', ['Event', '%0.nm','Provider', '%1.nm'], true));
  FOnEvent := Value;
end;

procedure TExtDirectManagerSingleton.SetFOnException(Value : TExtDirectManagerSingletonOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['Event', '%0.nm'], true));
  FOnException := Value;
end;

function TExtDirectManagerSingleton.JSClassName : string; begin
  Result := 'Ext.direct.Manager';
end;

{$IFDEF FPC}constructor TExtDirectManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectManagerSingleton.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddProvider(Provider : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.AddProvider(' + VarToJSON(Provider) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.AddProvider(Provider : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.addProvider(' + VarToJSON([Provider, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.GetProvider(Id : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.GetProvider(' + VarToJSON([Id, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.GetProvider(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getProvider(' + VarToJSON([Id]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveProvider(Provider : TExtDirectProvider) : TExtFunction; begin
  JSCode(JSName + '.RemoveProvider(' + VarToJSON([Provider, false]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.RemoveProvider(Provider : String) : TExtFunction; begin
  JSCode(JSName + '.removeProvider(' + VarToJSON([Provider]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

function TExtDirectManagerSingleton.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDirectManagerSingleton');
  Result := Self;
end;

procedure TExtDirectManagerSingleton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'event') and Assigned(FOnEvent) then
    FOnEvent(TExtDirectEvent(ParamAsObject('Event')), TExtDirectProvider(ParamAsObject('Provider')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDirectEvent(ParamAsObject('Event')));
end;

procedure TExtDdDragDrop.SetFAvailable(Value : Boolean); begin
  FAvailable := Value;
  JSCode(JSName + '.available=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFConfig(Value : TExtObject); begin
  FConfig := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.config=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFDefaultPadding(Value : TExtObject); begin
  FDefaultPadding := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.defaultPadding=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFGroups(Value : TExtObject); begin
  FGroups := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.groups=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFHasOuterHandles(Value : Boolean); begin
  FHasOuterHandles := Value;
  JSCode(JSName + '.hasOuterHandles=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFId(Value : String); begin
  FId := Value;
  JSCode(JSName + '.id=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFIgnoreSelf(Value : Boolean); begin
  FIgnoreSelf := Value;
  JSCode(JSName + '.ignoreSelf=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFInvalidHandleClasses(Value : TArrayOfString); begin
  FInvalidHandleClasses := Value;
  JSCode(JSName + '.invalidHandleClasses=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFInvalidHandleTypes(Value : TExtObject); begin
  FInvalidHandleTypes := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.invalidHandleTypes=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragDrop.SetFIsTarget(Value : Boolean); begin
  FIsTarget := Value;
  JSCode(JSName + '.isTarget=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFMaintainOffset(Value : Boolean); begin
  FMaintainOffset := Value;
  JSCode(JSName + '.maintainOffset=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFMoveOnly(Value : Boolean); begin
  FMoveOnly := Value;
  JSCode(JSName + '.moveOnly=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFPadding(Value : TArrayOfInteger); begin
  FPadding := Value;
  JSCode(JSName + '.padding=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFPrimaryButtonOnly(Value : Boolean); begin
  FPrimaryButtonOnly := Value;
  JSCode(JSName + '.primaryButtonOnly=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragDrop.SetFXTicks(Value : TArrayOfInteger); begin
  FXTicks := Value;
  JSCode(JSName + '.xTicks=' + ArrayToJSON(Value) + ';');
end;

procedure TExtDdDragDrop.SetFYTicks(Value : TArrayOfInteger); begin
  FYTicks := Value;
  JSCode(JSName + '.yTicks=' + ArrayToJSON(Value) + ';');
end;

function TExtDdDragDrop.JSClassName : string; begin
  Result := 'Ext.dd.DragDrop';
end;

procedure TExtDdDragDrop.InitDefaults; begin
  inherited;
  FConfig := TExtObject.CreateInternal(Self, 'config');
  FDefaultPadding := TExtObject.CreateInternal(Self, 'defaultPadding');
  FGroups := TExtObject.CreateInternal(Self, 'groups');
  FIgnoreSelf := true;
  FInvalidHandleTypes := TExtObject.CreateInternal(Self, 'invalidHandleTypes');
end;

{$IFDEF FPC}constructor TExtDdDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDragDrop.AddInvalidHandleClass(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleClass(' + VarToJSON([CssClass]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddInvalidHandleId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddInvalidHandleType(TagName : String) : TExtFunction; begin
  JSCode(JSName + '.addInvalidHandleType(' + VarToJSON([TagName]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.AddToGroup(SGroup : String) : TExtFunction; begin
  JSCode(JSName + '.addToGroup(' + VarToJSON([SGroup]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ApplyConfig : TExtFunction; begin
  JSCode(JSName + '.applyConfig();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ClearConstraints : TExtFunction; begin
  JSCode(JSName + '.clearConstraints();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ClearTicks : TExtFunction; begin
  JSCode(JSName + '.clearTicks();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : String; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : THTMLElement; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : THTMLElement; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : TExtElement; Pad : TExtObject; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, false, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : TExtElement; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.ConstrainTo(' + VarToJSON([ConstrainTo, false, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ConstrainTo(ConstrainTo : String; Pad : Integer = 0; InContent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.constrainTo(' + VarToJSON([ConstrainTo, Pad, InContent]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

constructor TExtDdDragDrop.Create(Id : String; SGroup : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Id, SGroup, Config, false]) + ');');
  InitDefaults;
end;

function TExtDdDragDrop.EndDrag(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.endDrag(' + VarToJSON([E, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.GetDragEl : TExtFunction; begin
  JSCode(JSName + '.getDragEl();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.GetEl : TExtFunction; begin
  JSCode(JSName + '.getEl();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Init(Id : String; SGroup : String; Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.init(' + VarToJSON([Id, SGroup, Config, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.InitTarget(Id : String; SGroup : String; Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.initTarget(' + VarToJSON([Id, SGroup, Config, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.IsLocked : TExtFunction; begin
  JSCode(JSName + '.isLocked();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.IsValidHandleChild(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.isValidHandleChild(' + VarToJSON([Node, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Lock : TExtFunction; begin
  JSCode(JSName + '.lock();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnAvailable : TExtFunction; begin
  JSCode(JSName + '.onAvailable();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDrag(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.onDrag(' + VarToJSON([E, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragDrop(E : TEvent; Id : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.OnDragDrop(' + VarToJSON([E, false]) + ',' + VarToJSON(Id) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragDrop(E : TEvent; Id : String) : TExtFunction; begin
  JSCode(JSName + '.onDragDrop(' + VarToJSON([E, false, Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragEnter(E : TEvent; Id : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.OnDragEnter(' + VarToJSON([E, false]) + ',' + VarToJSON(Id) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragEnter(E : TEvent; Id : String) : TExtFunction; begin
  JSCode(JSName + '.onDragEnter(' + VarToJSON([E, false, Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragOut(E : TEvent; Id : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.OnDragOut(' + VarToJSON([E, false]) + ',' + VarToJSON(Id) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragOut(E : TEvent; Id : String) : TExtFunction; begin
  JSCode(JSName + '.onDragOut(' + VarToJSON([E, false, Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragOver(E : TEvent; Id : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.OnDragOver(' + VarToJSON([E, false]) + ',' + VarToJSON(Id) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnDragOver(E : TEvent; Id : String) : TExtFunction; begin
  JSCode(JSName + '.onDragOver(' + VarToJSON([E, false, Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnInvalidDrop(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.onInvalidDrop(' + VarToJSON([E, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnMouseDown(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.onMouseDown(' + VarToJSON([E, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.OnMouseUp(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.onMouseUp(' + VarToJSON([E, false]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveFromGroup(SGroup : String) : TExtFunction; begin
  JSCode(JSName + '.removeFromGroup(' + VarToJSON([SGroup]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleClass(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleClass(' + VarToJSON([CssClass]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.RemoveInvalidHandleType(TagName : String) : TExtFunction; begin
  JSCode(JSName + '.removeInvalidHandleType(' + VarToJSON([TagName]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ResetConstraints(MaintainOffset : Boolean) : TExtFunction; begin
  JSCode(JSName + '.resetConstraints(' + VarToJSON([MaintainOffset]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetDragElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setDragElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetHandleElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setHandleElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetInitPosition(DiffX : Integer; DiffY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setInitPosition(' + VarToJSON([DiffX, DiffY]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetOuterHandleElId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.setOuterHandleElId(' + VarToJSON([Id]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetPadding(ITop : Integer; IRight : Integer; IBot : Integer; ILeft : Integer) : TExtFunction; begin
  JSCode(JSName + '.setPadding(' + VarToJSON([ITop, IRight, IBot, ILeft]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetXConstraint(ILeft : Integer; IRight : Integer; ITickSize : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setXConstraint(' + VarToJSON([ILeft, IRight, ITickSize]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.SetYConstraint(IUp : Integer; IDown : Integer; ITickSize : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setYConstraint(' + VarToJSON([IUp, IDown, ITickSize]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.StartDrag(X : Integer; Y : Integer) : TExtFunction; begin
  JSCode(JSName + '.startDrag(' + VarToJSON([X, Y]) + ');', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Unlock : TExtFunction; begin
  JSCode(JSName + '.unlock();', 'TExtDdDragDrop');
  Result := Self;
end;

function TExtDdDragDrop.Unreg : TExtFunction; begin
  JSCode(JSName + '.unreg();', 'TExtDdDragDrop');
  Result := Self;
end;

destructor TExtDdDragDrop.Destroy; begin
  try
    FConfig.Free;
    FDefaultPadding.Free;
    FGroups.Free;
    FInvalidHandleTypes.Free;
  except end;
  inherited;
end;

procedure TExtDdDragTracker.SetFActive(Value : Boolean); begin
  FActive := Value;
  JSCode(JSName + '.active=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragTracker.SetFAutoStart(Value : Boolean); begin
  FAutoStart := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFAutoStartInteger(Value : Integer); begin
  FAutoStartInteger := Value;
  JSCode('autoStart:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFConstrainTo(Value : TExtUtilRegion); begin
  FConstrainTo := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragTracker.SetFConstrainToElement(Value : TExtElement); begin
  FConstrainToElement := Value;
  Value.DeleteFromGarbage;
  JSCode('constrainTo:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragTracker.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFDragTarget(Value : THTMLElement); begin
  FDragTarget := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dragTarget=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragTracker.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragTracker.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragTracker.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDragTracker.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragTracker.SetFOverCls(Value : String); begin
  FOverCls := Value;
  JSCode('overCls:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFStopEvent(Value : Boolean); begin
  FStopEvent := Value;
  JSCode('stopEvent:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFTolerance(Value : Integer); begin
  FTolerance := Value;
  JSCode('tolerance:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFTrackOver(Value : Boolean); begin
  FTrackOver := Value;
  JSCode('trackOver:' + VarToJSON([Value]));
end;

procedure TExtDdDragTracker.SetFOnBeforestart(Value : TExtDdDragTrackerOnBeforestart); begin
  if Assigned(FOnBeforestart) then
    JSCode(JSName+'.events ["beforestart"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestart', Ajax('beforestart', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforestart := Value;
end;

procedure TExtDdDragTracker.SetFOnDrag(Value : TExtDdDragTrackerOnDrag); begin
  if Assigned(FOnDrag) then
    JSCode(JSName+'.events ["drag"].listeners=[];');
  if Assigned(Value) then
    AddListener('drag', Ajax('drag', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDrag := Value;
end;

procedure TExtDdDragTracker.SetFOnDragend(Value : TExtDdDragTrackerOnDragend); begin
  if Assigned(FOnDragend) then
    JSCode(JSName+'.events ["dragend"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragend', Ajax('dragend', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDragend := Value;
end;

procedure TExtDdDragTracker.SetFOnDragstart(Value : TExtDdDragTrackerOnDragstart); begin
  if Assigned(FOnDragstart) then
    JSCode(JSName+'.events ["dragstart"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragstart', Ajax('dragstart', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDragstart := Value;
end;

procedure TExtDdDragTracker.SetFOnMousedown(Value : TExtDdDragTrackerOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtDdDragTracker.SetFOnMousemove(Value : TExtDdDragTrackerOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMousemove := Value;
end;

procedure TExtDdDragTracker.SetFOnMouseout(Value : TExtDdDragTrackerOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtDdDragTracker.SetFOnMouseover(Value : TExtDdDragTrackerOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['This', '%0.nm','E', '%1.nm','Target', '%2.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtDdDragTracker.SetFOnMouseup(Value : TExtDdDragTrackerOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseup := Value;
end;

function TExtDdDragTracker.JSClassName : string; begin
  Result := 'Ext.dd.DragTracker';
end;

procedure TExtDdDragTracker.InitDefaults; begin
  inherited;
  FConstrainTo := TExtUtilRegion.CreateInternal(Self, 'constrainTo');
  FConstrainToElement := TExtElement.CreateInternal(Self, 'constrainTo');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
end;

{$IFDEF FPC}constructor TExtDdDragTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDragTracker.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDdDragTracker');
  Result := Self;
end;

constructor TExtDdDragTracker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDdDragTracker.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.GetDragTarget : TExtFunction; begin
  JSCode(JSName + '.getDragTarget();', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.GetOffset(ConstrainMode : String = '') : TExtFunction; begin
  JSCode(JSName + '.getOffset(' + VarToJSON([ConstrainMode]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.InitEl(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.InitEl(' + VarToJSON([El, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.InitEl(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.initEl(' + VarToJSON([El, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

function TExtDdDragTracker.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDdDragTracker');
  Result := Self;
end;

destructor TExtDdDragTracker.Destroy; begin
  try
    FConstrainTo.Free;
    FConstrainToElement.Free;
    FGlobalEvents.Free;
    FHasListeners.Free;
    FListeners.Free;
  except end;
  inherited;
end;

procedure TExtDdDragTracker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforestart') and Assigned(FOnBeforestart) then
    FOnBeforestart(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'drag') and Assigned(FOnDrag) then
    FOnDrag(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'dragend') and Assigned(FOnDragend) then
    FOnDragend(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'dragstart') and Assigned(FOnDragstart) then
    FOnDragstart(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')), THTMLElement(ParamAsObject('Target')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtDdDragTracker(ParamAsObject('This')), TExtObject(ParamAsObject('E')));
end;

function TExtDiagLayoutContext.JSClassName : string; begin
  Result := 'Ext.diag.layout.Context';
end;

{$IFDEF FPC}constructor TExtDiagLayoutContext.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDiagLayoutContextItem.JSClassName : string; begin
  Result := 'Ext.diag.layout.ContextItem';
end;

{$IFDEF FPC}constructor TExtDiagLayoutContextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdScrollManagerSingleton.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode(JSName + '.ddGroup=' + VarToJSON([Value]) + ';');
end;

function TExtDdScrollManagerSingleton.JSClassName : string; begin
  Result := 'Ext.dd.ScrollManager';
end;

{$IFDEF FPC}constructor TExtDdScrollManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdScrollManagerSingleton.RefreshCache : TExtFunction; begin
  JSCode(JSName + '.refreshCache();', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Register(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON([El, false]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Register(El : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON(El) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Register(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON([El, false]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Register(El : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON([El]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Register(El : String) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([El]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Unregister(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Unregister(El : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON(El) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Unregister(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Unregister(El : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDdScrollManagerSingleton.Unregister(El : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([El]) + ');', 'TExtDdScrollManagerSingleton');
  Result := Self;
end;

function TExtDirectEvent.JSClassName : string; begin
  Result := 'Ext.direct.Event';
end;

{$IFDEF FPC}constructor TExtDirectEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDirectEvent.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDirectEvent.GetData : TExtFunction; begin
  JSCode(JSName + '.getData();', 'TExtDirectEvent');
  Result := Self;
end;

function TExtDirectEvent.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtDirectEvent');
  Result := Self;
end;

function TExtDdRegistrySingleton.JSClassName : string; begin
  Result := 'Ext.dd.Registry';
end;

{$IFDEF FPC}constructor TExtDdRegistrySingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdRegistrySingleton.GetHandle(Id : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetHandle(' + VarToJSON([Id, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.GetHandle(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getHandle(' + VarToJSON([Id]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.GetHandleFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getHandleFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.GetTarget(Id : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetTarget(' + VarToJSON([Id, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.GetTarget(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getTarget(' + VarToJSON([Id]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.GetTargetFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getTargetFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.Register(Element : THTMLElement; Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Register(' + VarToJSON([Element, false, Data, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.Register(Element : String; Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Element, Data, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.Unregister(Element : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([Element, false]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

function TExtDdRegistrySingleton.Unregister(Element : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Element]) + ');', 'TExtDdRegistrySingleton');
  Result := Self;
end;

procedure TExtDataWriter.SetFDateFormat(Value : String); begin
  FDateFormat := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtDataWriter.SetFIsWriter(Value : Boolean); begin
  FIsWriter := Value;
  JSCode(JSName + '.isWriter=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataWriter.SetFNameProperty(Value : String); begin
  FNameProperty := Value;
  JSCode('nameProperty:' + VarToJSON([Value]));
end;

procedure TExtDataWriter.SetFWriteAllFields(Value : Boolean); begin
  FWriteAllFields := Value;
  JSCode('writeAllFields:' + VarToJSON([Value]));
end;

procedure TExtDataWriter.SetFWriteRecordId(Value : Boolean); begin
  FWriteRecordId := Value;
  JSCode('writeRecordId:' + VarToJSON([Value]));
end;

function TExtDataWriter.JSClassName : string; begin
  Result := 'Ext.data.writer.Writer';
end;

{$IFDEF FPC}constructor TExtDataWriter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataWriter.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataWriter.GetRecordData(RecordJS : TExtDataModel; Operation : TExtDataOperation = nil) : TExtFunction; begin
  JSCode(JSName + '.getRecordData(' + VarToJSON([RecordJS, false, Operation, false]) + ');', 'TExtDataWriter');
  Result := Self;
end;

function TExtDataWriter.Write(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.write(' + VarToJSON([Request, false]) + ');', 'TExtDataWriter');
  Result := Self;
end;

procedure TExtDirectProvider.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDirectProvider.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDirectProvider.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtDirectProvider.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtDirectProvider.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtDirectProvider.SetFRelayedEvents(Value : TArrayOfString); begin
  FRelayedEvents := Value;
  JSCode('relayedEvents:' + ArrayToJSON(Value));
end;

procedure TExtDirectProvider.SetFOnConnect(Value : TExtDirectProviderOnConnect); begin
  if Assigned(FOnConnect) then
    JSCode(JSName+'.events ["connect"].listeners=[];');
  if Assigned(Value) then
    AddListener('connect', Ajax('connect', ['Provider', '%0.nm'], true));
  FOnConnect := Value;
end;

procedure TExtDirectProvider.SetFOnData(Value : TExtDirectProviderOnData); begin
  if Assigned(FOnData) then
    JSCode(JSName+'.events ["data"].listeners=[];');
  if Assigned(Value) then
    AddListener('data', Ajax('data', ['Provider', '%0.nm','E', '%1.nm'], true));
  FOnData := Value;
end;

procedure TExtDirectProvider.SetFOnDisconnect(Value : TExtDirectProviderOnDisconnect); begin
  if Assigned(FOnDisconnect) then
    JSCode(JSName+'.events ["disconnect"].listeners=[];');
  if Assigned(Value) then
    AddListener('disconnect', Ajax('disconnect', ['Provider', '%0.nm'], true));
  FOnDisconnect := Value;
end;

procedure TExtDirectProvider.SetFOnException(Value : TExtDirectProviderOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', [], true));
  FOnException := Value;
end;

function TExtDirectProvider.JSClassName : string; begin
  Result := 'Ext.direct.Provider';
end;

{$IFDEF FPC}constructor TExtDirectProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectProvider.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

function TExtDirectProvider.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtDirectProvider');
  Result := Self;
end;

procedure TExtDirectProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'connect') and Assigned(FOnConnect) then
    FOnConnect(TExtDirectProvider(ParamAsObject('Provider')))
  else if (AEvtName = 'data') and Assigned(FOnData) then
    FOnData(TExtDirectProvider(ParamAsObject('Provider')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'disconnect') and Assigned(FOnDisconnect) then
    FOnDisconnect(TExtDirectProvider(ParamAsObject('Provider')))
  else if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException();
end;

function TExtGridProperty.JSClassName : string; begin
  Result := 'Ext.grid.property.Property';
end;

{$IFDEF FPC}constructor TExtGridProperty.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginHeaderReorderer.JSClassName : string; begin
  Result := 'Ext.grid.plugin.HeaderReorderer';
end;

{$IFDEF FPC}constructor TExtGridPluginHeaderReorderer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginRowExpander.SetFExpandOnDblClick(Value : Boolean); begin
  FExpandOnDblClick := Value;
  JSCode('expandOnDblClick:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowExpander.SetFExpandOnEnter(Value : Boolean); begin
  FExpandOnEnter := Value;
  JSCode('expandOnEnter:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowExpander.SetFSelectRowOnExpand(Value : Boolean); begin
  FSelectRowOnExpand := Value;
  JSCode('selectRowOnExpand:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowExpander.SetFOnCollapsebody(Value : TExtGridPluginRowExpanderOnCollapsebody); begin
  if Assigned(FOnCollapsebody) then
    JSCode(JSName+'.events ["collapsebody"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapsebody', Ajax('collapsebody', ['RowNode', '%0.nm','RecordJS', '%1.nm','ExpandRow', '%2.nm'], true));
  FOnCollapsebody := Value;
end;

procedure TExtGridPluginRowExpander.SetFOnExpandbody(Value : TExtGridPluginRowExpanderOnExpandbody); begin
  if Assigned(FOnExpandbody) then
    JSCode(JSName+'.events ["expandbody"].listeners=[];');
  if Assigned(Value) then
    AddListener('expandbody', Ajax('expandbody', ['RowNode', '%0.nm','RecordJS', '%1.nm','ExpandRow', '%2.nm'], true));
  FOnExpandbody := Value;
end;

function TExtGridPluginRowExpander.JSClassName : string; begin
  Result := 'Ext.grid.plugin.RowExpander';
end;

{$IFDEF FPC}constructor TExtGridPluginRowExpander.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginRowExpander.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'collapsebody') and Assigned(FOnCollapsebody) then
    FOnCollapsebody(THTMLElement(ParamAsObject('RowNode')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('ExpandRow')))
  else if (AEvtName = 'expandbody') and Assigned(FOnExpandbody) then
    FOnExpandbody(THTMLElement(ParamAsObject('RowNode')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('ExpandRow')));
end;

procedure TExtChartSeriesPie.SetFAngleField(Value : String); begin
  FAngleField := Value;
  JSCode('angleField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFColorSet(Value : TExtObjectList); begin
  FColorSet := Value;
  Value.DeleteFromGarbage;
  JSCode('colorSet:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesPie.SetFDonut(Value : Boolean); begin
  FDonut := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFDonutInteger(Value : Integer); begin
  FDonutInteger := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFField(Value : String); begin
  FField := Value;
  JSCode('field:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFHighlightDuration(Value : Integer); begin
  FHighlightDuration := Value;
  JSCode('highlightDuration:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFLengthField(Value : String); begin
  FLengthField := Value;
  JSCode('lengthField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesPie.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesPie.SetFXField(Value : String); begin
  FXField := Value;
  JSCode('xField:' + VarToJSON([Value]));
end;

function TExtChartSeriesPie.JSClassName : string; begin
  Result := 'Ext.chart.series.Pie';
end;

procedure TExtChartSeriesPie.InitDefaults; begin
  inherited;
  FColorSet := TExtObjectList.Create(Self, 'colorSet');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesPie.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesPie.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesPie.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.GetLegendColor(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.HighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

function TExtChartSeriesPie.UnHighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesPie');
  Result := Self;
end;

destructor TExtChartSeriesPie.Destroy; begin
  try
    FColorSet.Free;
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginHeaderResizer.SetFDynamic(Value : Boolean); begin
  FDynamic := Value;
  JSCode('dynamic:' + VarToJSON([Value]));
end;

function TExtGridPluginHeaderResizer.JSClassName : string; begin
  Result := 'Ext.grid.plugin.HeaderResizer';
end;

{$IFDEF FPC}constructor TExtGridPluginHeaderResizer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLoadMask.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFFixed(Value : Boolean); begin
  FFixed := Value;
  JSCode('fixed:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFFocusOnToFront(Value : Boolean); begin
  FFocusOnToFront := Value;
  JSCode('focusOnToFront:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFMaskCls(Value : String); begin
  FMaskCls := Value;
  JSCode('maskCls:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFMsg(Value : String); begin
  FMsg := Value;
  JSCode('msg:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFMsgCls(Value : String); begin
  FMsgCls := Value;
  JSCode('msgCls:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFShadow(Value : String); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFShadowBoolean(Value : Boolean); begin
  FShadowBoolean := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFShadowOffset(Value : Integer); begin
  FShadowOffset := Value;
  JSCode('shadowOffset:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtLoadMask.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtLoadMask.SetFUseMsg(Value : Boolean); begin
  FUseMsg := Value;
  JSCode('useMsg:' + VarToJSON([Value]));
end;

procedure TExtLoadMask.SetFUseTargetEl(Value : Boolean); begin
  FUseTargetEl := Value;
  JSCode('useTargetEl:' + VarToJSON([Value]));
end;

function TExtLoadMask.JSClassName : string; begin
  Result := 'Ext.LoadMask';
end;

procedure TExtLoadMask.InitDefaults; begin
  inherited;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FTarget := TExtComponent.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtLoadMask.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLoadMask.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.BindStore(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.Center : TExtFunction; begin
  JSCode(JSName + '.center();', 'TExtLoadMask');
  Result := Self;
end;

constructor TExtLoadMask.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtLoadMask.DoConstrain(ConstrainTo : String = '') : TExtFunction; begin
  JSCode(JSName + '.doConstrain(' + VarToJSON([ConstrainTo]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.DoConstrain(ConstrainTo : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.DoConstrain(ConstrainTo : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.DoConstrain(ConstrainTo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.DoConstrain(' + VarToJSON([ConstrainTo, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.SetActive(Active : Boolean = false; NewActive : TExtComponent = nil) : TExtFunction; begin
  JSCode(JSName + '.setActive(' + VarToJSON([Active, NewActive, false]) + ');', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.ToBack : TExtFunction; begin
  JSCode(JSName + '.toBack();', 'TExtLoadMask');
  Result := Self;
end;

function TExtLoadMask.ToFront(PreventFocus : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toFront(' + VarToJSON([PreventFocus]) + ');', 'TExtLoadMask');
  Result := Self;
end;

destructor TExtLoadMask.Destroy; begin
  try
    FStore.Free;
    FTarget.Free;
  except end;
  inherited;
end;

procedure TExtFlashComponent.SetFBackgroundColor(Value : String); begin
  FBackgroundColor := Value;
  JSCode('backgroundColor:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFExpressInstall(Value : Boolean); begin
  FExpressInstall := Value;
  JSCode('expressInstall:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFFlashAttributes(Value : TExtObject); begin
  FFlashAttributes := Value;
  Value.DeleteFromGarbage;
  JSCode('flashAttributes:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFFlashParams(Value : TExtObject); begin
  FFlashParams := Value;
  Value.DeleteFromGarbage;
  JSCode('flashParams:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFFlashVars(Value : TExtObject); begin
  FFlashVars := Value;
  Value.DeleteFromGarbage;
  JSCode('flashVars:' + VarToJSON([Value, false]));
end;

procedure TExtFlashComponent.SetFFlashVersion(Value : String); begin
  FFlashVersion := Value;
  JSCode('flashVersion:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwf(Value : TExtElement); begin
  FSwf := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.swf=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFlashComponent.SetFSwfHeight(Value : Integer); begin
  FSwfHeight := Value;
  JSCode('swfHeight:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfHeightString(Value : String); begin
  FSwfHeightString := Value;
  JSCode('swfHeight:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfWidth(Value : Integer); begin
  FSwfWidth := Value;
  JSCode('swfWidth:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFSwfWidthString(Value : String); begin
  FSwfWidthString := Value;
  JSCode('swfWidth:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFWmode(Value : String); begin
  FWmode := Value;
  JSCode('wmode:' + VarToJSON([Value]));
end;

procedure TExtFlashComponent.SetFOnFailure(Value : TExtFlashComponentOnFailure); begin
  if Assigned(FOnFailure) then
    JSCode(JSName+'.events ["failure"].listeners=[];');
  if Assigned(Value) then
    AddListener('failure', Ajax('failure', ['This', '%0.nm'], true));
  FOnFailure := Value;
end;

procedure TExtFlashComponent.SetFOnSuccess(Value : TExtFlashComponentOnSuccess); begin
  if Assigned(FOnSuccess) then
    JSCode(JSName+'.events ["success"].listeners=[];');
  if Assigned(Value) then
    AddListener('success', Ajax('success', ['This', '%0.nm'], true));
  FOnSuccess := Value;
end;

function TExtFlashComponent.JSClassName : string; begin
  Result := 'Ext.flash.Component';
end;

procedure TExtFlashComponent.InitDefaults; begin
  inherited;
  FFlashAttributes := TExtObject.CreateInternal(Self, 'flashAttributes');
  FFlashParams := TExtObject.CreateInternal(Self, 'flashParams');
  FFlashVars := TExtObject.CreateInternal(Self, 'flashVars');
  FSwf := TExtElement.CreateInternal(Self, 'swf');
  FSwfHeight := 100;
  FSwfWidth := 100;
end;

{$IFDEF FPC}constructor TExtFlashComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFlashComponent.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFlashComponent.GetSwfId : TExtFunction; begin
  JSCode(JSName + '.getSwfId();', 'TExtFlashComponent');
  Result := Self;
end;

destructor TExtFlashComponent.Destroy; begin
  try
    FFlashAttributes.Free;
    FFlashParams.Free;
    FFlashVars.Free;
    FSwf.Free;
  except end;
  inherited;
end;

procedure TExtFlashComponent.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'failure') and Assigned(FOnFailure) then
    FOnFailure(TExtFlashComponent(ParamAsObject('This')))
  else if (AEvtName = 'success') and Assigned(FOnSuccess) then
    FOnSuccess(TExtFlashComponent(ParamAsObject('This')));
end;

function TExtDataGroup.JSClassName : string; begin
  Result := 'Ext.data.Group';
end;

{$IFDEF FPC}constructor TExtDataGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataProxyClient.SetFIsSynchronous(Value : Boolean); begin
  FIsSynchronous := Value;
  JSCode(JSName + '.isSynchronous=' + VarToJSON([Value]) + ';');
end;

function TExtDataProxyClient.JSClassName : string; begin
  Result := 'Ext.data.proxy.Client';
end;

{$IFDEF FPC}constructor TExtDataProxyClient.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyClient.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtDataProxyClient');
  Result := Self;
end;

procedure TExtChartSeriesRadar.SetFMarkerConfig(Value : TExtObject); begin
  FMarkerConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('markerConfig:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesRadar.SetFShowMarkers(Value : Boolean); begin
  FShowMarkers := Value;
  JSCode('showMarkers:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesRadar.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesRadar.SetFXField(Value : String); begin
  FXField := Value;
  JSCode('xField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesRadar.SetFYField(Value : String); begin
  FYField := Value;
  JSCode('yField:' + VarToJSON([Value]));
end;

function TExtChartSeriesRadar.JSClassName : string; begin
  Result := 'Ext.chart.series.Radar';
end;

procedure TExtChartSeriesRadar.InitDefaults; begin
  inherited;
  FMarkerConfig := TExtObject.CreateInternal(Self, 'markerConfig');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesRadar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesRadar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesRadar.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesRadar');
  Result := Self;
end;

destructor TExtChartSeriesRadar.Destroy; begin
  try
    FMarkerConfig.Free;
    FStyle.Free;
  except end;
  inherited;
end;

function TExtUtilTaskManagerSingleton.JSClassName : string; begin
  Result := 'Ext.util.TaskManager';
end;

{$IFDEF FPC}constructor TExtUtilTaskManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginEditing.SetFClicksToEdit(Value : Integer); begin
  FClicksToEdit := Value;
  JSCode('clicksToEdit:' + VarToJSON([Value]));
end;

procedure TExtGridPluginEditing.SetFEditing(Value : Boolean); begin
  FEditing := Value;
  JSCode(JSName + '.editing=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridPluginEditing.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridPluginEditing.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridPluginEditing.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridPluginEditing.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtGridPluginEditing.SetFTriggerEvent(Value : String); begin
  FTriggerEvent := Value;
  JSCode('triggerEvent:' + VarToJSON([Value]));
end;

procedure TExtGridPluginEditing.SetFOnBeforeedit(Value : TExtGridPluginEditingOnBeforeedit); begin
  if Assigned(FOnBeforeedit) then
    JSCode(JSName+'.events ["beforeedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeedit', Ajax('beforeedit', ['Editor', '%0.nm','Context', '%1.nm'], true));
  FOnBeforeedit := Value;
end;

procedure TExtGridPluginEditing.SetFOnCanceledit(Value : TExtGridPluginEditingOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['Editor', '%0.nm','Context', '%1.nm'], true));
  FOnCanceledit := Value;
end;

procedure TExtGridPluginEditing.SetFOnEdit(Value : TExtGridPluginEditingOnEdit); begin
  if Assigned(FOnEdit) then
    JSCode(JSName+'.events ["edit"].listeners=[];');
  if Assigned(Value) then
    AddListener('edit', Ajax('edit', ['Editor', '%0.nm','Context', '%1.nm'], true));
  FOnEdit := Value;
end;

procedure TExtGridPluginEditing.SetFOnValidateedit(Value : TExtGridPluginEditingOnValidateedit); begin
  if Assigned(FOnValidateedit) then
    JSCode(JSName+'.events ["validateedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('validateedit', Ajax('validateedit', ['Editor', '%0.nm','Context', '%1.nm'], true));
  FOnValidateedit := Value;
end;

function TExtGridPluginEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.Editing';
end;

{$IFDEF FPC}constructor TExtGridPluginEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginEditing.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.CancelEdit : TExtFunction; begin
  JSCode(JSName + '.cancelEdit();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.CompleteEdit : TExtFunction; begin
  JSCode(JSName + '.completeEdit();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, ColumnHeader, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, false, ColumnHeader]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, ColumnHeader]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

function TExtGridPluginEditing.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtGridPluginEditing');
  Result := Self;
end;

procedure TExtGridPluginEditing.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeedit') and Assigned(FOnBeforeedit) then
    FOnBeforeedit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('Context')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('Context')))
  else if (AEvtName = 'edit') and Assigned(FOnEdit) then
    FOnEdit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('Context')))
  else if (AEvtName = 'validateedit') and Assigned(FOnValidateedit) then
    FOnValidateedit(TExtGridPluginEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('Context')));
end;

function TExtDomCompositeElement.JSClassName : string; begin
  Result := 'Ext.dom.CompositeElement';
end;

{$IFDEF FPC}constructor TExtDomCompositeElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtMenuItem.SetFActivated(Value : Boolean); begin
  FActivated := Value;
  JSCode(JSName + '.activated=' + VarToJSON([Value]) + ';');
end;

procedure TExtMenuItem.SetFActiveCls(Value : String); begin
  FActiveCls := Value;
  JSCode('activeCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFCanActivate(Value : Boolean); begin
  FCanActivate := Value;
  JSCode('canActivate:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFClickHideDelay(Value : Integer); begin
  FClickHideDelay := Value;
  JSCode('clickHideDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFDestroyMenu(Value : Boolean); begin
  FDestroyMenu := Value;
  JSCode('destroyMenu:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFDisabledCls(Value : String); begin
  FDisabledCls := Value;
  JSCode('disabledCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFGlyph(Value : Integer); begin
  FGlyph := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFGlyphString(Value : String); begin
  FGlyphString := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtMenuItem.SetFHandlerE(Value : TExtEventObject); begin
  FHandlerE := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerE:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFHandlerItem(Value : TExtMenuItem); begin
  FHandlerItem := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerItem:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHref(Value : String); begin
  FHref := Value;
  JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFMenuAlign(Value : String); begin
  FMenuAlign := Value;
  JSCode('menuAlign:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenuExpandDelay(Value : Integer); begin
  FMenuExpandDelay := Value;
  JSCode('menuExpandDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenuHideDelay(Value : Integer); begin
  FMenuHideDelay := Value;
  JSCode('menuHideDelay:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFMenuObject(Value : TExtObject); begin
  FMenuObject := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFParentMenu(Value : TExtMenu); begin
  FParentMenu := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.parentMenu=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenuItem.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFTooltipObject(Value : TExtObject); begin
  FTooltipObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtMenuItem.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtMenuItem.SetFOnActivate(Value : TExtMenuItemOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['Item', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtMenuItem.SetFOnClick(Value : TExtMenuItemOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['Item', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtMenuItem.SetFOnDeactivate(Value : TExtMenuItemOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['Item', '%0.nm'], true));
  FOnDeactivate := Value;
end;

procedure TExtMenuItem.SetFOnIconchange(Value : TExtMenuItemOnIconchange); begin
  if Assigned(FOnIconchange) then
    JSCode(JSName+'.events ["iconchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('iconchange', Ajax('iconchange', ['This', '%0.nm','OldIcon', '%1','NewIcon', '%2'], true));
  FOnIconchange := Value;
end;

procedure TExtMenuItem.SetFOnTextchange(Value : TExtMenuItemOnTextchange); begin
  if Assigned(FOnTextchange) then
    JSCode(JSName+'.events ["textchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('textchange', Ajax('textchange', ['This', '%0.nm','OldText', '%1','NewText', '%2'], true));
  FOnTextchange := Value;
end;

function TExtMenuItem.JSClassName : string; begin
  Result := 'Ext.menu.Item';
end;

procedure TExtMenuItem.InitDefaults; begin
  inherited;
  FHandlerE := TExtEventObject.CreateInternal(Self, 'handlerE');
  FHandlerItem := TExtMenuItem.CreateInternal(Self, 'handlerItem');
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
  FMenuObject := TExtObject.CreateInternal(Self, 'menu');
  FParentMenu := TExtMenu.CreateInternal(Self, 'parentMenu');
  FTooltipObject := TExtObject.CreateInternal(Self, 'tooltip');
end;

{$IFDEF FPC}constructor TExtMenuItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuItem.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenuItem.SetHandler(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetIconCls(IconCls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([IconCls]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetMenu(Menu : TExtObject; DestroyMenu : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetMenu(' + VarToJSON([Menu, false, DestroyMenu]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetMenu(Menu : TExtMenu; DestroyMenu : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setMenu(' + VarToJSON([Menu, false, DestroyMenu]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetTooltip(Tooltip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetTooltip(' + VarToJSON([Tooltip, false]) + ');', 'TExtMenuItem');
  Result := Self;
end;

function TExtMenuItem.SetTooltip(Tooltip : String) : TExtFunction; begin
  JSCode(JSName + '.setTooltip(' + VarToJSON([Tooltip]) + ');', 'TExtMenuItem');
  Result := Self;
end;

destructor TExtMenuItem.Destroy; begin
  try
    FHandlerE.Free;
    FHandlerItem.Free;
    FMenu.Free;
    FMenuObject.Free;
    FParentMenu.Free;
    FTooltipObject.Free;
  except end;
  inherited;
end;

procedure TExtMenuItem.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtMenuItem(ParamAsObject('Item')))
  else if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtMenuItem(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtMenuItem(ParamAsObject('Item')))
  else if (AEvtName = 'iconchange') and Assigned(FOnIconchange) then
    FOnIconchange(TExtMenuItem(ParamAsObject('This')), ParamAsString('OldIcon'), ParamAsString('NewIcon'))
  else if (AEvtName = 'textchange') and Assigned(FOnTextchange) then
    FOnTextchange(TExtMenuItem(ParamAsObject('This')), ParamAsString('OldText'), ParamAsString('NewText'));
end;

function TExtChartMaskLayer.JSClassName : string; begin
  Result := 'Ext.chart.MaskLayer';
end;

{$IFDEF FPC}constructor TExtChartMaskLayer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilPoint.JSClassName : string; begin
  Result := 'Ext.util.Point';
end;

{$IFDEF FPC}constructor TExtUtilPoint.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilPoint.Create(X : Integer; Y : Integer); begin
  CreateVar(JSClassName + '(' + VarToJSON([X, Y]) + ');');
  InitDefaults;
end;

function TExtUtilPoint.Equals(P : TExtUtilPoint) : TExtFunction; begin
  JSCode(JSName + '.Equals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.Equals(P : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.equals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.FromEvent(E : TExtEventObject) : TExtFunction; begin
  JSCode(JSName + '.FromEvent(' + VarToJSON([E, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.FromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.fromEvent(' + VarToJSON([E, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsContainedBy(Region : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IsContainedBy(' + VarToJSON([Region, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsContainedBy(Region : TExtUtilRegion) : TExtFunction; begin
  JSCode(JSName + '.IsContainedBy(' + VarToJSON([Region, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsContainedBy(Region : TExtDomElement) : TExtFunction; begin
  JSCode(JSName + '.IsContainedBy(' + VarToJSON([Region, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsContainedBy(Region : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.isContainedBy(' + VarToJSON([Region, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtObject; Threshold : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtUtilPoint; Threshold : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtUtilPoint; Threshold : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsWithin(' + VarToJSON([P, false, Threshold]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.IsWithin(P : TExtObject; Threshold : Integer) : TExtFunction; begin
  JSCode(JSName + '.isWithin(' + VarToJSON([P, false, Threshold]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.RoundedEquals(P : TExtUtilPoint) : TExtFunction; begin
  JSCode(JSName + '.RoundedEquals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.RoundedEquals(P : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.roundedEquals(' + VarToJSON([P, false]) + ');', 'TExtUtilPoint');
  Result := Self;
end;

function TExtUtilPoint.ToString : TExtFunction; begin
  JSCode(JSName + '.toString();', 'TExtUtilPoint');
  Result := Self;
end;

procedure TExtDataWriterJson.SetFAllowSingle(Value : Boolean); begin
  FAllowSingle := Value;
  JSCode('allowSingle:' + VarToJSON([Value]));
end;

procedure TExtDataWriterJson.SetFEncode(Value : Boolean); begin
  FEncode := Value;
  JSCode('encode:' + VarToJSON([Value]));
end;

procedure TExtDataWriterJson.SetFExpandData(Value : Boolean); begin
  FExpandData := Value;
  JSCode('expandData:' + VarToJSON([Value]));
end;

procedure TExtDataWriterJson.SetFRoot(Value : String); begin
  FRoot := Value;
  JSCode('root:' + VarToJSON([Value]));
end;

function TExtDataWriterJson.JSClassName : string; begin
  Result := 'Ext.data.writer.Json';
end;

{$IFDEF FPC}constructor TExtDataWriterJson.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdStatusProxy.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdStatusProxy.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

function TExtDdStatusProxy.JSClassName : string; begin
  Result := 'Ext.dd.StatusProxy';
end;

{$IFDEF FPC}constructor TExtDdStatusProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdStatusProxy.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDdStatusProxy.GetGhost : TExtFunction; begin
  JSCode(JSName + '.getGhost();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Hide(Clear : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Clear]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Repair(Xy : TArrayOfInteger; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.repair(' + VarToJSON([Xy, Callback, true, Scope, false]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Reset(ClearGhost : Boolean) : TExtFunction; begin
  JSCode(JSName + '.reset(' + VarToJSON([ClearGhost]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.SetStatus(CssClass : String) : TExtFunction; begin
  JSCode(JSName + '.setStatus(' + VarToJSON([CssClass]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Stop : TExtFunction; begin
  JSCode(JSName + '.stop();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Sync : TExtFunction; begin
  JSCode(JSName + '.sync();', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Update(Html : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Update(' + VarToJSON([Html, false]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

function TExtDdStatusProxy.Update(Html : String) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Html]) + ');', 'TExtDdStatusProxy');
  Result := Self;
end;

procedure TExtDomElement.SetFAutoBoxAdjust(Value : Boolean); begin
  FAutoBoxAdjust := Value;
  JSCode(JSName + '.autoBoxAdjust=' + VarToJSON([Value]) + ';');
end;

procedure TExtDomElement.SetFOnAbort(Value : TExtDomElementOnAbort); begin
  if Assigned(FOnAbort) then
    JSCode(JSName+'.events ["abort"].listeners=[];');
  if Assigned(Value) then
    AddListener('abort', Ajax('abort', ['E', '%0.nm','T', '%1.nm'], true));
  FOnAbort := Value;
end;

procedure TExtDomElement.SetFOnBlur(Value : TExtDomElementOnBlur); begin
  if Assigned(FOnBlur) then
    JSCode(JSName+'.events ["blur"].listeners=[];');
  if Assigned(Value) then
    AddListener('blur', Ajax('blur', ['E', '%0.nm','T', '%1.nm'], true));
  FOnBlur := Value;
end;

procedure TExtDomElement.SetFOnChange(Value : TExtDomElementOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['E', '%0.nm','T', '%1.nm'], true));
  FOnChange := Value;
end;

procedure TExtDomElement.SetFOnClick(Value : TExtDomElementOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['E', '%0.nm','T', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtDomElement.SetFOnContextmenu(Value : TExtDomElementOnContextmenu); begin
  if Assigned(FOnContextmenu) then
    JSCode(JSName+'.events ["contextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('contextmenu', Ajax('contextmenu', ['E', '%0.nm','T', '%1.nm'], true));
  FOnContextmenu := Value;
end;

procedure TExtDomElement.SetFOnDblclick(Value : TExtDomElementOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDblclick := Value;
end;

procedure TExtDomElement.SetFOnDOMActivate(Value : TExtDomElementOnDOMActivate); begin
  if Assigned(FOnDOMActivate) then
    JSCode(JSName+'.events ["DOMActivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMActivate', Ajax('DOMActivate', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMActivate := Value;
end;

procedure TExtDomElement.SetFOnDOMAttrModified(Value : TExtDomElementOnDOMAttrModified); begin
  if Assigned(FOnDOMAttrModified) then
    JSCode(JSName+'.events ["DOMAttrModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMAttrModified', Ajax('DOMAttrModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMAttrModified := Value;
end;

procedure TExtDomElement.SetFOnDOMCharacterDataModified(Value : TExtDomElementOnDOMCharacterDataModified); begin
  if Assigned(FOnDOMCharacterDataModified) then
    JSCode(JSName+'.events ["DOMCharacterDataModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMCharacterDataModified', Ajax('DOMCharacterDataModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMCharacterDataModified := Value;
end;

procedure TExtDomElement.SetFOnDOMFocusIn(Value : TExtDomElementOnDOMFocusIn); begin
  if Assigned(FOnDOMFocusIn) then
    JSCode(JSName+'.events ["DOMFocusIn"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMFocusIn', Ajax('DOMFocusIn', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMFocusIn := Value;
end;

procedure TExtDomElement.SetFOnDOMFocusOut(Value : TExtDomElementOnDOMFocusOut); begin
  if Assigned(FOnDOMFocusOut) then
    JSCode(JSName+'.events ["DOMFocusOut"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMFocusOut', Ajax('DOMFocusOut', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMFocusOut := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeInserted(Value : TExtDomElementOnDOMNodeInserted); begin
  if Assigned(FOnDOMNodeInserted) then
    JSCode(JSName+'.events ["DOMNodeInserted"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeInserted', Ajax('DOMNodeInserted', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeInserted := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeInsertedIntoDocument(Value : TExtDomElementOnDOMNodeInsertedIntoDocument); begin
  if Assigned(FOnDOMNodeInsertedIntoDocument) then
    JSCode(JSName+'.events ["DOMNodeInsertedIntoDocument"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeInsertedIntoDocument', Ajax('DOMNodeInsertedIntoDocument', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeInsertedIntoDocument := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeRemoved(Value : TExtDomElementOnDOMNodeRemoved); begin
  if Assigned(FOnDOMNodeRemoved) then
    JSCode(JSName+'.events ["DOMNodeRemoved"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeRemoved', Ajax('DOMNodeRemoved', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeRemoved := Value;
end;

procedure TExtDomElement.SetFOnDOMNodeRemovedFromDocument(Value : TExtDomElementOnDOMNodeRemovedFromDocument); begin
  if Assigned(FOnDOMNodeRemovedFromDocument) then
    JSCode(JSName+'.events ["DOMNodeRemovedFromDocument"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMNodeRemovedFromDocument', Ajax('DOMNodeRemovedFromDocument', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMNodeRemovedFromDocument := Value;
end;

procedure TExtDomElement.SetFOnDOMSubtreeModified(Value : TExtDomElementOnDOMSubtreeModified); begin
  if Assigned(FOnDOMSubtreeModified) then
    JSCode(JSName+'.events ["DOMSubtreeModified"].listeners=[];');
  if Assigned(Value) then
    AddListener('DOMSubtreeModified', Ajax('DOMSubtreeModified', ['E', '%0.nm','T', '%1.nm'], true));
  FOnDOMSubtreeModified := Value;
end;

procedure TExtDomElement.SetFOnError(Value : TExtDomElementOnError); begin
  if Assigned(FOnError) then
    JSCode(JSName+'.events ["error"].listeners=[];');
  if Assigned(Value) then
    AddListener('error', Ajax('error', ['E', '%0.nm','T', '%1.nm'], true));
  FOnError := Value;
end;

procedure TExtDomElement.SetFOnFocus(Value : TExtDomElementOnFocus); begin
  if Assigned(FOnFocus) then
    JSCode(JSName+'.events ["focus"].listeners=[];');
  if Assigned(Value) then
    AddListener('focus', Ajax('focus', ['E', '%0.nm','T', '%1.nm'], true));
  FOnFocus := Value;
end;

procedure TExtDomElement.SetFOnKeydown(Value : TExtDomElementOnKeydown); begin
  if Assigned(FOnKeydown) then
    JSCode(JSName+'.events ["keydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('keydown', Ajax('keydown', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeydown := Value;
end;

procedure TExtDomElement.SetFOnKeypress(Value : TExtDomElementOnKeypress); begin
  if Assigned(FOnKeypress) then
    JSCode(JSName+'.events ["keypress"].listeners=[];');
  if Assigned(Value) then
    AddListener('keypress', Ajax('keypress', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeypress := Value;
end;

procedure TExtDomElement.SetFOnKeyup(Value : TExtDomElementOnKeyup); begin
  if Assigned(FOnKeyup) then
    JSCode(JSName+'.events ["keyup"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyup', Ajax('keyup', ['E', '%0.nm','T', '%1.nm'], true));
  FOnKeyup := Value;
end;

procedure TExtDomElement.SetFOnLoad(Value : TExtDomElementOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['E', '%0.nm','T', '%1.nm'], true));
  FOnLoad := Value;
end;

procedure TExtDomElement.SetFOnMousedown(Value : TExtDomElementOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtDomElement.SetFOnMouseenter(Value : TExtDomElementOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseenter := Value;
end;

procedure TExtDomElement.SetFOnMouseleave(Value : TExtDomElementOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseleave := Value;
end;

procedure TExtDomElement.SetFOnMousemove(Value : TExtDomElementOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMousemove := Value;
end;

procedure TExtDomElement.SetFOnMouseout(Value : TExtDomElementOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtDomElement.SetFOnMouseover(Value : TExtDomElementOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtDomElement.SetFOnMouseup(Value : TExtDomElementOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['E', '%0.nm','T', '%1.nm'], true));
  FOnMouseup := Value;
end;

procedure TExtDomElement.SetFOnReset(Value : TExtDomElementOnReset); begin
  if Assigned(FOnReset) then
    JSCode(JSName+'.events ["reset"].listeners=[];');
  if Assigned(Value) then
    AddListener('reset', Ajax('reset', ['E', '%0.nm','T', '%1.nm'], true));
  FOnReset := Value;
end;

procedure TExtDomElement.SetFOnResize(Value : TExtDomElementOnResize); begin
  if Assigned(FOnResize) then
    JSCode(JSName+'.events ["resize"].listeners=[];');
  if Assigned(Value) then
    AddListener('resize', Ajax('resize', ['E', '%0.nm','T', '%1.nm'], true));
  FOnResize := Value;
end;

procedure TExtDomElement.SetFOnScroll(Value : TExtDomElementOnScroll); begin
  if Assigned(FOnScroll) then
    JSCode(JSName+'.events ["scroll"].listeners=[];');
  if Assigned(Value) then
    AddListener('scroll', Ajax('scroll', ['E', '%0.nm','T', '%1.nm'], true));
  FOnScroll := Value;
end;

procedure TExtDomElement.SetFOnSelect(Value : TExtDomElementOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['E', '%0.nm','T', '%1.nm'], true));
  FOnSelect := Value;
end;

procedure TExtDomElement.SetFOnSubmit(Value : TExtDomElementOnSubmit); begin
  if Assigned(FOnSubmit) then
    JSCode(JSName+'.events ["submit"].listeners=[];');
  if Assigned(Value) then
    AddListener('submit', Ajax('submit', ['E', '%0.nm','T', '%1.nm'], true));
  FOnSubmit := Value;
end;

procedure TExtDomElement.SetFOnUnload(Value : TExtDomElementOnUnload); begin
  if Assigned(FOnUnload) then
    JSCode(JSName+'.events ["unload"].listeners=[];');
  if Assigned(Value) then
    AddListener('unload', Ajax('unload', ['E', '%0.nm','T', '%1.nm'], true));
  FOnUnload := Value;
end;

function TExtDomElement.JSClassName : string; begin
  Result := 'Ext.dom.Element';
end;

{$IFDEF FPC}constructor TExtDomElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDomElement.AddKeyListener(Key : TExtObject; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddKeyListener(' + VarToJSON([Key, false, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.AddKeyListener(Key : TArrayOfInteger; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddKeyListener(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.AddKeyListener(Key : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddKeyListener(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.AddKeyListener(Key : Integer; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addKeyListener(' + VarToJSON([Key, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.AddKeyMap(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addKeyMap(' + VarToJSON([Config, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Blur : TExtFunction; begin
  JSCode(JSName + '.blur();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CacheScrollValues : TExtFunction; begin
  JSCode(JSName + '.cacheScrollValues();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Clean(ForceReclean : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.clean(' + VarToJSON([ForceReclean]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : String; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, RenderTo, false, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : TExtObject; RenderTo : THTMLElement; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, false, RenderTo, false, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : TExtObject; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Config, false, RenderTo, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateProxy(Config : String; RenderTo : String = ''; MatchBox : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.createProxy(' + VarToJSON([Config, RenderTo, MatchBox]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.CreateShim : TExtFunction; begin
  JSCode(JSName + '.createShim();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.EnableDisplayMode(Display : String = '') : TExtFunction; begin
  JSCode(JSName + '.enableDisplayMode(' + VarToJSON([Display]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Focus(Defer : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.focus(' + VarToJSON([Defer]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.GetAttributeNS(Namespace : String; Name : String) : TExtFunction; begin
  JSCode(JSName + '.getAttributeNS(' + VarToJSON([Namespace, Name]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.GetLoader : TExtFunction; begin
  JSCode(JSName + '.getLoader();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Hover(OverFn : TExtFunction; OutFn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.hover(' + VarToJSON([OverFn, true, OutFn, true, Scope, false, Options, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.IsBorderBox : TExtFunction; begin
  JSCode(JSName + '.isBorderBox();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.IsDisplayed : TExtFunction; begin
  JSCode(JSName + '.isDisplayed();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.IsFocusable : TExtFunction; begin
  JSCode(JSName + '.isFocusable();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.IsMasked : TExtFunction; begin
  JSCode(JSName + '.isMasked();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.IsVisible(Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.isVisible(' + VarToJSON([Deep]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Load : TExtFunction; begin
  JSCode(JSName + '.load();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Mask(Msg : String = ''; MsgCls : String = '') : TExtFunction; begin
  JSCode(JSName + '.mask(' + VarToJSON([Msg, MsgCls]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.MonitorMouseLeave(Delay : Integer; Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.monitorMouseLeave(' + VarToJSON([Delay, Handler, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.NeedsTabIndex : TExtFunction; begin
  JSCode(JSName + '.needsTabIndex();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.On(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.on(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.PurgeAllListeners : TExtFunction; begin
  JSCode(JSName + '.purgeAllListeners();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.RelayEvent(EventName : String; Observable : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.relayEvent(' + VarToJSON([EventName, Observable, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.RemoveAllListeners : TExtFunction; begin
  JSCode(JSName + '.removeAllListeners();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.SwallowEvent(EventName : TArrayOfString; PreventDefault : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SwallowEvent(' + VarToJSON([EventName, PreventDefault]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.SwallowEvent(EventName : String; PreventDefault : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.swallowEvent(' + VarToJSON([EventName, PreventDefault]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Un(EventName : String; Fn : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.un(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Unmask : TExtFunction; begin
  JSCode(JSName + '.unmask();', 'TExtDomElement');
  Result := Self;
end;

function TExtDomElement.Update(Html : String; LoadScripts : Boolean = false; Callback : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Html, LoadScripts, Callback, true]) + ');', 'TExtDomElement');
  Result := Self;
end;

procedure TExtDomElement.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'abort') and Assigned(FOnAbort) then
    FOnAbort(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'blur') and Assigned(FOnBlur) then
    FOnBlur(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'contextmenu') and Assigned(FOnContextmenu) then
    FOnContextmenu(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMActivate') and Assigned(FOnDOMActivate) then
    FOnDOMActivate(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMAttrModified') and Assigned(FOnDOMAttrModified) then
    FOnDOMAttrModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMCharacterDataModified') and Assigned(FOnDOMCharacterDataModified) then
    FOnDOMCharacterDataModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMFocusIn') and Assigned(FOnDOMFocusIn) then
    FOnDOMFocusIn(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMFocusOut') and Assigned(FOnDOMFocusOut) then
    FOnDOMFocusOut(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeInserted') and Assigned(FOnDOMNodeInserted) then
    FOnDOMNodeInserted(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeInsertedIntoDocument') and Assigned(FOnDOMNodeInsertedIntoDocument) then
    FOnDOMNodeInsertedIntoDocument(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeRemoved') and Assigned(FOnDOMNodeRemoved) then
    FOnDOMNodeRemoved(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMNodeRemovedFromDocument') and Assigned(FOnDOMNodeRemovedFromDocument) then
    FOnDOMNodeRemovedFromDocument(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'DOMSubtreeModified') and Assigned(FOnDOMSubtreeModified) then
    FOnDOMSubtreeModified(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'error') and Assigned(FOnError) then
    FOnError(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'focus') and Assigned(FOnFocus) then
    FOnFocus(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keydown') and Assigned(FOnKeydown) then
    FOnKeydown(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keypress') and Assigned(FOnKeypress) then
    FOnKeypress(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'keyup') and Assigned(FOnKeyup) then
    FOnKeyup(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'reset') and Assigned(FOnReset) then
    FOnReset(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'resize') and Assigned(FOnResize) then
    FOnResize(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'scroll') and Assigned(FOnScroll) then
    FOnScroll(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'submit') and Assigned(FOnSubmit) then
    FOnSubmit(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'unload') and Assigned(FOnUnload) then
    FOnUnload(TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')));
end;

procedure TExtChartSeriesGauge.SetFAngleField(Value : String); begin
  FAngleField := Value;
  JSCode('angleField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFDonut(Value : Boolean); begin
  FDonut := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFDonutInteger(Value : Integer); begin
  FDonutInteger := Value;
  JSCode('donut:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFHighlightDuration(Value : Integer); begin
  FHighlightDuration := Value;
  JSCode('highlightDuration:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFNeedle(Value : Boolean); begin
  FNeedle := Value;
  JSCode('needle:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFShowInLegend(Value : Boolean); begin
  FShowInLegend := Value;
  JSCode('showInLegend:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesGauge.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesGauge.JSClassName : string; begin
  Result := 'Ext.chart.series.Gauge';
end;

procedure TExtChartSeriesGauge.InitDefaults; begin
  inherited;
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesGauge.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesGauge.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesGauge.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesGauge');
  Result := Self;
end;

function TExtChartSeriesGauge.GetLegendColor(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesGauge');
  Result := Self;
end;

function TExtChartSeriesGauge.SetValue : TExtFunction; begin
  JSCode(JSName + '.setValue();', 'TExtChartSeriesGauge');
  Result := Self;
end;

destructor TExtChartSeriesGauge.Destroy; begin
  try
    FStyle.Free;
  except end;
  inherited;
end;

function TExtGridPluginDivRenderer.JSClassName : string; begin
  Result := 'Ext.grid.plugin.DivRenderer';
end;

{$IFDEF FPC}constructor TExtGridPluginDivRenderer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginDragDrop.SetFContainerScroll(Value : TExtObject); begin
  FContainerScroll := Value;
  Value.DeleteFromGarbage;
  JSCode('containerScroll:' + VarToJSON([Value, false]));
end;

procedure TExtGridPluginDragDrop.SetFContainerScrollBoolean(Value : Boolean); begin
  FContainerScrollBoolean := Value;
  JSCode('containerScroll:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFDragGroup(Value : String); begin
  FDragGroup := Value;
  JSCode('dragGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFDropGroup(Value : String); begin
  FDropGroup := Value;
  JSCode('dropGroup:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFEnableDrag(Value : Boolean); begin
  FEnableDrag := Value;
  JSCode('enableDrag:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFEnableDrop(Value : Boolean); begin
  FEnableDrop := Value;
  JSCode('enableDrop:' + VarToJSON([Value]));
end;

procedure TExtGridPluginDragDrop.SetFOnBeforedrop(Value : TExtGridPluginDragDropOnBeforedrop); begin
  if Assigned(FOnBeforedrop) then
    JSCode(JSName+'.events ["beforedrop"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedrop', Ajax('beforedrop', ['Node', '%0.nm','Data', '%1.nm','OverModel', '%2.nm','DropPosition', '%3','DropHandlers', '%4.nm'], true));
  FOnBeforedrop := Value;
end;

procedure TExtGridPluginDragDrop.SetFOnDrop(Value : TExtGridPluginDragDropOnDrop); begin
  if Assigned(FOnDrop) then
    JSCode(JSName+'.events ["drop"].listeners=[];');
  if Assigned(Value) then
    AddListener('drop', Ajax('drop', ['Node', '%0.nm','Data', '%1.nm','OverModel', '%2.nm','DropPosition', '%3'], true));
  FOnDrop := Value;
end;

function TExtGridPluginDragDrop.JSClassName : string; begin
  Result := 'Ext.grid.plugin.DragDrop';
end;

procedure TExtGridPluginDragDrop.InitDefaults; begin
  inherited;
  FContainerScroll := TExtObject.CreateInternal(Self, 'containerScroll');
end;

{$IFDEF FPC}constructor TExtGridPluginDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPluginDragDrop.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtGridPluginDragDrop.Destroy; begin
  try
    FContainerScroll.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginDragDrop.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedrop') and Assigned(FOnBeforedrop) then
    FOnBeforedrop(THTMLElement(ParamAsObject('Node')), TExtObject(ParamAsObject('Data')), TExtDataModel(ParamAsObject('OverModel')), ParamAsString('DropPosition'), TExtObject(ParamAsObject('DropHandlers')))
  else if (AEvtName = 'drop') and Assigned(FOnDrop) then
    FOnDrop(THTMLElement(ParamAsObject('Node')), TExtObject(ParamAsObject('Data')), TExtDataModel(ParamAsObject('OverModel')), ParamAsString('DropPosition'));
end;

function TExtMenuKeyNav.JSClassName : string; begin
  Result := 'Ext.menu.KeyNav';
end;

{$IFDEF FPC}constructor TExtMenuKeyNav.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridPluginBufferedRenderer.SetFPosition(Value : Integer); begin
  FPosition := Value;
  JSCode(JSName + '.position=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridPluginBufferedRenderer.SetFSynchronousRender(Value : Boolean); begin
  FSynchronousRender := Value;
  JSCode('synchronousRender:' + VarToJSON([Value]));
end;

procedure TExtGridPluginBufferedRenderer.SetFVariableRowHeight(Value : Boolean); begin
  FVariableRowHeight := Value;
  JSCode('variableRowHeight:' + VarToJSON([Value]));
end;

function TExtGridPluginBufferedRenderer.JSClassName : string; begin
  Result := 'Ext.grid.plugin.BufferedRenderer';
end;

{$IFDEF FPC}constructor TExtGridPluginBufferedRenderer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginBufferedRenderer.ScrollTo(RecordIdx : Integer; DoSelect : Boolean; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.scrollTo(' + VarToJSON([RecordIdx, DoSelect, Callback, true, Scope, false]) + ');', 'TExtGridPluginBufferedRenderer');
  Result := Self;
end;

procedure TExtChartSeriesCartesian.SetFAxis(Value : String); begin
  FAxis := Value;
  JSCode('axis:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesCartesian.SetFAxisTArrayOfString(Value : TArrayOfString); begin
  FAxisTArrayOfString := Value;
  JSCode('axis:' + ArrayToJSON(Value));
end;

procedure TExtChartSeriesCartesian.SetFXField(Value : String); begin
  FXField := Value;
  JSCode('xField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesCartesian.SetFYField(Value : String); begin
  FYField := Value;
  JSCode('yField:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesCartesian.SetFYFieldTArrayOfString(Value : TArrayOfString); begin
  FYFieldTArrayOfString := Value;
  JSCode('yField:' + ArrayToJSON(Value));
end;

function TExtChartSeriesCartesian.JSClassName : string; begin
  Result := 'Ext.chart.series.Cartesian';
end;

{$IFDEF FPC}constructor TExtChartSeriesCartesian.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartSeriesCartesian.GetMinMaxXValues : TExtFunction; begin
  JSCode(JSName + '.getMinMaxXValues();', 'TExtChartSeriesCartesian');
  Result := Self;
end;

function TExtChartSeriesCartesian.GetMinMaxYValues : TExtFunction; begin
  JSCode(JSName + '.getMinMaxYValues();', 'TExtChartSeriesCartesian');
  Result := Self;
end;

function TExtDrawEngineSvg.JSClassName : string; begin
  Result := 'Ext.draw.engine.Svg';
end;

{$IFDEF FPC}constructor TExtDrawEngineSvg.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineSvg.ApplyZIndex(Sprite : TExtDrawSprite) : TExtFunction; begin
  JSCode(JSName + '.applyZIndex(' + VarToJSON([Sprite, false]) + ');', 'TExtDrawEngineSvg');
  Result := Self;
end;

function TExtDrawEngineSvg.GetRegion : TExtFunction; begin
  JSCode(JSName + '.getRegion();', 'TExtDrawEngineSvg');
  Result := Self;
end;

function TExtDrawEngineSvg.HasCls(Sprite : TExtDrawSprite; ClassName : String) : TExtFunction; begin
  JSCode(JSName + '.hasCls(' + VarToJSON([Sprite, false, ClassName]) + ');', 'TExtDrawEngineSvg');
  Result := Self;
end;

procedure TExtDdDD.SetFScroll(Value : Boolean); begin
  FScroll := Value;
  JSCode(JSName + '.scroll=' + VarToJSON([Value]) + ';');
end;

function TExtDdDD.JSClassName : string; begin
  Result := 'Ext.dd.DD';
end;

{$IFDEF FPC}constructor TExtDdDD.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDD.AlignElWithMouse(El : THTMLElement; IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.alignElWithMouse(' + VarToJSON([El, false, IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.ApplyConfig : TExtFunction; begin
  JSCode(JSName + '.applyConfig();', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.AutoOffset(IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.autoOffset(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.B4Drag : TExtFunction; begin
  JSCode(JSName + '.b4Drag();', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.B4MouseDown : TExtFunction; begin
  JSCode(JSName + '.b4MouseDown();', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.CachePosition(IPageX : Integer = 0; IPageY : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.cachePosition(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

constructor TExtDdDD.Create(Id : String; SGroup : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Id, SGroup, Config, false]) + ');');
  InitDefaults;
end;

function TExtDdDD.SetDelta(IDeltaX : Integer; IDeltaY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setDelta(' + VarToJSON([IDeltaX, IDeltaY]) + ');', 'TExtDdDD');
  Result := Self;
end;

function TExtDdDD.SetDragElPos(IPageX : Integer; IPageY : Integer) : TExtFunction; begin
  JSCode(JSName + '.setDragElPos(' + VarToJSON([IPageX, IPageY]) + ');', 'TExtDdDD');
  Result := Self;
end;

procedure TExtProgressBar.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFAnimateObject(Value : TExtObject); begin
  FAnimateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('animate:' + VarToJSON([Value, false]));
end;

procedure TExtProgressBar.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFTextEl(Value : String); begin
  FTextEl := Value;
  JSCode('textEl:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFTextElElement(Value : TExtElement); begin
  FTextElElement := Value;
  Value.DeleteFromGarbage;
  JSCode('textEl:' + VarToJSON([Value, false]));
end;

procedure TExtProgressBar.SetFTextElTHTMLElement(Value : THTMLElement); begin
  FTextElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('textEl:' + VarToJSON([Value, false]));
end;

procedure TExtProgressBar.SetFValue(Value : Integer); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtProgressBar.SetFOnUpdate(Value : TExtProgressBarOnUpdate); begin
  if Assigned(FOnUpdate) then
    JSCode(JSName+'.events ["update"].listeners=[];');
  if Assigned(Value) then
    AddListener('update', Ajax('update', ['This', '%0.nm','Value', '%1','Text', '%2'], true));
  FOnUpdate := Value;
end;

function TExtProgressBar.JSClassName : string; begin
  Result := 'Ext.ProgressBar';
end;

procedure TExtProgressBar.InitDefaults; begin
  inherited;
  FAnimateObject := TExtObject.CreateInternal(Self, 'animate');
  FTextElElement := TExtElement.CreateInternal(Self, 'textEl');
end;

{$IFDEF FPC}constructor TExtProgressBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtProgressBar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtProgressBar.IsWaiting : TExtFunction; begin
  JSCode(JSName + '.isWaiting();', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.Reset(Hide : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.reset(' + VarToJSON([Hide]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.UpdateProgress(Value : Integer = 0; Text : String = ''; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.updateProgress(' + VarToJSON([Value, Text, Animate]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.UpdateText(Text : String = '') : TExtFunction; begin
  JSCode(JSName + '.updateText(' + VarToJSON([Text]) + ');', 'TExtProgressBar');
  Result := Self;
end;

function TExtProgressBar.Wait(Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.wait(' + VarToJSON([Config, false]) + ');', 'TExtProgressBar');
  Result := Self;
end;

destructor TExtProgressBar.Destroy; begin
  try
    FAnimateObject.Free;
    FTextElElement.Free;
  except end;
  inherited;
end;

procedure TExtProgressBar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'update') and Assigned(FOnUpdate) then
    FOnUpdate(TExtProgressBar(ParamAsObject('This')), ParamAsInteger('Value'), ParamAsString('Text'));
end;

function TExtResizerHandle.JSClassName : string; begin
  Result := 'Ext.resizer.Handle';
end;

{$IFDEF FPC}constructor TExtResizerHandle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtPanelTool.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPanelTool.SetFIsTool(Value : Boolean); begin
  FIsTool := Value;
  JSCode(JSName + '.isTool=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelTool.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTool.SetFStopEvent(Value : Boolean); begin
  FStopEvent := Value;
  JSCode('stopEvent:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFTooltipObject(Value : TExtObject); begin
  FTooltipObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTool.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtPanelTool.SetFOnClick(Value : TExtPanelToolOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

function TExtPanelTool.JSClassName : string; begin
  Result := 'Ext.panel.Tool';
end;

procedure TExtPanelTool.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FTooltipObject := TExtObject.CreateInternal(Self, 'tooltip');
end;

{$IFDEF FPC}constructor TExtPanelTool.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanelTool.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelTool.SetType(TypeJS : String) : TExtFunction; begin
  JSCode(JSName + '.setType(' + VarToJSON([TypeJS]) + ');', 'TExtPanelTool');
  Result := Self;
end;

destructor TExtPanelTool.Destroy; begin
  try
    FScope.Free;
    FTooltipObject.Free;
  except end;
  inherited;
end;

procedure TExtPanelTool.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtPanelTool(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtLayoutContainer.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainer.SetFOverflowPadderEl(Value : TExtElement); begin
  FOverflowPadderEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.overflowPadderEl=' + VarToJSON([Value, false]) + ';');
end;

function TExtLayoutContainer.JSClassName : string; begin
  Result := 'Ext.layout.container.Container';
end;

procedure TExtLayoutContainer.InitDefaults; begin
  inherited;
  FOverflowPadderEl := TExtElement.CreateInternal(Self, 'overflowPadderEl');
end;

{$IFDEF FPC}constructor TExtLayoutContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainer.AddChildEls : TExtFunction; begin
  JSCode(JSName + '.addChildEls();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.BeginLayout : TExtFunction; begin
  JSCode(JSName + '.beginLayout();', 'TExtLayoutContainer');
  Result := Self;
end;

constructor TExtLayoutContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtLayoutContainer.GetElementTarget : TExtFunction; begin
  JSCode(JSName + '.getElementTarget();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.GetLayoutItems : TExtFunction; begin
  JSCode(JSName + '.getLayoutItems();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.GetRenderTarget : TExtFunction; begin
  JSCode(JSName + '.getRenderTarget();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtLayoutContainer');
  Result := Self;
end;

function TExtLayoutContainer.RemoveChildEls(TestFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.removeChildEls(' + VarToJSON([TestFn, true]) + ');', 'TExtLayoutContainer');
  Result := Self;
end;

destructor TExtLayoutContainer.Destroy; begin
  try
    FOverflowPadderEl.Free;
  except end;
  inherited;
end;

function TExtPluginManagerSingleton.JSClassName : string; begin
  Result := 'Ext.PluginManager';
end;

{$IFDEF FPC}constructor TExtPluginManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPluginManagerSingleton.Create(Config : TExtObject; DefaultType : TExtFunction = nil); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, DefaultType, true]) + ');');
  InitDefaults;
end;

function TExtPluginManagerSingleton.FindByType(TypeJS : String; DefaultsOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.findByType(' + VarToJSON([TypeJS, DefaultsOnly]) + ');', 'TExtPluginManagerSingleton');
  Result := Self;
end;

procedure TExtPickerColor.SetFAllowReselect(Value : Boolean); begin
  FAllowReselect := Value;
  JSCode('allowReselect:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFClickEvent(Value : String); begin
  FClickEvent := Value;
  JSCode('clickEvent:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFColors(Value : TArrayOfString); begin
  FColors := Value;
  JSCode(JSName + '.colors=' + ArrayToJSON(Value) + ';');
end;

procedure TExtPickerColor.SetFComponentCls(Value : String); begin
  FComponentCls := Value;
  JSCode('componentCls:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPickerColor.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPickerColor.SetFSelectedCls(Value : String); begin
  FSelectedCls := Value;
  JSCode('selectedCls:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFValue(Value : String); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtPickerColor.SetFOnSelect(Value : TExtPickerColorOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','Color', '%1'], true));
  FOnSelect := Value;
end;

function TExtPickerColor.JSClassName : string; begin
  Result := 'Ext.picker.Color';
end;

procedure TExtPickerColor.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtPickerColor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerColor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerColor.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtPickerColor');
  Result := Self;
end;

function TExtPickerColor.Select(Color : String; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Color, SuppressEvent]) + ');', 'TExtPickerColor');
  Result := Self;
end;

destructor TExtPickerColor.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtPickerColor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtPickerColor(ParamAsObject('This')), ParamAsString('Color'));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFAfterCtCls(Value : String); begin
  FAfterCtCls := Value;
  JSCode('afterCtCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFAfterScrollerCls(Value : String); begin
  FAfterScrollerCls := Value;
  JSCode('afterScrollerCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFAnimateScroll(Value : Boolean); begin
  FAnimateScroll := Value;
  JSCode('animateScroll:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFBeforeCtCls(Value : String); begin
  FBeforeCtCls := Value;
  JSCode('beforeCtCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFBeforeScrollerCls(Value : String); begin
  FBeforeScrollerCls := Value;
  JSCode('beforeScrollerCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFScrollDuration(Value : Integer); begin
  FScrollDuration := Value;
  JSCode('scrollDuration:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFScrollerCls(Value : String); begin
  FScrollerCls := Value;
  JSCode('scrollerCls:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFScrollIncrement(Value : Integer); begin
  FScrollIncrement := Value;
  JSCode('scrollIncrement:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFScrollRepeatInterval(Value : Integer); begin
  FScrollRepeatInterval := Value;
  JSCode('scrollRepeatInterval:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFWheelIncrement(Value : Integer); begin
  FWheelIncrement := Value;
  JSCode('wheelIncrement:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBoxOverflowScroller.SetFOnScroll(Value : TExtLayoutContainerBoxOverflowScrollerOnScroll); begin
  if Assigned(FOnScroll) then
    JSCode(JSName+'.events ["scroll"].listeners=[];');
  if Assigned(Value) then
    AddListener('scroll', Ajax('scroll', ['Scroller', '%0.nm','NewPosition', '%1','Animate', '%2'], true));
  FOnScroll := Value;
end;

function TExtLayoutContainerBoxOverflowScroller.JSClassName : string; begin
  Result := 'Ext.layout.container.boxOverflow.Scroller';
end;

{$IFDEF FPC}constructor TExtLayoutContainerBoxOverflowScroller.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainerBoxOverflowScroller.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.GetScrollPosition : TExtFunction; begin
  JSCode(JSName + '.getScrollPosition();', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ScrollToItem(Item : TExtComponent; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollToItem(' + VarToJSON([Item, false, Animate]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ScrollToItem(Item : String; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.ScrollToItem(' + VarToJSON([Item, Animate]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.ScrollToItem(Item : Integer; Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.scrollToItem(' + VarToJSON([Item, Animate]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

function TExtLayoutContainerBoxOverflowScroller.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtLayoutContainerBoxOverflowScroller');
  Result := Self;
end;

procedure TExtLayoutContainerBoxOverflowScroller.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'scroll') and Assigned(FOnScroll) then
    FOnScroll(TExtLayoutContainerBoxOverflowScroller(ParamAsObject('Scroller')), ParamAsInteger('NewPosition'), ParamAsBoolean('Animate'));
end;

function TExtDrawEngineVml.JSClassName : string; begin
  Result := 'Ext.draw.engine.Vml';
end;

{$IFDEF FPC}constructor TExtDrawEngineVml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawEngineVml.AddGradient(Gradient : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addGradient(' + VarToJSON([Gradient, false]) + ');', 'TExtDrawEngineVml');
  Result := Self;
end;

procedure TExtPickerMonth.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFCancelText(Value : String); begin
  FCancelText := Value;
  JSCode('cancelText:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFOkText(Value : String); begin
  FOkText := Value;
  JSCode('okText:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFSelectedCls(Value : String); begin
  FSelectedCls := Value;
  JSCode('selectedCls:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFShowButtons(Value : Boolean); begin
  FShowButtons := Value;
  JSCode('showButtons:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFValue(Value : TDateTime); begin
  FValue := Value;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtPickerMonth.SetFValueTArrayOfInteger(Value : TArrayOfInteger); begin
  FValueTArrayOfInteger := Value;
  JSCode('value:' + ArrayToJSON(Value));
end;

procedure TExtPickerMonth.SetFOnCancelclick(Value : TExtPickerMonthOnCancelclick); begin
  if Assigned(FOnCancelclick) then
    JSCode(JSName+'.events ["cancelclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('cancelclick', Ajax('cancelclick', ['This', '%0.nm'], true));
  FOnCancelclick := Value;
end;

procedure TExtPickerMonth.SetFOnMonthclick(Value : TExtPickerMonthOnMonthclick); begin
  if Assigned(FOnMonthclick) then
    JSCode(JSName+'.events ["monthclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('monthclick', Ajax('monthclick', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnMonthclick := Value;
end;

procedure TExtPickerMonth.SetFOnMonthdblclick(Value : TExtPickerMonthOnMonthdblclick); begin
  if Assigned(FOnMonthdblclick) then
    JSCode(JSName+'.events ["monthdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('monthdblclick', Ajax('monthdblclick', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnMonthdblclick := Value;
end;

procedure TExtPickerMonth.SetFOnOkclick(Value : TExtPickerMonthOnOkclick); begin
  if Assigned(FOnOkclick) then
    JSCode(JSName+'.events ["okclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('okclick', Ajax('okclick', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnOkclick := Value;
end;

procedure TExtPickerMonth.SetFOnSelect(Value : TExtPickerMonthOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnSelect := Value;
end;

procedure TExtPickerMonth.SetFOnYearclick(Value : TExtPickerMonthOnYearclick); begin
  if Assigned(FOnYearclick) then
    JSCode(JSName+'.events ["yearclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('yearclick', Ajax('yearclick', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnYearclick := Value;
end;

procedure TExtPickerMonth.SetFOnYeardblclick(Value : TExtPickerMonthOnYeardblclick); begin
  if Assigned(FOnYeardblclick) then
    JSCode(JSName+'.events ["yeardblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('yeardblclick', Ajax('yeardblclick', ['This', '%0.nm','Value', '%1.nm'], true));
  FOnYeardblclick := Value;
end;

function TExtPickerMonth.JSClassName : string; begin
  Result := 'Ext.picker.Month';
end;

{$IFDEF FPC}constructor TExtPickerMonth.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPickerMonth.AdjustYear(Offset : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.adjustYear(' + VarToJSON([Offset]) + ');', 'TExtPickerMonth');
  Result := Self;
end;

function TExtPickerMonth.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtPickerMonth');
  Result := Self;
end;

function TExtPickerMonth.HasSelection : TExtFunction; begin
  JSCode(JSName + '.hasSelection();', 'TExtPickerMonth');
  Result := Self;
end;

function TExtPickerMonth.SetValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Value]) + ');', 'TExtPickerMonth');
  Result := Self;
end;

function TExtPickerMonth.SetValue(Value : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtPickerMonth');
  Result := Self;
end;

procedure TExtPickerMonth.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'cancelclick') and Assigned(FOnCancelclick) then
    FOnCancelclick(TExtPickerMonth(ParamAsObject('This')))
  else if (AEvtName = 'monthclick') and Assigned(FOnMonthclick) then
    FOnMonthclick(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')))
  else if (AEvtName = 'monthdblclick') and Assigned(FOnMonthdblclick) then
    FOnMonthdblclick(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')))
  else if (AEvtName = 'okclick') and Assigned(FOnOkclick) then
    FOnOkclick(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')))
  else if (AEvtName = 'yearclick') and Assigned(FOnYearclick) then
    FOnYearclick(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')))
  else if (AEvtName = 'yeardblclick') and Assigned(FOnYeardblclick) then
    FOnYeardblclick(TExtPickerMonth(ParamAsObject('This')), TExtObjectList(ParamAsObject('Value')));
end;

procedure TExtPickerDate.SetFAriaTitle(Value : String); begin
  FAriaTitle := Value;
  JSCode('ariaTitle:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFAriaTitleDateFormat(Value : String); begin
  FAriaTitleDateFormat := Value;
  JSCode('ariaTitleDateFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDayNames(Value : TArrayOfString); begin
  FDayNames := Value;
  JSCode('dayNames:' + ArrayToJSON(Value));
end;

procedure TExtPickerDate.SetFDisableAnim(Value : Boolean); begin
  FDisableAnim := Value;
  JSCode('disableAnim:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledCellCls(Value : String); begin
  FDisabledCellCls := Value;
  JSCode('disabledCellCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledDates(Value : TArrayOfString); begin
  FDisabledDates := Value;
  JSCode('disabledDates:' + ArrayToJSON(Value));
end;

procedure TExtPickerDate.SetFDisabledDatesRE(Value : TRegExp); begin
  FDisabledDatesRE := Value;
  JSCode('disabledDatesRE:' + VarToJSON([#3 +Value]));
end;

procedure TExtPickerDate.SetFDisabledDatesText(Value : String); begin
  FDisabledDatesText := Value;
  JSCode('disabledDatesText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFDisabledDays(Value : TArrayOfInteger); begin
  FDisabledDays := Value;
  if not ConfigAvailable(JSName) then
    SetDisabledDays(Value)
  else
    JSCode('disabledDays:' + ArrayToJSON(Value));
end;

procedure TExtPickerDate.SetFDisabledDaysText(Value : String); begin
  FDisabledDaysText := Value;
  JSCode('disabledDaysText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFFocusOnShow(Value : Boolean); begin
  FFocusOnShow := Value;
  JSCode('focusOnShow:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtPickerDate.SetFKeyNavConfig(Value : TExtObject); begin
  FKeyNavConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('keyNavConfig:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFLongDayFormat(Value : String); begin
  FLongDayFormat := Value;
  JSCode('longDayFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMaxDate(Value : TDateTime); begin
  FMaxDate := Value;
  if not ConfigAvailable(JSName) then
    SetMaxDate(Value)
  else
    JSCode('maxDate:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMinDate(Value : TDateTime); begin
  FMinDate := Value;
  if not ConfigAvailable(JSName) then
    SetMinDate(Value)
  else
    JSCode('minDate:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMonthNames(Value : TArrayOfString); begin
  FMonthNames := Value;
  JSCode('monthNames:' + ArrayToJSON(Value));
end;

procedure TExtPickerDate.SetFMonthYearFormat(Value : String); begin
  FMonthYearFormat := Value;
  JSCode('monthYearFormat:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFMonthYearText(Value : String); begin
  FMonthYearText := Value;
  JSCode('monthYearText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFNextText(Value : String); begin
  FNextText := Value;
  JSCode('nextText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFPrevText(Value : String); begin
  FPrevText := Value;
  JSCode('prevText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtPickerDate.SetFSelectedCls(Value : String); begin
  FSelectedCls := Value;
  JSCode('selectedCls:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFShowToday(Value : Boolean); begin
  FShowToday := Value;
  JSCode('showToday:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFStartDay(Value : Integer); begin
  FStartDay := Value;
  JSCode('startDay:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFTodayText(Value : String); begin
  FTodayText := Value;
  JSCode('todayText:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFTodayTip(Value : String); begin
  FTodayTip := Value;
  JSCode('todayTip:' + VarToJSON([Value]));
end;

procedure TExtPickerDate.SetFOnSelect(Value : TExtPickerDateOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','Date', '%1'], true));
  FOnSelect := Value;
end;

function TExtPickerDate.JSClassName : string; begin
  Result := 'Ext.picker.Date';
end;

procedure TExtPickerDate.InitDefaults; begin
  inherited;
  FKeyNavConfig := TExtObject.CreateInternal(Self, 'keyNavConfig');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FStartDay := 0;
end;

{$IFDEF FPC}constructor TExtPickerDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerDate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerDate.GetDayInitial : TExtFunction; begin
  JSCode(JSName + '.getDayInitial();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.HideMonthPicker(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.hideMonthPicker(' + VarToJSON([Animate]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SelectToday : TExtFunction; begin
  JSCode(JSName + '.selectToday();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetDisabledDates(DisabledDates : TRegExp) : TExtFunction; begin
  JSCode(JSName + '.SetDisabledDates(' + VarToJSON([#3 + DisabledDates]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetDisabledDates(DisabledDates : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDates(' + VarToJSON([DisabledDates]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDays(' + VarToJSON([DisabledDays]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetMaxDate(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxDate(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetMinDate(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinDate(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.SetValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowMonthPicker(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.showMonthPicker(' + VarToJSON([Animate]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowNextMonth(E : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.showNextMonth(' + VarToJSON([E, false]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowNextYear : TExtFunction; begin
  JSCode(JSName + '.showNextYear();', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowPrevMonth(E : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.showPrevMonth(' + VarToJSON([E, false]) + ');', 'TExtPickerDate');
  Result := Self;
end;

function TExtPickerDate.ShowPrevYear : TExtFunction; begin
  JSCode(JSName + '.showPrevYear();', 'TExtPickerDate');
  Result := Self;
end;

destructor TExtPickerDate.Destroy; begin
  try
    FKeyNavConfig.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtPickerDate.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtPickerDate(ParamAsObject('This')), ParamAsTDateTime('Date'));
end;

procedure TExtLayoutContainerBoxOverflowMenu.SetFMenuItems(Value : TExtObjectList); begin
  FMenuItems := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.menuItems=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtLayoutContainerBoxOverflowMenu.SetFNoItemsMenuText(Value : String); begin
  FNoItemsMenuText := Value;
  JSCode(JSName + '.noItemsMenuText=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutContainerBoxOverflowMenu.SetFTriggerButtonCls(Value : String); begin
  FTriggerButtonCls := Value;
  JSCode('triggerButtonCls:' + VarToJSON([Value]));
end;

function TExtLayoutContainerBoxOverflowMenu.JSClassName : string; begin
  Result := 'Ext.layout.container.boxOverflow.Menu';
end;

procedure TExtLayoutContainerBoxOverflowMenu.InitDefaults; begin
  inherited;
  FMenuItems := TExtObjectList.Create(Self, 'menuItems');
end;

{$IFDEF FPC}constructor TExtLayoutContainerBoxOverflowMenu.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerBoxOverflowMenu.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerBoxOverflowMenu.Destroy; begin
  try
    FMenuItems.Free;
  except end;
  inherited;
end;

function TExtLayoutComponent.JSClassName : string; begin
  Result := 'Ext.layout.component.Component';
end;

{$IFDEF FPC}constructor TExtLayoutComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponent.GetRenderTarget : TExtFunction; begin
  JSCode(JSName + '.getRenderTarget();', 'TExtLayoutComponent');
  Result := Self;
end;

function TExtLayoutComponent.GetTarget : TExtFunction; begin
  JSCode(JSName + '.getTarget();', 'TExtLayoutComponent');
  Result := Self;
end;

function TExtComponentManagerSingleton.JSClassName : string; begin
  Result := 'Ext.ComponentManager';
end;

{$IFDEF FPC}constructor TExtComponentManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtComponentManagerSingleton.Create(Config : TExtObject; DefaultType : String = ''); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Config, false, DefaultType]) + ');');
  InitDefaults;
end;

procedure TExtModelManagerSingleton.SetFAssociationStack(Value : TExtObjectList); begin
  FAssociationStack := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.associationStack=' + VarToJSON([Value, false]) + ';');
end;

function TExtModelManagerSingleton.JSClassName : string; begin
  Result := 'Ext.ModelManager';
end;

procedure TExtModelManagerSingleton.InitDefaults; begin
  inherited;
  FAssociationStack := TExtObjectList.Create(Self, 'associationStack');
end;

{$IFDEF FPC}constructor TExtModelManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtModelManagerSingleton.GetModel(Id : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.GetModel(' + VarToJSON([Id, false]) + ');', 'TExtModelManagerSingleton');
  Result := Self;
end;

function TExtModelManagerSingleton.GetModel(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getModel(' + VarToJSON([Id]) + ');', 'TExtModelManagerSingleton');
  Result := Self;
end;

destructor TExtModelManagerSingleton.Destroy; begin
  try
    FAssociationStack.Free;
  except end;
  inherited;
end;

procedure TExtDataUuidGenerator.SetFSalt(Value : Integer); begin
  FSalt := Value;
  JSCode(JSName + '.salt=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataUuidGenerator.SetFSaltObject(Value : TExtObject); begin
  FSaltObject := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.salt=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataUuidGenerator.SetFTimestamp(Value : Integer); begin
  FTimestamp := Value;
  JSCode(JSName + '.timestamp=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataUuidGenerator.SetFTimestampObject(Value : TExtObject); begin
  FTimestampObject := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.timestamp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataUuidGenerator.SetFVersion(Value : Integer); begin
  FVersion := Value;
  JSCode('version:' + VarToJSON([Value]));
end;

function TExtDataUuidGenerator.JSClassName : string; begin
  Result := 'Ext.data.UuidGenerator';
end;

procedure TExtDataUuidGenerator.InitDefaults; begin
  inherited;
  FSaltObject := TExtObject.CreateInternal(Self, 'salt');
  FTimestampObject := TExtObject.CreateInternal(Self, 'timestamp');
end;

{$IFDEF FPC}constructor TExtDataUuidGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataUuidGenerator.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataUuidGenerator.Reconfigure : TExtFunction; begin
  JSCode(JSName + '.reconfigure();', 'TExtDataUuidGenerator');
  Result := Self;
end;

destructor TExtDataUuidGenerator.Destroy; begin
  try
    FSaltObject.Free;
    FTimestampObject.Free;
  except end;
  inherited;
end;

procedure TExtImg.SetFAlt(Value : String); begin
  FAlt := Value;
  JSCode('alt:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFGlyph(Value : Integer); begin
  FGlyph := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFGlyphString(Value : String); begin
  FGlyphString := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFImgCls(Value : String); begin
  FImgCls := Value;
  JSCode('imgCls:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFSrc(Value : String); begin
  FSrc := Value;
  if not ConfigAvailable(JSName) then
    SetSrc(Value)
  else
    JSCode('src:' + VarToJSON([Value]));
end;

procedure TExtImg.SetFTitle(Value : String); begin
  FTitle := Value;
  JSCode('title:' + VarToJSON([Value]));
end;

function TExtImg.JSClassName : string; begin
  Result := 'Ext.Img';
end;

{$IFDEF FPC}constructor TExtImg.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtImg.SetSrc(Src : String) : TExtFunction; begin
  JSCode(JSName + '.setSrc(' + VarToJSON([Src]) + ');', 'TExtImg');
  Result := Self;
end;

procedure TExtComponentLoader.SetFLoadMask(Value : Boolean); begin
  FLoadMask := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFLoadMaskObject(Value : TExtObject); begin
  FLoadMaskObject := Value;
  Value.DeleteFromGarbage;
  JSCode('loadMask:' + VarToJSON([Value, false]));
end;

procedure TExtComponentLoader.SetFRenderer(Value : String); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFRendererFunction(Value : TExtFunction); begin
  FRendererFunction := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtComponentLoader.SetFScripts(Value : Boolean); begin
  FScripts := Value;
  JSCode('scripts:' + VarToJSON([Value]));
end;

procedure TExtComponentLoader.SetFTarget(Value : TExtComponent); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetTarget(Value)
  else
    JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtComponentLoader.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

function TExtComponentLoader.JSClassName : string; begin
  Result := 'Ext.ComponentLoader';
end;

procedure TExtComponentLoader.InitDefaults; begin
  inherited;
  FLoadMaskObject := TExtObject.CreateInternal(Self, 'loadMask');
  FTarget := TExtComponent.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtComponentLoader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtComponentLoader.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtComponentLoader.SetTarget(Target : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([Target, false]) + ');', 'TExtComponentLoader');
  Result := Self;
end;

function TExtComponentLoader.SetTarget(Target : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([Target]) + ');', 'TExtComponentLoader');
  Result := Self;
end;

destructor TExtComponentLoader.Destroy; begin
  try
    FLoadMaskObject.Free;
    FTarget.Free;
  except end;
  inherited;
end;

procedure TExtContainerAbstractContainer.SetFActiveItem(Value : Integer); begin
  FActiveItem := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFActiveItemString(Value : String); begin
  FActiveItemString := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFAutoDestroy(Value : Boolean); begin
  FAutoDestroy := Value;
  JSCode('autoDestroy:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFBubbleEvents(Value : TArrayOfString); begin
  FBubbleEvents := Value;
  JSCode('bubbleEvents:' + ArrayToJSON(Value));
end;

procedure TExtContainerAbstractContainer.SetFDefaults(Value : TExtObject); begin
  FDefaults := Value;
  Value.DeleteFromGarbage;
  JSCode('defaults:' + VarToJSON([Value, false]));
end;

procedure TExtContainerAbstractContainer.SetFDefaultsFunction(Value : TExtFunction); begin
  FDefaultsFunction := Value;
  JSCode('defaults:' + VarToJSON([Value, true]));
end;

procedure TExtContainerAbstractContainer.SetFDefaultType(Value : String); begin
  FDefaultType := Value;
  JSCode('defaultType:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFDetachOnRemove(Value : Boolean); begin
  FDetachOnRemove := Value;
  JSCode('detachOnRemove:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtContainerAbstractContainer.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtContainerAbstractContainer.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtContainerAbstractContainer.SetFSuspendLayout(Value : Boolean); begin
  FSuspendLayout := Value;
  JSCode('suspendLayout:' + VarToJSON([Value]));
end;

procedure TExtContainerAbstractContainer.SetFOnAdd(Value : TExtContainerAbstractContainerOnAdd); begin
  if Assigned(FOnAdd) then
    JSCode(JSName+'.events ["add"].listeners=[];');
  if Assigned(Value) then
    AddListener('add', Ajax('add', ['This', '%0.nm','Component', '%1.nm','Index', '%2'], true));
  FOnAdd := Value;
end;

procedure TExtContainerAbstractContainer.SetFOnAfterlayout(Value : TExtContainerAbstractContainerOnAfterlayout); begin
  if Assigned(FOnAfterlayout) then
    JSCode(JSName+'.events ["afterlayout"].listeners=[];');
  if Assigned(Value) then
    AddListener('afterlayout', Ajax('afterlayout', ['This', '%0.nm','Layout', '%1.nm'], true));
  FOnAfterlayout := Value;
end;

procedure TExtContainerAbstractContainer.SetFOnBeforeadd(Value : TExtContainerAbstractContainerOnBeforeadd); begin
  if Assigned(FOnBeforeadd) then
    JSCode(JSName+'.events ["beforeadd"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeadd', Ajax('beforeadd', ['This', '%0.nm','Component', '%1.nm','Index', '%2'], true));
  FOnBeforeadd := Value;
end;

procedure TExtContainerAbstractContainer.SetFOnBeforeremove(Value : TExtContainerAbstractContainerOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', ['This', '%0.nm','Component', '%1.nm'], true));
  FOnBeforeremove := Value;
end;

procedure TExtContainerAbstractContainer.SetFOnRemove(Value : TExtContainerAbstractContainerOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', ['This', '%0.nm','Component', '%1.nm'], true));
  FOnRemove := Value;
end;

function TExtContainerAbstractContainer.JSClassName : string; begin
  Result := 'Ext.container.AbstractContainer';
end;

procedure TExtContainerAbstractContainer.InitDefaults; begin
  inherited;
  FDefaults := TExtObject.CreateInternal(Self, 'defaults');
  FItems := TExtObjectList.Create(Self, 'items');
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtContainerAbstractContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtContainerAbstractContainer.Add(Component : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON(Component) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Add(Component : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Component, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Cascade(Fn : TExtFunction; Scope : TExtObject = nil; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.cascade(' + VarToJSON([Fn, true, Scope, false]) + ',' + VarToJSON(Args) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Child(Selector : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.Child(' + VarToJSON([Selector, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Child(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.child(' + VarToJSON([Selector]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Contains(Comp : TExtComponent; Deep : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.contains(' + VarToJSON([Comp, false, Deep]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

constructor TExtContainerAbstractContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtContainerAbstractContainer.DoLayout : TExtFunction; begin
  JSCode(JSName + '.doLayout();', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Down(Selector : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.Down(' + VarToJSON([Selector, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Down(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.down(' + VarToJSON([Selector]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.GetComponent(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.GetComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.GetComponent(Comp : Integer) : TExtFunction; begin
  JSCode(JSName + '.getComponent(' + VarToJSON([Comp]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.GetLayout : TExtFunction; begin
  JSCode(JSName + '.getLayout();', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Insert(Index : Integer; Component : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Insert(' + VarToJSON([Index, Component, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Insert(Index : Integer; Component : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.insert(' + VarToJSON([Index, Component, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.IsAncestor(PossibleDescendant : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.isAncestor(' + VarToJSON([PossibleDescendant, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Move(FromIdx : Integer; ToIdx : Integer) : TExtFunction; begin
  JSCode(JSName + '.move(' + VarToJSON([FromIdx, ToIdx]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Query(Selector : String = '') : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([Selector]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.QueryBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.queryBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.QueryById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.queryById(' + VarToJSON([Id]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Remove(Component : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Remove(' + VarToJSON([Component, false, AutoDestroy]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.Remove(Component : String; AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Component, AutoDestroy]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

function TExtContainerAbstractContainer.RemoveAll(AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([AutoDestroy]) + ');', 'TExtContainerAbstractContainer');
  Result := Self;
end;

destructor TExtContainerAbstractContainer.Destroy; begin
  try
    FDefaults.Free;
    FItems.Free;
    FLayoutObject.Free;
  except end;
  inherited;
end;

procedure TExtContainerAbstractContainer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'add') and Assigned(FOnAdd) then
    FOnAdd(TExtContainerAbstractContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')), ParamAsInteger('Index'))
  else if (AEvtName = 'afterlayout') and Assigned(FOnAfterlayout) then
    FOnAfterlayout(TExtContainerAbstractContainer(ParamAsObject('This')), TExtLayoutContainer(ParamAsObject('Layout')))
  else if (AEvtName = 'beforeadd') and Assigned(FOnBeforeadd) then
    FOnBeforeadd(TExtContainerAbstractContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove(TExtContainerAbstractContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')))
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove(TExtContainerAbstractContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')));
end;

function TExtResizerSplitterTracker.JSClassName : string; begin
  Result := 'Ext.resizer.SplitterTracker';
end;

{$IFDEF FPC}constructor TExtResizerSplitterTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtResizerSplitter.SetFCollapsedCls(Value : String); begin
  FCollapsedCls := Value;
  JSCode('collapsedCls:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseOnDblClick(Value : Boolean); begin
  FCollapseOnDblClick := Value;
  JSCode('collapseOnDblClick:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseTarget(Value : String); begin
  FCollapseTarget := Value;
  JSCode('collapseTarget:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFCollapseTargetPanel(Value : TExtPanel); begin
  FCollapseTargetPanel := Value;
  Value.DeleteFromGarbage;
  JSCode('collapseTarget:' + VarToJSON([Value, false]));
end;

procedure TExtResizerSplitter.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFDefaultSplitMax(Value : Integer); begin
  FDefaultSplitMax := Value;
  JSCode('defaultSplitMax:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFDefaultSplitMin(Value : Integer); begin
  FDefaultSplitMin := Value;
  JSCode('defaultSplitMin:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFOrientation(Value : String); begin
  FOrientation := Value;
  JSCode(JSName + '.orientation=' + VarToJSON([Value]) + ';');
end;

procedure TExtResizerSplitter.SetFPerformCollapse(Value : Boolean); begin
  FPerformCollapse := Value;
  JSCode('performCollapse:' + VarToJSON([Value]));
end;

procedure TExtResizerSplitter.SetFSize(Value : Integer); begin
  FSize := Value;
  JSCode('size:' + VarToJSON([Value]));
end;

function TExtResizerSplitter.JSClassName : string; begin
  Result := 'Ext.resizer.Splitter';
end;

procedure TExtResizerSplitter.InitDefaults; begin
  inherited;
  FCollapseTargetPanel := TExtPanel.CreateInternal(Self, 'collapseTarget');
end;

{$IFDEF FPC}constructor TExtResizerSplitter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtResizerSplitter.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtResizerSplitter.Destroy; begin
  try
    FCollapseTargetPanel.Free;
  except end;
  inherited;
end;

function TExtResizerResizeTracker.JSClassName : string; begin
  Result := 'Ext.resizer.ResizeTracker';
end;

{$IFDEF FPC}constructor TExtResizerResizeTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtResizerResizeTracker.CreateProxy(Target : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.CreateProxy(' + VarToJSON([Target, false]) + ');', 'TExtResizerResizeTracker');
  Result := Self;
end;

function TExtResizerResizeTracker.CreateProxy(Target : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.createProxy(' + VarToJSON([Target, false]) + ');', 'TExtResizerResizeTracker');
  Result := Self;
end;

procedure TExtDataWriterXml.SetFDefaultDocumentRoot(Value : String); begin
  FDefaultDocumentRoot := Value;
  JSCode('defaultDocumentRoot:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFDocumentRoot(Value : String); begin
  FDocumentRoot := Value;
  JSCode('documentRoot:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFHeader(Value : String); begin
  FHeader := Value;
  JSCode('header:' + VarToJSON([Value]));
end;

procedure TExtDataWriterXml.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

function TExtDataWriterXml.JSClassName : string; begin
  Result := 'Ext.data.writer.Xml';
end;

procedure TExtDataWriterXml.InitDefaults; begin
  inherited;
  FDocumentRoot := 'xmlData';
  FRecordJS := 'record';
end;

{$IFDEF FPC}constructor TExtDataWriterXml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataWriterXml.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDdDDTarget.JSClassName : string; begin
  Result := 'Ext.dd.DDTarget';
end;

{$IFDEF FPC}constructor TExtDdDDTarget.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDDTarget.Create(Id : String; SGroup : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Id, SGroup, Config, false]) + ');');
  InitDefaults;
end;

procedure TExtDrawComponent.SetFAutoSize(Value : Boolean); begin
  FAutoSize := Value;
  JSCode('autoSize:' + VarToJSON([Value]));
end;

procedure TExtDrawComponent.SetFEnginePriority(Value : TArrayOfString); begin
  FEnginePriority := Value;
  JSCode('enginePriority:' + ArrayToJSON(Value));
end;

procedure TExtDrawComponent.SetFGradients(Value : TExtObjectList); begin
  FGradients := Value;
  Value.DeleteFromGarbage;
  JSCode('gradients:' + VarToJSON([Value, false]));
end;

procedure TExtDrawComponent.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtDrawComponent.SetFSurface(Value : TExtDrawSurface); begin
  FSurface := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.surface=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDrawComponent.SetFViewBox(Value : Boolean); begin
  FViewBox := Value;
  JSCode('viewBox:' + VarToJSON([Value]));
end;

procedure TExtDrawComponent.SetFOnClick(Value : TExtDrawComponentOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', [], true));
  FOnClick := Value;
end;

procedure TExtDrawComponent.SetFOnDblclick(Value : TExtDrawComponentOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', [], true));
  FOnDblclick := Value;
end;

procedure TExtDrawComponent.SetFOnMousedown(Value : TExtDrawComponentOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', [], true));
  FOnMousedown := Value;
end;

procedure TExtDrawComponent.SetFOnMouseenter(Value : TExtDrawComponentOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', [], true));
  FOnMouseenter := Value;
end;

procedure TExtDrawComponent.SetFOnMouseleave(Value : TExtDrawComponentOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', [], true));
  FOnMouseleave := Value;
end;

procedure TExtDrawComponent.SetFOnMousemove(Value : TExtDrawComponentOnMousemove); begin
  if Assigned(FOnMousemove) then
    JSCode(JSName+'.events ["mousemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousemove', Ajax('mousemove', [], true));
  FOnMousemove := Value;
end;

procedure TExtDrawComponent.SetFOnMouseup(Value : TExtDrawComponentOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', [], true));
  FOnMouseup := Value;
end;

function TExtDrawComponent.JSClassName : string; begin
  Result := 'Ext.draw.Component';
end;

procedure TExtDrawComponent.InitDefaults; begin
  inherited;
  FGradients := TExtObjectList.Create(Self, 'gradients');
  FItems := TExtObjectList.Create(Self, 'items');
  FSurface := TExtDrawSurface.CreateInternal(Self, 'surface');
end;

{$IFDEF FPC}constructor TExtDrawComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDrawComponent.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDrawComponent.Destroy; begin
  try
    FGradients.Free;
    FItems.Free;
    FSurface.Free;
  except end;
  inherited;
end;

procedure TExtDrawComponent.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick()
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick()
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown()
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter()
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave()
  else if (AEvtName = 'mousemove') and Assigned(FOnMousemove) then
    FOnMousemove()
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup();
end;

function TExtToolbarSpacer.JSClassName : string; begin
  Result := 'Ext.toolbar.Spacer';
end;

{$IFDEF FPC}constructor TExtToolbarSpacer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtToolbarItem.SetFOverflowText(Value : String); begin
  FOverflowText := Value;
  JSCode('overflowText:' + VarToJSON([Value]));
end;

function TExtToolbarItem.JSClassName : string; begin
  Result := 'Ext.toolbar.Item';
end;

{$IFDEF FPC}constructor TExtToolbarItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtToolbarFill.SetFIsFill(Value : Boolean); begin
  FIsFill := Value;
  JSCode(JSName + '.isFill=' + VarToJSON([Value]) + ';');
end;

function TExtToolbarFill.JSClassName : string; begin
  Result := 'Ext.toolbar.Fill';
end;

{$IFDEF FPC}constructor TExtToolbarFill.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAppDomainStoreSingleton.JSClassName : string; begin
  Result := 'Ext.app.domain.Store';
end;

{$IFDEF FPC}constructor TExtAppDomainStoreSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtXTemplate.SetFDefinitions(Value : String); begin
  FDefinitions := Value;
  JSCode('definitions:' + VarToJSON([Value]));
end;

procedure TExtXTemplate.SetFDefinitionsList(Value : TExtObjectList); begin
  FDefinitionsList := Value;
  Value.DeleteFromGarbage;
  JSCode('definitions:' + VarToJSON([Value, false]));
end;

function TExtXTemplate.JSClassName : string; begin
  Result := 'Ext.XTemplate';
end;

procedure TExtXTemplate.InitDefaults; begin
  inherited;
  FDefinitionsList := TExtObjectList.Create(Self, 'definitions');
end;

{$IFDEF FPC}constructor TExtXTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtXTemplate.Compile : TExtFunction; begin
  JSCode(JSName + '.compile();', 'TExtXTemplate');
  Result := Self;
end;

constructor TExtXTemplate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtXTemplate.Destroy; begin
  try
    FDefinitionsList.Free;
  except end;
  inherited;
end;

function TExtAppDomainGlobalSingleton.JSClassName : string; begin
  Result := 'Ext.app.domain.Global';
end;

{$IFDEF FPC}constructor TExtAppDomainGlobalSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTreePluginTreeViewDragDrop.SetFAllowContainerDrops(Value : Boolean); begin
  FAllowContainerDrops := Value;
  JSCode('allowContainerDrops:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFAllowParentInserts(Value : Boolean); begin
  FAllowParentInserts := Value;
  JSCode('allowParentInserts:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFAppendOnly(Value : Boolean); begin
  FAppendOnly := Value;
  JSCode('appendOnly:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFContainerScroll(Value : TExtObject); begin
  FContainerScroll := Value;
  Value.DeleteFromGarbage;
  JSCode('containerScroll:' + VarToJSON([Value, false]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFContainerScrollBoolean(Value : Boolean); begin
  FContainerScrollBoolean := Value;
  JSCode('containerScroll:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDragGroup(Value : String); begin
  FDragGroup := Value;
  JSCode('dragGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFDropGroup(Value : String); begin
  FDropGroup := Value;
  JSCode('dropGroup:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFEnableDrag(Value : Boolean); begin
  FEnableDrag := Value;
  JSCode('enableDrag:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFEnableDrop(Value : Boolean); begin
  FEnableDrop := Value;
  JSCode('enableDrop:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFExpandDelay(Value : String); begin
  FExpandDelay := Value;
  JSCode('expandDelay:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightColor(Value : String); begin
  FNodeHighlightColor := Value;
  JSCode('nodeHighlightColor:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightOnDrop(Value : Boolean); begin
  FNodeHighlightOnDrop := Value;
  JSCode('nodeHighlightOnDrop:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFNodeHighlightOnRepair(Value : Boolean); begin
  FNodeHighlightOnRepair := Value;
  JSCode('nodeHighlightOnRepair:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFSortOnDrop(Value : Boolean); begin
  FSortOnDrop := Value;
  JSCode('sortOnDrop:' + VarToJSON([Value]));
end;

procedure TExtTreePluginTreeViewDragDrop.SetFOnBeforedrop(Value : TExtTreePluginTreeViewDragDropOnBeforedrop); begin
  if Assigned(FOnBeforedrop) then
    JSCode(JSName+'.events ["beforedrop"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedrop', Ajax('beforedrop', ['Node', '%0.nm','Data', '%1.nm','OverModel', '%2.nm','DropPosition', '%3','DropHandlers', '%4.nm'], true));
  FOnBeforedrop := Value;
end;

procedure TExtTreePluginTreeViewDragDrop.SetFOnDrop(Value : TExtTreePluginTreeViewDragDropOnDrop); begin
  if Assigned(FOnDrop) then
    JSCode(JSName+'.events ["drop"].listeners=[];');
  if Assigned(Value) then
    AddListener('drop', Ajax('drop', ['Node', '%0.nm','Data', '%1.nm','OverModel', '%2.nm','DropPosition', '%3'], true));
  FOnDrop := Value;
end;

function TExtTreePluginTreeViewDragDrop.JSClassName : string; begin
  Result := 'Ext.tree.plugin.TreeViewDragDrop';
end;

procedure TExtTreePluginTreeViewDragDrop.InitDefaults; begin
  inherited;
  FContainerScroll := TExtObject.CreateInternal(Self, 'containerScroll');
end;

{$IFDEF FPC}constructor TExtTreePluginTreeViewDragDrop.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTreePluginTreeViewDragDrop.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtTreePluginTreeViewDragDrop.Destroy; begin
  try
    FContainerScroll.Free;
  except end;
  inherited;
end;

procedure TExtTreePluginTreeViewDragDrop.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedrop') and Assigned(FOnBeforedrop) then
    FOnBeforedrop(THTMLElement(ParamAsObject('Node')), TExtObject(ParamAsObject('Data')), TExtDataModel(ParamAsObject('OverModel')), ParamAsString('DropPosition'), TExtObject(ParamAsObject('DropHandlers')))
  else if (AEvtName = 'drop') and Assigned(FOnDrop) then
    FOnDrop(THTMLElement(ParamAsObject('Node')), TExtObject(ParamAsObject('Data')), TExtDataModel(ParamAsObject('OverModel')), ParamAsString('DropPosition'));
end;

procedure TExtFormLabel.SetFForId(Value : String); begin
  FForId := Value;
  JSCode('forId:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFHtml(Value : String); begin
  FHtml := Value;
  JSCode('html:' + VarToJSON([Value]));
end;

procedure TExtFormLabel.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtFormLabel.JSClassName : string; begin
  Result := 'Ext.form.Label';
end;

{$IFDEF FPC}constructor TExtFormLabel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormLabel.SetText(Text : String; Encode : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text, Encode]) + ');', 'TExtFormLabel');
  Result := Self;
end;

function TExtDataTreeModel.JSClassName : string; begin
  Result := 'Ext.data.TreeModel';
end;

{$IFDEF FPC}constructor TExtDataTreeModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataTreeStore.SetFClearOnLoad(Value : Boolean); begin
  FClearOnLoad := Value;
  JSCode('clearOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFClearRemovedOnLoad(Value : Boolean); begin
  FClearRemovedOnLoad := Value;
  JSCode('clearRemovedOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFDefaultRootId(Value : String); begin
  FDefaultRootId := Value;
  JSCode('defaultRootId:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFDefaultRootProperty(Value : String); begin
  FDefaultRootProperty := Value;
  JSCode('defaultRootProperty:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFDefaultRootText(Value : String); begin
  FDefaultRootText := Value;
  JSCode('defaultRootText:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFFolderSort(Value : Boolean); begin
  FFolderSort := Value;
  JSCode('folderSort:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFNodeParam(Value : String); begin
  FNodeParam := Value;
  JSCode('nodeParam:' + VarToJSON([Value]));
end;

procedure TExtDataTreeStore.SetFRoot(Value : TExtDataModel); begin
  FRoot := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFRootInterface(Value : TExtDataNodeInterface); begin
  FRootInterface := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFRootObject(Value : TExtObject); begin
  FRootObject := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtDataTreeStore.SetFOnAppend(Value : TExtDataTreeStoreOnAppend); begin
  if Assigned(FOnAppend) then
    JSCode(JSName+'.events ["append"].listeners=[];');
  if Assigned(Value) then
    AddListener('append', Ajax('append', [], true));
  FOnAppend := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeappend(Value : TExtDataTreeStoreOnBeforeappend); begin
  if Assigned(FOnBeforeappend) then
    JSCode(JSName+'.events ["beforeappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeappend', Ajax('beforeappend', [], true));
  FOnBeforeappend := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforecollapse(Value : TExtDataTreeStoreOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', [], true));
  FOnBeforecollapse := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeexpand(Value : TExtDataTreeStoreOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', [], true));
  FOnBeforeexpand := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeinsert(Value : TExtDataTreeStoreOnBeforeinsert); begin
  if Assigned(FOnBeforeinsert) then
    JSCode(JSName+'.events ["beforeinsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeinsert', Ajax('beforeinsert', [], true));
  FOnBeforeinsert := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforemove(Value : TExtDataTreeStoreOnBeforemove); begin
  if Assigned(FOnBeforemove) then
    JSCode(JSName+'.events ["beforemove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforemove', Ajax('beforemove', [], true));
  FOnBeforemove := Value;
end;

procedure TExtDataTreeStore.SetFOnBeforeremove(Value : TExtDataTreeStoreOnBeforeremove); begin
  if Assigned(FOnBeforeremove) then
    JSCode(JSName+'.events ["beforeremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeremove', Ajax('beforeremove', [], true));
  FOnBeforeremove := Value;
end;

procedure TExtDataTreeStore.SetFOnCollapse(Value : TExtDataTreeStoreOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', [], true));
  FOnCollapse := Value;
end;

procedure TExtDataTreeStore.SetFOnExpand(Value : TExtDataTreeStoreOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', [], true));
  FOnExpand := Value;
end;

procedure TExtDataTreeStore.SetFOnInsert(Value : TExtDataTreeStoreOnInsert); begin
  if Assigned(FOnInsert) then
    JSCode(JSName+'.events ["insert"].listeners=[];');
  if Assigned(Value) then
    AddListener('insert', Ajax('insert', [], true));
  FOnInsert := Value;
end;

procedure TExtDataTreeStore.SetFOnLoad(Value : TExtDataTreeStoreOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', ['This', '%0.nm','Node', '%1.nm','Records', '%2.nm','Successful', '%3'], true));
  FOnLoad := Value;
end;

procedure TExtDataTreeStore.SetFOnMove(Value : TExtDataTreeStoreOnMove); begin
  if Assigned(FOnMove) then
    JSCode(JSName+'.events ["move"].listeners=[];');
  if Assigned(Value) then
    AddListener('move', Ajax('move', [], true));
  FOnMove := Value;
end;

procedure TExtDataTreeStore.SetFOnRemove(Value : TExtDataTreeStoreOnRemove); begin
  if Assigned(FOnRemove) then
    JSCode(JSName+'.events ["remove"].listeners=[];');
  if Assigned(Value) then
    AddListener('remove', Ajax('remove', [], true));
  FOnRemove := Value;
end;

procedure TExtDataTreeStore.SetFOnSort(Value : TExtDataTreeStoreOnSort); begin
  if Assigned(FOnSort) then
    JSCode(JSName+'.events ["sort"].listeners=[];');
  if Assigned(Value) then
    AddListener('sort', Ajax('sort', [], true));
  FOnSort := Value;
end;

function TExtDataTreeStore.JSClassName : string; begin
  Result := 'Ext.data.TreeStore';
end;

procedure TExtDataTreeStore.InitDefaults; begin
  inherited;
  FRoot := TExtDataModel.CreateInternal(Self, 'root');
  FRootInterface := TExtDataNodeInterface.CreateInternal(Self, 'root');
  FRootObject := TExtObject.CreateInternal(Self, 'root');
end;

{$IFDEF FPC}constructor TExtDataTreeStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataTreeStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataTreeStore.GetNodeById : TExtFunction; begin
  JSCode(JSName + '.getNodeById();', 'TExtDataTreeStore');
  Result := Self;
end;

function TExtDataTreeStore.GetRootNode : TExtFunction; begin
  JSCode(JSName + '.getRootNode();', 'TExtDataTreeStore');
  Result := Self;
end;

function TExtDataTreeStore.Load(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtDataTreeStore');
  Result := Self;
end;

function TExtDataTreeStore.SetRootNode(Root : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtDataTreeStore');
  Result := Self;
end;

function TExtDataTreeStore.SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtDataTreeStore');
  Result := Self;
end;

function TExtDataTreeStore.SetRootNode(Root : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.setRootNode(' + VarToJSON([Root, false]) + ');', 'TExtDataTreeStore');
  Result := Self;
end;

destructor TExtDataTreeStore.Destroy; begin
  try
    FRoot.Free;
    FRootInterface.Free;
    FRootObject.Free;
  except end;
  inherited;
end;

procedure TExtDataTreeStore.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'append') and Assigned(FOnAppend) then
    FOnAppend()
  else if (AEvtName = 'beforeappend') and Assigned(FOnBeforeappend) then
    FOnBeforeappend()
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse()
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand()
  else if (AEvtName = 'beforeinsert') and Assigned(FOnBeforeinsert) then
    FOnBeforeinsert()
  else if (AEvtName = 'beforemove') and Assigned(FOnBeforemove) then
    FOnBeforemove()
  else if (AEvtName = 'beforeremove') and Assigned(FOnBeforeremove) then
    FOnBeforeremove()
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse()
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand()
  else if (AEvtName = 'insert') and Assigned(FOnInsert) then
    FOnInsert()
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad(TExtDataTreeStore(ParamAsObject('This')), TExtDataNodeInterface(ParamAsObject('Node')), TExtObjectList(ParamAsObject('Records')), ParamAsBoolean('Successful'))
  else if (AEvtName = 'move') and Assigned(FOnMove) then
    FOnMove()
  else if (AEvtName = 'remove') and Assigned(FOnRemove) then
    FOnRemove()
  else if (AEvtName = 'sort') and Assigned(FOnSort) then
    FOnSort();
end;

procedure TExtDataReaderXml.SetFNamespace(Value : String); begin
  FNamespace := Value;
  JSCode('namespace:' + VarToJSON([Value]));
end;

procedure TExtDataReaderXml.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

function TExtDataReaderXml.JSClassName : string; begin
  Result := 'Ext.data.reader.Xml';
end;

{$IFDEF FPC}constructor TExtDataReaderXml.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataReaderXml.GetData(Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getData(' + VarToJSON([Data, false]) + ');', 'TExtDataReaderXml');
  Result := Self;
end;

function TExtDataReaderXml.ReadRecords(Doc : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.readRecords(' + VarToJSON([Doc, false]) + ');', 'TExtDataReaderXml');
  Result := Self;
end;

procedure TExtUtilLruCache.SetFMaxSize(Value : Integer); begin
  FMaxSize := Value;
  JSCode('maxSize:' + VarToJSON([Value]));
end;

function TExtUtilLruCache.JSClassName : string; begin
  Result := 'Ext.util.LruCache';
end;

{$IFDEF FPC}constructor TExtUtilLruCache.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilLruCache.Clone : TExtFunction; begin
  JSCode(JSName + '.clone();', 'TExtUtilLruCache');
  Result := Self;
end;

function TExtUtilLruCache.Each(Fn : TExtFunction; Scope : TExtObject; Reverse : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false, Reverse]) + ');', 'TExtUtilLruCache');
  Result := Self;
end;

function TExtUtilLruCache.Prune : TExtFunction; begin
  JSCode(JSName + '.prune();', 'TExtUtilLruCache');
  Result := Self;
end;

procedure TExtDataSequentialIdGenerator.SetFPrefix(Value : String); begin
  FPrefix := Value;
  JSCode('prefix:' + VarToJSON([Value]));
end;

procedure TExtDataSequentialIdGenerator.SetFSeed(Value : Integer); begin
  FSeed := Value;
  JSCode('seed:' + VarToJSON([Value]));
end;

function TExtDataSequentialIdGenerator.JSClassName : string; begin
  Result := 'Ext.data.SequentialIdGenerator';
end;

{$IFDEF FPC}constructor TExtDataSequentialIdGenerator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataSequentialIdGenerator.Generate : TExtFunction; begin
  JSCode(JSName + '.generate();', 'TExtDataSequentialIdGenerator');
  Result := Self;
end;

function TExtDirectJsonProvider.JSClassName : string; begin
  Result := 'Ext.direct.JsonProvider';
end;

{$IFDEF FPC}constructor TExtDirectJsonProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectJsonProvider.CreateEvent(Response : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.createEvent(' + VarToJSON([Response, false]) + ');', 'TExtDirectJsonProvider');
  Result := Self;
end;

function TExtDirectJsonProvider.CreateEvents(Response : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.createEvents(' + VarToJSON([Response, false]) + ');', 'TExtDirectJsonProvider');
  Result := Self;
end;

procedure TExtButton.SetFAllowDepress(Value : Boolean); begin
  FAllowDepress := Value;
  JSCode('allowDepress:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFArrowAlign(Value : String); begin
  FArrowAlign := Value;
  JSCode('arrowAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFArrowCls(Value : String); begin
  FArrowCls := Value;
  JSCode('arrowCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFClickEvent(Value : String); begin
  FClickEvent := Value;
  JSCode('clickEvent:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFCls(Value : String); begin
  FCls := Value;
  JSCode('cls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFDestroyMenu(Value : Boolean); begin
  FDestroyMenu := Value;
  JSCode('destroyMenu:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode(JSName + '.disabled=' + VarToJSON([Value]) + ';');
end;

procedure TExtButton.SetFEnableToggle(Value : Boolean); begin
  FEnableToggle := Value;
  JSCode('enableToggle:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFGlyph(Value : Integer); begin
  FGlyph := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFGlyphString(Value : String); begin
  FGlyphString := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHandleMouseEvents(Value : Boolean); begin
  FHandleMouseEvents := Value;
  JSCode('handleMouseEvents:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  if not ConfigAvailable(JSName) then
    SetHandler(Value)
  else
    JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtButton.SetFHandlerButton(Value : TExtButton); begin
  FHandlerButton := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerButton:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFHandlerE(Value : TExtEventObject); begin
  FHandlerE := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerE:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode(JSName + '.hidden=' + VarToJSON([Value]) + ';');
end;

procedure TExtButton.SetFHref(Value : String); begin
  FHref := Value;
  if not ConfigAvailable(JSName) then
    SetHref(Value)
  else
    JSCode('href:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFHrefTarget(Value : String); begin
  FHrefTarget := Value;
  JSCode('hrefTarget:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIconAlign(Value : String); begin
  FIconAlign := Value;
  JSCode('iconAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFIsAction(Value : Boolean); begin
  FIsAction := Value;
  JSCode(JSName + '.isAction=' + VarToJSON([Value]) + ';');
end;

procedure TExtButton.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFMenuActiveCls(Value : String); begin
  FMenuActiveCls := Value;
  JSCode('menuActiveCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMenuAlign(Value : String); begin
  FMenuAlign := Value;
  JSCode('menuAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMenuObject(Value : TExtObject); begin
  FMenuObject := Value;
  Value.DeleteFromGarbage;
  JSCode('menu:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFMenuString(Value : String); begin
  FMenuString := Value;
  JSCode('menu:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFOverCls(Value : String); begin
  FOverCls := Value;
  JSCode('overCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFOverflowText(Value : String); begin
  FOverflowText := Value;
  JSCode('overflowText:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFParams(Value : TExtObject); begin
  FParams := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetParams(Value)
  else
    JSCode('params:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFPressed(Value : Boolean); begin
  FPressed := Value;
  JSCode(JSName + '.pressed=' + VarToJSON([Value]) + ';');
end;

procedure TExtButton.SetFPressedCls(Value : String); begin
  FPressedCls := Value;
  JSCode('pressedCls:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFRepeatJS(Value : Boolean); begin
  FRepeatJS := Value;
  JSCode('repeatJS:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFRepeatJSObject(Value : TExtObject); begin
  FRepeatJSObject := Value;
  Value.DeleteFromGarbage;
  JSCode('repeatJS:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFScale(Value : TScaleEnum); begin
  FScale := Value;
  JSCode('scale:"' + EnumToJSString(TypeInfo(TScaleEnum), ord(Value)) + '"');
end;

procedure TExtButton.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFShowEmptyMenu(Value : Boolean); begin
  FShowEmptyMenu := Value;
  JSCode('showEmptyMenu:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTabIndex(Value : Integer); begin
  FTabIndex := Value;
  JSCode('tabIndex:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTemplate(Value : TExtTemplate); begin
  FTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.template=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtButton.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTextAlign(Value : String); begin
  FTextAlign := Value;
  if not ConfigAvailable(JSName) then
    SetTextAlign(Value)
  else
    JSCode('textAlign:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFToggleGroup(Value : String); begin
  FToggleGroup := Value;
  JSCode('toggleGroup:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFToggleHandler(Value : TExtFunction); begin
  FToggleHandler := Value;
  JSCode('toggleHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButton.SetFToggleHandlerButton(Value : TExtButton); begin
  FToggleHandlerButton := Value;
  Value.DeleteFromGarbage;
  JSCode('toggleHandlerButton:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFToggleHandlerState(Value : Boolean); begin
  FToggleHandlerState := Value;
  JSCode('toggleHandlerState:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTooltipObject(Value : TExtObject); begin
  FTooltipObject := Value;
  Value.DeleteFromGarbage;
  JSCode('tooltip:' + VarToJSON([Value, false]));
end;

procedure TExtButton.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFTypeJS(Value : String); begin
  FTypeJS := Value;
  JSCode('typeJS:' + VarToJSON([Value]));
end;

procedure TExtButton.SetFOnClick(Value : TExtButtonOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtButton.SetFOnGlyphchange(Value : TExtButtonOnGlyphchange); begin
  if Assigned(FOnGlyphchange) then
    JSCode(JSName+'.events ["glyphchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('glyphchange', Ajax('glyphchange', ['This', '%0.nm','NewGlyph', '%1','OldGlyph', '%2'], true));
  FOnGlyphchange := Value;
end;

procedure TExtButton.SetFOnIconchange(Value : TExtButtonOnIconchange); begin
  if Assigned(FOnIconchange) then
    JSCode(JSName+'.events ["iconchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('iconchange', Ajax('iconchange', ['This', '%0.nm','OldIcon', '%1','NewIcon', '%2'], true));
  FOnIconchange := Value;
end;

procedure TExtButton.SetFOnMenuhide(Value : TExtButtonOnMenuhide); begin
  if Assigned(FOnMenuhide) then
    JSCode(JSName+'.events ["menuhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('menuhide', Ajax('menuhide', ['This', '%0.nm','Menu', '%1.nm'], true));
  FOnMenuhide := Value;
end;

procedure TExtButton.SetFOnMenushow(Value : TExtButtonOnMenushow); begin
  if Assigned(FOnMenushow) then
    JSCode(JSName+'.events ["menushow"].listeners=[];');
  if Assigned(Value) then
    AddListener('menushow', Ajax('menushow', ['This', '%0.nm','Menu', '%1.nm'], true));
  FOnMenushow := Value;
end;

procedure TExtButton.SetFOnMenutriggerout(Value : TExtButtonOnMenutriggerout); begin
  if Assigned(FOnMenutriggerout) then
    JSCode(JSName+'.events ["menutriggerout"].listeners=[];');
  if Assigned(Value) then
    AddListener('menutriggerout', Ajax('menutriggerout', ['This', '%0.nm','Menu', '%1.nm','E', '%2.nm'], true));
  FOnMenutriggerout := Value;
end;

procedure TExtButton.SetFOnMenutriggerover(Value : TExtButtonOnMenutriggerover); begin
  if Assigned(FOnMenutriggerover) then
    JSCode(JSName+'.events ["menutriggerover"].listeners=[];');
  if Assigned(Value) then
    AddListener('menutriggerover', Ajax('menutriggerover', ['This', '%0.nm','Menu', '%1.nm','E', '%2.nm'], true));
  FOnMenutriggerover := Value;
end;

procedure TExtButton.SetFOnMouseout(Value : TExtButtonOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseout := Value;
end;

procedure TExtButton.SetFOnMouseover(Value : TExtButtonOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseover := Value;
end;

procedure TExtButton.SetFOnTextchange(Value : TExtButtonOnTextchange); begin
  if Assigned(FOnTextchange) then
    JSCode(JSName+'.events ["textchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('textchange', Ajax('textchange', ['This', '%0.nm','OldText', '%1','NewText', '%2'], true));
  FOnTextchange := Value;
end;

procedure TExtButton.SetFOnToggle(Value : TExtButtonOnToggle); begin
  if Assigned(FOnToggle) then
    JSCode(JSName+'.events ["toggle"].listeners=[];');
  if Assigned(Value) then
    AddListener('toggle', Ajax('toggle', ['This', '%0.nm','Pressed', '%1'], true));
  FOnToggle := Value;
end;

function TExtButton.JSClassName : string; begin
  Result := 'Ext.button.Button';
end;

procedure TExtButton.InitDefaults; begin
  inherited;
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FHandlerButton := TExtButton.CreateInternal(Self, 'handlerButton');
  FHandlerE := TExtEventObject.CreateInternal(Self, 'handlerE');
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
  FMenuObject := TExtObject.CreateInternal(Self, 'menu');
  FParams := TExtObject.CreateInternal(Self, 'params');
  FRepeatJSObject := TExtObject.CreateInternal(Self, 'repeatJS');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FTemplate := TExtTemplate.CreateInternal(Self, 'template');
  FToggleHandlerButton := TExtButton.CreateInternal(Self, 'toggleHandlerButton');
  FTooltipObject := TExtObject.CreateInternal(Self, 'tooltip');
end;

{$IFDEF FPC}constructor TExtButton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtButton.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtButton.GetTemplateArgs : TExtFunction; begin
  JSCode(JSName + '.getTemplateArgs();', 'TExtButton');
  Result := Self;
end;

function TExtButton.GetText : TExtFunction; begin
  JSCode(JSName + '.getText();', 'TExtButton');
  Result := Self;
end;

function TExtButton.HasVisibleMenu : TExtFunction; begin
  JSCode(JSName + '.hasVisibleMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.HideMenu : TExtFunction; begin
  JSCode(JSName + '.hideMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetGlyph(Glyph : String) : TExtFunction; begin
  JSCode(JSName + '.SetGlyph(' + VarToJSON([Glyph]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetGlyph(Glyph : Integer) : TExtFunction; begin
  JSCode(JSName + '.setGlyph(' + VarToJSON([Glyph]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setHandler(' + VarToJSON([Handler, true, Scope, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetHref(Href : String) : TExtFunction; begin
  JSCode(JSName + '.setHref(' + VarToJSON([Href]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetParams(Params : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setParams(' + VarToJSON([Params, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetScale(Scale : String) : TExtFunction; begin
  JSCode(JSName + '.setScale(' + VarToJSON([Scale]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTextAlign(Align : String) : TExtFunction; begin
  JSCode(JSName + '.setTextAlign(' + VarToJSON([Align]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTooltip(Tooltip : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetTooltip(' + VarToJSON([Tooltip, false]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.SetTooltip(Tooltip : String) : TExtFunction; begin
  JSCode(JSName + '.setTooltip(' + VarToJSON([Tooltip]) + ');', 'TExtButton');
  Result := Self;
end;

function TExtButton.ShowMenu : TExtFunction; begin
  JSCode(JSName + '.showMenu();', 'TExtButton');
  Result := Self;
end;

function TExtButton.Toggle(State : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([State, SuppressEvent]) + ');', 'TExtButton');
  Result := Self;
end;

destructor TExtButton.Destroy; begin
  try
    FBaseParams.Free;
    FHandlerButton.Free;
    FHandlerE.Free;
    FMenu.Free;
    FMenuObject.Free;
    FParams.Free;
    FRepeatJSObject.Free;
    FScope.Free;
    FTemplate.Free;
    FToggleHandlerButton.Free;
    FTooltipObject.Free;
  except end;
  inherited;
end;

procedure TExtButton.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'glyphchange') and Assigned(FOnGlyphchange) then
    FOnGlyphchange(TExtButton(ParamAsObject('This')), ParamAsInteger('NewGlyph'), ParamAsInteger('OldGlyph'))
  else if (AEvtName = 'iconchange') and Assigned(FOnIconchange) then
    FOnIconchange(TExtButton(ParamAsObject('This')), ParamAsString('OldIcon'), ParamAsString('NewIcon'))
  else if (AEvtName = 'menuhide') and Assigned(FOnMenuhide) then
    FOnMenuhide(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')))
  else if (AEvtName = 'menushow') and Assigned(FOnMenushow) then
    FOnMenushow(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')))
  else if (AEvtName = 'menutriggerout') and Assigned(FOnMenutriggerout) then
    FOnMenutriggerout(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'menutriggerover') and Assigned(FOnMenutriggerover) then
    FOnMenutriggerover(TExtButton(ParamAsObject('This')), TExtMenu(ParamAsObject('Menu')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtButton(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')))
  else if (AEvtName = 'textchange') and Assigned(FOnTextchange) then
    FOnTextchange(TExtButton(ParamAsObject('This')), ParamAsString('OldText'), ParamAsString('NewText'))
  else if (AEvtName = 'toggle') and Assigned(FOnToggle) then
    FOnToggle(TExtButton(ParamAsObject('This')), ParamAsBoolean('Pressed'));
end;

procedure TExtAjaxSingleton.SetFAutoAbort(Value : Boolean); begin
  FAutoAbort := Value;
  JSCode(JSName + '.autoAbort=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFDefaultHeaders(Value : TExtObject); begin
  FDefaultHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.defaultHeaders=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAjaxSingleton.SetFDisableCaching(Value : Boolean); begin
  FDisableCaching := Value;
  JSCode(JSName + '.disableCaching=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.extraParams=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtAjaxSingleton.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode(JSName + '.method=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode(JSName + '.timeout=' + VarToJSON([Value]) + ';');
end;

procedure TExtAjaxSingleton.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode(JSName + '.url=' + VarToJSON([Value]) + ';');
end;

function TExtAjaxSingleton.JSClassName : string; begin
  Result := 'Ext.Ajax';
end;

procedure TExtAjaxSingleton.InitDefaults; begin
  inherited;
  FDefaultHeaders := TExtObject.CreateInternal(Self, 'defaultHeaders');
  FDisableCaching := true;
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
  FTimeout := 30000;
end;

{$IFDEF FPC}constructor TExtAjaxSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

destructor TExtAjaxSingleton.Destroy; begin
  try
    FDefaultHeaders.Free;
    FExtraParams.Free;
  except end;
  inherited;
end;

procedure TExtAppApplication.SetFAppFolder(Value : String); begin
  FAppFolder := Value;
  JSCode('appFolder:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFAppProperty(Value : String); begin
  FAppProperty := Value;
  JSCode('appProperty:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFAutoCreateViewport(Value : Boolean); begin
  FAutoCreateViewport := Value;
  JSCode('autoCreateViewport:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFControllers(Value : TArrayOfString); begin
  FControllers := Value;
  JSCode('controllers:' + ArrayToJSON(Value));
end;

procedure TExtAppApplication.SetFEnableQuickTips(Value : Boolean); begin
  FEnableQuickTips := Value;
  JSCode('enableQuickTips:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtAppApplication.SetFNamespaces(Value : TArrayOfString); begin
  FNamespaces := Value;
  JSCode('namespaces:' + ArrayToJSON(Value));
end;

procedure TExtAppApplication.SetFPaths(Value : TExtObject); begin
  FPaths := Value;
  Value.DeleteFromGarbage;
  JSCode('paths:' + VarToJSON([Value, false]));
end;

procedure TExtAppApplication.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

function TExtAppApplication.JSClassName : string; begin
  Result := 'Ext.app.Application';
end;

procedure TExtAppApplication.InitDefaults; begin
  inherited;
  FPaths := TExtObject.CreateInternal(Self, 'paths');
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtAppApplication.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtAppApplication.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

destructor TExtAppApplication.Destroy; begin
  try
    FPaths.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldBase.SetFActiveError(Value : String); begin
  FActiveError := Value;
  if not ConfigAvailable(JSName) then
    SetActiveError(Value)
  else
    JSCode('activeError:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFActiveErrorsTpl(Value : String); begin
  FActiveErrorsTpl := Value;
  JSCode('activeErrorsTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString); begin
  FActiveErrorsTplTArrayOfString := Value;
  JSCode('activeErrorsTpl:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldBase.SetFActiveErrorsTplTemplate(Value : TExtXTemplate); begin
  FActiveErrorsTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('activeErrorsTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterBodyEl(Value : String); begin
  FAfterBodyEl := Value;
  JSCode('afterBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFAfterBodyElList(Value : TExtObjectList); begin
  FAfterBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterBodyElTemplate(Value : TExtXTemplate); begin
  FAfterBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTextTpl(Value : String); begin
  FAfterLabelTextTpl := Value;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTextTplList(Value : TExtObjectList); begin
  FAfterLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTextTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTpl(Value : String); begin
  FAfterLabelTpl := Value;
  JSCode('afterLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTplList(Value : TExtObjectList); begin
  FAfterLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterLabelTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterSubTpl(Value : String); begin
  FAfterSubTpl := Value;
  JSCode('afterSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFAfterSubTplList(Value : TExtObjectList); begin
  FAfterSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAfterSubTplTemplate(Value : TExtXTemplate); begin
  FAfterSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFAutoFitErrors(Value : Boolean); begin
  FAutoFitErrors := Value;
  JSCode('autoFitErrors:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBaseBodyCls(Value : String); begin
  FBaseBodyCls := Value;
  JSCode('baseBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBeforeBodyEl(Value : String); begin
  FBeforeBodyEl := Value;
  JSCode('beforeBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBeforeBodyElList(Value : TExtObjectList); begin
  FBeforeBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeBodyElTemplate(Value : TExtXTemplate); begin
  FBeforeBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTextTpl(Value : String); begin
  FBeforeLabelTextTpl := Value;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTextTplList(Value : TExtObjectList); begin
  FBeforeLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTpl(Value : String); begin
  FBeforeLabelTpl := Value;
  JSCode('beforeLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTplList(Value : TExtObjectList); begin
  FBeforeLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeLabelTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeSubTpl(Value : String); begin
  FBeforeSubTpl := Value;
  JSCode('beforeSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFBeforeSubTplList(Value : TExtObjectList); begin
  FBeforeSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBeforeSubTplTemplate(Value : TExtXTemplate); begin
  FBeforeSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFBodyEl(Value : TExtElement); begin
  FBodyEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.bodyEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFCheckChangeBuffer(Value : Integer); begin
  FCheckChangeBuffer := Value;
  JSCode('checkChangeBuffer:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFCheckChangeEvents(Value : TArrayOfString); begin
  FCheckChangeEvents := Value;
  JSCode('checkChangeEvents:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldBase.SetFClearCls(Value : String); begin
  FClearCls := Value;
  JSCode('clearCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFDirtyCls(Value : String); begin
  FDirtyCls := Value;
  JSCode('dirtyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFErrorEl(Value : TExtElement); begin
  FErrorEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.errorEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFErrorMsgCls(Value : String); begin
  FErrorMsgCls := Value;
  JSCode('errorMsgCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldLabel(Value : String); begin
  FFieldLabel := Value;
  if not ConfigAvailable(JSName) then
    SetFieldLabel(Value)
  else
    JSCode('fieldLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFieldStyle(Value : String); begin
  FFieldStyle := Value;
  JSCode('fieldStyle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFFormItemCls(Value : String); begin
  FFormItemCls := Value;
  JSCode('formItemCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFHideEmptyLabel(Value : Boolean); begin
  FHideEmptyLabel := Value;
  JSCode('hideEmptyLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFHideLabel(Value : Boolean); begin
  FHideLabel := Value;
  JSCode('hideLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputAttrTpl(Value : String); begin
  FInputAttrTpl := Value;
  JSCode('inputAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputAttrTplList(Value : TExtObjectList); begin
  FInputAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('inputAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFInputAttrTplTemplate(Value : TExtXTemplate); begin
  FInputAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('inputAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFInputEl(Value : TExtElement); begin
  FInputEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.inputEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFInputId(Value : String); begin
  FInputId := Value;
  JSCode('inputId:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInputType(Value : String); begin
  FInputType := Value;
  JSCode('inputType:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInvalidCls(Value : String); begin
  FInvalidCls := Value;
  JSCode('invalidCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFIsFieldLabelable(Value : Boolean); begin
  FIsFieldLabelable := Value;
  JSCode(JSName + '.isFieldLabelable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldBase.SetFIsFormField(Value : Boolean); begin
  FIsFormField := Value;
  JSCode(JSName + '.isFormField=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldBase.SetFLabelAlign(Value : TLabelAlignEnum); begin
  FLabelAlign := Value;
  JSCode('labelAlign:"' + EnumToJSString(TypeInfo(TLabelAlignEnum), ord(Value)) + '"');
end;

procedure TExtFormFieldBase.SetFLabelAttrTpl(Value : String); begin
  FLabelAttrTpl := Value;
  JSCode('labelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelAttrTplList(Value : TExtObjectList); begin
  FLabelAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFLabelAttrTplTemplate(Value : TExtXTemplate); begin
  FLabelAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFLabelCell(Value : TExtElement); begin
  FLabelCell := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelCell=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFLabelCls(Value : String); begin
  FLabelCls := Value;
  JSCode('labelCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelClsExtra(Value : String); begin
  FLabelClsExtra := Value;
  JSCode('labelClsExtra:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelEl(Value : TExtElement); begin
  FLabelEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFLabelPad(Value : Integer); begin
  FLabelPad := Value;
  JSCode('labelPad:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelSeparator(Value : String); begin
  FLabelSeparator := Value;
  JSCode('labelSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelStyle(Value : String); begin
  FLabelStyle := Value;
  JSCode('labelStyle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFMsgTarget(Value : String); begin
  FMsgTarget := Value;
  JSCode('msgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldBase.SetFPreventMark(Value : Boolean); begin
  FPreventMark := Value;
  JSCode('preventMark:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  if not ConfigAvailable(JSName) then
    SetReadOnly(Value)
  else
    JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFReadOnlyCls(Value : String); begin
  FReadOnlyCls := Value;
  JSCode('readOnlyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFTabIndex(Value : Integer); begin
  FTabIndex := Value;
  JSCode('tabIndex:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFValidateOnBlur(Value : Boolean); begin
  FValidateOnBlur := Value;
  JSCode('validateOnBlur:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFValidateOnChange(Value : Boolean); begin
  FValidateOnChange := Value;
  JSCode('validateOnChange:' + VarToJSON([Value]));
end;

procedure TExtFormFieldBase.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldBase.SetFOnChange(Value : TExtFormFieldBaseOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','NewValue', '%1.nm','OldValue', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtFormFieldBase.SetFOnDirtychange(Value : TExtFormFieldBaseOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', ['This', '%0.nm','IsDirty', '%1'], true));
  FOnDirtychange := Value;
end;

procedure TExtFormFieldBase.SetFOnErrorchange(Value : TExtFormFieldBaseOnErrorchange); begin
  if Assigned(FOnErrorchange) then
    JSCode(JSName+'.events ["errorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('errorchange', Ajax('errorchange', ['This', '%0.nm','Error', '%1'], true));
  FOnErrorchange := Value;
end;

procedure TExtFormFieldBase.SetFOnSpecialkey(Value : TExtFormFieldBaseOnSpecialkey); begin
  if Assigned(FOnSpecialkey) then
    JSCode(JSName+'.events ["specialkey"].listeners=[];');
  if Assigned(Value) then
    AddListener('specialkey', Ajax('specialkey', ['This', '%0.nm','E', '%1.nm'], true));
  FOnSpecialkey := Value;
end;

procedure TExtFormFieldBase.SetFOnValiditychange(Value : TExtFormFieldBaseOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', ['This', '%0.nm','IsValid', '%1'], true));
  FOnValiditychange := Value;
end;

procedure TExtFormFieldBase.SetFOnWriteablechange(Value : TExtFormFieldBaseOnWriteablechange); begin
  if Assigned(FOnWriteablechange) then
    JSCode(JSName+'.events ["writeablechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('writeablechange', Ajax('writeablechange', ['This', '%0.nm','Read', '%1'], true));
  FOnWriteablechange := Value;
end;

function TExtFormFieldBase.JSClassName : string; begin
  Result := 'Ext.form.field.Base';
end;

procedure TExtFormFieldBase.InitDefaults; begin
  inherited;
  FActiveErrorsTplTemplate := TExtXTemplate.CreateInternal(Self, 'activeErrorsTpl');
  FAfterBodyElList := TExtObjectList.Create(Self, 'afterBodyEl');
  FAfterBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'afterBodyEl');
  FAfterLabelTextTplList := TExtObjectList.Create(Self, 'afterLabelTextTpl');
  FAfterLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTextTpl');
  FAfterLabelTplList := TExtObjectList.Create(Self, 'afterLabelTpl');
  FAfterLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTpl');
  FAfterSubTplList := TExtObjectList.Create(Self, 'afterSubTpl');
  FAfterSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterSubTpl');
  FBeforeBodyElList := TExtObjectList.Create(Self, 'beforeBodyEl');
  FBeforeBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBodyEl');
  FBeforeLabelTextTplList := TExtObjectList.Create(Self, 'beforeLabelTextTpl');
  FBeforeLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTextTpl');
  FBeforeLabelTplList := TExtObjectList.Create(Self, 'beforeLabelTpl');
  FBeforeLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTpl');
  FBeforeSubTplList := TExtObjectList.Create(Self, 'beforeSubTpl');
  FBeforeSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeSubTpl');
  FBodyEl := TExtElement.CreateInternal(Self, 'bodyEl');
  FCheckChangeBuffer := 50;
  FErrorEl := TExtElement.CreateInternal(Self, 'errorEl');
  FInputAttrTplList := TExtObjectList.Create(Self, 'inputAttrTpl');
  FInputAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'inputAttrTpl');
  FInputEl := TExtElement.CreateInternal(Self, 'inputEl');
  FLabelAttrTplList := TExtObjectList.Create(Self, 'labelAttrTpl');
  FLabelAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'labelAttrTpl');
  FLabelCell := TExtElement.CreateInternal(Self, 'labelCell');
  FLabelEl := TExtElement.CreateInternal(Self, 'labelEl');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
  FValue := TExtObject.CreateInternal(Self, 'value');
end;

{$IFDEF FPC}constructor TExtFormFieldBase.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldBase.BatchChanges(Fn : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.batchChanges(' + VarToJSON([Fn, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormFieldBase');
  Result := Self;
end;

constructor TExtFormFieldBase.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldBase.ExtractFileInput : TExtFunction; begin
  JSCode(JSName + '.extractFileInput();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetActiveError : TExtFunction; begin
  JSCode(JSName + '.getActiveError();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetActiveErrors : TExtFunction; begin
  JSCode(JSName + '.getActiveErrors();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetInputId : TExtFunction; begin
  JSCode(JSName + '.getInputId();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetLabelWidth : TExtFunction; begin
  JSCode(JSName + '.getLabelWidth();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetModelData : TExtFunction; begin
  JSCode(JSName + '.getModelData();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetSubmitData : TExtFunction; begin
  JSCode(JSName + '.getSubmitData();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetSubTplMarkup : TExtFunction; begin
  JSCode(JSName + '.getSubTplMarkup();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.HasActiveError : TExtFunction; begin
  JSCode(JSName + '.hasActiveError();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.HasVisibleLabel : TExtFunction; begin
  JSCode(JSName + '.hasVisibleLabel();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.InitField : TExtFunction; begin
  JSCode(JSName + '.initField();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.InitLabelable : TExtFunction; begin
  JSCode(JSName + '.initLabelable();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.InitValue : TExtFunction; begin
  JSCode(JSName + '.initValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isEqual(' + VarToJSON([Value1, false, Value2, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.IsFileUpload : TExtFunction; begin
  JSCode(JSName + '.isFileUpload();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.MarkInvalid(Errors : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON([Errors]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.MarkInvalid(Errors : String) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Errors]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ResetOriginalValue : TExtFunction; begin
  JSCode(JSName + '.resetOriginalValue();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetActiveError(Msg : String) : TExtFunction; begin
  JSCode(JSName + '.setActiveError(' + VarToJSON([Msg]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetActiveErrors(Errors : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.setActiveErrors(' + VarToJSON([Errors]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldDefaults(Defaults : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setFieldDefaults(' + VarToJSON([Defaults, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldLabel(LabelJS : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldLabel(' + VarToJSON([LabelJS]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetFieldStyle(' + VarToJSON([Style, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.SetFieldStyle(' + VarToJSON([Style, true]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetFieldStyle(Style : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldStyle(' + VarToJSON([Style]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetRawValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setRawValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetReadOnly(ReadOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([ReadOnly]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.TrimLabelSeparator : TExtFunction; begin
  JSCode(JSName + '.trimLabelSeparator();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.UnsetActiveError : TExtFunction; begin
  JSCode(JSName + '.unsetActiveError();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ValidateValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.validateValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

function TExtFormFieldBase.ValueToRaw(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.valueToRaw(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldBase');
  Result := Self;
end;

destructor TExtFormFieldBase.Destroy; begin
  try
    FActiveErrorsTplTemplate.Free;
    FAfterBodyElList.Free;
    FAfterBodyElTemplate.Free;
    FAfterLabelTextTplList.Free;
    FAfterLabelTextTplTemplate.Free;
    FAfterLabelTplList.Free;
    FAfterLabelTplTemplate.Free;
    FAfterSubTplList.Free;
    FAfterSubTplTemplate.Free;
    FBeforeBodyElList.Free;
    FBeforeBodyElTemplate.Free;
    FBeforeLabelTextTplList.Free;
    FBeforeLabelTextTplTemplate.Free;
    FBeforeLabelTplList.Free;
    FBeforeLabelTplTemplate.Free;
    FBeforeSubTplList.Free;
    FBeforeSubTplTemplate.Free;
    FBodyEl.Free;
    FErrorEl.Free;
    FInputAttrTplList.Free;
    FInputAttrTplTemplate.Free;
    FInputEl.Free;
    FLabelAttrTplList.Free;
    FLabelAttrTplTemplate.Free;
    FLabelCell.Free;
    FLabelEl.Free;
    FOriginalValue.Free;
    FValue.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldBase.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormField(ParamAsObject('This')), TExtObject(ParamAsObject('NewValue')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsDirty'))
  else if (AEvtName = 'errorchange') and Assigned(FOnErrorchange) then
    FOnErrorchange(TExtFormLabelable(ParamAsObject('This')), ParamAsString('Error'))
  else if (AEvtName = 'specialkey') and Assigned(FOnSpecialkey) then
    FOnSpecialkey(TExtFormFieldBase(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsValid'))
  else if (AEvtName = 'writeablechange') and Assigned(FOnWriteablechange) then
    FOnWriteablechange(TExtFormFieldBase(ParamAsObject('This')), ParamAsBoolean('Read'));
end;

procedure TExtFormBasic.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFErrorReader(Value : TExtObject); begin
  FErrorReader := Value;
  Value.DeleteFromGarbage;
  JSCode('errorReader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFErrorReaderReader(Value : TExtDataReader); begin
  FErrorReaderReader := Value;
  Value.DeleteFromGarbage;
  JSCode('errorReader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFJsonSubmit(Value : Boolean); begin
  FJsonSubmit := Value;
  JSCode('jsonSubmit:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFMethod(Value : String); begin
  FMethod := Value;
  JSCode('method:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFOwner(Value : TExtContainer); begin
  FOwner := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.owner=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormBasic.SetFParamOrder(Value : String); begin
  FParamOrder := Value;
  JSCode('paramOrder:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFParamOrderTArrayOfString(Value : TArrayOfString); begin
  FParamOrderTArrayOfString := Value;
  JSCode('paramOrder:' + ArrayToJSON(Value));
end;

procedure TExtFormBasic.SetFParamsAsHash(Value : Boolean); begin
  FParamsAsHash := Value;
  JSCode('paramsAsHash:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFReader(Value : TExtObject); begin
  FReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFReaderReader(Value : TExtDataReader); begin
  FReaderReader := Value;
  Value.DeleteFromGarbage;
  JSCode('reader:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFStandardSubmit(Value : Boolean); begin
  FStandardSubmit := Value;
  JSCode('standardSubmit:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFTrackResetOnLoad(Value : Boolean); begin
  FTrackResetOnLoad := Value;
  JSCode('trackResetOnLoad:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFWaitMsgTarget(Value : String); begin
  FWaitMsgTarget := Value;
  JSCode('waitMsgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFWaitMsgTargetElement(Value : TExtElement); begin
  FWaitMsgTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('waitMsgTarget:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFWaitMsgTargetTHTMLElement(Value : THTMLElement); begin
  FWaitMsgTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('waitMsgTarget:' + VarToJSON([Value, false]));
end;

procedure TExtFormBasic.SetFWaitTitle(Value : String); begin
  FWaitTitle := Value;
  JSCode('waitTitle:' + VarToJSON([Value]));
end;

procedure TExtFormBasic.SetFOnActioncomplete(Value : TExtFormBasicOnActioncomplete); begin
  if Assigned(FOnActioncomplete) then
    JSCode(JSName+'.events ["actioncomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('actioncomplete', Ajax('actioncomplete', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnActioncomplete := Value;
end;

procedure TExtFormBasic.SetFOnActionfailed(Value : TExtFormBasicOnActionfailed); begin
  if Assigned(FOnActionfailed) then
    JSCode(JSName+'.events ["actionfailed"].listeners=[];');
  if Assigned(Value) then
    AddListener('actionfailed', Ajax('actionfailed', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnActionfailed := Value;
end;

procedure TExtFormBasic.SetFOnBeforeaction(Value : TExtFormBasicOnBeforeaction); begin
  if Assigned(FOnBeforeaction) then
    JSCode(JSName+'.events ["beforeaction"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeaction', Ajax('beforeaction', ['This', '%0.nm','Action', '%1.nm'], true));
  FOnBeforeaction := Value;
end;

procedure TExtFormBasic.SetFOnDirtychange(Value : TExtFormBasicOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', ['This', '%0.nm','Dirty', '%1'], true));
  FOnDirtychange := Value;
end;

procedure TExtFormBasic.SetFOnValiditychange(Value : TExtFormBasicOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', ['This', '%0.nm','Valid', '%1'], true));
  FOnValiditychange := Value;
end;

function TExtFormBasic.JSClassName : string; begin
  Result := 'Ext.form.Basic';
end;

procedure TExtFormBasic.InitDefaults; begin
  inherited;
  FApi := TExtObject.CreateInternal(Self, 'api');
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FErrorReader := TExtObject.CreateInternal(Self, 'errorReader');
  FErrorReaderReader := TExtDataReader.CreateInternal(Self, 'errorReader');
  FOwner := TExtContainer.CreateInternal(Self, 'owner');
  FReader := TExtObject.CreateInternal(Self, 'reader');
  FReaderReader := TExtDataReader.CreateInternal(Self, 'reader');
  FWaitMsgTargetElement := TExtElement.CreateInternal(Self, 'waitMsgTarget');
end;

{$IFDEF FPC}constructor TExtFormBasic.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormBasic.ApplyIfToFields(Obj : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyIfToFields(' + VarToJSON([Obj, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.ApplyToFields(Obj : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.applyToFields(' + VarToJSON([Obj, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.CheckValidity : TExtFunction; begin
  JSCode(JSName + '.checkValidity();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.ClearInvalid : TExtFunction; begin
  JSCode(JSName + '.clearInvalid();', 'TExtFormBasic');
  Result := Self;
end;

constructor TExtFormBasic.Create(Owner : TExtContainer; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Owner, false, Config, false]) + ');');
  InitDefaults;
end;

function TExtFormBasic.DoAction(Action : TExtFormAction; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.DoAction(' + VarToJSON([Action, false, Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.DoAction(Action : String; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.doAction(' + VarToJSON([Action, Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.FindField(Id : String) : TExtFunction; begin
  JSCode(JSName + '.findField(' + VarToJSON([Id]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetFields : TExtFunction; begin
  JSCode(JSName + '.getFields();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetFieldValues(DirtyOnly : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getFieldValues(' + VarToJSON([DirtyOnly]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetRecord : TExtFunction; begin
  JSCode(JSName + '.getRecord();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.GetValues(AsString : Boolean = false; DirtyOnly : Boolean = false; IncludeEmptyText : Boolean = false; UseDataValues : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getValues(' + VarToJSON([AsString, DirtyOnly, IncludeEmptyText, UseDataValues]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.HasInvalidField : TExtFunction; begin
  JSCode(JSName + '.hasInvalidField();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.HasUpload : TExtFunction; begin
  JSCode(JSName + '.hasUpload();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.LoadRecord(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.loadRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON(Errors) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.MarkInvalid(' + VarToJSON([Errors, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.MarkInvalid(Errors : TExtDataErrors) : TExtFunction; begin
  JSCode(JSName + '.markInvalid(' + VarToJSON([Errors, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Reset(ResetRecord : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.reset(' + VarToJSON([ResetRecord]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.SetValues(Values : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.SetValues(' + VarToJSON(Values) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.SetValues(Values : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValues(' + VarToJSON([Values, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.Submit(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.submit(' + VarToJSON([Options, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

function TExtFormBasic.UpdateRecord(RecordJS : TExtDataModel = nil) : TExtFunction; begin
  JSCode(JSName + '.updateRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormBasic');
  Result := Self;
end;

destructor TExtFormBasic.Destroy; begin
  try
    FApi.Free;
    FBaseParams.Free;
    FErrorReader.Free;
    FErrorReaderReader.Free;
    FOwner.Free;
    FReader.Free;
    FReaderReader.Free;
    FWaitMsgTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtFormBasic.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'actioncomplete') and Assigned(FOnActioncomplete) then
    FOnActioncomplete(TExtFormBasic(ParamAsObject('This')), TExtFormAction(ParamAsObject('Action')))
  else if (AEvtName = 'actionfailed') and Assigned(FOnActionfailed) then
    FOnActionfailed(TExtFormBasic(ParamAsObject('This')), TExtFormAction(ParamAsObject('Action')))
  else if (AEvtName = 'beforeaction') and Assigned(FOnBeforeaction) then
    FOnBeforeaction(TExtFormBasic(ParamAsObject('This')), TExtFormAction(ParamAsObject('Action')))
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange(TExtFormBasic(ParamAsObject('This')), ParamAsBoolean('Dirty'))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange(TExtFormBasic(ParamAsObject('This')), ParamAsBoolean('Valid'));
end;

function TExtFormActionLoad.JSClassName : string; begin
  Result := 'Ext.form.action.Load';
end;

{$IFDEF FPC}constructor TExtFormActionLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectRemotingEvent.JSClassName : string; begin
  Result := 'Ext.direct.RemotingEvent';
end;

{$IFDEF FPC}constructor TExtDirectRemotingEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectRemotingEvent.GetTransaction : TExtFunction; begin
  JSCode(JSName + '.getTransaction();', 'TExtDirectRemotingEvent');
  Result := Self;
end;

procedure TExtFormActionSubmit.SetFClientValidation(Value : Boolean); begin
  FClientValidation := Value;
  JSCode('clientValidation:' + VarToJSON([Value]));
end;

function TExtFormActionSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.Submit';
end;

{$IFDEF FPC}constructor TExtFormActionSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataStore.SetFAutoDestroy(Value : Boolean); begin
  FAutoDestroy := Value;
  JSCode('autoDestroy:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFBuffered(Value : Boolean); begin
  FBuffered := Value;
  JSCode('buffered:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFClearOnPageLoad(Value : Boolean); begin
  FClearOnPageLoad := Value;
  JSCode('clearOnPageLoad:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFClearRemovedOnLoad(Value : Boolean); begin
  FClearRemovedOnLoad := Value;
  JSCode('clearRemovedOnLoad:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFCurrentPage(Value : Integer); begin
  FCurrentPage := Value;
  JSCode(JSName + '.currentPage=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataStore.SetFData(Value : TExtObjectList); begin
  FData := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFDataList(Value : TExtObjectList); begin
  FDataList := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFGroupDir(Value : String); begin
  FGroupDir := Value;
  JSCode('groupDir:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFGroupers(Value : TExtUtilMixedCollection); begin
  FGroupers := Value;
  Value.DeleteFromGarbage;
  JSCode('groupers:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFGroupField(Value : String); begin
  FGroupField := Value;
  JSCode('groupField:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFLeadingBufferZone(Value : Integer); begin
  FLeadingBufferZone := Value;
  JSCode('leadingBufferZone:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFProxy(Value : String); begin
  FProxy := Value;
  JSCode('proxy:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFProxyObject(Value : TExtObject); begin
  FProxyObject := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFProxyProxy(Value : TExtDataProxy); begin
  FProxyProxy := Value;
  Value.DeleteFromGarbage;
  JSCode('proxy:' + VarToJSON([Value, false]));
end;

procedure TExtDataStore.SetFPurgePageCount(Value : Integer); begin
  FPurgePageCount := Value;
  JSCode('purgePageCount:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFRemoteFilter(Value : Boolean); begin
  FRemoteFilter := Value;
  JSCode('remoteFilter:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFRemoteGroup(Value : Boolean); begin
  FRemoteGroup := Value;
  JSCode('remoteGroup:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFRemoteSort(Value : Boolean); begin
  FRemoteSort := Value;
  JSCode('remoteSort:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFSnapshot(Value : TExtUtilMixedCollection); begin
  FSnapshot := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.snapshot=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataStore.SetFSortOnFilter(Value : Boolean); begin
  FSortOnFilter := Value;
  JSCode('sortOnFilter:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFTrailingBufferZone(Value : Integer); begin
  FTrailingBufferZone := Value;
  JSCode('trailingBufferZone:' + VarToJSON([Value]));
end;

procedure TExtDataStore.SetFOnBeforeprefetch(Value : TExtDataStoreOnBeforeprefetch); begin
  if Assigned(FOnBeforeprefetch) then
    JSCode(JSName+'.events ["beforeprefetch"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeprefetch', Ajax('beforeprefetch', ['This', '%0.nm','Operation', '%1.nm'], true));
  FOnBeforeprefetch := Value;
end;

procedure TExtDataStore.SetFOnFilterchange(Value : TExtDataStoreOnFilterchange); begin
  if Assigned(FOnFilterchange) then
    JSCode(JSName+'.events ["filterchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('filterchange', Ajax('filterchange', ['Store', '%0.nm','Filters', '%1.nm'], true));
  FOnFilterchange := Value;
end;

procedure TExtDataStore.SetFOnGroupchange(Value : TExtDataStoreOnGroupchange); begin
  if Assigned(FOnGroupchange) then
    JSCode(JSName+'.events ["groupchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupchange', Ajax('groupchange', ['Store', '%0.nm','Groupers', '%1.nm'], true));
  FOnGroupchange := Value;
end;

procedure TExtDataStore.SetFOnPrefetch(Value : TExtDataStoreOnPrefetch); begin
  if Assigned(FOnPrefetch) then
    JSCode(JSName+'.events ["prefetch"].listeners=[];');
  if Assigned(Value) then
    AddListener('prefetch', Ajax('prefetch', ['This', '%0.nm','Records', '%1.nm','Successful', '%2','Operation', '%3.nm'], true));
  FOnPrefetch := Value;
end;

function TExtDataStore.JSClassName : string; begin
  Result := 'Ext.data.Store';
end;

procedure TExtDataStore.InitDefaults; begin
  inherited;
  FData := TExtObjectList.Create(Self, 'data');
  FDataList := TExtObjectList.Create(Self, 'data');
  FGroupers := TExtUtilMixedCollection.CreateInternal(Self, 'groupers');
  FPageSize := 25;
  FProxyObject := TExtObject.CreateInternal(Self, 'proxy');
  FProxyProxy := TExtDataProxy.CreateInternal(Self, 'proxy');
  FSnapshot := TExtUtilMixedCollection.CreateInternal(Self, 'snapshot');
end;

{$IFDEF FPC}constructor TExtDataStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataStore.Add(Model : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Add(' + VarToJSON(Model) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Add(Model : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.add(' + VarToJSON([Model, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.AddFilter(Filters : TExtObjectList; ApplyFilters : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.addFilter(' + VarToJSON(Filters) + ',' + VarToJSON([ApplyFilters]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.AddSorted(RecordJS : TExtDataRecord) : TExtFunction; begin
  JSCode(JSName + '.addSorted(' + VarToJSON([RecordJS]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Aggregate(Fn : TExtFunction; Scope : TExtObject = nil; Grouped : Boolean = false; Args : TExtObjectList = nil) : TExtFunction; begin
  JSCode(JSName + '.aggregate(' + VarToJSON([Fn, true, Scope, false, Grouped]) + ',' + VarToJSON(Args) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Average(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.average(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.ClearFilter(SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.clearFilter(' + VarToJSON([SuppressEvent]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.ClearGrouping : TExtFunction; begin
  JSCode(JSName + '.clearGrouping();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Collect(DataIndex : String; AllowNull : Boolean = false; BypassFilter : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.collect(' + VarToJSON([DataIndex, AllowNull, BypassFilter]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.CommitChanges : TExtFunction; begin
  JSCode(JSName + '.commitChanges();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Count(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.count(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

constructor TExtDataStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataStore.Each(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.each(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Filter(Filters : TExtObjectList; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.Filter(' + VarToJSON(Filters) + ',' + VarToJSON([Value]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Filter(Filters : String = ''; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.filter(' + VarToJSON([Filters, Value]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FilterBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.filterBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Find(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Find(' + VarToJSON([FieldName, #3 + Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Find(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.find(' + VarToJSON([FieldName, Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindBy(Fn : TExtFunction; Scope : TExtObject = nil; StartIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.findBy(' + VarToJSON([Fn, true, Scope, false, StartIndex]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindExact(FieldName : String; Value : TExtObject; StartIndex : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.findExact(' + VarToJSON([FieldName, Value, false, StartIndex]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindRecord(FieldName : String; Value : TRegExp; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.FindRecord(' + VarToJSON([FieldName, #3 + Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.FindRecord(FieldName : String; Value : String; StartIndex : Integer = 0; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.findRecord(' + VarToJSON([FieldName, Value, StartIndex, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.First(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.first(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getAt(' + VarToJSON([Index]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetById(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getById(' + VarToJSON([Id]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetGroups(GroupName : String = '') : TExtFunction; begin
  JSCode(JSName + '.getGroups(' + VarToJSON([GroupName]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetGroupString(Instance : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.getGroupString(' + VarToJSON([Instance, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetPageFromRecordIndex(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getPageFromRecordIndex(' + VarToJSON([Index]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetRange(Start : Integer; EndJS : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getRange(' + VarToJSON([Start, EndJS, Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.GetTotalCount : TExtFunction; begin
  JSCode(JSName + '.getTotalCount();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Group(Groupers : TExtObjectList; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.Group(' + VarToJSON(Groupers) + ',' + VarToJSON([Direction]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Group(Groupers : String; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.group(' + VarToJSON([Groupers, Direction]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOf(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([RecordJS, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOfId(Id : String) : TExtFunction; begin
  JSCode(JSName + '.indexOfId(' + VarToJSON([Id]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IndexOfTotal(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.indexOfTotal(' + VarToJSON([RecordJS, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Insert(Index : Integer; Records : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.insert(' + VarToJSON([Index]) + ',' + VarToJSON(Records) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IsFiltered : TExtFunction; begin
  JSCode(JSName + '.isFiltered();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.IsGrouped : TExtFunction; begin
  JSCode(JSName + '.isGrouped();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Last(Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.last(' + VarToJSON([Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Load(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Load(Options : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, true]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.loadData(' + VarToJSON(Data) + ',' + VarToJSON([Append]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadPage(Page : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.loadPage(' + VarToJSON([Page, Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadRawData(Data : TExtObjectList; Append : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.loadRawData(' + VarToJSON(Data) + ',' + VarToJSON([Append]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.LoadRecords(Records : TExtObjectList; Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.loadRecords(' + VarToJSON(Records) + ',' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Max(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.max(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Min(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.min(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.NextPage(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.nextPage(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Prefetch(Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.prefetch(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PrefetchPage(Page : Integer; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.prefetchPage(' + VarToJSON([Page, Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PrefetchRange : TExtFunction; begin
  JSCode(JSName + '.prefetchRange();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.PreviousPage(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.previousPage(' + VarToJSON([Options, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Query(PropertyJS : String; Value : TRegExp; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Query(' + VarToJSON([PropertyJS, #3 + Value, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Query(PropertyJS : String; Value : String; AnyMatch : Boolean = false; CaseSensitive : Boolean = false; ExactMatch : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.query(' + VarToJSON([PropertyJS, Value, AnyMatch, CaseSensitive, ExactMatch]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.QueryBy(Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.queryBy(' + VarToJSON([Fn, true, Scope, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RejectChanges : TExtFunction; begin
  JSCode(JSName + '.rejectChanges();', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Remove(Records : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Remove(' + VarToJSON(Records) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Remove(Records : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.Remove(' + VarToJSON([Records, false]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Remove(Records : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.Remove(' + VarToJSON([Records]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Remove(Records : Integer) : TExtFunction; begin
  JSCode(JSName + '.remove(' + VarToJSON([Records]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RemoveAll(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeAll(' + VarToJSON([Silent]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RemoveAt(Index : Integer; Count : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.removeAt(' + VarToJSON([Index, Count]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.RemoveFilter(ToRemove : String; ApplyFilters : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeFilter(' + VarToJSON([ToRemove, ApplyFilters]) + ');', 'TExtDataStore');
  Result := Self;
end;

function TExtDataStore.Sum(Field : String; Grouped : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.sum(' + VarToJSON([Field, Grouped]) + ');', 'TExtDataStore');
  Result := Self;
end;

destructor TExtDataStore.Destroy; begin
  try
    FData.Free;
    FDataList.Free;
    FGroupers.Free;
    FProxyObject.Free;
    FProxyProxy.Free;
    FSnapshot.Free;
  except end;
  inherited;
end;

procedure TExtDataStore.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeprefetch') and Assigned(FOnBeforeprefetch) then
    FOnBeforeprefetch(TExtDataStore(ParamAsObject('This')), TExtDataOperation(ParamAsObject('Operation')))
  else if (AEvtName = 'filterchange') and Assigned(FOnFilterchange) then
    FOnFilterchange(TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Filters')))
  else if (AEvtName = 'groupchange') and Assigned(FOnGroupchange) then
    FOnGroupchange(TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Groupers')))
  else if (AEvtName = 'prefetch') and Assigned(FOnPrefetch) then
    FOnPrefetch(TExtDataStore(ParamAsObject('This')), TExtObjectList(ParamAsObject('Records')), ParamAsBoolean('Successful'), TExtDataOperation(ParamAsObject('Operation')));
end;

function TExtAppDomainControllerSingleton.JSClassName : string; begin
  Result := 'Ext.app.domain.Controller';
end;

{$IFDEF FPC}constructor TExtAppDomainControllerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtAppDomainDirectSingleton.JSClassName : string; begin
  Result := 'Ext.app.domain.Direct';
end;

{$IFDEF FPC}constructor TExtAppDomainDirectSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilGrouper.JSClassName : string; begin
  Result := 'Ext.util.Grouper';
end;

{$IFDEF FPC}constructor TExtUtilGrouper.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtUtilGrouper.GetGroupString(Instance : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.getGroupString(' + VarToJSON([Instance, false]) + ');', 'TExtUtilGrouper');
  Result := Self;
end;

function TExtAppDomainComponentSingleton.JSClassName : string; begin
  Result := 'Ext.app.domain.Component';
end;

{$IFDEF FPC}constructor TExtAppDomainComponentSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtUtilComponentDragger.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtUtilComponentDragger.SetFConstrainDelegate(Value : Boolean); begin
  FConstrainDelegate := Value;
  JSCode('constrainDelegate:' + VarToJSON([Value]));
end;

procedure TExtUtilComponentDragger.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

procedure TExtUtilComponentDragger.SetFDelegateElement(Value : TExtElement); begin
  FDelegateElement := Value;
  Value.DeleteFromGarbage;
  JSCode('delegate:' + VarToJSON([Value, false]));
end;

function TExtUtilComponentDragger.JSClassName : string; begin
  Result := 'Ext.util.ComponentDragger';
end;

procedure TExtUtilComponentDragger.InitDefaults; begin
  inherited;
  FDelegateElement := TExtElement.CreateInternal(Self, 'delegate');
end;

{$IFDEF FPC}constructor TExtUtilComponentDragger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilComponentDragger.Create(Comp : TExtObject; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([Comp, false, Config, false]) + ');');
  InitDefaults;
end;

destructor TExtUtilComponentDragger.Destroy; begin
  try
    FDelegateElement.Free;
  except end;
  inherited;
end;

function TExtXTemplateCompiler.JSClassName : string; begin
  Result := 'Ext.XTemplateCompiler';
end;

{$IFDEF FPC}constructor TExtXTemplateCompiler.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtUtilClickRepeater.SetFAccelerate(Value : Boolean); begin
  FAccelerate := Value;
  JSCode('accelerate:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFDelay(Value : Integer); begin
  FDelay := Value;
  JSCode('delay:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFEl(Value : String); begin
  FEl := Value;
  JSCode('el:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFElElement(Value : TExtElement); begin
  FElElement := Value;
  Value.DeleteFromGarbage;
  JSCode('el:' + VarToJSON([Value, false]));
end;

procedure TExtUtilClickRepeater.SetFElTHTMLElement(Value : THTMLElement); begin
  FElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('el:' + VarToJSON([Value, false]));
end;

procedure TExtUtilClickRepeater.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFPressedCls(Value : String); begin
  FPressedCls := Value;
  JSCode('pressedCls:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFPreventDefault(Value : Boolean); begin
  FPreventDefault := Value;
  JSCode('preventDefault:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFStopDefault(Value : Boolean); begin
  FStopDefault := Value;
  JSCode('stopDefault:' + VarToJSON([Value]));
end;

procedure TExtUtilClickRepeater.SetFOnClick(Value : TExtUtilClickRepeaterOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtUtilClickRepeater.SetFOnMousedown(Value : TExtUtilClickRepeaterOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMousedown := Value;
end;

procedure TExtUtilClickRepeater.SetFOnMouseup(Value : TExtUtilClickRepeaterOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnMouseup := Value;
end;

function TExtUtilClickRepeater.JSClassName : string; begin
  Result := 'Ext.util.ClickRepeater';
end;

procedure TExtUtilClickRepeater.InitDefaults; begin
  inherited;
  FElElement := TExtElement.CreateInternal(Self, 'el');
end;

{$IFDEF FPC}constructor TExtUtilClickRepeater.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilClickRepeater.Create(El : THTMLElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtUtilClickRepeater.Create(El : TExtElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtUtilClickRepeater.Create(El : String; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, Config, false]) + ');');
  InitDefaults;
end;

function TExtUtilClickRepeater.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtUtilClickRepeater');
  Result := Self;
end;

function TExtUtilClickRepeater.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtUtilClickRepeater');
  Result := Self;
end;

function TExtUtilClickRepeater.SetDisabled(Disabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setDisabled(' + VarToJSON([Disabled]) + ');', 'TExtUtilClickRepeater');
  Result := Self;
end;

destructor TExtUtilClickRepeater.Destroy; begin
  try
    FElElement.Free;
  except end;
  inherited;
end;

procedure TExtUtilClickRepeater.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtUtilClickRepeater(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown(TExtUtilClickRepeater(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup(TExtUtilClickRepeater(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtDataReaderJson.SetFMetaProperty(Value : String); begin
  FMetaProperty := Value;
  JSCode('metaProperty:' + VarToJSON([Value]));
end;

procedure TExtDataReaderJson.SetFRecordJS(Value : String); begin
  FRecordJS := Value;
  JSCode('recordJS:' + VarToJSON([Value]));
end;

procedure TExtDataReaderJson.SetFUseSimpleAccessors(Value : Boolean); begin
  FUseSimpleAccessors := Value;
  JSCode('useSimpleAccessors:' + VarToJSON([Value]));
end;

function TExtDataReaderJson.JSClassName : string; begin
  Result := 'Ext.data.reader.Json';
end;

{$IFDEF FPC}constructor TExtDataReaderJson.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataReaderJson.ReadRecords(Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.readRecords(' + VarToJSON([Data, false]) + ');', 'TExtDataReaderJson');
  Result := Self;
end;

procedure TExtStateCookieProvider.SetFDomain(Value : String); begin
  FDomain := Value;
  JSCode('domain:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFExpires(Value : TDateTime); begin
  FExpires := Value;
  JSCode('expires:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFPath(Value : String); begin
  FPath := Value;
  JSCode('path:' + VarToJSON([Value]));
end;

procedure TExtStateCookieProvider.SetFSecure(Value : Boolean); begin
  FSecure := Value;
  JSCode('secure:' + VarToJSON([Value]));
end;

function TExtStateCookieProvider.JSClassName : string; begin
  Result := 'Ext.state.CookieProvider';
end;

procedure TExtStateCookieProvider.InitDefaults; begin
  inherited;
  FDomain := 'www';
  FPath := '/';
end;

{$IFDEF FPC}constructor TExtStateCookieProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtStateCookieProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtUtilMixedCollection.SetFAllowFunctions(Value : Boolean); begin
  FAllowFunctions := Value;
  JSCode('allowFunctions:' + VarToJSON([Value]));
end;

procedure TExtUtilMixedCollection.SetFDefaultSortDirection(Value : String); begin
  FDefaultSortDirection := Value;
  JSCode('defaultSortDirection:' + VarToJSON([Value]));
end;

procedure TExtUtilMixedCollection.SetFIsSortable(Value : Boolean); begin
  FIsSortable := Value;
  JSCode(JSName + '.isSortable=' + VarToJSON([Value]) + ';');
end;

procedure TExtUtilMixedCollection.SetFSorters(Value : TExtObjectList); begin
  FSorters := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtUtilMixedCollection.SetFSortersList(Value : TExtObjectList); begin
  FSortersList := Value;
  Value.DeleteFromGarbage;
  JSCode('sorters:' + VarToJSON([Value, false]));
end;

procedure TExtUtilMixedCollection.SetFSortRoot(Value : String); begin
  FSortRoot := Value;
  JSCode('sortRoot:' + VarToJSON([Value]));
end;

function TExtUtilMixedCollection.JSClassName : string; begin
  Result := 'Ext.util.MixedCollection';
end;

{$IFDEF FPC}constructor TExtUtilMixedCollection.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtUtilMixedCollection.Create(Config : TExtObject); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtUtilMixedCollection.CreateComparator(Sorters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.createComparator(' + VarToJSON(Sorters) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.FindInsertionIndex(NewItem : TExtObject; SorterFn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.findInsertionIndex(' + VarToJSON([NewItem, false, SorterFn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.GenerateComparator : TExtFunction; begin
  JSCode(JSName + '.generateComparator();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.InitSortable : TExtFunction; begin
  JSCode(JSName + '.initSortable();', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Reorder(Mapping : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.reorder(' + VarToJSON([Mapping, false]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Sort(Sorters : String = ''; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.sort(' + VarToJSON([Sorters, Direction]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.Sort(Sorters : TExtObjectList; Direction : String = '') : TExtFunction; begin
  JSCode(JSName + '.Sort(' + VarToJSON(Sorters) + ',' + VarToJSON([Direction]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.SortBy(SorterFn : TExtFunction) : TExtFunction; begin
  JSCode(JSName + '.sortBy(' + VarToJSON([SorterFn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

function TExtUtilMixedCollection.SortByKey(Direction : String = ''; Fn : TExtFunction = nil) : TExtFunction; begin
  JSCode(JSName + '.sortByKey(' + VarToJSON([Direction, Fn, true]) + ');', 'TExtUtilMixedCollection');
  Result := Self;
end;

procedure TExtDataProxyServer.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyServer.SetFCacheString(Value : String); begin
  FCacheString := Value;
  JSCode('cacheString:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFDirectionParam(Value : String); begin
  FDirectionParam := Value;
  JSCode('directionParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode('extraParams:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyServer.SetFFilterParam(Value : String); begin
  FFilterParam := Value;
  JSCode('filterParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFGroupDirectionParam(Value : String); begin
  FGroupDirectionParam := Value;
  JSCode('groupDirectionParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFGroupParam(Value : String); begin
  FGroupParam := Value;
  JSCode('groupParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFIdParam(Value : String); begin
  FIdParam := Value;
  JSCode('idParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFLimitParam(Value : String); begin
  FLimitParam := Value;
  JSCode('limitParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFNoCache(Value : Boolean); begin
  FNoCache := Value;
  JSCode('noCache:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFPageParam(Value : String); begin
  FPageParam := Value;
  JSCode('pageParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFSimpleGroupMode(Value : Boolean); begin
  FSimpleGroupMode := Value;
  JSCode('simpleGroupMode:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFSimpleSortMode(Value : Boolean); begin
  FSimpleSortMode := Value;
  JSCode('simpleSortMode:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFSortParam(Value : String); begin
  FSortParam := Value;
  JSCode('sortParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFStartParam(Value : String); begin
  FStartParam := Value;
  JSCode('startParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtDataProxyServer.SetFOnException(Value : TExtDataProxyServerOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['This', '%0.nm','Response', '%1.nm','Operation', '%2.nm'], true));
  FOnException := Value;
end;

function TExtDataProxyServer.JSClassName : string; begin
  Result := 'Ext.data.proxy.Server';
end;

procedure TExtDataProxyServer.InitDefaults; begin
  inherited;
  FApi := TExtObject.CreateInternal(Self, 'api');
  FCacheString := '_dc';
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
  FFilterParam := 'filter';
  FGroupParam := 'group';
  FLimitParam := 'limit';
  FNoCache := true;
  FPageParam := 'page';
  FSortParam := 'sort';
  FStartParam := 'start';
  FTimeout := 30000;
end;

{$IFDEF FPC}constructor TExtDataProxyServer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyServer.BuildRequest(Operation : TExtDataOperation) : TExtFunction; begin
  JSCode(JSName + '.buildRequest(' + VarToJSON([Operation, false]) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

function TExtDataProxyServer.BuildUrl(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.buildUrl(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

constructor TExtDataProxyServer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxyServer.DoRequest(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.doRequest(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

function TExtDataProxyServer.EncodeFilters(Filters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.encodeFilters(' + VarToJSON(Filters) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

function TExtDataProxyServer.EncodeSorters(Sorters : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.encodeSorters(' + VarToJSON(Sorters) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

function TExtDataProxyServer.SetExtraParam(Name : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setExtraParam(' + VarToJSON([Name, Value, false]) + ');', 'TExtDataProxyServer');
  Result := Self;
end;

destructor TExtDataProxyServer.Destroy; begin
  try
    FApi.Free;
    FExtraParams.Free;
  except end;
  inherited;
end;

procedure TExtDataProxyServer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDataProxyServer(ParamAsObject('This')), TExtObject(ParamAsObject('Response')), TExtDataOperation(ParamAsObject('Operation')));
end;

function TExtFxTargetElement.JSClassName : string; begin
  Result := 'Ext.fx.target.Element';
end;

{$IFDEF FPC}constructor TExtFxTargetElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtStateLocalStorageProvider.JSClassName : string; begin
  Result := 'Ext.state.LocalStorageProvider';
end;

{$IFDEF FPC}constructor TExtStateLocalStorageProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxTargetSprite.JSClassName : string; begin
  Result := 'Ext.fx.target.Sprite';
end;

{$IFDEF FPC}constructor TExtFxTargetSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridFeature.SetFIsFeature(Value : Boolean); begin
  FIsFeature := Value;
  JSCode(JSName + '.isFeature=' + VarToJSON([Value]) + ';');
end;

function TExtGridFeature.JSClassName : string; begin
  Result := 'Ext.grid.feature.Feature';
end;

{$IFDEF FPC}constructor TExtGridFeature.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeature.Disable : TExtFunction; begin
  JSCode(JSName + '.disable();', 'TExtGridFeature');
  Result := Self;
end;

function TExtGridFeature.Enable : TExtFunction; begin
  JSCode(JSName + '.enable();', 'TExtGridFeature');
  Result := Self;
end;

procedure TExtSelectionModel.SetFAllowDeselect(Value : Boolean); begin
  FAllowDeselect := Value;
  JSCode('allowDeselect:' + VarToJSON([Value]));
end;

procedure TExtSelectionModel.SetFMode(Value : TModeEnum); begin
  FMode := Value;
  JSCode('mode:"' + EnumToJSString(TypeInfo(TModeEnum), ord(Value)) + '"');
end;

procedure TExtSelectionModel.SetFPruneRemoved(Value : Boolean); begin
  FPruneRemoved := Value;
  JSCode('pruneRemoved:' + VarToJSON([Value]));
end;

procedure TExtSelectionModel.SetFSelected(Value : TExtUtilMixedCollection); begin
  FSelected := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.selected=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtSelectionModel.SetFOnFocuschange(Value : TExtSelectionModelOnFocuschange); begin
  if Assigned(FOnFocuschange) then
    JSCode(JSName+'.events ["focuschange"].listeners=[];');
  if Assigned(Value) then
    AddListener('focuschange', Ajax('focuschange', ['This', '%0.nm','OldFocused', '%1.nm','NewFocused', '%2.nm'], true));
  FOnFocuschange := Value;
end;

procedure TExtSelectionModel.SetFOnSelectionchange(Value : TExtSelectionModelOnSelectionchange); begin
  if Assigned(FOnSelectionchange) then
    JSCode(JSName+'.events ["selectionchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('selectionchange', Ajax('selectionchange', ['This', '%0.nm','Selected', '%1.nm'], true));
  FOnSelectionchange := Value;
end;

function TExtSelectionModel.JSClassName : string; begin
  Result := 'Ext.selection.Model';
end;

procedure TExtSelectionModel.InitDefaults; begin
  inherited;
  FSelected := TExtUtilMixedCollection.CreateInternal(Self, 'selected');
end;

{$IFDEF FPC}constructor TExtSelectionModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionModel.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

constructor TExtSelectionModel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtSelectionModel.Deselect(Records : TExtObjectList; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Deselect(' + VarToJSON(Records) + ',' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Deselect(Records : Integer; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.deselect(' + VarToJSON([Records, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectAll(SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.deselectAll(' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectRange(StartRow : Integer; EndRow : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.DeselectRange(' + VarToJSON([StartRow, EndRow, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectRange(StartRow : TExtDataModel; EndRow : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.DeselectRange(' + VarToJSON([StartRow, false, EndRow, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectRange(StartRow : TExtDataModel; EndRow : Integer) : TExtFunction; begin
  JSCode(JSName + '.DeselectRange(' + VarToJSON([StartRow, false, EndRow]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.DeselectRange(StartRow : Integer; EndRow : Integer) : TExtFunction; begin
  JSCode(JSName + '.deselectRange(' + VarToJSON([StartRow, EndRow]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetCount : TExtFunction; begin
  JSCode(JSName + '.getCount();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetLastSelected : TExtFunction; begin
  JSCode(JSName + '.getLastSelected();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetSelection : TExtFunction; begin
  JSCode(JSName + '.getSelection();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetSelectionMode : TExtFunction; begin
  JSCode(JSName + '.getSelectionMode();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.HasSelection : TExtFunction; begin
  JSCode(JSName + '.hasSelection();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsFocused(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.isFocused(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsLocked : TExtFunction; begin
  JSCode(JSName + '.isLocked();', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsRangeSelected(From : Integer; ToJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.IsRangeSelected(' + VarToJSON([From, ToJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsRangeSelected(From : TExtDataModel; ToJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.IsRangeSelected(' + VarToJSON([From, false, ToJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsRangeSelected(From : TExtDataModel; ToJS : Integer) : TExtFunction; begin
  JSCode(JSName + '.IsRangeSelected(' + VarToJSON([From, false, ToJS]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsRangeSelected(From : Integer; ToJS : Integer) : TExtFunction; begin
  JSCode(JSName + '.isRangeSelected(' + VarToJSON([From, ToJS]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsSelected(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.IsSelected(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.IsSelected(RecordJS : Integer) : TExtFunction; begin
  JSCode(JSName + '.isSelected(' + VarToJSON([RecordJS]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Select(Records : TExtObjectList; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.Select(' + VarToJSON(Records) + ',' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.Select(Records : Integer; KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([Records, KeepExisting, SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectAll(SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.selectAll(' + VarToJSON([SuppressEvent]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : Integer; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, EndRow, false, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : TExtDataModel; EndRow : TExtDataModel; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, false, EndRow, false, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : TExtDataModel; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SelectRange(' + VarToJSON([StartRow, false, EndRow, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SelectRange(StartRow : Integer; EndRow : Integer; KeepExisting : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectRange(' + VarToJSON([StartRow, EndRow, KeepExisting]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetLastFocused(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.setLastFocused(' + VarToJSON([RecordJS, false]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetLocked(Locked : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setLocked(' + VarToJSON([Locked]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

function TExtSelectionModel.SetSelectionMode(SelMode : String) : TExtFunction; begin
  JSCode(JSName + '.setSelectionMode(' + VarToJSON([SelMode]) + ');', 'TExtSelectionModel');
  Result := Self;
end;

destructor TExtSelectionModel.Destroy; begin
  try
    FSelected.Free;
  except end;
  inherited;
end;

procedure TExtSelectionModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'focuschange') and Assigned(FOnFocuschange) then
    FOnFocuschange(TExtSelectionModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('OldFocused')), TExtDataModel(ParamAsObject('NewFocused')))
  else if (AEvtName = 'selectionchange') and Assigned(FOnSelectionchange) then
    FOnSelectionchange(TExtSelectionModel(ParamAsObject('This')), TExtObjectList(ParamAsObject('Selected')));
end;

function TExtGridFeatureGroupStore.JSClassName : string; begin
  Result := 'Ext.grid.feature.GroupStore';
end;

{$IFDEF FPC}constructor TExtGridFeatureGroupStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartAxisGauge.SetFMargin(Value : Integer); begin
  FMargin := Value;
  JSCode('margin:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFMaximum(Value : Integer); begin
  FMaximum := Value;
  JSCode('maximum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFMinimum(Value : Integer); begin
  FMinimum := Value;
  JSCode('minimum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFSteps(Value : Integer); begin
  FSteps := Value;
  JSCode('steps:' + VarToJSON([Value]));
end;

procedure TExtChartAxisGauge.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

function TExtChartAxisGauge.JSClassName : string; begin
  Result := 'Ext.chart.axis.Gauge';
end;

{$IFDEF FPC}constructor TExtChartAxisGauge.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartAxisGauge.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtChartAxisGauge');
  Result := Self;
end;

procedure TExtViewBoundListKeyNav.SetFBoundList(Value : TExtViewBoundList); begin
  FBoundList := Value;
  Value.DeleteFromGarbage;
  JSCode('boundList:' + VarToJSON([Value, false]));
end;

function TExtViewBoundListKeyNav.JSClassName : string; begin
  Result := 'Ext.view.BoundListKeyNav';
end;

procedure TExtViewBoundListKeyNav.InitDefaults; begin
  inherited;
  FBoundList := TExtViewBoundList.CreateInternal(Self, 'boundList');
end;

{$IFDEF FPC}constructor TExtViewBoundListKeyNav.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtViewBoundListKeyNav.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtViewBoundListKeyNav.HighlightAt(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.highlightAt(' + VarToJSON([Index]) + ');', 'TExtViewBoundListKeyNav');
  Result := Self;
end;

function TExtViewBoundListKeyNav.SelectHighlighted : TExtFunction; begin
  JSCode(JSName + '.selectHighlighted();', 'TExtViewBoundListKeyNav');
  Result := Self;
end;

destructor TExtViewBoundListKeyNav.Destroy; begin
  try
    FBoundList.Free;
  except end;
  inherited;
end;

procedure TExtViewAbstractView.SetFBlockRefresh(Value : Boolean); begin
  FBlockRefresh := Value;
  JSCode('blockRefresh:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFDeferEmptyText(Value : Boolean); begin
  FDeferEmptyText := Value;
  JSCode('deferEmptyText:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFDeferInitialRefresh(Value : Boolean); begin
  FDeferInitialRefresh := Value;
  JSCode('deferInitialRefresh:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFDisableSelection(Value : Boolean); begin
  FDisableSelection := Value;
  JSCode('disableSelection:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFItemSelector(Value : String); begin
  FItemSelector := Value;
  JSCode('itemSelector:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFItemTpl(Value : String); begin
  FItemTpl := Value;
  JSCode('itemTpl:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFItemTplTArrayOfString(Value : TArrayOfString); begin
  FItemTplTArrayOfString := Value;
  JSCode('itemTpl:' + ArrayToJSON(Value));
end;

procedure TExtViewAbstractView.SetFItemTplTemplate(Value : TExtXTemplate); begin
  FItemTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('itemTpl:' + VarToJSON([Value, false]));
end;

procedure TExtViewAbstractView.SetFLoadingCls(Value : String); begin
  FLoadingCls := Value;
  JSCode('loadingCls:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFLoadingHeight(Value : Integer); begin
  FLoadingHeight := Value;
  JSCode('loadingHeight:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFLoadingText(Value : String); begin
  FLoadingText := Value;
  JSCode('loadingText:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFLoadMask(Value : Boolean); begin
  FLoadMask := Value;
  JSCode('loadMask:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFLoadMaskObject(Value : TExtObject); begin
  FLoadMaskObject := Value;
  Value.DeleteFromGarbage;
  JSCode('loadMask:' + VarToJSON([Value, false]));
end;

procedure TExtViewAbstractView.SetFOverItemCls(Value : String); begin
  FOverItemCls := Value;
  JSCode('overItemCls:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFPreserveScrollOnRefresh(Value : Boolean); begin
  FPreserveScrollOnRefresh := Value;
  JSCode('preserveScrollOnRefresh:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFSelectedItemCls(Value : String); begin
  FSelectedItemCls := Value;
  JSCode('selectedItemCls:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFSingleSelect(Value : Boolean); begin
  FSingleSelect := Value;
  JSCode('singleSelect:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtViewAbstractView.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFTplTArrayOfString(Value : TArrayOfString); begin
  FTplTArrayOfString := Value;
  JSCode('tpl:' + ArrayToJSON(Value));
end;

procedure TExtViewAbstractView.SetFTplTemplate(Value : TExtXTemplate); begin
  FTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

procedure TExtViewAbstractView.SetFTrackOver(Value : Boolean); begin
  FTrackOver := Value;
  JSCode('trackOver:' + VarToJSON([Value]));
end;

procedure TExtViewAbstractView.SetFOnBeforerefresh(Value : TExtViewAbstractViewOnBeforerefresh); begin
  if Assigned(FOnBeforerefresh) then
    JSCode(JSName+'.events ["beforerefresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerefresh', Ajax('beforerefresh', ['This', '%0.nm'], true));
  FOnBeforerefresh := Value;
end;

procedure TExtViewAbstractView.SetFOnItemadd(Value : TExtViewAbstractViewOnItemadd); begin
  if Assigned(FOnItemadd) then
    JSCode(JSName+'.events ["itemadd"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemadd', Ajax('itemadd', ['Records', '%0.nm','Index', '%1','Node', '%2.nm'], true));
  FOnItemadd := Value;
end;

procedure TExtViewAbstractView.SetFOnItemremove(Value : TExtViewAbstractViewOnItemremove); begin
  if Assigned(FOnItemremove) then
    JSCode(JSName+'.events ["itemremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemremove', Ajax('itemremove', ['RecordJS', '%0.nm','Index', '%1'], true));
  FOnItemremove := Value;
end;

procedure TExtViewAbstractView.SetFOnItemupdate(Value : TExtViewAbstractViewOnItemupdate); begin
  if Assigned(FOnItemupdate) then
    JSCode(JSName+'.events ["itemupdate"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemupdate', Ajax('itemupdate', ['RecordJS', '%0.nm','Index', '%1','Node', '%2.nm'], true));
  FOnItemupdate := Value;
end;

procedure TExtViewAbstractView.SetFOnRefresh(Value : TExtViewAbstractViewOnRefresh); begin
  if Assigned(FOnRefresh) then
    JSCode(JSName+'.events ["refresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('refresh', Ajax('refresh', ['This', '%0.nm'], true));
  FOnRefresh := Value;
end;

procedure TExtViewAbstractView.SetFOnViewready(Value : TExtViewAbstractViewOnViewready); begin
  if Assigned(FOnViewready) then
    JSCode(JSName+'.events ["viewready"].listeners=[];');
  if Assigned(Value) then
    AddListener('viewready', Ajax('viewready', ['This', '%0.nm'], true));
  FOnViewready := Value;
end;

function TExtViewAbstractView.JSClassName : string; begin
  Result := 'Ext.view.AbstractView';
end;

procedure TExtViewAbstractView.InitDefaults; begin
  inherited;
  FDeferInitialRefresh := true;
  FItemTplTemplate := TExtXTemplate.CreateInternal(Self, 'itemTpl');
  FLoadMaskObject := TExtObject.CreateInternal(Self, 'loadMask');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FTplTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtViewAbstractView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewAbstractView.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.BindStore(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.CollectData(Records : TExtObjectList; StartIndex : Integer) : TExtFunction; begin
  JSCode(JSName + '.collectData(' + VarToJSON(Records) + ',' + VarToJSON([StartIndex]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

constructor TExtViewAbstractView.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtViewAbstractView.Deselect(Records : TExtObjectList; SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.Deselect(' + VarToJSON(Records) + ',' + VarToJSON([SuppressEvent]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.Deselect(Records : Integer; SuppressEvent : Boolean) : TExtFunction; begin
  JSCode(JSName + '.deselect(' + VarToJSON([Records, SuppressEvent]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.FindItemByChild(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.findItemByChild(' + VarToJSON([Node, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.FindTargetByEvent(E : TExtEventObject) : TExtFunction; begin
  JSCode(JSName + '.findTargetByEvent(' + VarToJSON([E, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetNode(NodeInfo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetNode(NodeInfo : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetNode(NodeInfo : String) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetNode(NodeInfo : Integer) : TExtFunction; begin
  JSCode(JSName + '.getNode(' + VarToJSON([NodeInfo]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetNodes(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.getNodes(' + VarToJSON([Start, EndJS]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetRecord(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.GetRecord(' + VarToJSON([Node, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetRecord(Node : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.getRecord(' + VarToJSON([Node, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetRecords(Nodes : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.getRecords(' + VarToJSON(Nodes) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetSelectedNodes : TExtFunction; begin
  JSCode(JSName + '.getSelectedNodes();', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetSelectionModel : TExtFunction; begin
  JSCode(JSName + '.getSelectionModel();', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IndexOf(NodeInfo : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([NodeInfo, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IndexOf(NodeInfo : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([NodeInfo, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IndexOf(NodeInfo : String) : TExtFunction; begin
  JSCode(JSName + '.IndexOf(' + VarToJSON([NodeInfo]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IndexOf(NodeInfo : Integer) : TExtFunction; begin
  JSCode(JSName + '.indexOf(' + VarToJSON([NodeInfo]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IsSelected(Node : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.IsSelected(' + VarToJSON([Node, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IsSelected(Node : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.IsSelected(' + VarToJSON([Node, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.IsSelected(Node : Integer) : TExtFunction; begin
  JSCode(JSName + '.isSelected(' + VarToJSON([Node]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.PrepareData(Data : TExtObjectList; RecordIndex : Integer; RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.PrepareData(' + VarToJSON(Data) + ',' + VarToJSON([RecordIndex, RecordJS, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.PrepareData(Data : TExtObject; RecordIndex : Integer; RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.prepareData(' + VarToJSON([Data, false, RecordIndex, RecordJS, false]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.Refresh : TExtFunction; begin
  JSCode(JSName + '.refresh();', 'TExtViewAbstractView');
  Result := Self;
end;

function TExtViewAbstractView.RefreshNode(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.refreshNode(' + VarToJSON([Index]) + ');', 'TExtViewAbstractView');
  Result := Self;
end;

destructor TExtViewAbstractView.Destroy; begin
  try
    FItemTplTemplate.Free;
    FLoadMaskObject.Free;
    FStore.Free;
    FTplTemplate.Free;
  except end;
  inherited;
end;

procedure TExtViewAbstractView.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforerefresh') and Assigned(FOnBeforerefresh) then
    FOnBeforerefresh(TExtViewAbstractView(ParamAsObject('This')))
  else if (AEvtName = 'itemadd') and Assigned(FOnItemadd) then
    FOnItemadd(TExtObjectList(ParamAsObject('Records')), ParamAsInteger('Index'), TExtObjectList(ParamAsObject('Node')))
  else if (AEvtName = 'itemremove') and Assigned(FOnItemremove) then
    FOnItemremove(TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'itemupdate') and Assigned(FOnItemupdate) then
    FOnItemupdate(TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'), THTMLElement(ParamAsObject('Node')))
  else if (AEvtName = 'refresh') and Assigned(FOnRefresh) then
    FOnRefresh(TExtViewAbstractView(ParamAsObject('This')))
  else if (AEvtName = 'viewready') and Assigned(FOnViewready) then
    FOnViewready(TExtViewAbstractView(ParamAsObject('This')));
end;

function TExtFxTargetComponent.JSClassName : string; begin
  Result := 'Ext.fx.target.Component';
end;

{$IFDEF FPC}constructor TExtFxTargetComponent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartAxis.SetFAdjustEnd(Value : Boolean); begin
  FAdjustEnd := Value;
  JSCode('adjustEnd:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFDashSize(Value : Integer); begin
  FDashSize := Value;
  JSCode('dashSize:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFGrid(Value : Boolean); begin
  FGrid := Value;
  JSCode('grid:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFGridObject(Value : TExtObject); begin
  FGridObject := Value;
  Value.DeleteFromGarbage;
  JSCode('grid:' + VarToJSON([Value, false]));
end;

procedure TExtChartAxis.SetFLength(Value : Integer); begin
  FLength := Value;
  JSCode('length:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFMajorTickSteps(Value : Integer); begin
  FMajorTickSteps := Value;
  JSCode('majorTickSteps:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFMinorTickSteps(Value : Integer); begin
  FMinorTickSteps := Value;
  JSCode('minorTickSteps:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtChartAxis.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

function TExtChartAxis.JSClassName : string; begin
  Result := 'Ext.chart.axis.Axis';
end;

procedure TExtChartAxis.InitDefaults; begin
  inherited;
  FGridObject := TExtObject.CreateInternal(Self, 'grid');
end;

{$IFDEF FPC}constructor TExtChartAxis.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartAxis.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartAxis.DrawAxis : TExtFunction; begin
  JSCode(JSName + '.drawAxis();', 'TExtChartAxis');
  Result := Self;
end;

function TExtChartAxis.DrawGrid : TExtFunction; begin
  JSCode(JSName + '.drawGrid();', 'TExtChartAxis');
  Result := Self;
end;

function TExtChartAxis.DrawLabel : TExtFunction; begin
  JSCode(JSName + '.drawLabel();', 'TExtChartAxis');
  Result := Self;
end;

function TExtChartAxis.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtChartAxis');
  Result := Self;
end;

destructor TExtChartAxis.Destroy; begin
  try
    FGridObject.Free;
  except end;
  inherited;
end;

function TExtDataDirectStore.JSClassName : string; begin
  Result := 'Ext.data.DirectStore';
end;

{$IFDEF FPC}constructor TExtDataDirectStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtMenuSeparator.SetFSeparatorCls(Value : String); begin
  FSeparatorCls := Value;
  JSCode('separatorCls:' + VarToJSON([Value]));
end;

function TExtMenuSeparator.JSClassName : string; begin
  Result := 'Ext.menu.Separator';
end;

{$IFDEF FPC}constructor TExtMenuSeparator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSelectionRowModel.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtSelectionRowModel.SetFIgnoreRightMouseSelection(Value : Boolean); begin
  FIgnoreRightMouseSelection := Value;
  JSCode('ignoreRightMouseSelection:' + VarToJSON([Value]));
end;

procedure TExtSelectionRowModel.SetFOnBeforedeselect(Value : TExtSelectionRowModelOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforedeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnBeforeselect(Value : TExtSelectionRowModelOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnDeselect(Value : TExtSelectionRowModelOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnDeselect := Value;
end;

procedure TExtSelectionRowModel.SetFOnSelect(Value : TExtSelectionRowModelOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnSelect := Value;
end;

function TExtSelectionRowModel.JSClassName : string; begin
  Result := 'Ext.selection.RowModel';
end;

{$IFDEF FPC}constructor TExtSelectionRowModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionRowModel.GetCurrentPosition : TExtFunction; begin
  JSCode(JSName + '.getCurrentPosition();', 'TExtSelectionRowModel');
  Result := Self;
end;

function TExtSelectionRowModel.SelectNext(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectNext(' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionRowModel');
  Result := Self;
end;

function TExtSelectionRowModel.SelectPrevious(KeepExisting : Boolean = false; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.selectPrevious(' + VarToJSON([KeepExisting, SuppressEvent]) + ');', 'TExtSelectionRowModel');
  Result := Self;
end;

procedure TExtSelectionRowModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtSelectionRowModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Index'));
end;

procedure TExtChartSeriesArea.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesArea.JSClassName : string; begin
  Result := 'Ext.chart.series.Area';
end;

procedure TExtChartSeriesArea.InitDefaults; begin
  inherited;
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesArea.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesArea.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.GetLegendColor(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getLegendColor(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.HighlightItem(Info : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Info, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.HighlightSeries(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.highlightSeries(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.UnHighlightItem(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightItem(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

function TExtChartSeriesArea.UnHighlightSeries(Item : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.unHighlightSeries(' + VarToJSON([Item, false]) + ');', 'TExtChartSeriesArea');
  Result := Self;
end;

destructor TExtChartSeriesArea.Destroy; begin
  try
    FStyle.Free;
  except end;
  inherited;
end;

function TExtDataXmlStore.JSClassName : string; begin
  Result := 'Ext.data.XmlStore';
end;

{$IFDEF FPC}constructor TExtDataXmlStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDirectPollingProvider.SetFBaseParams(Value : TExtObject); begin
  FBaseParams := Value;
  Value.DeleteFromGarbage;
  JSCode('baseParams:' + VarToJSON([Value, false]));
end;

procedure TExtDirectPollingProvider.SetFInterval(Value : Integer); begin
  FInterval := Value;
  JSCode('interval:' + VarToJSON([Value]));
end;

procedure TExtDirectPollingProvider.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtDirectPollingProvider.SetFUrlFunction(Value : TExtFunction); begin
  FUrlFunction := Value;
  JSCode('url:' + VarToJSON([Value, true]));
end;

procedure TExtDirectPollingProvider.SetFOnBeforepoll(Value : TExtDirectPollingProviderOnBeforepoll); begin
  if Assigned(FOnBeforepoll) then
    JSCode(JSName+'.events ["beforepoll"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforepoll', Ajax('beforepoll', ['This', '%0.nm'], true));
  FOnBeforepoll := Value;
end;

procedure TExtDirectPollingProvider.SetFOnPoll(Value : TExtDirectPollingProviderOnPoll); begin
  if Assigned(FOnPoll) then
    JSCode(JSName+'.events ["poll"].listeners=[];');
  if Assigned(Value) then
    AddListener('poll', Ajax('poll', ['This', '%0.nm'], true));
  FOnPoll := Value;
end;

function TExtDirectPollingProvider.JSClassName : string; begin
  Result := 'Ext.direct.PollingProvider';
end;

procedure TExtDirectPollingProvider.InitDefaults; begin
  inherited;
  FBaseParams := TExtObject.CreateInternal(Self, 'baseParams');
  FInterval := 3;
end;

{$IFDEF FPC}constructor TExtDirectPollingProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectPollingProvider.Connect : TExtFunction; begin
  JSCode(JSName + '.connect();', 'TExtDirectPollingProvider');
  Result := Self;
end;

constructor TExtDirectPollingProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDirectPollingProvider.Disconnect : TExtFunction; begin
  JSCode(JSName + '.disconnect();', 'TExtDirectPollingProvider');
  Result := Self;
end;

function TExtDirectPollingProvider.IsConnected : TExtFunction; begin
  JSCode(JSName + '.isConnected();', 'TExtDirectPollingProvider');
  Result := Self;
end;

destructor TExtDirectPollingProvider.Destroy; begin
  try
    FBaseParams.Free;
  except end;
  inherited;
end;

procedure TExtDirectPollingProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforepoll') and Assigned(FOnBeforepoll) then
    FOnBeforepoll(TExtDirectPollingProvider(ParamAsObject('This')))
  else if (AEvtName = 'poll') and Assigned(FOnPoll) then
    FOnPoll(TExtDirectPollingProvider(ParamAsObject('This')));
end;

function TExtDataBufferStore.JSClassName : string; begin
  Result := 'Ext.data.BufferStore';
end;

{$IFDEF FPC}constructor TExtDataBufferStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSelectionDataViewModel.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtSelectionDataViewModel.SetFOnBeforedeselect(Value : TExtSelectionDataViewModelOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', ['This', '%0.nm','RecordJS', '%1.nm'], true));
  FOnBeforedeselect := Value;
end;

procedure TExtSelectionDataViewModel.SetFOnBeforeselect(Value : TExtSelectionDataViewModelOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', ['This', '%0.nm','RecordJS', '%1.nm'], true));
  FOnBeforeselect := Value;
end;

procedure TExtSelectionDataViewModel.SetFOnDeselect(Value : TExtSelectionDataViewModelOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', ['This', '%0.nm','RecordJS', '%1.nm'], true));
  FOnDeselect := Value;
end;

procedure TExtSelectionDataViewModel.SetFOnSelect(Value : TExtSelectionDataViewModelOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','RecordJS', '%1.nm'], true));
  FOnSelect := Value;
end;

function TExtSelectionDataViewModel.JSClassName : string; begin
  Result := 'Ext.selection.DataViewModel';
end;

{$IFDEF FPC}constructor TExtSelectionDataViewModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSelectionDataViewModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect(TExtSelectionDataViewModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtSelectionDataViewModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')))
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect(TExtSelectionDataViewModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtSelectionDataViewModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')));
end;

function TExtChartTipSurface.JSClassName : string; begin
  Result := 'Ext.chart.TipSurface';
end;

{$IFDEF FPC}constructor TExtChartTipSurface.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectExceptionEvent.JSClassName : string; begin
  Result := 'Ext.direct.ExceptionEvent';
end;

{$IFDEF FPC}constructor TExtDirectExceptionEvent.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSelectionCellModel.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtSelectionCellModel.SetFMode(Value : TModeEnum); begin
  FMode := Value;
  JSCode('mode:"' + EnumToJSString(TypeInfo(TModeEnum), ord(Value)) + '"');
end;

procedure TExtSelectionCellModel.SetFPreventWrap(Value : Boolean); begin
  FPreventWrap := Value;
  JSCode('preventWrap:' + VarToJSON([Value]));
end;

procedure TExtSelectionCellModel.SetFOnDeselect(Value : TExtSelectionCellModelOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', ['This', '%0.nm','RecordJS', '%1.nm','Row', '%2','Column', '%3'], true));
  FOnDeselect := Value;
end;

procedure TExtSelectionCellModel.SetFOnSelect(Value : TExtSelectionCellModelOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['This', '%0.nm','RecordJS', '%1.nm','Row', '%2','Column', '%3'], true));
  FOnSelect := Value;
end;

function TExtSelectionCellModel.JSClassName : string; begin
  Result := 'Ext.selection.CellModel';
end;

{$IFDEF FPC}constructor TExtSelectionCellModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionCellModel.GetCurrentPosition : TExtFunction; begin
  JSCode(JSName + '.getCurrentPosition();', 'TExtSelectionCellModel');
  Result := Self;
end;

function TExtSelectionCellModel.SetCurrentPosition(Position : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setCurrentPosition(' + VarToJSON([Position, false]) + ');', 'TExtSelectionCellModel');
  Result := Self;
end;

procedure TExtSelectionCellModel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect(TExtSelectionCellModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Row'), ParamAsInteger('Column'))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtSelectionCellModel(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), ParamAsInteger('Row'), ParamAsInteger('Column'));
end;

procedure TExtTab.SetFActive(Value : Boolean); begin
  FActive := Value;
  JSCode(JSName + '.active=' + VarToJSON([Value]) + ';');
end;

procedure TExtTab.SetFActiveCls(Value : String); begin
  FActiveCls := Value;
  JSCode('activeCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  if not ConfigAvailable(JSName) then
    SetClosable(Value)
  else
    JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFClosableCls(Value : String); begin
  FClosableCls := Value;
  JSCode('closableCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFCloseText(Value : String); begin
  FCloseText := Value;
  JSCode('closeText:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFDisabledCls(Value : String); begin
  FDisabledCls := Value;
  JSCode('disabledCls:' + VarToJSON([Value]));
end;

procedure TExtTab.SetFIsTab(Value : Boolean); begin
  FIsTab := Value;
  JSCode(JSName + '.isTab=' + VarToJSON([Value]) + ';');
end;

procedure TExtTab.SetFOnActivate(Value : TExtTabOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtTab.SetFOnBeforeclose(Value : TExtTabOnBeforeclose); begin
  if Assigned(FOnBeforeclose) then
    JSCode(JSName+'.events ["beforeclose"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeclose', Ajax('beforeclose', ['Tab', '%0.nm'], true));
  FOnBeforeclose := Value;
end;

procedure TExtTab.SetFOnClose(Value : TExtTabOnClose); begin
  if Assigned(FOnClose) then
    JSCode(JSName+'.events ["close"].listeners=[];');
  if Assigned(Value) then
    AddListener('close', Ajax('close', ['Tab', '%0.nm'], true));
  FOnClose := Value;
end;

procedure TExtTab.SetFOnDeactivate(Value : TExtTabOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['This', '%0.nm'], true));
  FOnDeactivate := Value;
end;

function TExtTab.JSClassName : string; begin
  Result := 'Ext.tab.Tab';
end;

{$IFDEF FPC}constructor TExtTab.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTab.SetCard(Card : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.setCard(' + VarToJSON([Card, false]) + ');', 'TExtTab');
  Result := Self;
end;

function TExtTab.SetClosable(Closable : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setClosable(' + VarToJSON([Closable]) + ');', 'TExtTab');
  Result := Self;
end;

procedure TExtTab.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtTab(ParamAsObject('This')))
  else if (AEvtName = 'beforeclose') and Assigned(FOnBeforeclose) then
    FOnBeforeclose(TExtTab(ParamAsObject('Tab')))
  else if (AEvtName = 'close') and Assigned(FOnClose) then
    FOnClose(TExtTab(ParamAsObject('Tab')))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtTab(ParamAsObject('This')));
end;

function TExtDataErrors.JSClassName : string; begin
  Result := 'Ext.data.Errors';
end;

{$IFDEF FPC}constructor TExtDataErrors.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataErrors.GetByField(FieldName : String) : TExtFunction; begin
  JSCode(JSName + '.getByField(' + VarToJSON([FieldName]) + ');', 'TExtDataErrors');
  Result := Self;
end;

function TExtDataErrors.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtDataErrors');
  Result := Self;
end;

procedure TExtDirectRemotingProvider.SetFActions(Value : TExtObject); begin
  FActions := Value;
  Value.DeleteFromGarbage;
  JSCode('actions:' + VarToJSON([Value, false]));
end;

procedure TExtDirectRemotingProvider.SetFDisableNestedActions(Value : Boolean); begin
  FDisableNestedActions := Value;
  JSCode('disableNestedActions:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableBuffer(Value : Integer); begin
  FEnableBuffer := Value;
  JSCode('enableBuffer:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableBufferBoolean(Value : Boolean); begin
  FEnableBufferBoolean := Value;
  JSCode('enableBuffer:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFEnableUrlEncode(Value : String); begin
  FEnableUrlEncode := Value;
  JSCode('enableUrlEncode:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFMaxRetries(Value : Integer); begin
  FMaxRetries := Value;
  JSCode('maxRetries:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFNamespace(Value : String); begin
  FNamespace := Value;
  JSCode('namespace:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFNamespaceObject(Value : TExtObject); begin
  FNamespaceObject := Value;
  Value.DeleteFromGarbage;
  JSCode('namespace:' + VarToJSON([Value, false]));
end;

procedure TExtDirectRemotingProvider.SetFTimeout(Value : Integer); begin
  FTimeout := Value;
  JSCode('timeout:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFUrl(Value : String); begin
  FUrl := Value;
  JSCode('url:' + VarToJSON([Value]));
end;

procedure TExtDirectRemotingProvider.SetFOnBeforecall(Value : TExtDirectRemotingProviderOnBeforecall); begin
  if Assigned(FOnBeforecall) then
    JSCode(JSName+'.events ["beforecall"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecall', Ajax('beforecall', ['Provider', '%0.nm','Transaction', '%1.nm','Meta', '%2.nm'], true));
  FOnBeforecall := Value;
end;

procedure TExtDirectRemotingProvider.SetFOnBeforecallback(Value : TExtDirectRemotingProviderOnBeforecallback); begin
  if Assigned(FOnBeforecallback) then
    JSCode(JSName+'.events ["beforecallback"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecallback', Ajax('beforecallback', ['Provider', '%0.nm','Transaction', '%1.nm'], true));
  FOnBeforecallback := Value;
end;

procedure TExtDirectRemotingProvider.SetFOnCall(Value : TExtDirectRemotingProviderOnCall); begin
  if Assigned(FOnCall) then
    JSCode(JSName+'.events ["call"].listeners=[];');
  if Assigned(Value) then
    AddListener('call', Ajax('call', ['Provider', '%0.nm','Transaction', '%1.nm','Meta', '%2.nm'], true));
  FOnCall := Value;
end;

function TExtDirectRemotingProvider.JSClassName : string; begin
  Result := 'Ext.direct.RemotingProvider';
end;

procedure TExtDirectRemotingProvider.InitDefaults; begin
  inherited;
  FActions := TExtObject.CreateInternal(Self, 'actions');
  FNamespaceObject := TExtObject.CreateInternal(Self, 'namespace');
end;

{$IFDEF FPC}constructor TExtDirectRemotingProvider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDirectRemotingProvider.Connect : TExtFunction; begin
  JSCode(JSName + '.connect();', 'TExtDirectRemotingProvider');
  Result := Self;
end;

constructor TExtDirectRemotingProvider.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDirectRemotingProvider.Disconnect : TExtFunction; begin
  JSCode(JSName + '.disconnect();', 'TExtDirectRemotingProvider');
  Result := Self;
end;

function TExtDirectRemotingProvider.IsConnected : TExtFunction; begin
  JSCode(JSName + '.isConnected();', 'TExtDirectRemotingProvider');
  Result := Self;
end;

destructor TExtDirectRemotingProvider.Destroy; begin
  try
    FActions.Free;
    FNamespaceObject.Free;
  except end;
  inherited;
end;

procedure TExtDirectRemotingProvider.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecall') and Assigned(FOnBeforecall) then
    FOnBeforecall(TExtDirectRemotingProvider(ParamAsObject('Provider')), TExtDirectTransaction(ParamAsObject('Transaction')), TExtObject(ParamAsObject('Meta')))
  else if (AEvtName = 'beforecallback') and Assigned(FOnBeforecallback) then
    FOnBeforecallback(TExtDirectRemotingProvider(ParamAsObject('Provider')), TExtDirectTransaction(ParamAsObject('Transaction')))
  else if (AEvtName = 'call') and Assigned(FOnCall) then
    FOnCall(TExtDirectRemotingProvider(ParamAsObject('Provider')), TExtDirectTransaction(ParamAsObject('Transaction')), TExtObject(ParamAsObject('Meta')));
end;

procedure TExtButtonSplit.SetFArrowHandler(Value : TExtFunction); begin
  FArrowHandler := Value;
  if not ConfigAvailable(JSName) then
    SetArrowHandler(Value)
  else
    JSCode('arrowHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButtonSplit.SetFArrowHandlerE(Value : TEvent); begin
  FArrowHandlerE := Value;
  Value.DeleteFromGarbage;
  JSCode('arrowHandlerE:' + VarToJSON([Value, false]));
end;

procedure TExtButtonSplit.SetFArrowHandlerThis(Value : TExtButtonSplit); begin
  FArrowHandlerThis := Value;
  Value.DeleteFromGarbage;
  JSCode('arrowHandlerThis:' + VarToJSON([Value, false]));
end;

procedure TExtButtonSplit.SetFArrowTooltip(Value : String); begin
  FArrowTooltip := Value;
  JSCode('arrowTooltip:' + VarToJSON([Value]));
end;

procedure TExtButtonSplit.SetFOnArrowclick(Value : TExtButtonSplitOnArrowclick); begin
  if Assigned(FOnArrowclick) then
    JSCode(JSName+'.events ["arrowclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('arrowclick', Ajax('arrowclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnArrowclick := Value;
end;

function TExtButtonSplit.JSClassName : string; begin
  Result := 'Ext.button.Split';
end;

procedure TExtButtonSplit.InitDefaults; begin
  inherited;
  FArrowHandlerThis := TExtButtonSplit.CreateInternal(Self, 'arrowHandlerThis');
end;

{$IFDEF FPC}constructor TExtButtonSplit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtButtonSplit.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtButtonSplit.SetArrowHandler(Handler : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setArrowHandler(' + VarToJSON([Handler, true, Scope, false]) + ');', 'TExtButtonSplit');
  Result := Self;
end;

destructor TExtButtonSplit.Destroy; begin
  try
    FArrowHandlerThis.Free;
  except end;
  inherited;
end;

procedure TExtButtonSplit.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'arrowclick') and Assigned(FOnArrowclick) then
    FOnArrowclick(TExtButtonSplit(ParamAsObject('This')), TExtDirectEvent(ParamAsObject('E')));
end;

procedure TExtChartSeriesBar.SetFColumn(Value : Boolean); begin
  FColumn := Value;
  JSCode('column:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFGroupGutter(Value : Integer); begin
  FGroupGutter := Value;
  JSCode('groupGutter:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFGutter(Value : Integer); begin
  FGutter := Value;
  JSCode('gutter:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFStacked(Value : Boolean); begin
  FStacked := Value;
  JSCode('stacked:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFXPadding(Value : Integer); begin
  FXPadding := Value;
  JSCode('xPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFXPaddingObject(Value : TExtObject); begin
  FXPaddingObject := Value;
  Value.DeleteFromGarbage;
  JSCode('xPadding:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesBar.SetFYPadding(Value : Integer); begin
  FYPadding := Value;
  JSCode('yPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesBar.SetFYPaddingObject(Value : TExtObject); begin
  FYPaddingObject := Value;
  Value.DeleteFromGarbage;
  JSCode('yPadding:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesBar.JSClassName : string; begin
  Result := 'Ext.chart.series.Bar';
end;

procedure TExtChartSeriesBar.InitDefaults; begin
  inherited;
  FXPaddingObject := TExtObject.CreateInternal(Self, 'xPadding');
  FYPaddingObject := TExtObject.CreateInternal(Self, 'yPadding');
end;

{$IFDEF FPC}constructor TExtChartSeriesBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesBar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesBar.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesBar');
  Result := Self;
end;

function TExtChartSeriesBar.GetLegendColor : TExtFunction; begin
  JSCode(JSName + '.getLegendColor();', 'TExtChartSeriesBar');
  Result := Self;
end;

destructor TExtChartSeriesBar.Destroy; begin
  try
    FXPaddingObject.Free;
    FYPaddingObject.Free;
  except end;
  inherited;
end;

procedure TExtToolbarTextItem.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtToolbarTextItem.JSClassName : string; begin
  Result := 'Ext.toolbar.TextItem';
end;

{$IFDEF FPC}constructor TExtToolbarTextItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtToolbarTextItem.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtToolbarTextItem');
  Result := Self;
end;

function TExtResizerBorderSplitterTracker.JSClassName : string; begin
  Result := 'Ext.resizer.BorderSplitterTracker';
end;

{$IFDEF FPC}constructor TExtResizerBorderSplitterTracker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtResizerBorderSplitter.JSClassName : string; begin
  Result := 'Ext.resizer.BorderSplitter';
end;

{$IFDEF FPC}constructor TExtResizerBorderSplitter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDrawCompositeSprite.SetFOnClick(Value : TExtDrawCompositeSpriteOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', [], true));
  FOnClick := Value;
end;

procedure TExtDrawCompositeSprite.SetFOnMousedown(Value : TExtDrawCompositeSpriteOnMousedown); begin
  if Assigned(FOnMousedown) then
    JSCode(JSName+'.events ["mousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('mousedown', Ajax('mousedown', [], true));
  FOnMousedown := Value;
end;

procedure TExtDrawCompositeSprite.SetFOnMouseout(Value : TExtDrawCompositeSpriteOnMouseout); begin
  if Assigned(FOnMouseout) then
    JSCode(JSName+'.events ["mouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseout', Ajax('mouseout', [], true));
  FOnMouseout := Value;
end;

procedure TExtDrawCompositeSprite.SetFOnMouseover(Value : TExtDrawCompositeSpriteOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', [], true));
  FOnMouseover := Value;
end;

procedure TExtDrawCompositeSprite.SetFOnMouseup(Value : TExtDrawCompositeSpriteOnMouseup); begin
  if Assigned(FOnMouseup) then
    JSCode(JSName+'.events ["mouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseup', Ajax('mouseup', [], true));
  FOnMouseup := Value;
end;

function TExtDrawCompositeSprite.JSClassName : string; begin
  Result := 'Ext.draw.CompositeSprite';
end;

{$IFDEF FPC}constructor TExtDrawCompositeSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawCompositeSprite.AddCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addCls(' + VarToJSON([Cls]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Animate(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.animate(' + VarToJSON([Config, false]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.GetActiveAnimation : TExtFunction; begin
  JSCode(JSName + '.getActiveAnimation();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.GetBBox : TExtFunction; begin
  JSCode(JSName + '.getBBox();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Hide(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.hide(' + VarToJSON([Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Redraw : TExtFunction; begin
  JSCode(JSName + '.redraw();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.RemoveCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeCls(' + VarToJSON([Cls]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SequenceFx : TExtFunction; begin
  JSCode(JSName + '.sequenceFx();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SetAttributes(Attrs : TExtObject; Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setAttributes(' + VarToJSON([Attrs, false, Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SetStyle(Style : String) : TExtFunction; begin
  JSCode(JSName + '.setStyle(' + VarToJSON([Style]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.Show(Redraw : Boolean) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Redraw]) + ');', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.StopAnimation : TExtFunction; begin
  JSCode(JSName + '.stopAnimation();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

function TExtDrawCompositeSprite.SyncFx : TExtFunction; begin
  JSCode(JSName + '.syncFx();', 'TExtDrawCompositeSprite');
  Result := Self;
end;

procedure TExtDrawCompositeSprite.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick()
  else if (AEvtName = 'mousedown') and Assigned(FOnMousedown) then
    FOnMousedown()
  else if (AEvtName = 'mouseout') and Assigned(FOnMouseout) then
    FOnMouseout()
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover()
  else if (AEvtName = 'mouseup') and Assigned(FOnMouseup) then
    FOnMouseup();
end;

procedure TExtDdDDProxy.SetFCenterFrame(Value : Boolean); begin
  FCenterFrame := Value;
  JSCode(JSName + '.centerFrame=' + VarToJSON([Value]) + ';');
end;

procedure TExtDdDDProxy.SetFResizeFrame(Value : Boolean); begin
  FResizeFrame := Value;
  JSCode(JSName + '.resizeFrame=' + VarToJSON([Value]) + ';');
end;

function TExtDdDDProxy.JSClassName : string; begin
  Result := 'Ext.dd.DDProxy';
end;

{$IFDEF FPC}constructor TExtDdDDProxy.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDDProxy.CreateFrame : TExtFunction; begin
  JSCode(JSName + '.createFrame();', 'TExtDdDDProxy');
  Result := Self;
end;

function TExtDdDDProxy.InitFrame : TExtFunction; begin
  JSCode(JSName + '.initFrame();', 'TExtDdDDProxy');
  Result := Self;
end;

function TExtDataArrayStore.JSClassName : string; begin
  Result := 'Ext.data.ArrayStore';
end;

{$IFDEF FPC}constructor TExtDataArrayStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtToolbarSeparator.JSClassName : string; begin
  Result := 'Ext.toolbar.Separator';
end;

{$IFDEF FPC}constructor TExtToolbarSeparator.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChart.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFAnimateObject(Value : TExtObject); begin
  FAnimateObject := Value;
  Value.DeleteFromGarbage;
  JSCode('animate:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFAxes(Value : TExtObjectList); begin
  FAxes := Value;
  Value.DeleteFromGarbage;
  JSCode('axes:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFBackground(Value : TExtObject); begin
  FBackground := Value;
  Value.DeleteFromGarbage;
  JSCode('background:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFBackgroundBoolean(Value : Boolean); begin
  FBackgroundBoolean := Value;
  JSCode('background:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFGlobalEvents(Value : TExtUtilObservable); begin
  FGlobalEvents := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.globalEvents=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChart.SetFGradients(Value : TExtObjectList); begin
  FGradients := Value;
  Value.DeleteFromGarbage;
  JSCode('gradients:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFHasListeners(Value : TExtObject); begin
  FHasListeners := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.hasListeners=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtChart.SetFInsetPadding(Value : Integer); begin
  FInsetPadding := Value;
  JSCode('insetPadding:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFIsObservable(Value : Boolean); begin
  FIsObservable := Value;
  JSCode(JSName + '.isObservable=' + VarToJSON([Value]) + ';');
end;

procedure TExtChart.SetFLegend(Value : Boolean); begin
  FLegend := Value;
  JSCode('legend:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFLegendObject(Value : TExtObject); begin
  FLegendObject := Value;
  Value.DeleteFromGarbage;
  JSCode('legend:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFListeners(Value : TExtObject); begin
  FListeners := Value;
  Value.DeleteFromGarbage;
  JSCode('listeners:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFMask(Value : Boolean); begin
  FMask := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFMaskString(Value : String); begin
  FMaskString := Value;
  JSCode('mask:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFSeries(Value : TExtObjectList); begin
  FSeries := Value;
  Value.DeleteFromGarbage;
  JSCode('series:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtChart.SetFTheme(Value : String); begin
  FTheme := Value;
  JSCode('theme:' + VarToJSON([Value]));
end;

procedure TExtChart.SetFOnBeforerefresh(Value : TExtChartOnBeforerefresh); begin
  if Assigned(FOnBeforerefresh) then
    JSCode(JSName+'.events ["beforerefresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforerefresh', Ajax('beforerefresh', ['This', '%0.nm'], true));
  FOnBeforerefresh := Value;
end;

procedure TExtChart.SetFOnRefresh(Value : TExtChartOnRefresh); begin
  if Assigned(FOnRefresh) then
    JSCode(JSName+'.events ["refresh"].listeners=[];');
  if Assigned(Value) then
    AddListener('refresh', Ajax('refresh', ['This', '%0.nm'], true));
  FOnRefresh := Value;
end;

function TExtChart.JSClassName : string; begin
  Result := 'Ext.chart.Chart';
end;

procedure TExtChart.InitDefaults; begin
  inherited;
  FAnimateObject := TExtObject.CreateInternal(Self, 'animate');
  FAxes := TExtObjectList.Create(Self, 'axes');
  FBackground := TExtObject.CreateInternal(Self, 'background');
  FGlobalEvents := TExtUtilObservable.CreateInternal(Self, 'globalEvents');
  FGradients := TExtObjectList.Create(Self, 'gradients');
  FHasListeners := TExtObject.CreateInternal(Self, 'hasListeners');
  FInsetPadding := 10;
  FLegendObject := TExtObject.CreateInternal(Self, 'legend');
  FListeners := TExtObject.CreateInternal(Self, 'listeners');
  FSeries := TExtObjectList.Create(Self, 'series');
  FStore := TExtDataStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtChart.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChart.AddEvents(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.addEvents(' + VarToJSON([EventNames]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddEvents(EventNames : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.AddEvents(' + VarToJSON([EventNames, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddListener(EventName : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addListener(' + VarToJSON([EventName, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddListener(EventName : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddListener(' + VarToJSON([EventName, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.addManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.AddManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil; Options : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.AddManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false, Options, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.Capture(O : TExtUtilObservable; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.capture(' + VarToJSON([O, false, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.ClearListeners : TExtFunction; begin
  JSCode(JSName + '.clearListeners();', 'TExtChart');
  Result := Self;
end;

function TExtChart.ClearManagedListeners : TExtFunction; begin
  JSCode(JSName + '.clearManagedListeners();', 'TExtChart');
  Result := Self;
end;

constructor TExtChart.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChart.EnableBubble(EventNames : String) : TExtFunction; begin
  JSCode(JSName + '.enableBubble(' + VarToJSON([EventNames]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.EnableBubble(EventNames : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.EnableBubble(' + VarToJSON([EventNames]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.FireEvent(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEvent(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.FireEventArgs(EventName : String; Args : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.fireEventArgs(' + VarToJSON([EventName]) + ',' + VarToJSON(Args) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtChart');
  Result := Self;
end;

function TExtChart.HasListener(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.hasListener(' + VarToJSON([EventName]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.Observe(C : TExtFunction; Listeners : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.observe(' + VarToJSON([C, true, Listeners, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.Redraw(Resize : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.redraw(' + VarToJSON([Resize]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RelayEvents(Origin : TExtObject; Events : TArrayOfString; Prefix : String = '') : TExtFunction; begin
  JSCode(JSName + '.relayEvents(' + VarToJSON([Origin, false, Events, Prefix]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.ReleaseCapture(O : TExtUtilObservable) : TExtFunction; begin
  JSCode(JSName + '.releaseCapture(' + VarToJSON([O, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RemoveListener(EventName : String; Fn : TExtFunction; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeListener(' + VarToJSON([EventName, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RemoveManagedListener(Item : TExtElement; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.removeManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RemoveManagedListener(Item : TExtUtilObservable; Ename : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RemoveManagedListener(Item : TExtUtilObservable; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RemoveManagedListener(Item : TExtElement; Ename : TExtObject; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.RemoveManagedListener(' + VarToJSON([Item, false, Ename, false, Fn, true, Scope, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.RestoreZoom : TExtFunction; begin
  JSCode(JSName + '.restoreZoom();', 'TExtChart');
  Result := Self;
end;

function TExtChart.ResumeEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.resumeEvent(' + VarToJSON([EventName]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.ResumeEvents : TExtFunction; begin
  JSCode(JSName + '.resumeEvents();', 'TExtChart');
  Result := Self;
end;

function TExtChart.Save(Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.save(' + VarToJSON([Config, false]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.SetZoom : TExtFunction; begin
  JSCode(JSName + '.setZoom();', 'TExtChart');
  Result := Self;
end;

function TExtChart.SuspendEvent(EventName : String) : TExtFunction; begin
  JSCode(JSName + '.suspendEvent(' + VarToJSON([EventName]) + ');', 'TExtChart');
  Result := Self;
end;

function TExtChart.SuspendEvents(QueueSuspended : Boolean) : TExtFunction; begin
  JSCode(JSName + '.suspendEvents(' + VarToJSON([QueueSuspended]) + ');', 'TExtChart');
  Result := Self;
end;

destructor TExtChart.Destroy; begin
  try
    FAnimateObject.Free;
    FAxes.Free;
    FBackground.Free;
    FGlobalEvents.Free;
    FGradients.Free;
    FHasListeners.Free;
    FLegendObject.Free;
    FListeners.Free;
    FSeries.Free;
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtChart.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforerefresh') and Assigned(FOnBeforerefresh) then
    FOnBeforerefresh(TExtChart(ParamAsObject('This')))
  else if (AEvtName = 'refresh') and Assigned(FOnRefresh) then
    FOnRefresh(TExtChart(ParamAsObject('This')));
end;

function TExtContainer.JSClassName : string; begin
  Result := 'Ext.container.Container';
end;

{$IFDEF FPC}constructor TExtContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtContainer.GetChildByElement(El : THTMLElement; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetChildByElement(' + VarToJSON([El, false, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

function TExtContainer.GetChildByElement(El : TExtElement; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.GetChildByElement(' + VarToJSON([El, false, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

function TExtContainer.GetChildByElement(El : String; Deep : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getChildByElement(' + VarToJSON([El, Deep]) + ');', 'TExtContainer');
  Result := Self;
end;

procedure TExtDdDropTarget.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDropTarget.SetFOverClass(Value : String); begin
  FOverClass := Value;
  JSCode('overClass:' + VarToJSON([Value]));
end;

function TExtDdDropTarget.JSClassName : string; begin
  Result := 'Ext.dd.DropTarget';
end;

{$IFDEF FPC}constructor TExtDdDropTarget.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDropTarget.Create(El : THTMLElement; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDropTarget.Create(El : TExtElement; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDropTarget.Create(El : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, Config, false]) + ');');
  InitDefaults;
end;

procedure TExtChartAxisNumeric.SetFAdjustMaximumByMajorUnit(Value : Boolean); begin
  FAdjustMaximumByMajorUnit := Value;
  JSCode('adjustMaximumByMajorUnit:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFAdjustMinimumByMajorUnit(Value : Boolean); begin
  FAdjustMinimumByMajorUnit := Value;
  JSCode('adjustMinimumByMajorUnit:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFDecimals(Value : Integer); begin
  FDecimals := Value;
  JSCode('decimals:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFMaximum(Value : Integer); begin
  FMaximum := Value;
  JSCode('maximum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFMinimum(Value : Integer); begin
  FMinimum := Value;
  JSCode('minimum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisNumeric.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

function TExtChartAxisNumeric.JSClassName : string; begin
  Result := 'Ext.chart.axis.Numeric';
end;

{$IFDEF FPC}constructor TExtChartAxisNumeric.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartSeriesLine.SetFFill(Value : Boolean); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFMarkerConfig(Value : TExtObject); begin
  FMarkerConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('markerConfig:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesLine.SetFSelectionTolerance(Value : Integer); begin
  FSelectionTolerance := Value;
  JSCode('selectionTolerance:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFShowMarkers(Value : Boolean); begin
  FShowMarkers := Value;
  JSCode('showMarkers:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFSmooth(Value : Boolean); begin
  FSmooth := Value;
  JSCode('smooth:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFSmoothInteger(Value : Integer); begin
  FSmoothInteger := Value;
  JSCode('smooth:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesLine.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesLine.JSClassName : string; begin
  Result := 'Ext.chart.series.Line';
end;

procedure TExtChartSeriesLine.InitDefaults; begin
  inherited;
  FMarkerConfig := TExtObject.CreateInternal(Self, 'markerConfig');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesLine.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesLine.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesLine.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesLine');
  Result := Self;
end;

destructor TExtChartSeriesLine.Destroy; begin
  try
    FMarkerConfig.Free;
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtChartSeriesScatter.SetFMarkerConfig(Value : TExtObject); begin
  FMarkerConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('markerConfig:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesScatter.SetFStyle(Value : TExtObject); begin
  FStyle := Value;
  Value.DeleteFromGarbage;
  JSCode('style:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesScatter.JSClassName : string; begin
  Result := 'Ext.chart.series.Scatter';
end;

procedure TExtChartSeriesScatter.InitDefaults; begin
  inherited;
  FMarkerConfig := TExtObject.CreateInternal(Self, 'markerConfig');
  FStyle := TExtObject.CreateInternal(Self, 'style');
end;

{$IFDEF FPC}constructor TExtChartSeriesScatter.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesScatter.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtChartSeriesScatter.DrawSeries : TExtFunction; begin
  JSCode(JSName + '.drawSeries();', 'TExtChartSeriesScatter');
  Result := Self;
end;

destructor TExtChartSeriesScatter.Destroy; begin
  try
    FMarkerConfig.Free;
    FStyle.Free;
  except end;
  inherited;
end;

procedure TExtChartAxisCategory.SetFCalculateCategoryCount(Value : Boolean); begin
  FCalculateCategoryCount := Value;
  JSCode('calculateCategoryCount:' + VarToJSON([Value]));
end;

procedure TExtChartAxisCategory.SetFCategoryNames(Value : String); begin
  FCategoryNames := Value;
  JSCode('categoryNames:' + VarToJSON([Value]));
end;

function TExtChartAxisCategory.JSClassName : string; begin
  Result := 'Ext.chart.axis.Category';
end;

{$IFDEF FPC}constructor TExtChartAxisCategory.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSliderMulti.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFClickToChange(Value : Boolean); begin
  FClickToChange := Value;
  JSCode('clickToChange:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFConstrainThumbs(Value : Boolean); begin
  FConstrainThumbs := Value;
  JSCode('constrainThumbs:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFDecimalPrecision(Value : Integer); begin
  FDecimalPrecision := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFDecimalPrecisionBoolean(Value : Boolean); begin
  FDecimalPrecisionBoolean := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFDragging(Value : Boolean); begin
  FDragging := Value;
  JSCode(JSName + '.dragging=' + VarToJSON([Value]) + ';');
end;

procedure TExtSliderMulti.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFKeyIncrement(Value : Integer); begin
  FKeyIncrement := Value;
  JSCode('keyIncrement:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFMaxValue(Value : Integer); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFMinValue(Value : Integer); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFThumbs(Value : TExtObjectList); begin
  FThumbs := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.thumbs=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtSliderMulti.SetFTipText(Value : TExtFunction); begin
  FTipText := Value;
  JSCode('tipText:' + VarToJSON([Value, true]));
end;

procedure TExtSliderMulti.SetFTipTextReturn(Value : String); begin
  FTipTextReturn := Value;
  JSCode('tipTextReturn:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFTipTextThumb(Value : TExtSliderThumb); begin
  FTipTextThumb := Value;
  Value.DeleteFromGarbage;
  JSCode('tipTextThumb:' + VarToJSON([Value, false]));
end;

procedure TExtSliderMulti.SetFUseTips(Value : TExtObject); begin
  FUseTips := Value;
  Value.DeleteFromGarbage;
  JSCode('useTips:' + VarToJSON([Value, false]));
end;

procedure TExtSliderMulti.SetFUseTipsBoolean(Value : Boolean); begin
  FUseTipsBoolean := Value;
  JSCode('useTips:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFValue(Value : Integer); begin
  FValue := Value;
  JSCode('value:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFValues(Value : TArrayOfInteger); begin
  FValues := Value;
  JSCode('values:' + ArrayToJSON(Value));
end;

procedure TExtSliderMulti.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFZeroBasedSnapping(Value : Boolean); begin
  FZeroBasedSnapping := Value;
  JSCode('zeroBasedSnapping:' + VarToJSON([Value]));
end;

procedure TExtSliderMulti.SetFOnBeforechange(Value : TExtSliderMultiOnBeforechange); begin
  if Assigned(FOnBeforechange) then
    JSCode(JSName+'.events ["beforechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforechange', Ajax('beforechange', ['Slider', '%0.nm','NewValue', '%1','OldValue', '%2'], true));
  FOnBeforechange := Value;
end;

procedure TExtSliderMulti.SetFOnChange(Value : TExtSliderMultiOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['Slider', '%0.nm','NewValue', '%1','Thumb', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtSliderMulti.SetFOnChangecomplete(Value : TExtSliderMultiOnChangecomplete); begin
  if Assigned(FOnChangecomplete) then
    JSCode(JSName+'.events ["changecomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('changecomplete', Ajax('changecomplete', ['Slider', '%0.nm','NewValue', '%1','Thumb', '%2.nm'], true));
  FOnChangecomplete := Value;
end;

procedure TExtSliderMulti.SetFOnDrag(Value : TExtSliderMultiOnDrag); begin
  if Assigned(FOnDrag) then
    JSCode(JSName+'.events ["drag"].listeners=[];');
  if Assigned(Value) then
    AddListener('drag', Ajax('drag', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDrag := Value;
end;

procedure TExtSliderMulti.SetFOnDragend(Value : TExtSliderMultiOnDragend); begin
  if Assigned(FOnDragend) then
    JSCode(JSName+'.events ["dragend"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragend', Ajax('dragend', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDragend := Value;
end;

procedure TExtSliderMulti.SetFOnDragstart(Value : TExtSliderMultiOnDragstart); begin
  if Assigned(FOnDragstart) then
    JSCode(JSName+'.events ["dragstart"].listeners=[];');
  if Assigned(Value) then
    AddListener('dragstart', Ajax('dragstart', ['Slider', '%0.nm','E', '%1.nm'], true));
  FOnDragstart := Value;
end;

function TExtSliderMulti.JSClassName : string; begin
  Result := 'Ext.slider.Multi';
end;

procedure TExtSliderMulti.InitDefaults; begin
  inherited;
  FThumbs := TExtObjectList.Create(Self, 'thumbs');
  FTipTextThumb := TExtSliderThumb.CreateInternal(Self, 'tipTextThumb');
  FUseTips := TExtObject.CreateInternal(Self, 'useTips');
end;

{$IFDEF FPC}constructor TExtSliderMulti.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSliderMulti.AddThumb(Value : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.addThumb(' + VarToJSON([Value]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

constructor TExtSliderMulti.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtSliderMulti.GetValue(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getValue(' + VarToJSON([Index]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetMaxValue(Val : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Val]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetMinValue(Val : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Val]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetValue(Index : TArrayOfInteger; Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Index, Value, Animate]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SetValue(Index : Integer; Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Index, Value, Animate]) + ');', 'TExtSliderMulti');
  Result := Self;
end;

function TExtSliderMulti.SyncThumbs : TExtFunction; begin
  JSCode(JSName + '.syncThumbs();', 'TExtSliderMulti');
  Result := Self;
end;

destructor TExtSliderMulti.Destroy; begin
  try
    FThumbs.Free;
    FTipTextThumb.Free;
    FUseTips.Free;
  except end;
  inherited;
end;

procedure TExtSliderMulti.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforechange') and Assigned(FOnBeforechange) then
    FOnBeforechange(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), ParamAsInteger('OldValue'))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), TExtSliderThumb(ParamAsObject('Thumb')))
  else if (AEvtName = 'changecomplete') and Assigned(FOnChangecomplete) then
    FOnChangecomplete(TExtSliderMulti(ParamAsObject('Slider')), ParamAsInteger('NewValue'), TExtSliderThumb(ParamAsObject('Thumb')))
  else if (AEvtName = 'drag') and Assigned(FOnDrag) then
    FOnDrag(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dragend') and Assigned(FOnDragend) then
    FOnDragend(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dragstart') and Assigned(FOnDragstart) then
    FOnDragstart(TExtSliderMulti(ParamAsObject('Slider')), TExtEventObject(ParamAsObject('E')));
end;

function TExtLayoutComponentDock.JSClassName : string; begin
  Result := 'Ext.layout.component.Dock';
end;

{$IFDEF FPC}constructor TExtLayoutComponentDock.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentDock.InvalidateAxes : TExtFunction; begin
  JSCode(JSName + '.invalidateAxes();', 'TExtLayoutComponentDock');
  Result := Self;
end;

function TExtFxTargetElementCSS.JSClassName : string; begin
  Result := 'Ext.fx.target.ElementCSS';
end;

{$IFDEF FPC}constructor TExtFxTargetElementCSS.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxTargetCompositeSprite.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeSprite';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeSprite.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataNodeStore.SetFIsNodeStore(Value : Boolean); begin
  FIsNodeStore := Value;
  JSCode(JSName + '.isNodeStore=' + VarToJSON([Value]) + ';');
end;

procedure TExtDataNodeStore.SetFNode(Value : TExtDataModel); begin
  FNode := Value;
  Value.DeleteFromGarbage;
  JSCode('node:' + VarToJSON([Value, false]));
end;

procedure TExtDataNodeStore.SetFRecursive(Value : Boolean); begin
  FRecursive := Value;
  JSCode('recursive:' + VarToJSON([Value]));
end;

procedure TExtDataNodeStore.SetFRootVisible(Value : Boolean); begin
  FRootVisible := Value;
  JSCode('rootVisible:' + VarToJSON([Value]));
end;

procedure TExtDataNodeStore.SetFTreeStore(Value : TExtDataTreeStore); begin
  FTreeStore := Value;
  Value.DeleteFromGarbage;
  JSCode('treeStore:' + VarToJSON([Value, false]));
end;

function TExtDataNodeStore.JSClassName : string; begin
  Result := 'Ext.data.NodeStore';
end;

procedure TExtDataNodeStore.InitDefaults; begin
  inherited;
  FNode := TExtDataModel.CreateInternal(Self, 'node');
  FTreeStore := TExtDataTreeStore.CreateInternal(Self, 'treeStore');
end;

{$IFDEF FPC}constructor TExtDataNodeStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataNodeStore.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataNodeStore.Destroy; begin
  try
    FNode.Free;
    FTreeStore.Free;
  except end;
  inherited;
end;

function TExtLayoutComponentAuto.JSClassName : string; begin
  Result := 'Ext.layout.component.Auto';
end;

{$IFDEF FPC}constructor TExtLayoutComponentAuto.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldText.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFAllowOnlyWhitespace(Value : Boolean); begin
  FAllowOnlyWhitespace := Value;
  JSCode('allowOnlyWhitespace:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFDisableKeyFilter(Value : Boolean); begin
  FDisableKeyFilter := Value;
  JSCode('disableKeyFilter:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEmptyCls(Value : String); begin
  FEmptyCls := Value;
  JSCode('emptyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEnableKeyEvents(Value : Boolean); begin
  FEnableKeyEvents := Value;
  JSCode('enableKeyEvents:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFEnforceMaxLength(Value : Boolean); begin
  FEnforceMaxLength := Value;
  JSCode('enforceMaxLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrow(Value : Boolean); begin
  FGrow := Value;
  JSCode('grow:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowAppend(Value : String); begin
  FGrowAppend := Value;
  JSCode('growAppend:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMaskRe(Value : TRegExp); begin
  FMaskRe := Value;
  JSCode('maskRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFMaxLength(Value : Integer); begin
  FMaxLength := Value;
  JSCode('maxLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMaxLengthText(Value : String); begin
  FMaxLengthText := Value;
  JSCode('maxLengthText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFMinLength(Value : Integer); begin
  FMinLength := Value;
  JSCode('minLength:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFRegex(Value : TRegExp); begin
  FRegex := Value;
  JSCode('regex:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFRegexText(Value : String); begin
  FRegexText := Value;
  JSCode('regexText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFRequiredCls(Value : String); begin
  FRequiredCls := Value;
  JSCode('requiredCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFSize(Value : Integer); begin
  FSize := Value;
  JSCode('size:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFStripCharsRe(Value : TRegExp); begin
  FStripCharsRe := Value;
  JSCode('stripCharsRe:' + VarToJSON([#3 +Value]));
end;

procedure TExtFormFieldText.SetFValidateBlank(Value : Boolean); begin
  FValidateBlank := Value;
  JSCode('validateBlank:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFValidator(Value : TExtFunction); begin
  FValidator := Value;
  JSCode('validator:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldText.SetFValidatorReturn(Value : Boolean); begin
  FValidatorReturn := Value;
  JSCode('validatorReturn:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFValidatorReturnString(Value : String); begin
  FValidatorReturnString := Value;
  JSCode('validatorReturn:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFValidatorValue(Value : TExtObject); begin
  FValidatorValue := Value;
  Value.DeleteFromGarbage;
  JSCode('validatorValue:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldText.SetFVtype(Value : String); begin
  FVtype := Value;
  JSCode('vtype:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFVtypeText(Value : String); begin
  FVtypeText := Value;
  JSCode('vtypeText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldText.SetFOnAutosize(Value : TExtFormFieldTextOnAutosize); begin
  if Assigned(FOnAutosize) then
    JSCode(JSName+'.events ["autosize"].listeners=[];');
  if Assigned(Value) then
    AddListener('autosize', Ajax('autosize', ['This', '%0.nm','Width', '%1'], true));
  FOnAutosize := Value;
end;

procedure TExtFormFieldText.SetFOnKeydown(Value : TExtFormFieldTextOnKeydown); begin
  if Assigned(FOnKeydown) then
    JSCode(JSName+'.events ["keydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('keydown', Ajax('keydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeydown := Value;
end;

procedure TExtFormFieldText.SetFOnKeypress(Value : TExtFormFieldTextOnKeypress); begin
  if Assigned(FOnKeypress) then
    JSCode(JSName+'.events ["keypress"].listeners=[];');
  if Assigned(Value) then
    AddListener('keypress', Ajax('keypress', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeypress := Value;
end;

procedure TExtFormFieldText.SetFOnKeyup(Value : TExtFormFieldTextOnKeyup); begin
  if Assigned(FOnKeyup) then
    JSCode(JSName+'.events ["keyup"].listeners=[];');
  if Assigned(Value) then
    AddListener('keyup', Ajax('keyup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnKeyup := Value;
end;

function TExtFormFieldText.JSClassName : string; begin
  Result := 'Ext.form.field.Text';
end;

procedure TExtFormFieldText.InitDefaults; begin
  inherited;
  FGrowAppend := 'W';
  FSize := 20;
  FValidatorValue := TExtObject.CreateInternal(Self, 'validatorValue');
end;

{$IFDEF FPC}constructor TExtFormFieldText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldText.AutoSize : TExtFunction; begin
  JSCode(JSName + '.autoSize();', 'TExtFormFieldText');
  Result := Self;
end;

constructor TExtFormFieldText.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldText.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.ProcessRawValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.processRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.SelectText(Start : Integer = 0; EndJS : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.selectText(' + VarToJSON([Start, EndJS]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

function TExtFormFieldText.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldText');
  Result := Self;
end;

destructor TExtFormFieldText.Destroy; begin
  try
    FValidatorValue.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldText.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'autosize') and Assigned(FOnAutosize) then
    FOnAutosize(TExtFormFieldText(ParamAsObject('This')), ParamAsInteger('Width'))
  else if (AEvtName = 'keydown') and Assigned(FOnKeydown) then
    FOnKeydown(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'keypress') and Assigned(FOnKeypress) then
    FOnKeypress(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'keyup') and Assigned(FOnKeyup) then
    FOnKeyup(TExtFormFieldText(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtFormFieldDisplay.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDisplay.SetFHtmlEncode(Value : Boolean); begin
  FHtmlEncode := Value;
  JSCode('htmlEncode:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDisplay.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldDisplay.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

function TExtFormFieldDisplay.JSClassName : string; begin
  Result := 'Ext.form.field.Display';
end;

procedure TExtFormFieldDisplay.InitDefaults; begin
  inherited;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtFormFieldDisplay.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldDisplay.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtFormFieldDisplay.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

function TExtDataJsonPStore.JSClassName : string; begin
  Result := 'Ext.data.JsonPStore';
end;

{$IFDEF FPC}constructor TExtDataJsonPStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFxTargetCompositeElement.SetFIsComposite(Value : Boolean); begin
  FIsComposite := Value;
  JSCode(JSName + '.isComposite=' + VarToJSON([Value]) + ';');
end;

function TExtFxTargetCompositeElement.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeElement';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeElement.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldHidden.JSClassName : string; begin
  Result := 'Ext.form.field.Hidden';
end;

{$IFDEF FPC}constructor TExtFormFieldHidden.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataJsonStore.JSClassName : string; begin
  Result := 'Ext.data.JsonStore';
end;

{$IFDEF FPC}constructor TExtDataJsonStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldFileButton.JSClassName : string; begin
  Result := 'Ext.form.field.FileButton';
end;

{$IFDEF FPC}constructor TExtFormFieldFileButton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDataProxyMemory.SetFData(Value : TExtObject); begin
  FData := Value;
  Value.DeleteFromGarbage;
  JSCode('data:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyMemory.SetFEnablePaging(Value : Boolean); begin
  FEnablePaging := Value;
  JSCode('enablePaging:' + VarToJSON([Value]));
end;

function TExtDataProxyMemory.JSClassName : string; begin
  Result := 'Ext.data.proxy.Memory';
end;

procedure TExtDataProxyMemory.InitDefaults; begin
  inherited;
  FData := TExtObject.CreateInternal(Self, 'data');
end;

{$IFDEF FPC}constructor TExtDataProxyMemory.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyMemory.Create(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject); begin
  CreateVarAlt(JSClassName + '.create(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');');
  InitDefaults;
end;

function TExtDataProxyMemory.Read(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.read(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');', 'TExtDataProxyMemory');
  Result := Self;
end;

function TExtDataProxyMemory.Update(Operation : TExtDataOperation; Callback : TExtFunction; Scope : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.update(' + VarToJSON([Operation, false, Callback, true, Scope, false]) + ');', 'TExtDataProxyMemory');
  Result := Self;
end;

destructor TExtDataProxyMemory.Destroy; begin
  try
    FData.Free;
  except end;
  inherited;
end;

procedure TExtDataProxyJsonP.SetFAutoAppendParams(Value : Boolean); begin
  FAutoAppendParams := Value;
  JSCode('autoAppendParams:' + VarToJSON([Value]));
end;

procedure TExtDataProxyJsonP.SetFCallbackKey(Value : String); begin
  FCallbackKey := Value;
  JSCode('callbackKey:' + VarToJSON([Value]));
end;

procedure TExtDataProxyJsonP.SetFRecordParam(Value : String); begin
  FRecordParam := Value;
  JSCode('recordParam:' + VarToJSON([Value]));
end;

procedure TExtDataProxyJsonP.SetFOnException(Value : TExtDataProxyJsonPOnException); begin
  if Assigned(FOnException) then
    JSCode(JSName+'.events ["exception"].listeners=[];');
  if Assigned(Value) then
    AddListener('exception', Ajax('exception', ['This', '%0.nm','Request', '%1.nm','Operation', '%2.nm'], true));
  FOnException := Value;
end;

function TExtDataProxyJsonP.JSClassName : string; begin
  Result := 'Ext.data.proxy.JsonP';
end;

procedure TExtDataProxyJsonP.InitDefaults; begin
  inherited;
  FAutoAppendParams := true;
end;

{$IFDEF FPC}constructor TExtDataProxyJsonP.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyJsonP.Abort : TExtFunction; begin
  JSCode(JSName + '.abort();', 'TExtDataProxyJsonP');
  Result := Self;
end;

function TExtDataProxyJsonP.BuildUrl(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.buildUrl(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyJsonP');
  Result := Self;
end;

constructor TExtDataProxyJsonP.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxyJsonP.EncodeRecords(Records : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.encodeRecords(' + VarToJSON(Records) + ');', 'TExtDataProxyJsonP');
  Result := Self;
end;

procedure TExtDataProxyJsonP.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'exception') and Assigned(FOnException) then
    FOnException(TExtDataProxyJsonP(ParamAsObject('This')), TExtDataRequest(ParamAsObject('Request')), TExtDataOperation(ParamAsObject('Operation')));
end;

procedure TExtDataProxyDirect.SetFApi(Value : TExtObject); begin
  FApi := Value;
  Value.DeleteFromGarbage;
  JSCode('api:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyDirect.SetFDirectFn(Value : TExtFunction); begin
  FDirectFn := Value;
  JSCode('directFn:' + VarToJSON([Value, true]));
end;

procedure TExtDataProxyDirect.SetFDirectFnString(Value : String); begin
  FDirectFnString := Value;
  JSCode('directFn:' + VarToJSON([Value]));
end;

procedure TExtDataProxyDirect.SetFExtraParams(Value : TExtObject); begin
  FExtraParams := Value;
  Value.DeleteFromGarbage;
  JSCode('extraParams:' + VarToJSON([Value, false]));
end;

procedure TExtDataProxyDirect.SetFParamOrder(Value : String); begin
  FParamOrder := Value;
  JSCode('paramOrder:' + VarToJSON([Value]));
end;

procedure TExtDataProxyDirect.SetFParamOrderTArrayOfString(Value : TArrayOfString); begin
  FParamOrderTArrayOfString := Value;
  JSCode('paramOrder:' + ArrayToJSON(Value));
end;

procedure TExtDataProxyDirect.SetFParamsAsHash(Value : Boolean); begin
  FParamsAsHash := Value;
  JSCode('paramsAsHash:' + VarToJSON([Value]));
end;

function TExtDataProxyDirect.JSClassName : string; begin
  Result := 'Ext.data.proxy.Direct';
end;

procedure TExtDataProxyDirect.InitDefaults; begin
  inherited;
  FApi := TExtObject.CreateInternal(Self, 'api');
  FExtraParams := TExtObject.CreateInternal(Self, 'extraParams');
end;

{$IFDEF FPC}constructor TExtDataProxyDirect.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyDirect.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataProxyDirect.Destroy; begin
  try
    FApi.Free;
    FExtraParams.Free;
  except end;
  inherited;
end;

procedure TExtView.SetFMouseOverOutBuffer(Value : Integer); begin
  FMouseOverOutBuffer := Value;
  JSCode('mouseOverOutBuffer:' + VarToJSON([Value]));
end;

procedure TExtView.SetFOnBeforecontainerclick(Value : TExtViewOnBeforecontainerclick); begin
  if Assigned(FOnBeforecontainerclick) then
    JSCode(JSName+'.events ["beforecontainerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerclick', Ajax('beforecontainerclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerclick := Value;
end;

procedure TExtView.SetFOnBeforecontainercontextmenu(Value : TExtViewOnBeforecontainercontextmenu); begin
  if Assigned(FOnBeforecontainercontextmenu) then
    JSCode(JSName+'.events ["beforecontainercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainercontextmenu', Ajax('beforecontainercontextmenu', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainercontextmenu := Value;
end;

procedure TExtView.SetFOnBeforecontainerdblclick(Value : TExtViewOnBeforecontainerdblclick); begin
  if Assigned(FOnBeforecontainerdblclick) then
    JSCode(JSName+'.events ["beforecontainerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerdblclick', Ajax('beforecontainerdblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerdblclick := Value;
end;

procedure TExtView.SetFOnBeforecontainerkeydown(Value : TExtViewOnBeforecontainerkeydown); begin
  if Assigned(FOnBeforecontainerkeydown) then
    JSCode(JSName+'.events ["beforecontainerkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerkeydown', Ajax('beforecontainerkeydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainerkeydown := Value;
end;

procedure TExtView.SetFOnBeforecontainermousedown(Value : TExtViewOnBeforecontainermousedown); begin
  if Assigned(FOnBeforecontainermousedown) then
    JSCode(JSName+'.events ["beforecontainermousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermousedown', Ajax('beforecontainermousedown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermousedown := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseout(Value : TExtViewOnBeforecontainermouseout); begin
  if Assigned(FOnBeforecontainermouseout) then
    JSCode(JSName+'.events ["beforecontainermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseout', Ajax('beforecontainermouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseout := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseover(Value : TExtViewOnBeforecontainermouseover); begin
  if Assigned(FOnBeforecontainermouseover) then
    JSCode(JSName+'.events ["beforecontainermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseover', Ajax('beforecontainermouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseover := Value;
end;

procedure TExtView.SetFOnBeforecontainermouseup(Value : TExtViewOnBeforecontainermouseup); begin
  if Assigned(FOnBeforecontainermouseup) then
    JSCode(JSName+'.events ["beforecontainermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseup', Ajax('beforecontainermouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnBeforecontainermouseup := Value;
end;

procedure TExtView.SetFOnBeforedeselect(Value : TExtViewOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', [], true));
  FOnBeforedeselect := Value;
end;

procedure TExtView.SetFOnBeforeitemclick(Value : TExtViewOnBeforeitemclick); begin
  if Assigned(FOnBeforeitemclick) then
    JSCode(JSName+'.events ["beforeitemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemclick', Ajax('beforeitemclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemclick := Value;
end;

procedure TExtView.SetFOnBeforeitemcontextmenu(Value : TExtViewOnBeforeitemcontextmenu); begin
  if Assigned(FOnBeforeitemcontextmenu) then
    JSCode(JSName+'.events ["beforeitemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcontextmenu', Ajax('beforeitemcontextmenu', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemcontextmenu := Value;
end;

procedure TExtView.SetFOnBeforeitemdblclick(Value : TExtViewOnBeforeitemdblclick); begin
  if Assigned(FOnBeforeitemdblclick) then
    JSCode(JSName+'.events ["beforeitemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemdblclick', Ajax('beforeitemdblclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemdblclick := Value;
end;

procedure TExtView.SetFOnBeforeitemkeydown(Value : TExtViewOnBeforeitemkeydown); begin
  if Assigned(FOnBeforeitemkeydown) then
    JSCode(JSName+'.events ["beforeitemkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemkeydown', Ajax('beforeitemkeydown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemkeydown := Value;
end;

procedure TExtView.SetFOnBeforeitemmousedown(Value : TExtViewOnBeforeitemmousedown); begin
  if Assigned(FOnBeforeitemmousedown) then
    JSCode(JSName+'.events ["beforeitemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmousedown', Ajax('beforeitemmousedown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmousedown := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseenter(Value : TExtViewOnBeforeitemmouseenter); begin
  if Assigned(FOnBeforeitemmouseenter) then
    JSCode(JSName+'.events ["beforeitemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseenter', Ajax('beforeitemmouseenter', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseenter := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseleave(Value : TExtViewOnBeforeitemmouseleave); begin
  if Assigned(FOnBeforeitemmouseleave) then
    JSCode(JSName+'.events ["beforeitemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseleave', Ajax('beforeitemmouseleave', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseleave := Value;
end;

procedure TExtView.SetFOnBeforeitemmouseup(Value : TExtViewOnBeforeitemmouseup); begin
  if Assigned(FOnBeforeitemmouseup) then
    JSCode(JSName+'.events ["beforeitemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseup', Ajax('beforeitemmouseup', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnBeforeitemmouseup := Value;
end;

procedure TExtView.SetFOnBeforeselect(Value : TExtViewOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', [], true));
  FOnBeforeselect := Value;
end;

procedure TExtView.SetFOnContainerclick(Value : TExtViewOnContainerclick); begin
  if Assigned(FOnContainerclick) then
    JSCode(JSName+'.events ["containerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerclick', Ajax('containerclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerclick := Value;
end;

procedure TExtView.SetFOnContainercontextmenu(Value : TExtViewOnContainercontextmenu); begin
  if Assigned(FOnContainercontextmenu) then
    JSCode(JSName+'.events ["containercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('containercontextmenu', Ajax('containercontextmenu', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainercontextmenu := Value;
end;

procedure TExtView.SetFOnContainerdblclick(Value : TExtViewOnContainerdblclick); begin
  if Assigned(FOnContainerdblclick) then
    JSCode(JSName+'.events ["containerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerdblclick', Ajax('containerdblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerdblclick := Value;
end;

procedure TExtView.SetFOnContainerkeydown(Value : TExtViewOnContainerkeydown); begin
  if Assigned(FOnContainerkeydown) then
    JSCode(JSName+'.events ["containerkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerkeydown', Ajax('containerkeydown', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainerkeydown := Value;
end;

procedure TExtView.SetFOnContainermouseout(Value : TExtViewOnContainermouseout); begin
  if Assigned(FOnContainermouseout) then
    JSCode(JSName+'.events ["containermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseout', Ajax('containermouseout', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseout := Value;
end;

procedure TExtView.SetFOnContainermouseover(Value : TExtViewOnContainermouseover); begin
  if Assigned(FOnContainermouseover) then
    JSCode(JSName+'.events ["containermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseover', Ajax('containermouseover', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseover := Value;
end;

procedure TExtView.SetFOnContainermouseup(Value : TExtViewOnContainermouseup); begin
  if Assigned(FOnContainermouseup) then
    JSCode(JSName+'.events ["containermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseup', Ajax('containermouseup', ['This', '%0.nm','E', '%1.nm'], true));
  FOnContainermouseup := Value;
end;

procedure TExtView.SetFOnDeselect(Value : TExtViewOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', [], true));
  FOnDeselect := Value;
end;

procedure TExtView.SetFOnFocuschange(Value : TExtViewOnFocuschange); begin
  if Assigned(FOnFocuschange) then
    JSCode(JSName+'.events ["focuschange"].listeners=[];');
  if Assigned(Value) then
    AddListener('focuschange', Ajax('focuschange', [], true));
  FOnFocuschange := Value;
end;

procedure TExtView.SetFOnHighlightitem(Value : TExtViewOnHighlightitem); begin
  if Assigned(FOnHighlightitem) then
    JSCode(JSName+'.events ["highlightitem"].listeners=[];');
  if Assigned(Value) then
    AddListener('highlightitem', Ajax('highlightitem', ['View', '%0.nm','Node', '%1.nm'], true));
  FOnHighlightitem := Value;
end;

procedure TExtView.SetFOnItemclick(Value : TExtViewOnItemclick); begin
  if Assigned(FOnItemclick) then
    JSCode(JSName+'.events ["itemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemclick', Ajax('itemclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemclick := Value;
end;

procedure TExtView.SetFOnItemcontextmenu(Value : TExtViewOnItemcontextmenu); begin
  if Assigned(FOnItemcontextmenu) then
    JSCode(JSName+'.events ["itemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcontextmenu', Ajax('itemcontextmenu', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemcontextmenu := Value;
end;

procedure TExtView.SetFOnItemdblclick(Value : TExtViewOnItemdblclick); begin
  if Assigned(FOnItemdblclick) then
    JSCode(JSName+'.events ["itemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemdblclick', Ajax('itemdblclick', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemdblclick := Value;
end;

procedure TExtView.SetFOnItemkeydown(Value : TExtViewOnItemkeydown); begin
  if Assigned(FOnItemkeydown) then
    JSCode(JSName+'.events ["itemkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemkeydown', Ajax('itemkeydown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemkeydown := Value;
end;

procedure TExtView.SetFOnItemmousedown(Value : TExtViewOnItemmousedown); begin
  if Assigned(FOnItemmousedown) then
    JSCode(JSName+'.events ["itemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmousedown', Ajax('itemmousedown', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmousedown := Value;
end;

procedure TExtView.SetFOnItemmouseenter(Value : TExtViewOnItemmouseenter); begin
  if Assigned(FOnItemmouseenter) then
    JSCode(JSName+'.events ["itemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseenter', Ajax('itemmouseenter', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseenter := Value;
end;

procedure TExtView.SetFOnItemmouseleave(Value : TExtViewOnItemmouseleave); begin
  if Assigned(FOnItemmouseleave) then
    JSCode(JSName+'.events ["itemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseleave', Ajax('itemmouseleave', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseleave := Value;
end;

procedure TExtView.SetFOnItemmouseup(Value : TExtViewOnItemmouseup); begin
  if Assigned(FOnItemmouseup) then
    JSCode(JSName+'.events ["itemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseup', Ajax('itemmouseup', ['This', '%0.nm','RecordJS', '%1.nm','Item', '%2.nm','Index', '%3','E', '%4.nm'], true));
  FOnItemmouseup := Value;
end;

procedure TExtView.SetFOnSelect(Value : TExtViewOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

procedure TExtView.SetFOnSelectionchange(Value : TExtViewOnSelectionchange); begin
  if Assigned(FOnSelectionchange) then
    JSCode(JSName+'.events ["selectionchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('selectionchange', Ajax('selectionchange', [], true));
  FOnSelectionchange := Value;
end;

procedure TExtView.SetFOnUnhighlightitem(Value : TExtViewOnUnhighlightitem); begin
  if Assigned(FOnUnhighlightitem) then
    JSCode(JSName+'.events ["unhighlightitem"].listeners=[];');
  if Assigned(Value) then
    AddListener('unhighlightitem', Ajax('unhighlightitem', ['View', '%0.nm','Node', '%1.nm'], true));
  FOnUnhighlightitem := Value;
end;

function TExtView.JSClassName : string; begin
  Result := 'Ext.view.View';
end;

{$IFDEF FPC}constructor TExtView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtView.ClearHighlight : TExtFunction; begin
  JSCode(JSName + '.clearHighlight();', 'TExtView');
  Result := Self;
end;

function TExtView.FocusNode(Rec : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.focusNode(' + VarToJSON([Rec, false]) + ');', 'TExtView');
  Result := Self;
end;

function TExtView.HighlightItem(Item : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.highlightItem(' + VarToJSON([Item, false]) + ');', 'TExtView');
  Result := Self;
end;

procedure TExtView.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecontainerclick') and Assigned(FOnBeforecontainerclick) then
    FOnBeforecontainerclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainercontextmenu') and Assigned(FOnBeforecontainercontextmenu) then
    FOnBeforecontainercontextmenu(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainerdblclick') and Assigned(FOnBeforecontainerdblclick) then
    FOnBeforecontainerdblclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainerkeydown') and Assigned(FOnBeforecontainerkeydown) then
    FOnBeforecontainerkeydown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermousedown') and Assigned(FOnBeforecontainermousedown) then
    FOnBeforecontainermousedown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseout') and Assigned(FOnBeforecontainermouseout) then
    FOnBeforecontainermouseout(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseover') and Assigned(FOnBeforecontainermouseover) then
    FOnBeforecontainermouseover(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecontainermouseup') and Assigned(FOnBeforecontainermouseup) then
    FOnBeforecontainermouseup(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect()
  else if (AEvtName = 'beforeitemclick') and Assigned(FOnBeforeitemclick) then
    FOnBeforeitemclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemcontextmenu') and Assigned(FOnBeforeitemcontextmenu) then
    FOnBeforeitemcontextmenu(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemdblclick') and Assigned(FOnBeforeitemdblclick) then
    FOnBeforeitemdblclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemkeydown') and Assigned(FOnBeforeitemkeydown) then
    FOnBeforeitemkeydown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmousedown') and Assigned(FOnBeforeitemmousedown) then
    FOnBeforeitemmousedown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseenter') and Assigned(FOnBeforeitemmouseenter) then
    FOnBeforeitemmouseenter(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseleave') and Assigned(FOnBeforeitemmouseleave) then
    FOnBeforeitemmouseleave(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeitemmouseup') and Assigned(FOnBeforeitemmouseup) then
    FOnBeforeitemmouseup(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect()
  else if (AEvtName = 'containerclick') and Assigned(FOnContainerclick) then
    FOnContainerclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containercontextmenu') and Assigned(FOnContainercontextmenu) then
    FOnContainercontextmenu(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containerdblclick') and Assigned(FOnContainerdblclick) then
    FOnContainerdblclick(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containerkeydown') and Assigned(FOnContainerkeydown) then
    FOnContainerkeydown(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseout') and Assigned(FOnContainermouseout) then
    FOnContainermouseout(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseover') and Assigned(FOnContainermouseover) then
    FOnContainermouseover(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'containermouseup') and Assigned(FOnContainermouseup) then
    FOnContainermouseup(TExtView(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect()
  else if (AEvtName = 'focuschange') and Assigned(FOnFocuschange) then
    FOnFocuschange()
  else if (AEvtName = 'highlightitem') and Assigned(FOnHighlightitem) then
    FOnHighlightitem(TExtView(ParamAsObject('View')), TExtElement(ParamAsObject('Node')))
  else if (AEvtName = 'itemclick') and Assigned(FOnItemclick) then
    FOnItemclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemcontextmenu') and Assigned(FOnItemcontextmenu) then
    FOnItemcontextmenu(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemdblclick') and Assigned(FOnItemdblclick) then
    FOnItemdblclick(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemkeydown') and Assigned(FOnItemkeydown) then
    FOnItemkeydown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmousedown') and Assigned(FOnItemmousedown) then
    FOnItemmousedown(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseenter') and Assigned(FOnItemmouseenter) then
    FOnItemmouseenter(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseleave') and Assigned(FOnItemmouseleave) then
    FOnItemmouseleave(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'itemmouseup') and Assigned(FOnItemmouseup) then
    FOnItemmouseup(TExtView(ParamAsObject('This')), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Item')), ParamAsInteger('Index'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect()
  else if (AEvtName = 'selectionchange') and Assigned(FOnSelectionchange) then
    FOnSelectionchange()
  else if (AEvtName = 'unhighlightitem') and Assigned(FOnUnhighlightitem) then
    FOnUnhighlightitem(TExtView(ParamAsObject('View')), TExtElement(ParamAsObject('Node')));
end;

function TExtGridFeatureRowWrap.JSClassName : string; begin
  Result := 'Ext.grid.feature.RowWrap';
end;

{$IFDEF FPC}constructor TExtGridFeatureRowWrap.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureRowBody.JSClassName : string; begin
  Result := 'Ext.grid.feature.RowBody';
end;

{$IFDEF FPC}constructor TExtGridFeatureRowBody.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureRowBody.SetupRowData(Data : TExtObject; Idx : Integer; RecordJS : TExtDataModel; Orig : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setupRowData(' + VarToJSON([Data, false, Idx, RecordJS, false, Orig, false]) + ');', 'TExtGridFeatureRowBody');
  Result := Self;
end;

procedure TExtGridFeatureGrouping.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFDepthToIndent(Value : Integer); begin
  FDepthToIndent := Value;
  JSCode('depthToIndent:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFEnableGroupingMenu(Value : Boolean); begin
  FEnableGroupingMenu := Value;
  JSCode('enableGroupingMenu:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFEnableNoGroups(Value : Boolean); begin
  FEnableNoGroups := Value;
  JSCode('enableNoGroups:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFGroupByText(Value : String); begin
  FGroupByText := Value;
  JSCode('groupByText:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTpl(Value : String); begin
  FGroupHeaderTpl := Value;
  JSCode('groupHeaderTpl:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplChildren(Value : TExtObjectList); begin
  FGroupHeaderTplChildren := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTplChildren:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplList(Value : TExtObjectList); begin
  FGroupHeaderTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplRows(Value : TExtObjectList); begin
  FGroupHeaderTplRows := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTplRows:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFGroupHeaderTplTemplate(Value : TExtTemplate); begin
  FGroupHeaderTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('groupHeaderTpl:' + VarToJSON([Value, false]));
end;

procedure TExtGridFeatureGrouping.SetFHideGroupedHeader(Value : Boolean); begin
  FHideGroupedHeader := Value;
  JSCode('hideGroupedHeader:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFRemoteRoot(Value : String); begin
  FRemoteRoot := Value;
  JSCode('remoteRoot:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFShowGroupsText(Value : String); begin
  FShowGroupsText := Value;
  JSCode('showGroupsText:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFStartCollapsed(Value : Boolean); begin
  FStartCollapsed := Value;
  JSCode('startCollapsed:' + VarToJSON([Value]));
end;

procedure TExtGridFeatureGrouping.SetFOnGroupclick(Value : TExtGridFeatureGroupingOnGroupclick); begin
  if Assigned(FOnGroupclick) then
    JSCode(JSName+'.events ["groupclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupclick', Ajax('groupclick', ['View', '%0.nm','Node', '%1.nm','Group', '%2','E', '%3.nm'], true));
  FOnGroupclick := Value;
end;

procedure TExtGridFeatureGrouping.SetFOnGroupcollapse(Value : TExtGridFeatureGroupingOnGroupcollapse); begin
  if Assigned(FOnGroupcollapse) then
    JSCode(JSName+'.events ["groupcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupcollapse', Ajax('groupcollapse', ['View', '%0.nm','Node', '%1.nm','Group', '%2'], true));
  FOnGroupcollapse := Value;
end;

procedure TExtGridFeatureGrouping.SetFOnGroupcontextmenu(Value : TExtGridFeatureGroupingOnGroupcontextmenu); begin
  if Assigned(FOnGroupcontextmenu) then
    JSCode(JSName+'.events ["groupcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupcontextmenu', Ajax('groupcontextmenu', ['View', '%0.nm','Node', '%1.nm','Group', '%2','E', '%3.nm'], true));
  FOnGroupcontextmenu := Value;
end;

procedure TExtGridFeatureGrouping.SetFOnGroupdblclick(Value : TExtGridFeatureGroupingOnGroupdblclick); begin
  if Assigned(FOnGroupdblclick) then
    JSCode(JSName+'.events ["groupdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupdblclick', Ajax('groupdblclick', ['View', '%0.nm','Node', '%1.nm','Group', '%2','E', '%3.nm'], true));
  FOnGroupdblclick := Value;
end;

procedure TExtGridFeatureGrouping.SetFOnGroupexpand(Value : TExtGridFeatureGroupingOnGroupexpand); begin
  if Assigned(FOnGroupexpand) then
    JSCode(JSName+'.events ["groupexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('groupexpand', Ajax('groupexpand', ['View', '%0.nm','Node', '%1.nm','Group', '%2'], true));
  FOnGroupexpand := Value;
end;

function TExtGridFeatureGrouping.JSClassName : string; begin
  Result := 'Ext.grid.feature.Grouping';
end;

procedure TExtGridFeatureGrouping.InitDefaults; begin
  inherited;
  FGroupHeaderTplChildren := TExtObjectList.Create(Self, 'groupHeaderTplChildren');
  FGroupHeaderTplList := TExtObjectList.Create(Self, 'groupHeaderTpl');
  FGroupHeaderTplRows := TExtObjectList.Create(Self, 'groupHeaderTplRows');
  FGroupHeaderTplTemplate := TExtTemplate.CreateInternal(Self, 'groupHeaderTpl');
end;

{$IFDEF FPC}constructor TExtGridFeatureGrouping.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureGrouping.Collapse(GroupName : String; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([GroupName, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.CollapseAll : TExtFunction; begin
  JSCode(JSName + '.collapseAll();', 'TExtGridFeatureGrouping');
  Result := Self;
end;

constructor TExtGridFeatureGrouping.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridFeatureGrouping.Expand(GroupName : String; Focus : Boolean) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([GroupName, Focus]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.ExpandAll : TExtFunction; begin
  JSCode(JSName + '.expandAll();', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.GetRecordGroup(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.getRecordGroup(' + VarToJSON([RecordJS, false]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.IsExpanded(GroupName : String) : TExtFunction; begin
  JSCode(JSName + '.isExpanded(' + VarToJSON([GroupName]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

function TExtGridFeatureGrouping.ToggleSummaryRow(Visible : Boolean) : TExtFunction; begin
  JSCode(JSName + '.toggleSummaryRow(' + VarToJSON([Visible]) + ');', 'TExtGridFeatureGrouping');
  Result := Self;
end;

destructor TExtGridFeatureGrouping.Destroy; begin
  try
    FGroupHeaderTplChildren.Free;
    FGroupHeaderTplList.Free;
    FGroupHeaderTplRows.Free;
    FGroupHeaderTplTemplate.Free;
  except end;
  inherited;
end;

procedure TExtGridFeatureGrouping.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'groupclick') and Assigned(FOnGroupclick) then
    FOnGroupclick(TExtViewTable(ParamAsObject('View')), THTMLElement(ParamAsObject('Node')), ParamAsString('Group'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'groupcollapse') and Assigned(FOnGroupcollapse) then
    FOnGroupcollapse(TExtViewTable(ParamAsObject('View')), THTMLElement(ParamAsObject('Node')), ParamAsString('Group'))
  else if (AEvtName = 'groupcontextmenu') and Assigned(FOnGroupcontextmenu) then
    FOnGroupcontextmenu(TExtViewTable(ParamAsObject('View')), THTMLElement(ParamAsObject('Node')), ParamAsString('Group'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'groupdblclick') and Assigned(FOnGroupdblclick) then
    FOnGroupdblclick(TExtViewTable(ParamAsObject('View')), THTMLElement(ParamAsObject('Node')), ParamAsString('Group'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'groupexpand') and Assigned(FOnGroupexpand) then
    FOnGroupexpand(TExtViewTable(ParamAsObject('View')), THTMLElement(ParamAsObject('Node')), ParamAsString('Group'));
end;

procedure TExtGridFeatureAbstractSummary.SetFRemoteRoot(Value : String); begin
  FRemoteRoot := Value;
  JSCode('remoteRoot:' + VarToJSON([Value]));
end;

function TExtGridFeatureAbstractSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.AbstractSummary';
end;

{$IFDEF FPC}constructor TExtGridFeatureAbstractSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridFeatureAbstractSummary.ToggleSummaryRow(Visible : Boolean) : TExtFunction; begin
  JSCode(JSName + '.toggleSummaryRow(' + VarToJSON([Visible]) + ');', 'TExtGridFeatureAbstractSummary');
  Result := Self;
end;

procedure TExtDataProxyAjax.SetFActionMethods(Value : TExtObject); begin
  FActionMethods := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.actionMethods=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataProxyAjax.SetFBinary(Value : Boolean); begin
  FBinary := Value;
  JSCode('binary:' + VarToJSON([Value]));
end;

procedure TExtDataProxyAjax.SetFHeaders(Value : TExtObject); begin
  FHeaders := Value;
  Value.DeleteFromGarbage;
  JSCode('headers:' + VarToJSON([Value, false]));
end;

function TExtDataProxyAjax.JSClassName : string; begin
  Result := 'Ext.data.proxy.Ajax';
end;

procedure TExtDataProxyAjax.InitDefaults; begin
  inherited;
  FActionMethods := TExtObject.CreateInternal(Self, 'actionMethods');
  FHeaders := TExtObject.CreateInternal(Self, 'headers');
end;

{$IFDEF FPC}constructor TExtDataProxyAjax.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDataProxyAjax.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtDataProxyAjax.GetMethod(Request : TExtDataRequest) : TExtFunction; begin
  JSCode(JSName + '.getMethod(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyAjax');
  Result := Self;
end;

destructor TExtDataProxyAjax.Destroy; begin
  try
    FActionMethods.Free;
    FHeaders.Free;
  except end;
  inherited;
end;

procedure TExtGridPluginCellEditing.SetFOnBeforeedit(Value : TExtGridPluginCellEditingOnBeforeedit); begin
  if Assigned(FOnBeforeedit) then
    JSCode(JSName+'.events ["beforeedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeedit', Ajax('beforeedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnBeforeedit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnCanceledit(Value : TExtGridPluginCellEditingOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnCanceledit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnEdit(Value : TExtGridPluginCellEditingOnEdit); begin
  if Assigned(FOnEdit) then
    JSCode(JSName+'.events ["edit"].listeners=[];');
  if Assigned(Value) then
    AddListener('edit', Ajax('edit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnEdit := Value;
end;

procedure TExtGridPluginCellEditing.SetFOnValidateedit(Value : TExtGridPluginCellEditingOnValidateedit); begin
  if Assigned(FOnValidateedit) then
    JSCode(JSName+'.events ["validateedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('validateedit', Ajax('validateedit', ['Editor', '%0.nm','E', '%1.nm'], true));
  FOnValidateedit := Value;
end;

function TExtGridPluginCellEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.CellEditing';
end;

{$IFDEF FPC}constructor TExtGridPluginCellEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginCellEditing.CancelEdit : TExtFunction; begin
  JSCode(JSName + '.cancelEdit();', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEdit(RecordJS : Integer; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, ColumnHeader, false]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([RecordJS, false, ColumnHeader]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEdit(RecordJS : Integer; ColumnHeader : Integer) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, ColumnHeader]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

function TExtGridPluginCellEditing.StartEditByPosition(Position : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.startEditByPosition(' + VarToJSON([Position, false]) + ');', 'TExtGridPluginCellEditing');
  Result := Self;
end;

procedure TExtGridPluginCellEditing.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeedit') and Assigned(FOnBeforeedit) then
    FOnBeforeedit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'edit') and Assigned(FOnEdit) then
    FOnEdit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')))
  else if (AEvtName = 'validateedit') and Assigned(FOnValidateedit) then
    FOnValidateedit(TExtGridPluginCellEditing(ParamAsObject('Editor')), TExtObject(ParamAsObject('E')));
end;

procedure TExtGridPluginRowEditing.SetFAutoCancel(Value : Boolean); begin
  FAutoCancel := Value;
  JSCode('autoCancel:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowEditing.SetFClicksToMoveEditor(Value : Integer); begin
  FClicksToMoveEditor := Value;
  JSCode('clicksToMoveEditor:' + VarToJSON([Value]));
end;

procedure TExtGridPluginRowEditing.SetFErrorSummary(Value : Boolean); begin
  FErrorSummary := Value;
  JSCode('errorSummary:' + VarToJSON([Value]));
end;

function TExtGridPluginRowEditing.JSClassName : string; begin
  Result := 'Ext.grid.plugin.RowEditing';
end;

{$IFDEF FPC}constructor TExtGridPluginRowEditing.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPluginRowEditing.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridPluginRowEditing');
  Result := Self;
end;

function TExtGridPropertyStore.JSClassName : string; begin
  Result := 'Ext.grid.property.Store';
end;

{$IFDEF FPC}constructor TExtGridPropertyStore.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyStore.Create(Grid : TExtGridPanel; Source : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Grid, false, Source, false]) + ');');
  InitDefaults;
end;

procedure TExtDataProxyWebStorage.SetFCache(Value : TExtObject); begin
  FCache := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.cache=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataProxyWebStorage.SetFId(Value : String); begin
  FId := Value;
  JSCode('id:' + VarToJSON([Value]));
end;

function TExtDataProxyWebStorage.JSClassName : string; begin
  Result := 'Ext.data.proxy.WebStorage';
end;

procedure TExtDataProxyWebStorage.InitDefaults; begin
  inherited;
  FCache := TExtObject.CreateInternal(Self, 'cache');
end;

{$IFDEF FPC}constructor TExtDataProxyWebStorage.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyWebStorage.Clear : TExtFunction; begin
  JSCode(JSName + '.clear();', 'TExtDataProxyWebStorage');
  Result := Self;
end;

constructor TExtDataProxyWebStorage.Create(Config : TExtObject = nil); begin
  if Config = nil then CreateVar(JSClassName + '({});') else
  CreateVar(JSClassName + '(' + VarToJSON([Config, false]) + ');');
  InitDefaults;
end;

function TExtDataProxyWebStorage.SetRecord(RecordJS : TExtDataModel; Id : String = '') : TExtFunction; begin
  JSCode(JSName + '.setRecord(' + VarToJSON([RecordJS, false, Id]) + ');', 'TExtDataProxyWebStorage');
  Result := Self;
end;

destructor TExtDataProxyWebStorage.Destroy; begin
  try
    FCache.Free;
  except end;
  inherited;
end;

procedure TExtLayoutContainerTable.SetFColumns(Value : Integer); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerTable.SetFTableAttrs(Value : TExtObject); begin
  FTableAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('tableAttrs:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerTable.SetFTdAttrs(Value : TExtObject); begin
  FTdAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('tdAttrs:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerTable.SetFTrAttrs(Value : TExtObject); begin
  FTrAttrs := Value;
  Value.DeleteFromGarbage;
  JSCode('trAttrs:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerTable.JSClassName : string; begin
  Result := 'Ext.layout.container.Table';
end;

procedure TExtLayoutContainerTable.InitDefaults; begin
  inherited;
  FTableAttrs := TExtObject.CreateInternal(Self, 'tableAttrs');
  FTdAttrs := TExtObject.CreateInternal(Self, 'tdAttrs');
  FTrAttrs := TExtObject.CreateInternal(Self, 'trAttrs');
end;

{$IFDEF FPC}constructor TExtLayoutContainerTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerTable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerTable.Destroy; begin
  try
    FTableAttrs.Free;
    FTdAttrs.Free;
    FTrAttrs.Free;
  except end;
  inherited;
end;

function TExtFormCheckboxManagerSingleton.JSClassName : string; begin
  Result := 'Ext.form.CheckboxManager';
end;

{$IFDEF FPC}constructor TExtFormCheckboxManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormActionStandardSubmit.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

function TExtFormActionStandardSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.StandardSubmit';
end;

{$IFDEF FPC}constructor TExtFormActionStandardSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDrawText.SetFDegrees(Value : Integer); begin
  FDegrees := Value;
  JSCode('degrees:' + VarToJSON([Value]));
end;

procedure TExtDrawText.SetFStyleSelector(Value : String); begin
  FStyleSelector := Value;
  JSCode('styleSelector:' + VarToJSON([Value]));
end;

procedure TExtDrawText.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

function TExtDrawText.JSClassName : string; begin
  Result := 'Ext.draw.Text';
end;

{$IFDEF FPC}constructor TExtDrawText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDrawText.SetAngle(Degrees : Integer) : TExtFunction; begin
  JSCode(JSName + '.setAngle(' + VarToJSON([Degrees]) + ');', 'TExtDrawText');
  Result := Self;
end;

function TExtDrawText.SetText(T : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([T]) + ');', 'TExtDrawText');
  Result := Self;
end;

procedure TExtLayoutContainerFit.SetFDefaultMargins(Value : TExtObject); begin
  FDefaultMargins := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultMargins:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerFit.JSClassName : string; begin
  Result := 'Ext.layout.container.Fit';
end;

procedure TExtLayoutContainerFit.InitDefaults; begin
  inherited;
  FDefaultMargins := TExtObject.CreateInternal(Self, 'defaultMargins');
end;

{$IFDEF FPC}constructor TExtLayoutContainerFit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerFit.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerFit.Destroy; begin
  try
    FDefaultMargins.Free;
  except end;
  inherited;
end;

function TExtLayoutContainerEditor.JSClassName : string; begin
  Result := 'Ext.layout.container.Editor';
end;

{$IFDEF FPC}constructor TExtLayoutContainerEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormRadioManagerSingleton.JSClassName : string; begin
  Result := 'Ext.form.RadioManager';
end;

{$IFDEF FPC}constructor TExtFormRadioManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerCheckboxGroup.SetFAutoFlex(Value : Boolean); begin
  FAutoFlex := Value;
  JSCode('autoFlex:' + VarToJSON([Value]));
end;

function TExtLayoutContainerCheckboxGroup.JSClassName : string; begin
  Result := 'Ext.layout.container.CheckboxGroup';
end;

{$IFDEF FPC}constructor TExtLayoutContainerCheckboxGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataReaderArray.JSClassName : string; begin
  Result := 'Ext.data.reader.Array';
end;

{$IFDEF FPC}constructor TExtDataReaderArray.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtMenuCheckItem.SetFCheckChangeDisabled(Value : Boolean); begin
  FCheckChangeDisabled := Value;
  JSCode('checkChangeDisabled:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  if not ConfigAvailable(JSName) then
    SetChecked(Value)
  else
    JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFCheckedCls(Value : String); begin
  FCheckedCls := Value;
  JSCode('checkedCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFCheckHandler(Value : TExtFunction); begin
  FCheckHandler := Value;
  JSCode('checkHandler:' + VarToJSON([Value, true]));
end;

procedure TExtMenuCheckItem.SetFGroup(Value : String); begin
  FGroup := Value;
  JSCode('group:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFGroupCls(Value : String); begin
  FGroupCls := Value;
  JSCode('groupCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtMenuCheckItem.SetFUncheckedCls(Value : String); begin
  FUncheckedCls := Value;
  JSCode('uncheckedCls:' + VarToJSON([Value]));
end;

procedure TExtMenuCheckItem.SetFOnBeforecheckchange(Value : TExtMenuCheckItemOnBeforecheckchange); begin
  if Assigned(FOnBeforecheckchange) then
    JSCode(JSName+'.events ["beforecheckchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecheckchange', Ajax('beforecheckchange', ['This', '%0.nm','Checked', '%1'], true));
  FOnBeforecheckchange := Value;
end;

procedure TExtMenuCheckItem.SetFOnCheckchange(Value : TExtMenuCheckItemOnCheckchange); begin
  if Assigned(FOnCheckchange) then
    JSCode(JSName+'.events ["checkchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('checkchange', Ajax('checkchange', ['This', '%0.nm','Checked', '%1'], true));
  FOnCheckchange := Value;
end;

function TExtMenuCheckItem.JSClassName : string; begin
  Result := 'Ext.menu.CheckItem';
end;

procedure TExtMenuCheckItem.InitDefaults; begin
  inherited;
  FHideOnClick := true;
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtMenuCheckItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuCheckItem.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenuCheckItem.DisableCheckChange : TExtFunction; begin
  JSCode(JSName + '.disableCheckChange();', 'TExtMenuCheckItem');
  Result := Self;
end;

function TExtMenuCheckItem.EnableCheckChange : TExtFunction; begin
  JSCode(JSName + '.enableCheckChange();', 'TExtMenuCheckItem');
  Result := Self;
end;

function TExtMenuCheckItem.SetChecked(Checked : Boolean; SuppressEvents : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setChecked(' + VarToJSON([Checked, SuppressEvents]) + ');', 'TExtMenuCheckItem');
  Result := Self;
end;

destructor TExtMenuCheckItem.Destroy; begin
  try
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtMenuCheckItem.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecheckchange') and Assigned(FOnBeforecheckchange) then
    FOnBeforecheckchange(TExtMenuCheckItem(ParamAsObject('This')), ParamAsBoolean('Checked'))
  else if (AEvtName = 'checkchange') and Assigned(FOnCheckchange) then
    FOnCheckchange(TExtMenuCheckItem(ParamAsObject('This')), ParamAsBoolean('Checked'));
end;

function TExtFormActionDirectLoad.JSClassName : string; begin
  Result := 'Ext.form.action.DirectLoad';
end;

{$IFDEF FPC}constructor TExtFormActionDirectLoad.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTpl(Value : String); begin
  FAfterBoxLabelTextTpl := Value;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTplList(Value : TExtObjectList); begin
  FAfterBoxLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTextTplTemplate(Value : TExtXTemplate); begin
  FAfterBoxLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTpl(Value : String); begin
  FAfterBoxLabelTpl := Value;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTplList(Value : TExtObjectList); begin
  FAfterBoxLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFAfterBoxLabelTplTemplate(Value : TExtXTemplate); begin
  FAfterBoxLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTpl(Value : String); begin
  FBeforeBoxLabelTextTpl := Value;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTplList(Value : TExtObjectList); begin
  FBeforeBoxLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTextTplTemplate(Value : TExtXTemplate); begin
  FBeforeBoxLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTpl(Value : String); begin
  FBeforeBoxLabelTpl := Value;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTplList(Value : TExtObjectList); begin
  FBeforeBoxLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBeforeBoxLabelTplTemplate(Value : TExtXTemplate); begin
  FBeforeBoxLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBoxLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabel(Value : String); begin
  FBoxLabel := Value;
  if not ConfigAvailable(JSName) then
    SetBoxLabel(Value)
  else
    JSCode('boxLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAlign(Value : String); begin
  FBoxLabelAlign := Value;
  JSCode('boxLabelAlign:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTpl(Value : String); begin
  FBoxLabelAttrTpl := Value;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTplList(Value : TExtObjectList); begin
  FBoxLabelAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelAttrTplTemplate(Value : TExtXTemplate); begin
  FBoxLabelAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('boxLabelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelCls(Value : String); begin
  FBoxLabelCls := Value;
  JSCode('boxLabelCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFBoxLabelEl(Value : TExtElement); begin
  FBoxLabelEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.boxLabelEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldCheckbox.SetFChecked(Value : Boolean); begin
  FChecked := Value;
  JSCode('checked:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFCheckedCls(Value : String); begin
  FCheckedCls := Value;
  JSCode('checkedCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFFieldCls(Value : String); begin
  FFieldCls := Value;
  JSCode('fieldCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtFormFieldCheckbox.SetFHandlerCheckbox(Value : TExtFormFieldCheckbox); begin
  FHandlerCheckbox := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerCheckbox:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFHandlerChecked(Value : Boolean); begin
  FHandlerChecked := Value;
  JSCode('handlerChecked:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFInputValue(Value : String); begin
  FInputValue := Value;
  JSCode('inputValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldCheckbox.SetFIsCheckbox(Value : Boolean); begin
  FIsCheckbox := Value;
  JSCode(JSName + '.isCheckbox=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldCheckbox.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldCheckbox.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldCheckbox.SetFUncheckedValue(Value : String); begin
  FUncheckedValue := Value;
  JSCode('uncheckedValue:' + VarToJSON([Value]));
end;

function TExtFormFieldCheckbox.JSClassName : string; begin
  Result := 'Ext.form.field.Checkbox';
end;

procedure TExtFormFieldCheckbox.InitDefaults; begin
  inherited;
  FAfterBoxLabelTextTplList := TExtObjectList.Create(Self, 'afterBoxLabelTextTpl');
  FAfterBoxLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterBoxLabelTextTpl');
  FAfterBoxLabelTplList := TExtObjectList.Create(Self, 'afterBoxLabelTpl');
  FAfterBoxLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterBoxLabelTpl');
  FBeforeBoxLabelTextTplList := TExtObjectList.Create(Self, 'beforeBoxLabelTextTpl');
  FBeforeBoxLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBoxLabelTextTpl');
  FBeforeBoxLabelTplList := TExtObjectList.Create(Self, 'beforeBoxLabelTpl');
  FBeforeBoxLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBoxLabelTpl');
  FBoxLabelAttrTplList := TExtObjectList.Create(Self, 'boxLabelAttrTpl');
  FBoxLabelAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'boxLabelAttrTpl');
  FBoxLabelEl := TExtElement.CreateInternal(Self, 'boxLabelEl');
  FHandlerCheckbox := TExtFormFieldCheckbox.CreateInternal(Self, 'handlerCheckbox');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtFormFieldCheckbox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldCheckbox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldCheckbox.GetRawValue : TExtFunction; begin
  JSCode(JSName + '.getRawValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetBoxLabel(BoxLabel : String) : TExtFunction; begin
  JSCode(JSName + '.setBoxLabel(' + VarToJSON([BoxLabel]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.SetRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetRawValue(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setRawValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetValue(Checked : String) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Checked]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

function TExtFormFieldCheckbox.SetValue(Checked : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Checked]) + ');', 'TExtFormFieldCheckbox');
  Result := Self;
end;

destructor TExtFormFieldCheckbox.Destroy; begin
  try
    FAfterBoxLabelTextTplList.Free;
    FAfterBoxLabelTextTplTemplate.Free;
    FAfterBoxLabelTplList.Free;
    FAfterBoxLabelTplTemplate.Free;
    FBeforeBoxLabelTextTplList.Free;
    FBeforeBoxLabelTextTplTemplate.Free;
    FBeforeBoxLabelTplList.Free;
    FBeforeBoxLabelTplTemplate.Free;
    FBoxLabelAttrTplList.Free;
    FBoxLabelAttrTplTemplate.Free;
    FBoxLabelEl.Free;
    FHandlerCheckbox.Free;
    FOriginalValue.Free;
    FScope.Free;
  except end;
  inherited;
end;

function TExtDataStoreManagerSingleton.JSClassName : string; begin
  Result := 'Ext.data.StoreManager';
end;

{$IFDEF FPC}constructor TExtDataStoreManagerSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataStoreManagerSingleton.Lookup(Store : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.Lookup(' + VarToJSON([Store, false]) + ');', 'TExtDataStoreManagerSingleton');
  Result := Self;
end;

function TExtDataStoreManagerSingleton.Lookup(Store : String) : TExtFunction; begin
  JSCode(JSName + '.lookup(' + VarToJSON([Store]) + ');', 'TExtDataStoreManagerSingleton');
  Result := Self;
end;

function TExtDataStoreManagerSingleton.Register(Stores : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Stores, false]) + ');', 'TExtDataStoreManagerSingleton');
  Result := Self;
end;

function TExtDataStoreManagerSingleton.Unregister(Stores : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON(Stores) + ');', 'TExtDataStoreManagerSingleton');
  Result := Self;
end;

function TExtDataStoreManagerSingleton.Unregister(Stores : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([Stores]) + ');', 'TExtDataStoreManagerSingleton');
  Result := Self;
end;

procedure TExtLayoutContainerAuto.SetFManageOverflow(Value : Boolean); begin
  FManageOverflow := Value;
  JSCode(JSName + '.manageOverflow=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutContainerAuto.SetFManagePadding(Value : Boolean); begin
  FManagePadding := Value;
  JSCode(JSName + '.managePadding=' + VarToJSON([Value]) + ';');
end;

procedure TExtLayoutContainerAuto.SetFReserveScrollbar(Value : Boolean); begin
  FReserveScrollbar := Value;
  JSCode('reserveScrollbar:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAuto.JSClassName : string; begin
  Result := 'Ext.layout.container.Auto';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAuto.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerBox.SetFDefaultMargins(Value : TExtObject); begin
  FDefaultMargins := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultMargins:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBox.SetFFlex(Value : Integer); begin
  FFlex := Value;
  JSCode('flex:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFPack(Value : String); begin
  FPack := Value;
  JSCode('pack:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFPadding(Value : String); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFStretchMaxPartner(Value : String); begin
  FStretchMaxPartner := Value;
  JSCode('stretchMaxPartner:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBox.SetFStretchMaxPartnerComponent(Value : TExtComponent); begin
  FStretchMaxPartnerComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('stretchMaxPartner:' + VarToJSON([Value, false]));
end;

function TExtLayoutContainerBox.JSClassName : string; begin
  Result := 'Ext.layout.container.Box';
end;

procedure TExtLayoutContainerBox.InitDefaults; begin
  inherited;
  FDefaultMargins := TExtObject.CreateInternal(Self, 'defaultMargins');
  FStretchMaxPartnerComponent := TExtComponent.CreateInternal(Self, 'stretchMaxPartner');
end;

{$IFDEF FPC}constructor TExtLayoutContainerBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerBox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerBox.Destroy; begin
  try
    FDefaultMargins.Free;
    FStretchMaxPartnerComponent.Free;
  except end;
  inherited;
end;

function TExtLayoutContainerForm.JSClassName : string; begin
  Result := 'Ext.layout.container.Form';
end;

{$IFDEF FPC}constructor TExtLayoutContainerForm.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainerForm.CalculateOverflow(OwnerContext : TExtLayoutContextItem; ContainerSize : TExtObject; Dimensions : Integer) : TExtFunction; begin
  JSCode(JSName + '.calculateOverflow(' + VarToJSON([OwnerContext, false, ContainerSize, false, Dimensions]) + ');', 'TExtLayoutContainerForm');
  Result := Self;
end;

function TExtLayoutContainerForm.DoRenderPadder : TExtFunction; begin
  JSCode(JSName + '.doRenderPadder();', 'TExtLayoutContainerForm');
  Result := Self;
end;

function TExtFormActionDirectSubmit.JSClassName : string; begin
  Result := 'Ext.form.action.DirectSubmit';
end;

{$IFDEF FPC}constructor TExtFormActionDirectSubmit.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerBorder.SetFPadding(Value : Integer); begin
  FPadding := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFPaddingObject(Value : TExtObject); begin
  FPaddingObject := Value;
  Value.DeleteFromGarbage;
  JSCode('padding:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBorder.SetFPaddingString(Value : String); begin
  FPaddingString := Value;
  JSCode('padding:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFRegionWeights(Value : TExtObject); begin
  FRegionWeights := Value;
  Value.DeleteFromGarbage;
  JSCode('regionWeights:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerBorder.SetFSplit(Value : Boolean); begin
  FSplit := Value;
  JSCode('split:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerBorder.SetFSplitterResize(Value : Boolean); begin
  FSplitterResize := Value;
  JSCode('splitterResize:' + VarToJSON([Value]));
end;

function TExtLayoutContainerBorder.JSClassName : string; begin
  Result := 'Ext.layout.container.Border';
end;

procedure TExtLayoutContainerBorder.InitDefaults; begin
  inherited;
  FPaddingObject := TExtObject.CreateInternal(Self, 'padding');
  FRegionWeights := TExtObject.CreateInternal(Self, 'regionWeights');
end;

{$IFDEF FPC}constructor TExtLayoutContainerBorder.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerBorder.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerBorder.Destroy; begin
  try
    FPaddingObject.Free;
    FRegionWeights.Free;
  except end;
  inherited;
end;

procedure TExtViewTable.SetFFirstCls(Value : String); begin
  FFirstCls := Value;
  JSCode('firstCls:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFLastCls(Value : String); begin
  FLastCls := Value;
  JSCode('lastCls:' + VarToJSON([Value]));
end;

procedure TExtViewTable.SetFOnBeforecellclick(Value : TExtViewTableOnBeforecellclick); begin
  if Assigned(FOnBeforecellclick) then
    JSCode(JSName+'.events ["beforecellclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellclick', Ajax('beforecellclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecellclick := Value;
end;

procedure TExtViewTable.SetFOnBeforecellcontextmenu(Value : TExtViewTableOnBeforecellcontextmenu); begin
  if Assigned(FOnBeforecellcontextmenu) then
    JSCode(JSName+'.events ["beforecellcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellcontextmenu', Ajax('beforecellcontextmenu', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecellcontextmenu := Value;
end;

procedure TExtViewTable.SetFOnBeforecelldblclick(Value : TExtViewTableOnBeforecelldblclick); begin
  if Assigned(FOnBeforecelldblclick) then
    JSCode(JSName+'.events ["beforecelldblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecelldblclick', Ajax('beforecelldblclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecelldblclick := Value;
end;

procedure TExtViewTable.SetFOnBeforecellkeydown(Value : TExtViewTableOnBeforecellkeydown); begin
  if Assigned(FOnBeforecellkeydown) then
    JSCode(JSName+'.events ["beforecellkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellkeydown', Ajax('beforecellkeydown', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecellkeydown := Value;
end;

procedure TExtViewTable.SetFOnBeforecellmousedown(Value : TExtViewTableOnBeforecellmousedown); begin
  if Assigned(FOnBeforecellmousedown) then
    JSCode(JSName+'.events ["beforecellmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellmousedown', Ajax('beforecellmousedown', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecellmousedown := Value;
end;

procedure TExtViewTable.SetFOnBeforecellmouseup(Value : TExtViewTableOnBeforecellmouseup); begin
  if Assigned(FOnBeforecellmouseup) then
    JSCode(JSName+'.events ["beforecellmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellmouseup', Ajax('beforecellmouseup', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnBeforecellmouseup := Value;
end;

procedure TExtViewTable.SetFOnCellclick(Value : TExtViewTableOnCellclick); begin
  if Assigned(FOnCellclick) then
    JSCode(JSName+'.events ["cellclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellclick', Ajax('cellclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellclick := Value;
end;

procedure TExtViewTable.SetFOnCellcontextmenu(Value : TExtViewTableOnCellcontextmenu); begin
  if Assigned(FOnCellcontextmenu) then
    JSCode(JSName+'.events ["cellcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellcontextmenu', Ajax('cellcontextmenu', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellcontextmenu := Value;
end;

procedure TExtViewTable.SetFOnCelldblclick(Value : TExtViewTableOnCelldblclick); begin
  if Assigned(FOnCelldblclick) then
    JSCode(JSName+'.events ["celldblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('celldblclick', Ajax('celldblclick', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCelldblclick := Value;
end;

procedure TExtViewTable.SetFOnCellkeydown(Value : TExtViewTableOnCellkeydown); begin
  if Assigned(FOnCellkeydown) then
    JSCode(JSName+'.events ["cellkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellkeydown', Ajax('cellkeydown', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellkeydown := Value;
end;

procedure TExtViewTable.SetFOnCellmousedown(Value : TExtViewTableOnCellmousedown); begin
  if Assigned(FOnCellmousedown) then
    JSCode(JSName+'.events ["cellmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellmousedown', Ajax('cellmousedown', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellmousedown := Value;
end;

procedure TExtViewTable.SetFOnCellmouseup(Value : TExtViewTableOnCellmouseup); begin
  if Assigned(FOnCellmouseup) then
    JSCode(JSName+'.events ["cellmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellmouseup', Ajax('cellmouseup', ['This', '%0.nm','Td', '%1.nm','CellIndex', '%2','RecordJS', '%3.nm','Tr', '%4.nm','RowIndex', '%5','E', '%6.nm'], true));
  FOnCellmouseup := Value;
end;

function TExtViewTable.JSClassName : string; begin
  Result := 'Ext.view.Table';
end;

{$IFDEF FPC}constructor TExtViewTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewTable.AddRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : String; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.AddRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AddRowCls(RowInfo : Integer; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AutoSizeColumn(Header : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.AutoSizeColumn(' + VarToJSON([Header, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.AutoSizeColumn(Header : Integer) : TExtFunction; begin
  JSCode(JSName + '.autoSizeColumn(' + VarToJSON([Header]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : String) : TExtFunction; begin
  JSCode(JSName + '.FocusRow(' + VarToJSON([RowIdx]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.FocusRow(RowIdx : Integer) : TExtFunction; begin
  JSCode(JSName + '.focusRow(' + VarToJSON([RowIdx]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetBodySelector : TExtFunction; begin
  JSCode(JSName + '.getBodySelector();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetCellSelector(Header : TExtGridColumn = nil) : TExtFunction; begin
  JSCode(JSName + '.getCellSelector(' + VarToJSON([Header, false]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetColumnSizerSelector : TExtFunction; begin
  JSCode(JSName + '.getColumnSizerSelector();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetDataRowSelector : TExtFunction; begin
  JSCode(JSName + '.getDataRowSelector();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetFeature(Id : String) : TExtFunction; begin
  JSCode(JSName + '.getFeature(' + VarToJSON([Id]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetItemSelector : TExtFunction; begin
  JSCode(JSName + '.getItemSelector();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetNode(NodeInfo : THTMLElement; DataRow : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo, false, DataRow]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetNode(NodeInfo : TExtDataModel; DataRow : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo, false, DataRow]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetNode(NodeInfo : String; DataRow : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.GetNode(' + VarToJSON([NodeInfo, DataRow]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetNode(NodeInfo : Integer; DataRow : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.getNode(' + VarToJSON([NodeInfo, DataRow]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.GetNodeContainerSelector : TExtFunction; begin
  JSCode(JSName + '.getNodeContainerSelector();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.Refresh : TExtFunction; begin
  JSCode(JSName + '.refresh();', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : THTMLElement; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : TExtDataModel; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, false, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : String; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.RemoveRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.RemoveRowCls(RowInfo : Integer; Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeRowCls(' + VarToJSON([RowInfo, Cls]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.WalkRecs(StartRec : TExtDataModel; Distance : Integer) : TExtFunction; begin
  JSCode(JSName + '.walkRecs(' + VarToJSON([StartRec, false, Distance]) + ');', 'TExtViewTable');
  Result := Self;
end;

function TExtViewTable.WalkRows(StartRow : Integer; Distance : Integer) : TExtFunction; begin
  JSCode(JSName + '.walkRows(' + VarToJSON([StartRow, Distance]) + ');', 'TExtViewTable');
  Result := Self;
end;

procedure TExtViewTable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecellclick') and Assigned(FOnBeforecellclick) then
    FOnBeforecellclick(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecellcontextmenu') and Assigned(FOnBeforecellcontextmenu) then
    FOnBeforecellcontextmenu(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecelldblclick') and Assigned(FOnBeforecelldblclick) then
    FOnBeforecelldblclick(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecellkeydown') and Assigned(FOnBeforecellkeydown) then
    FOnBeforecellkeydown(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecellmousedown') and Assigned(FOnBeforecellmousedown) then
    FOnBeforecellmousedown(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'beforecellmouseup') and Assigned(FOnBeforecellmouseup) then
    FOnBeforecellmouseup(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'cellclick') and Assigned(FOnCellclick) then
    FOnCellclick(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'cellcontextmenu') and Assigned(FOnCellcontextmenu) then
    FOnCellcontextmenu(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'celldblclick') and Assigned(FOnCelldblclick) then
    FOnCelldblclick(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'cellkeydown') and Assigned(FOnCellkeydown) then
    FOnCellkeydown(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'cellmousedown') and Assigned(FOnCellmousedown) then
    FOnCellmousedown(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'cellmouseup') and Assigned(FOnCellmouseup) then
    FOnCellmouseup(TExtViewTable(ParamAsObject('This')), THTMLElement(ParamAsObject('Td')), ParamAsInteger('CellIndex'), TExtDataModel(ParamAsObject('RecordJS')), THTMLElement(ParamAsObject('Tr')), ParamAsInteger('RowIndex'), TExtEventObject(ParamAsObject('E')));
end;

function TExtGridFeatureGroupingSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.GroupingSummary';
end;

{$IFDEF FPC}constructor TExtGridFeatureGroupingSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridFeatureSummary.SetFDock(Value : String); begin
  FDock := Value;
  JSCode('dock:' + VarToJSON([Value]));
end;

function TExtGridFeatureSummary.JSClassName : string; begin
  Result := 'Ext.grid.feature.Summary';
end;

{$IFDEF FPC}constructor TExtGridFeatureSummary.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridHeaderContainer.SetFDefaultWidth(Value : Integer); begin
  FDefaultWidth := Value;
  JSCode('defaultWidth:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFEnableColumnHide(Value : Boolean); begin
  FEnableColumnHide := Value;
  JSCode('enableColumnHide:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFIsGroupHeader(Value : Boolean); begin
  FIsGroupHeader := Value;
  JSCode(JSName + '.isGroupHeader=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridHeaderContainer.SetFSealed(Value : Boolean); begin
  FSealed := Value;
  JSCode('sealed:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFSortable(Value : Boolean); begin
  FSortable := Value;
  JSCode('sortable:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFWeight(Value : Integer); begin
  FWeight := Value;
  JSCode('weight:' + VarToJSON([Value]));
end;

procedure TExtGridHeaderContainer.SetFOnColumnhide(Value : TExtGridHeaderContainerOnColumnhide); begin
  if Assigned(FOnColumnhide) then
    JSCode(JSName+'.events ["columnhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnhide', Ajax('columnhide', ['Ct', '%0.nm','Column', '%1.nm'], true));
  FOnColumnhide := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnmove(Value : TExtGridHeaderContainerOnColumnmove); begin
  if Assigned(FOnColumnmove) then
    JSCode(JSName+'.events ["columnmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnmove', Ajax('columnmove', ['Ct', '%0.nm','Column', '%1.nm','FromIdx', '%2','ToIdx', '%3'], true));
  FOnColumnmove := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnresize(Value : TExtGridHeaderContainerOnColumnresize); begin
  if Assigned(FOnColumnresize) then
    JSCode(JSName+'.events ["columnresize"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnresize', Ajax('columnresize', ['Ct', '%0.nm','Column', '%1.nm','Width', '%2'], true));
  FOnColumnresize := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnschanged(Value : TExtGridHeaderContainerOnColumnschanged); begin
  if Assigned(FOnColumnschanged) then
    JSCode(JSName+'.events ["columnschanged"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnschanged', Ajax('columnschanged', ['Ct', '%0.nm'], true));
  FOnColumnschanged := Value;
end;

procedure TExtGridHeaderContainer.SetFOnColumnshow(Value : TExtGridHeaderContainerOnColumnshow); begin
  if Assigned(FOnColumnshow) then
    JSCode(JSName+'.events ["columnshow"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnshow', Ajax('columnshow', ['Ct', '%0.nm','Column', '%1.nm'], true));
  FOnColumnshow := Value;
end;

procedure TExtGridHeaderContainer.SetFOnHeaderclick(Value : TExtGridHeaderContainerOnHeaderclick); begin
  if Assigned(FOnHeaderclick) then
    JSCode(JSName+'.events ["headerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headerclick', Ajax('headerclick', ['Ct', '%0.nm','Column', '%1.nm','E', '%2.nm','T', '%3.nm'], true));
  FOnHeaderclick := Value;
end;

procedure TExtGridHeaderContainer.SetFOnHeadercontextmenu(Value : TExtGridHeaderContainerOnHeadercontextmenu); begin
  if Assigned(FOnHeadercontextmenu) then
    JSCode(JSName+'.events ["headercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('headercontextmenu', Ajax('headercontextmenu', ['Ct', '%0.nm','Column', '%1.nm','E', '%2.nm','T', '%3.nm'], true));
  FOnHeadercontextmenu := Value;
end;

procedure TExtGridHeaderContainer.SetFOnHeadertriggerclick(Value : TExtGridHeaderContainerOnHeadertriggerclick); begin
  if Assigned(FOnHeadertriggerclick) then
    JSCode(JSName+'.events ["headertriggerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headertriggerclick', Ajax('headertriggerclick', ['Ct', '%0.nm','Column', '%1.nm','E', '%2.nm','T', '%3.nm'], true));
  FOnHeadertriggerclick := Value;
end;

procedure TExtGridHeaderContainer.SetFOnMenucreate(Value : TExtGridHeaderContainerOnMenucreate); begin
  if Assigned(FOnMenucreate) then
    JSCode(JSName+'.events ["menucreate"].listeners=[];');
  if Assigned(Value) then
    AddListener('menucreate', Ajax('menucreate', ['Ct', '%0.nm','Menu', '%1.nm'], true));
  FOnMenucreate := Value;
end;

procedure TExtGridHeaderContainer.SetFOnSortchange(Value : TExtGridHeaderContainerOnSortchange); begin
  if Assigned(FOnSortchange) then
    JSCode(JSName+'.events ["sortchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('sortchange', Ajax('sortchange', ['Ct', '%0.nm','Column', '%1.nm','Direction', '%2'], true));
  FOnSortchange := Value;
end;

function TExtGridHeaderContainer.JSClassName : string; begin
  Result := 'Ext.grid.header.Container';
end;

{$IFDEF FPC}constructor TExtGridHeaderContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridHeaderContainer.GetColumnCount : TExtFunction; begin
  JSCode(JSName + '.getColumnCount();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetColumnMenu : TExtFunction; begin
  JSCode(JSName + '.getColumnMenu();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetFullWidth : TExtFunction; begin
  JSCode(JSName + '.getFullWidth();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetGridColumns : TExtFunction; begin
  JSCode(JSName + '.getGridColumns();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetHeaderAtIndex(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getHeaderAtIndex(' + VarToJSON([Index]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetHeaderIndex(Header : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.getHeaderIndex(' + VarToJSON([Header, false]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetMenuItems : TExtFunction; begin
  JSCode(JSName + '.getMenuItems();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetVisibleGridColumns : TExtFunction; begin
  JSCode(JSName + '.getVisibleGridColumns();', 'TExtGridHeaderContainer');
  Result := Self;
end;

function TExtGridHeaderContainer.GetVisibleHeaderClosestToIndex(Index : Integer) : TExtFunction; begin
  JSCode(JSName + '.getVisibleHeaderClosestToIndex(' + VarToJSON([Index]) + ');', 'TExtGridHeaderContainer');
  Result := Self;
end;

procedure TExtGridHeaderContainer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'columnhide') and Assigned(FOnColumnhide) then
    FOnColumnhide(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')))
  else if (AEvtName = 'columnmove') and Assigned(FOnColumnmove) then
    FOnColumnmove(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsInteger('FromIdx'), ParamAsInteger('ToIdx'))
  else if (AEvtName = 'columnresize') and Assigned(FOnColumnresize) then
    FOnColumnresize(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsInteger('Width'))
  else if (AEvtName = 'columnschanged') and Assigned(FOnColumnschanged) then
    FOnColumnschanged(TExtGridHeaderContainer(ParamAsObject('Ct')))
  else if (AEvtName = 'columnshow') and Assigned(FOnColumnshow) then
    FOnColumnshow(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')))
  else if (AEvtName = 'headerclick') and Assigned(FOnHeaderclick) then
    FOnHeaderclick(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'headercontextmenu') and Assigned(FOnHeadercontextmenu) then
    FOnHeadercontextmenu(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'headertriggerclick') and Assigned(FOnHeadertriggerclick) then
    FOnHeadertriggerclick(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), TExtEventObject(ParamAsObject('E')), THTMLElement(ParamAsObject('T')))
  else if (AEvtName = 'menucreate') and Assigned(FOnMenucreate) then
    FOnMenucreate(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtMenu(ParamAsObject('Menu')))
  else if (AEvtName = 'sortchange') and Assigned(FOnSortchange) then
    FOnSortchange(TExtGridHeaderContainer(ParamAsObject('Ct')), TExtGridColumn(ParamAsObject('Column')), ParamAsString('Direction'));
end;

procedure TExtToolbar.SetFDefaultButtonUI(Value : String); begin
  FDefaultButtonUI := Value;
  JSCode('defaultButtonUI:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFEnableOverflow(Value : Boolean); begin
  FEnableOverflow := Value;
  JSCode('enableOverflow:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFIsToolbar(Value : Boolean); begin
  FIsToolbar := Value;
  JSCode(JSName + '.isToolbar=' + VarToJSON([Value]) + ';');
end;

procedure TExtToolbar.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtToolbar.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtToolbar.SetFMenuTriggerCls(Value : String); begin
  FMenuTriggerCls := Value;
  JSCode('menuTriggerCls:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtToolbar.SetFOnOverflowchange(Value : TExtToolbarOnOverflowchange); begin
  if Assigned(FOnOverflowchange) then
    JSCode(JSName+'.events ["overflowchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('overflowchange', Ajax('overflowchange', ['LastHiddenCount', '%0','HiddenCount', '%1','The', '%2.nm'], true));
  FOnOverflowchange := Value;
end;

function TExtToolbar.JSClassName : string; begin
  Result := 'Ext.toolbar.Toolbar';
end;

procedure TExtToolbar.InitDefaults; begin
  inherited;
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtToolbar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtToolbar.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtToolbar.Destroy; begin
  try
    FLayoutObject.Free;
  except end;
  inherited;
end;

procedure TExtToolbar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'overflowchange') and Assigned(FOnOverflowchange) then
    FOnOverflowchange(ParamAsInteger('LastHiddenCount'), ParamAsInteger('HiddenCount'), TExtObjectList(ParamAsObject('The')));
end;

function TExtViewTableLayout.JSClassName : string; begin
  Result := 'Ext.view.TableLayout';
end;

{$IFDEF FPC}constructor TExtViewTableLayout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartAxisTime.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFDateFormat(Value : String); begin
  FDateFormat := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFDateFormatBoolean(Value : Boolean); begin
  FDateFormatBoolean := Value;
  JSCode('dateFormat:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFFromDate(Value : TDateTime); begin
  FFromDate := Value;
  JSCode('fromDate:' + VarToJSON([Value]));
end;

procedure TExtChartAxisTime.SetFStep(Value : TExtObjectList); begin
  FStep := Value;
  Value.DeleteFromGarbage;
  JSCode('step:' + VarToJSON([Value, false]));
end;

procedure TExtChartAxisTime.SetFToDate(Value : TDateTime); begin
  FToDate := Value;
  JSCode('toDate:' + VarToJSON([Value]));
end;

function TExtChartAxisTime.JSClassName : string; begin
  Result := 'Ext.chart.axis.Time';
end;

procedure TExtChartAxisTime.InitDefaults; begin
  inherited;
  FStep := TExtObjectList.Create(Self, 'step');
end;

{$IFDEF FPC}constructor TExtChartAxisTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartAxisTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartAxisTime.Destroy; begin
  try
    FStep.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldTextArea.SetFCols(Value : Integer); begin
  FCols := Value;
  JSCode('cols:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFEnterIsSpecial(Value : Boolean); begin
  FEnterIsSpecial := Value;
  JSCode('enterIsSpecial:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFGrowAppend(Value : String); begin
  FGrowAppend := Value;
  JSCode('growAppend:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFGrowMax(Value : Integer); begin
  FGrowMax := Value;
  JSCode('growMax:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFGrowMin(Value : Integer); begin
  FGrowMin := Value;
  JSCode('growMin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFPreventScrollbars(Value : Boolean); begin
  FPreventScrollbars := Value;
  JSCode('preventScrollbars:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFRows(Value : Integer); begin
  FRows := Value;
  JSCode('rows:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTextArea.SetFOnAutosize(Value : TExtFormFieldTextAreaOnAutosize); begin
  if Assigned(FOnAutosize) then
    JSCode(JSName+'.events ["autosize"].listeners=[];');
  if Assigned(Value) then
    AddListener('autosize', Ajax('autosize', ['This', '%0.nm','Height', '%1'], true));
  FOnAutosize := Value;
end;

function TExtFormFieldTextArea.JSClassName : string; begin
  Result := 'Ext.form.field.TextArea';
end;

procedure TExtFormFieldTextArea.InitDefaults; begin
  inherited;
  FRows := 4;
end;

{$IFDEF FPC}constructor TExtFormFieldTextArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldTextArea.AutoSize : TExtFunction; begin
  JSCode(JSName + '.autoSize();', 'TExtFormFieldTextArea');
  Result := Self;
end;

constructor TExtFormFieldTextArea.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

procedure TExtFormFieldTextArea.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'autosize') and Assigned(FOnAutosize) then
    FOnAutosize(TExtFormFieldTextArea(ParamAsObject('This')), ParamAsInteger('Height'));
end;

function TExtSliderSingle.JSClassName : string; begin
  Result := 'Ext.slider.Single';
end;

{$IFDEF FPC}constructor TExtSliderSingle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSliderSingle.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtSliderSingle');
  Result := Self;
end;

function TExtSliderSingle.SetValue(Value : Integer; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, Animate]) + ');', 'TExtSliderSingle');
  Result := Self;
end;

procedure TExtFormFieldTrigger.SetFEditable(Value : Boolean); begin
  FEditable := Value;
  if not ConfigAvailable(JSName) then
    SetEditable(Value)
  else
    JSCode('editable:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFHideTrigger(Value : Boolean); begin
  FHideTrigger := Value;
  JSCode('hideTrigger:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFInputCell(Value : TExtElement); begin
  FInputCell := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.inputCell=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldTrigger.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  if not ConfigAvailable(JSName) then
    SetReadOnly(Value)
  else
    JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFRepeatTriggerClick(Value : Boolean); begin
  FRepeatTriggerClick := Value;
  JSCode('repeatTriggerClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFSelectOnFocus(Value : Boolean); begin
  FSelectOnFocus := Value;
  JSCode('selectOnFocus:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTrigger.SetFTriggerEl(Value : TExtCompositeElement); begin
  FTriggerEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.triggerEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldTrigger.SetFTriggerWrap(Value : TExtElement); begin
  FTriggerWrap := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.triggerWrap=' + VarToJSON([Value, false]) + ';');
end;

function TExtFormFieldTrigger.JSClassName : string; begin
  Result := 'Ext.form.field.Trigger';
end;

procedure TExtFormFieldTrigger.InitDefaults; begin
  inherited;
  FInputCell := TExtElement.CreateInternal(Self, 'inputCell');
  FTriggerEl := TExtCompositeElement.CreateInternal(Self, 'triggerEl');
  FTriggerWrap := TExtElement.CreateInternal(Self, 'triggerWrap');
end;

{$IFDEF FPC}constructor TExtFormFieldTrigger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldTrigger.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldTrigger.GetTriggerWidth : TExtFunction; begin
  JSCode(JSName + '.getTriggerWidth();', 'TExtFormFieldTrigger');
  Result := Self;
end;

function TExtFormFieldTrigger.SetEditable(Editable : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setEditable(' + VarToJSON([Editable]) + ');', 'TExtFormFieldTrigger');
  Result := Self;
end;

function TExtFormFieldTrigger.SetReadOnly(ReadOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([ReadOnly]) + ');', 'TExtFormFieldTrigger');
  Result := Self;
end;

destructor TExtFormFieldTrigger.Destroy; begin
  try
    FInputCell.Free;
    FTriggerEl.Free;
    FTriggerWrap.Free;
  except end;
  inherited;
end;

function TExtDataProxySessionStorage.JSClassName : string; begin
  Result := 'Ext.data.proxy.SessionStorage';
end;

{$IFDEF FPC}constructor TExtDataProxySessionStorage.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFxTargetCompositeElementCSS.JSClassName : string; begin
  Result := 'Ext.fx.target.CompositeElementCSS';
end;

{$IFDEF FPC}constructor TExtFxTargetCompositeElementCSS.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridColumnComponentLayout.JSClassName : string; begin
  Result := 'Ext.grid.ColumnComponentLayout';
end;

{$IFDEF FPC}constructor TExtGridColumnComponentLayout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtSelectionCheckboxModel.SetFCheckOnly(Value : Boolean); begin
  FCheckOnly := Value;
  JSCode('checkOnly:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFCheckSelector(Value : String); begin
  FCheckSelector := Value;
  JSCode('checkSelector:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFInjectCheckbox(Value : Integer); begin
  FInjectCheckbox := Value;
  JSCode('injectCheckbox:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFInjectCheckboxString(Value : String); begin
  FInjectCheckboxString := Value;
  JSCode('injectCheckbox:' + VarToJSON([Value]));
end;

procedure TExtSelectionCheckboxModel.SetFMode(Value : TModeEnum); begin
  FMode := Value;
  JSCode('mode:"' + EnumToJSString(TypeInfo(TModeEnum), ord(Value)) + '"');
end;

procedure TExtSelectionCheckboxModel.SetFShowHeaderCheckbox(Value : Boolean); begin
  FShowHeaderCheckbox := Value;
  JSCode('showHeaderCheckbox:' + VarToJSON([Value]));
end;

function TExtSelectionCheckboxModel.JSClassName : string; begin
  Result := 'Ext.selection.CheckboxModel';
end;

{$IFDEF FPC}constructor TExtSelectionCheckboxModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionCheckboxModel.GetHeaderConfig : TExtFunction; begin
  JSCode(JSName + '.getHeaderConfig();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

function TExtSelectionCheckboxModel.OnHeaderClick : TExtFunction; begin
  JSCode(JSName + '.onHeaderClick();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

function TExtSelectionCheckboxModel.Renderer : TExtFunction; begin
  JSCode(JSName + '.renderer();', 'TExtSelectionCheckboxModel');
  Result := Self;
end;

procedure TExtButtonCycle.SetFChangeHandler(Value : TExtFunction); begin
  FChangeHandler := Value;
  JSCode('changeHandler:' + VarToJSON([Value, true]));
end;

procedure TExtButtonCycle.SetFForceGlyph(Value : Integer); begin
  FForceGlyph := Value;
  JSCode('forceGlyph:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFForceGlyphString(Value : String); begin
  FForceGlyphString := Value;
  JSCode('forceGlyph:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFForceIcon(Value : String); begin
  FForceIcon := Value;
  JSCode('forceIcon:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFMenu(Value : TExtMenu); begin
  FMenu := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.menu=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtButtonCycle.SetFPrependText(Value : String); begin
  FPrependText := Value;
  JSCode('prependText:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFShowText(Value : Boolean); begin
  FShowText := Value;
  JSCode('showText:' + VarToJSON([Value]));
end;

procedure TExtButtonCycle.SetFOnChange(Value : TExtButtonCycleOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','Item', '%1.nm'], true));
  FOnChange := Value;
end;

function TExtButtonCycle.JSClassName : string; begin
  Result := 'Ext.button.Cycle';
end;

procedure TExtButtonCycle.InitDefaults; begin
  inherited;
  FMenu := TExtMenu.CreateInternal(Self, 'menu');
end;

{$IFDEF FPC}constructor TExtButtonCycle.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtButtonCycle.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtButtonCycle.GetActiveItem : TExtFunction; begin
  JSCode(JSName + '.getActiveItem();', 'TExtButtonCycle');
  Result := Self;
end;

function TExtButtonCycle.SetActiveItem(Item : TExtMenuCheckItem; SuppressEvent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setActiveItem(' + VarToJSON([Item, false, SuppressEvent]) + ');', 'TExtButtonCycle');
  Result := Self;
end;

function TExtButtonCycle.ToggleSelected : TExtFunction; begin
  JSCode(JSName + '.toggleSelected();', 'TExtButtonCycle');
  Result := Self;
end;

destructor TExtButtonCycle.Destroy; begin
  try
    FMenu.Free;
  except end;
  inherited;
end;

procedure TExtButtonCycle.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtButtonCycle(ParamAsObject('This')), TExtMenuCheckItem(ParamAsObject('Item')));
end;

procedure TExtViewBoundList.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFPagingToolbar(Value : TExtToolbarPaging); begin
  FPagingToolbar := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.pagingToolbar=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtViewBoundList.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtViewBoundList.SetFTplTemplate(Value : TExtXTemplate); begin
  FTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

function TExtViewBoundList.JSClassName : string; begin
  Result := 'Ext.view.BoundList';
end;

procedure TExtViewBoundList.InitDefaults; begin
  inherited;
  FPagingToolbar := TExtToolbarPaging.CreateInternal(Self, 'pagingToolbar');
  FTplTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtViewBoundList.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtViewBoundList.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtViewBoundList.GetInnerTpl(DisplayField : String) : TExtFunction; begin
  JSCode(JSName + '.getInnerTpl(' + VarToJSON([DisplayField]) + ');', 'TExtViewBoundList');
  Result := Self;
end;

destructor TExtViewBoundList.Destroy; begin
  try
    FPagingToolbar.Free;
    FTplTemplate.Free;
  except end;
  inherited;
end;

procedure TExtChartAxisRadial.SetFMaximum(Value : Integer); begin
  FMaximum := Value;
  JSCode('maximum:' + VarToJSON([Value]));
end;

procedure TExtChartAxisRadial.SetFSteps(Value : Integer); begin
  FSteps := Value;
  JSCode('steps:' + VarToJSON([Value]));
end;

function TExtChartAxisRadial.JSClassName : string; begin
  Result := 'Ext.chart.axis.Radial';
end;

{$IFDEF FPC}constructor TExtChartAxisRadial.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtSelectionTreeModel.JSClassName : string; begin
  Result := 'Ext.selection.TreeModel';
end;

{$IFDEF FPC}constructor TExtSelectionTreeModel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtEditor.SetFAlignment(Value : String); begin
  FAlignment := Value;
  JSCode('alignment:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFAllowBlur(Value : Boolean); begin
  FAllowBlur := Value;
  JSCode('allowBlur:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFAutoSize(Value : Boolean); begin
  FAutoSize := Value;
  JSCode('autoSize:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFAutoSizeObject(Value : TExtObject); begin
  FAutoSizeObject := Value;
  Value.DeleteFromGarbage;
  JSCode('autoSize:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFCancelOnEsc(Value : Boolean); begin
  FCancelOnEsc := Value;
  JSCode('cancelOnEsc:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFCompleteOnEnter(Value : Boolean); begin
  FCompleteOnEnter := Value;
  JSCode('completeOnEnter:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFField(Value : TExtFormField); begin
  FField := Value;
  Value.DeleteFromGarbage;
  JSCode('field:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFHideEl(Value : Boolean); begin
  FHideEl := Value;
  JSCode('hideEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFIgnoreNoChange(Value : Boolean); begin
  FIgnoreNoChange := Value;
  JSCode('ignoreNoChange:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFOffsets(Value : TArrayOfInteger); begin
  FOffsets := Value;
  JSCode('offsets:' + ArrayToJSON(Value));
end;

procedure TExtEditor.SetFParentEl(Value : String); begin
  FParentEl := Value;
  JSCode('parentEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFParentElElement(Value : TExtElement); begin
  FParentElElement := Value;
  Value.DeleteFromGarbage;
  JSCode('parentEl:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFParentElTHTMLElement(Value : THTMLElement); begin
  FParentElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('parentEl:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFRevertInvalid(Value : Boolean); begin
  FRevertInvalid := Value;
  JSCode('revertInvalid:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFShadow(Value : Boolean); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFShadowString(Value : String); begin
  FShadowString := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFSwallowKeys(Value : Boolean); begin
  FSwallowKeys := Value;
  JSCode('swallowKeys:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFUpdateEl(Value : Boolean); begin
  FUpdateEl := Value;
  JSCode('updateEl:' + VarToJSON([Value]));
end;

procedure TExtEditor.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtEditor.SetFOnBeforecomplete(Value : TExtEditorOnBeforecomplete); begin
  if Assigned(FOnBeforecomplete) then
    JSCode(JSName+'.events ["beforecomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecomplete', Ajax('beforecomplete', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnBeforecomplete := Value;
end;

procedure TExtEditor.SetFOnBeforestartedit(Value : TExtEditorOnBeforestartedit); begin
  if Assigned(FOnBeforestartedit) then
    JSCode(JSName+'.events ["beforestartedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforestartedit', Ajax('beforestartedit', ['This', '%0.nm','BoundEl', '%1.nm','Value', '%2.nm'], true));
  FOnBeforestartedit := Value;
end;

procedure TExtEditor.SetFOnCanceledit(Value : TExtEditorOnCanceledit); begin
  if Assigned(FOnCanceledit) then
    JSCode(JSName+'.events ["canceledit"].listeners=[];');
  if Assigned(Value) then
    AddListener('canceledit', Ajax('canceledit', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnCanceledit := Value;
end;

procedure TExtEditor.SetFOnComplete(Value : TExtEditorOnComplete); begin
  if Assigned(FOnComplete) then
    JSCode(JSName+'.events ["complete"].listeners=[];');
  if Assigned(Value) then
    AddListener('complete', Ajax('complete', ['This', '%0.nm','Value', '%1.nm','StartValue', '%2.nm'], true));
  FOnComplete := Value;
end;

procedure TExtEditor.SetFOnSpecialkey(Value : TExtEditorOnSpecialkey); begin
  if Assigned(FOnSpecialkey) then
    JSCode(JSName+'.events ["specialkey"].listeners=[];');
  if Assigned(Value) then
    AddListener('specialkey', Ajax('specialkey', ['This', '%0.nm','Field', '%1.nm','Event', '%2.nm'], true));
  FOnSpecialkey := Value;
end;

procedure TExtEditor.SetFOnStartedit(Value : TExtEditorOnStartedit); begin
  if Assigned(FOnStartedit) then
    JSCode(JSName+'.events ["startedit"].listeners=[];');
  if Assigned(Value) then
    AddListener('startedit', Ajax('startedit', ['This', '%0.nm','BoundEl', '%1.nm','Value', '%2.nm'], true));
  FOnStartedit := Value;
end;

function TExtEditor.JSClassName : string; begin
  Result := 'Ext.Editor';
end;

procedure TExtEditor.InitDefaults; begin
  inherited;
  FAutoSizeObject := TExtObject.CreateInternal(Self, 'autoSize');
  FField := TExtFormField.CreateInternal(Self, 'field');
  FParentElElement := TExtElement.CreateInternal(Self, 'parentEl');
  FValue := TExtObject.CreateInternal(Self, 'value');
end;

{$IFDEF FPC}constructor TExtEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtEditor.CancelEdit(RemainVisible : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.cancelEdit(' + VarToJSON([RemainVisible]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.CompleteEdit(RemainVisible : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.completeEdit(' + VarToJSON([RemainVisible]) + ');', 'TExtEditor');
  Result := Self;
end;

constructor TExtEditor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtEditor.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.Realign(AutoSize : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.realign(' + VarToJSON([AutoSize]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.StartEdit(El : THTMLElement; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([El, false, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.StartEdit(El : TExtElement; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.StartEdit(' + VarToJSON([El, false, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

function TExtEditor.StartEdit(El : String; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([El, Value]) + ');', 'TExtEditor');
  Result := Self;
end;

destructor TExtEditor.Destroy; begin
  try
    FAutoSizeObject.Free;
    FField.Free;
    FParentElElement.Free;
    FValue.Free;
  except end;
  inherited;
end;

procedure TExtEditor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecomplete') and Assigned(FOnBeforecomplete) then
    FOnBeforecomplete(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'beforestartedit') and Assigned(FOnBeforestartedit) then
    FOnBeforestartedit(TExtEditor(ParamAsObject('This')), TExtElement(ParamAsObject('BoundEl')), TExtObject(ParamAsObject('Value')))
  else if (AEvtName = 'canceledit') and Assigned(FOnCanceledit) then
    FOnCanceledit(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'complete') and Assigned(FOnComplete) then
    FOnComplete(TExtEditor(ParamAsObject('This')), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('StartValue')))
  else if (AEvtName = 'specialkey') and Assigned(FOnSpecialkey) then
    FOnSpecialkey(TExtEditor(ParamAsObject('This')), TExtFormField(ParamAsObject('Field')), TExtEventObject(ParamAsObject('Event')))
  else if (AEvtName = 'startedit') and Assigned(FOnStartedit) then
    FOnStartedit(TExtEditor(ParamAsObject('This')), TExtElement(ParamAsObject('BoundEl')), TExtObject(ParamAsObject('Value')));
end;

procedure TExtFormFieldContainer.SetFActiveError(Value : String); begin
  FActiveError := Value;
  if not ConfigAvailable(JSName) then
    SetActiveError(Value)
  else
    JSCode('activeError:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFActiveErrorsTpl(Value : String); begin
  FActiveErrorsTpl := Value;
  JSCode('activeErrorsTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFActiveErrorsTplTArrayOfString(Value : TArrayOfString); begin
  FActiveErrorsTplTArrayOfString := Value;
  JSCode('activeErrorsTpl:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldContainer.SetFActiveErrorsTplTemplate(Value : TExtXTemplate); begin
  FActiveErrorsTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('activeErrorsTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterBodyEl(Value : String); begin
  FAfterBodyEl := Value;
  JSCode('afterBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFAfterBodyElList(Value : TExtObjectList); begin
  FAfterBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterBodyElTemplate(Value : TExtXTemplate); begin
  FAfterBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTextTpl(Value : String); begin
  FAfterLabelTextTpl := Value;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTextTplList(Value : TExtObjectList); begin
  FAfterLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTextTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTpl(Value : String); begin
  FAfterLabelTpl := Value;
  JSCode('afterLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTplList(Value : TExtObjectList); begin
  FAfterLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterLabelTplTemplate(Value : TExtXTemplate); begin
  FAfterLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterSubTpl(Value : String); begin
  FAfterSubTpl := Value;
  JSCode('afterSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFAfterSubTplList(Value : TExtObjectList); begin
  FAfterSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAfterSubTplTemplate(Value : TExtXTemplate); begin
  FAfterSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFAutoFitErrors(Value : Boolean); begin
  FAutoFitErrors := Value;
  JSCode('autoFitErrors:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBaseBodyCls(Value : String); begin
  FBaseBodyCls := Value;
  JSCode('baseBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBeforeBodyEl(Value : String); begin
  FBeforeBodyEl := Value;
  JSCode('beforeBodyEl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBeforeBodyElList(Value : TExtObjectList); begin
  FBeforeBodyElList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeBodyElTemplate(Value : TExtXTemplate); begin
  FBeforeBodyElTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeBodyEl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTextTpl(Value : String); begin
  FBeforeLabelTextTpl := Value;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTextTplList(Value : TExtObjectList); begin
  FBeforeLabelTextTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTextTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTextTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTextTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTpl(Value : String); begin
  FBeforeLabelTpl := Value;
  JSCode('beforeLabelTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTplList(Value : TExtObjectList); begin
  FBeforeLabelTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeLabelTplTemplate(Value : TExtXTemplate); begin
  FBeforeLabelTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeLabelTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeSubTpl(Value : String); begin
  FBeforeSubTpl := Value;
  JSCode('beforeSubTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFBeforeSubTplList(Value : TExtObjectList); begin
  FBeforeSubTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBeforeSubTplTemplate(Value : TExtXTemplate); begin
  FBeforeSubTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeSubTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFBodyEl(Value : TExtElement); begin
  FBodyEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.bodyEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldContainer.SetFClearCls(Value : String); begin
  FClearCls := Value;
  JSCode('clearCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFCombineErrors(Value : Boolean); begin
  FCombineErrors := Value;
  JSCode('combineErrors:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFCombineLabels(Value : Boolean); begin
  FCombineLabels := Value;
  JSCode('combineLabels:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFErrorEl(Value : TExtElement); begin
  FErrorEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.errorEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldContainer.SetFErrorMsgCls(Value : String); begin
  FErrorMsgCls := Value;
  JSCode('errorMsgCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFFieldDefaults(Value : TExtObject); begin
  FFieldDefaults := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetFieldDefaults(Value)
  else
    JSCode('fieldDefaults:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFFieldLabel(Value : String); begin
  FFieldLabel := Value;
  if not ConfigAvailable(JSName) then
    SetFieldLabel(Value)
  else
    JSCode('fieldLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFFormItemCls(Value : String); begin
  FFormItemCls := Value;
  JSCode('formItemCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFHideEmptyLabel(Value : Boolean); begin
  FHideEmptyLabel := Value;
  JSCode('hideEmptyLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFHideLabel(Value : Boolean); begin
  FHideLabel := Value;
  JSCode('hideLabel:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFInvalidCls(Value : String); begin
  FInvalidCls := Value;
  JSCode('invalidCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFIsFieldLabelable(Value : Boolean); begin
  FIsFieldLabelable := Value;
  JSCode(JSName + '.isFieldLabelable=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldContainer.SetFLabelAlign(Value : TLabelAlignEnum); begin
  FLabelAlign := Value;
  JSCode('labelAlign:"' + EnumToJSString(TypeInfo(TLabelAlignEnum), ord(Value)) + '"');
end;

procedure TExtFormFieldContainer.SetFLabelAttrTpl(Value : String); begin
  FLabelAttrTpl := Value;
  JSCode('labelAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelAttrTplList(Value : TExtObjectList); begin
  FLabelAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFLabelAttrTplTemplate(Value : TExtXTemplate); begin
  FLabelAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('labelAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldContainer.SetFLabelCell(Value : TExtElement); begin
  FLabelCell := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelCell=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldContainer.SetFLabelCls(Value : String); begin
  FLabelCls := Value;
  JSCode('labelCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelClsExtra(Value : String); begin
  FLabelClsExtra := Value;
  JSCode('labelClsExtra:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelConnector(Value : String); begin
  FLabelConnector := Value;
  JSCode('labelConnector:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelEl(Value : TExtElement); begin
  FLabelEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.labelEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldContainer.SetFLabelPad(Value : Integer); begin
  FLabelPad := Value;
  JSCode('labelPad:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelSeparator(Value : String); begin
  FLabelSeparator := Value;
  JSCode('labelSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelStyle(Value : String); begin
  FLabelStyle := Value;
  JSCode('labelStyle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFLabelWidth(Value : Integer); begin
  FLabelWidth := Value;
  JSCode('labelWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFMsgTarget(Value : String); begin
  FMsgTarget := Value;
  JSCode('msgTarget:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFPreventMark(Value : Boolean); begin
  FPreventMark := Value;
  JSCode('preventMark:' + VarToJSON([Value]));
end;

procedure TExtFormFieldContainer.SetFOnErrorchange(Value : TExtFormFieldContainerOnErrorchange); begin
  if Assigned(FOnErrorchange) then
    JSCode(JSName+'.events ["errorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('errorchange', Ajax('errorchange', ['This', '%0.nm','Error', '%1'], true));
  FOnErrorchange := Value;
end;

procedure TExtFormFieldContainer.SetFOnFielderrorchange(Value : TExtFormFieldContainerOnFielderrorchange); begin
  if Assigned(FOnFielderrorchange) then
    JSCode(JSName+'.events ["fielderrorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fielderrorchange', Ajax('fielderrorchange', ['This', '%0.nm','The', '%1.nm','Error', '%2'], true));
  FOnFielderrorchange := Value;
end;

procedure TExtFormFieldContainer.SetFOnFieldvaliditychange(Value : TExtFormFieldContainerOnFieldvaliditychange); begin
  if Assigned(FOnFieldvaliditychange) then
    JSCode(JSName+'.events ["fieldvaliditychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fieldvaliditychange', Ajax('fieldvaliditychange', ['This', '%0.nm','The', '%1.nm','IsValid', '%2'], true));
  FOnFieldvaliditychange := Value;
end;

function TExtFormFieldContainer.JSClassName : string; begin
  Result := 'Ext.form.FieldContainer';
end;

procedure TExtFormFieldContainer.InitDefaults; begin
  inherited;
  FActiveErrorsTplTemplate := TExtXTemplate.CreateInternal(Self, 'activeErrorsTpl');
  FAfterBodyElList := TExtObjectList.Create(Self, 'afterBodyEl');
  FAfterBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'afterBodyEl');
  FAfterLabelTextTplList := TExtObjectList.Create(Self, 'afterLabelTextTpl');
  FAfterLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTextTpl');
  FAfterLabelTplList := TExtObjectList.Create(Self, 'afterLabelTpl');
  FAfterLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterLabelTpl');
  FAfterSubTplList := TExtObjectList.Create(Self, 'afterSubTpl');
  FAfterSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterSubTpl');
  FBeforeBodyElList := TExtObjectList.Create(Self, 'beforeBodyEl');
  FBeforeBodyElTemplate := TExtXTemplate.CreateInternal(Self, 'beforeBodyEl');
  FBeforeLabelTextTplList := TExtObjectList.Create(Self, 'beforeLabelTextTpl');
  FBeforeLabelTextTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTextTpl');
  FBeforeLabelTplList := TExtObjectList.Create(Self, 'beforeLabelTpl');
  FBeforeLabelTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeLabelTpl');
  FBeforeSubTplList := TExtObjectList.Create(Self, 'beforeSubTpl');
  FBeforeSubTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeSubTpl');
  FBodyEl := TExtElement.CreateInternal(Self, 'bodyEl');
  FErrorEl := TExtElement.CreateInternal(Self, 'errorEl');
  FFieldDefaults := TExtObject.CreateInternal(Self, 'fieldDefaults');
  FLabelAttrTplList := TExtObjectList.Create(Self, 'labelAttrTpl');
  FLabelAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'labelAttrTpl');
  FLabelCell := TExtElement.CreateInternal(Self, 'labelCell');
  FLabelConnector := ',';
  FLabelEl := TExtElement.CreateInternal(Self, 'labelEl');
end;

{$IFDEF FPC}constructor TExtFormFieldContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldContainer.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldContainer.GetActiveError : TExtFunction; begin
  JSCode(JSName + '.getActiveError();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.GetActiveErrors : TExtFunction; begin
  JSCode(JSName + '.getActiveErrors();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.GetCombinedErrors(InvalidFields : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.getCombinedErrors(' + VarToJSON(InvalidFields) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.GetInputId : TExtFunction; begin
  JSCode(JSName + '.getInputId();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.GetLabelWidth : TExtFunction; begin
  JSCode(JSName + '.getLabelWidth();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.HasActiveError : TExtFunction; begin
  JSCode(JSName + '.hasActiveError();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.HasVisibleLabel : TExtFunction; begin
  JSCode(JSName + '.hasVisibleLabel();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.InitLabelable : TExtFunction; begin
  JSCode(JSName + '.initLabelable();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.SetActiveError(Msg : String) : TExtFunction; begin
  JSCode(JSName + '.setActiveError(' + VarToJSON([Msg]) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.SetActiveErrors(Errors : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.setActiveErrors(' + VarToJSON([Errors]) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.SetFieldDefaults(Defaults : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setFieldDefaults(' + VarToJSON([Defaults, false]) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.SetFieldLabel(LabelJS : String) : TExtFunction; begin
  JSCode(JSName + '.setFieldLabel(' + VarToJSON([LabelJS]) + ');', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.TrimLabelSeparator : TExtFunction; begin
  JSCode(JSName + '.trimLabelSeparator();', 'TExtFormFieldContainer');
  Result := Self;
end;

function TExtFormFieldContainer.UnsetActiveError : TExtFunction; begin
  JSCode(JSName + '.unsetActiveError();', 'TExtFormFieldContainer');
  Result := Self;
end;

procedure TExtFormFieldContainer.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'errorchange') and Assigned(FOnErrorchange) then
    FOnErrorchange(TExtFormLabelable(ParamAsObject('This')), ParamAsString('Error'))
  else if (AEvtName = 'fielderrorchange') and Assigned(FOnFielderrorchange) then
    FOnFielderrorchange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('Error'))
  else if (AEvtName = 'fieldvaliditychange') and Assigned(FOnFieldvaliditychange) then
    FOnFieldvaliditychange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('IsValid'));
end;

function TExtLayoutComponentProgressBar.JSClassName : string; begin
  Result := 'Ext.layout.component.ProgressBar';
end;

{$IFDEF FPC}constructor TExtLayoutComponentProgressBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtContainerViewport.SetFIsViewport(Value : Boolean); begin
  FIsViewport := Value;
  JSCode(JSName + '.isViewport=' + VarToJSON([Value]) + ';');
end;

function TExtContainerViewport.JSClassName : string; begin
  Result := 'Ext.container.Viewport';
end;

{$IFDEF FPC}constructor TExtContainerViewport.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentButton.JSClassName : string; begin
  Result := 'Ext.layout.component.Button';
end;

{$IFDEF FPC}constructor TExtLayoutComponentButton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentDraw.JSClassName : string; begin
  Result := 'Ext.layout.component.Draw';
end;

{$IFDEF FPC}constructor TExtLayoutComponentDraw.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentField.JSClassName : string; begin
  Result := 'Ext.layout.component.field.Field';
end;

{$IFDEF FPC}constructor TExtLayoutComponentField.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentField.DestroyTip : TExtFunction; begin
  JSCode(JSName + '.destroyTip();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.ElementIdApplyIf : TExtFunction; begin
  JSCode(JSName + '.elementId: applyIf({ prepare();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.GetErrorStrategy : TExtFunction; begin
  JSCode(JSName + '.getErrorStrategy();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.GetLabelStrategy : TExtFunction; begin
  JSCode(JSName + '.getLabelStrategy();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.InitTip : TExtFunction; begin
  JSCode(JSName + '.initTip();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.QtipApplyIf : TExtFunction; begin
  JSCode(JSName + '.qtip: applyIf({ prepare();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.SideApplyIf : TExtFunction; begin
  JSCode(JSName + '.side: applyIf({ prepare();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.TitleApplyIf : TExtFunction; begin
  JSCode(JSName + '.title: applyIf({ prepare();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.TopExtApplyIf : TExtFunction; begin
  JSCode(JSName + '.top: Ext.applyIf({ getHeight();', 'TExtLayoutComponentField');
  Result := Self;
end;

function TExtLayoutComponentField.UnderApplyIf : TExtFunction; begin
  JSCode(JSName + '.under: applyIf({ prepare();', 'TExtLayoutComponentField');
  Result := Self;
end;

procedure TExtPanelAbstractPanel.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBody(Value : TExtDomElement); begin
  FBody := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.body=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtPanelAbstractPanel.SetFBodyBorder(Value : Boolean); begin
  FBodyBorder := Value;
  JSCode('bodyBorder:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBodyCls(Value : String); begin
  FBodyCls := Value;
  JSCode('bodyCls:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBodyClsTArrayOfString(Value : TArrayOfString); begin
  FBodyClsTArrayOfString := Value;
  JSCode('bodyCls:' + ArrayToJSON(Value));
end;

procedure TExtPanelAbstractPanel.SetFBodyPadding(Value : Integer); begin
  FBodyPadding := Value;
  JSCode('bodyPadding:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBodyPaddingString(Value : String); begin
  FBodyPaddingString := Value;
  JSCode('bodyPadding:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBodyStyle(Value : String); begin
  FBodyStyle := Value;
  if not ConfigAvailable(JSName) then
    SetBodyStyle(Value, '')
  else
    JSCode('bodyStyle:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFBodyStyleFunction(Value : TExtFunction); begin
  FBodyStyleFunction := Value;
  JSCode('bodyStyle:' + VarToJSON([Value, true]));
end;

procedure TExtPanelAbstractPanel.SetFBodyStyleObject(Value : TExtObject); begin
  FBodyStyleObject := Value;
  Value.DeleteFromGarbage;
  JSCode('bodyStyle:' + VarToJSON([Value, false]));
end;

procedure TExtPanelAbstractPanel.SetFContentPaddingProperty(Value : String); begin
  FContentPaddingProperty := Value;
  JSCode(JSName + '.contentPaddingProperty=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelAbstractPanel.SetFDefaultDockWeights(Value : TExtObject); begin
  FDefaultDockWeights := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultDockWeights:' + VarToJSON([Value, false]));
end;

procedure TExtPanelAbstractPanel.SetFDockedItems(Value : TExtObjectList); begin
  FDockedItems := Value;
  Value.DeleteFromGarbage;
  JSCode('dockedItems:' + VarToJSON([Value, false]));
end;

procedure TExtPanelAbstractPanel.SetFIsPanel(Value : Boolean); begin
  FIsPanel := Value;
  JSCode(JSName + '.isPanel=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelAbstractPanel.SetFShrinkWrapDock(Value : Boolean); begin
  FShrinkWrapDock := Value;
  JSCode('shrinkWrapDock:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFShrinkWrapDockInteger(Value : Integer); begin
  FShrinkWrapDockInteger := Value;
  JSCode('shrinkWrapDock:' + VarToJSON([Value]));
end;

procedure TExtPanelAbstractPanel.SetFOnDockedadd(Value : TExtPanelAbstractPanelOnDockedadd); begin
  if Assigned(FOnDockedadd) then
    JSCode(JSName+'.events ["dockedadd"].listeners=[];');
  if Assigned(Value) then
    AddListener('dockedadd', Ajax('dockedadd', ['This', '%0.nm','Component', '%1.nm','Index', '%2'], true));
  FOnDockedadd := Value;
end;

procedure TExtPanelAbstractPanel.SetFOnDockedremove(Value : TExtPanelAbstractPanelOnDockedremove); begin
  if Assigned(FOnDockedremove) then
    JSCode(JSName+'.events ["dockedremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('dockedremove', Ajax('dockedremove', ['This', '%0.nm','Component', '%1.nm'], true));
  FOnDockedremove := Value;
end;

function TExtPanelAbstractPanel.JSClassName : string; begin
  Result := 'Ext.panel.AbstractPanel';
end;

procedure TExtPanelAbstractPanel.InitDefaults; begin
  inherited;
  FBody := TExtDomElement.CreateInternal(Self, 'body');
  FBodyStyleObject := TExtObject.CreateInternal(Self, 'bodyStyle');
  FDefaultDockWeights := TExtObject.CreateInternal(Self, 'defaultDockWeights');
  FDockedItems := TExtObjectList.Create(Self, 'dockedItems');
end;

{$IFDEF FPC}constructor TExtPanelAbstractPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPanelAbstractPanel.AddBodyCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.addBodyCls(' + VarToJSON([Cls]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.AddDocked(Component : TExtObject; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.addDocked(' + VarToJSON([Component, false, Pos]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.AddDocked(Component : TExtObjectList; Pos : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.AddDocked(' + VarToJSON(Component) + ',' + VarToJSON([Pos]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

constructor TExtPanelAbstractPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelAbstractPanel.GetComponent(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.GetComponent(' + VarToJSON([Comp]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.GetComponent(Comp : Integer) : TExtFunction; begin
  JSCode(JSName + '.getComponent(' + VarToJSON([Comp]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.GetDockedComponent(Comp : Integer) : TExtFunction; begin
  JSCode(JSName + '.getDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.GetDockedComponent(Comp : String) : TExtFunction; begin
  JSCode(JSName + '.GetDockedComponent(' + VarToJSON([Comp]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.GetDockedItems(Selector : String; BeforeBody : Boolean) : TExtFunction; begin
  JSCode(JSName + '.getDockedItems(' + VarToJSON([Selector, BeforeBody]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.InsertDocked(Pos : Integer; Component : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.insertDocked(' + VarToJSON([Pos, Component, false]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.InsertDocked(Pos : Integer; Component : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.InsertDocked(' + VarToJSON([Pos]) + ',' + VarToJSON(Component) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.RemoveBodyCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.removeBodyCls(' + VarToJSON([Cls]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.RemoveDocked(Item : TExtComponent; AutoDestroy : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.removeDocked(' + VarToJSON([Item, false, AutoDestroy]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

function TExtPanelAbstractPanel.SetBodyStyle(Style : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.setBodyStyle(' + VarToJSON([Style, Value]) + ');', 'TExtPanelAbstractPanel');
  Result := Self;
end;

destructor TExtPanelAbstractPanel.Destroy; begin
  try
    FBody.Free;
    FBodyStyleObject.Free;
    FDefaultDockWeights.Free;
    FDockedItems.Free;
  except end;
  inherited;
end;

procedure TExtPanelAbstractPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'dockedadd') and Assigned(FOnDockedadd) then
    FOnDockedadd(TExtContainerDockingContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')), ParamAsInteger('Index'))
  else if (AEvtName = 'dockedremove') and Assigned(FOnDockedremove) then
    FOnDockedremove(TExtContainerDockingContainer(ParamAsObject('This')), TExtComponent(ParamAsObject('Component')));
end;

procedure TExtLayoutContainerHBox.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerHBox.SetFAlignRoundingMethod(Value : TAlignRoundingMethodEnum); begin
  FAlignRoundingMethod := Value;
  JSCode('alignRoundingMethod:"' + EnumToJSString(TypeInfo(TAlignRoundingMethodEnum), ord(Value)) + '"');
end;

procedure TExtLayoutContainerHBox.SetFConstrainAlign(Value : Boolean); begin
  FConstrainAlign := Value;
  JSCode('constrainAlign:' + VarToJSON([Value]));
end;

function TExtLayoutContainerHBox.JSClassName : string; begin
  Result := 'Ext.layout.container.HBox';
end;

{$IFDEF FPC}constructor TExtLayoutContainerHBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerVBox.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerVBox.SetFAlignRoundingMethod(Value : TAlignRoundingMethodEnum); begin
  FAlignRoundingMethod := Value;
  JSCode('alignRoundingMethod:"' + EnumToJSString(TypeInfo(TAlignRoundingMethodEnum), ord(Value)) + '"');
end;

procedure TExtLayoutContainerVBox.SetFConstrainAlign(Value : Boolean); begin
  FConstrainAlign := Value;
  JSCode('constrainAlign:' + VarToJSON([Value]));
end;

function TExtLayoutContainerVBox.JSClassName : string; begin
  Result := 'Ext.layout.container.VBox';
end;

{$IFDEF FPC}constructor TExtLayoutContainerVBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtPanelHeader.SetFGlyph(Value : Integer); begin
  FGlyph := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFGlyphString(Value : String); begin
  FGlyphString := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFIsHeader(Value : Boolean); begin
  FIsHeader := Value;
  JSCode(JSName + '.isHeader=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelHeader.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFTitleAlign(Value : String); begin
  FTitleAlign := Value;
  JSCode('titleAlign:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFTitlePosition(Value : Integer); begin
  FTitlePosition := Value;
  JSCode('titlePosition:' + VarToJSON([Value]));
end;

procedure TExtPanelHeader.SetFOnClick(Value : TExtPanelHeaderOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['This', '%0.nm','E', '%1.nm'], true));
  FOnClick := Value;
end;

procedure TExtPanelHeader.SetFOnDblclick(Value : TExtPanelHeaderOnDblclick); begin
  if Assigned(FOnDblclick) then
    JSCode(JSName+'.events ["dblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('dblclick', Ajax('dblclick', ['This', '%0.nm','E', '%1.nm'], true));
  FOnDblclick := Value;
end;

function TExtPanelHeader.JSClassName : string; begin
  Result := 'Ext.panel.Header';
end;

procedure TExtPanelHeader.InitDefaults; begin
  inherited;
  FTitleAlign := 's natural * behavior depending on the css direction property - `';
end;

{$IFDEF FPC}constructor TExtPanelHeader.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPanelHeader.AddTool(Tool : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.addTool(' + VarToJSON([Tool, false]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

constructor TExtPanelHeader.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelHeader.GetTools : TExtFunction; begin
  JSCode(JSName + '.getTools();', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetGlyph(Glyph : String) : TExtFunction; begin
  JSCode(JSName + '.SetGlyph(' + VarToJSON([Glyph]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetGlyph(Glyph : Integer) : TExtFunction; begin
  JSCode(JSName + '.setGlyph(' + VarToJSON([Glyph]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetIcon(Icon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetIconCls(Cls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([Cls]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

function TExtPanelHeader.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtPanelHeader');
  Result := Self;
end;

procedure TExtPanelHeader.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtPanelHeader(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'dblclick') and Assigned(FOnDblclick) then
    FOnDblclick(TExtPanelHeader(ParamAsObject('This')), TExtEventObject(ParamAsObject('E')));
end;

procedure TExtLayoutContainerAnchor.SetFAnchor(Value : String); begin
  FAnchor := Value;
  JSCode('anchor:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAnchor.SetFAnchorSize(Value : Integer); begin
  FAnchorSize := Value;
  JSCode('anchorSize:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAnchor.SetFAnchorSizeObject(Value : TExtObject); begin
  FAnchorSizeObject := Value;
  Value.DeleteFromGarbage;
  JSCode('anchorSize:' + VarToJSON([Value, false]));
end;

procedure TExtLayoutContainerAnchor.SetFDefaultAnchor(Value : String); begin
  FDefaultAnchor := Value;
  JSCode('defaultAnchor:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAnchor.JSClassName : string; begin
  Result := 'Ext.layout.container.Anchor';
end;

procedure TExtLayoutContainerAnchor.InitDefaults; begin
  inherited;
  FAnchorSizeObject := TExtObject.CreateInternal(Self, 'anchorSize');
end;

{$IFDEF FPC}constructor TExtLayoutContainerAnchor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtLayoutContainerAnchor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtLayoutContainerAnchor.Destroy; begin
  try
    FAnchorSizeObject.Free;
  except end;
  inherited;
end;

procedure TExtLayoutContainerCard.SetFDeferredRender(Value : Boolean); begin
  FDeferredRender := Value;
  JSCode('deferredRender:' + VarToJSON([Value]));
end;

function TExtLayoutContainerCard.JSClassName : string; begin
  Result := 'Ext.layout.container.Card';
end;

{$IFDEF FPC}constructor TExtLayoutContainerCard.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutContainerCard.GetActiveItem : TExtFunction; begin
  JSCode(JSName + '.getActiveItem();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.GetNext : TExtFunction; begin
  JSCode(JSName + '.getNext();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.GetPrev : TExtFunction; begin
  JSCode(JSName + '.getPrev();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.Next : TExtFunction; begin
  JSCode(JSName + '.next();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.Prev : TExtFunction; begin
  JSCode(JSName + '.prev();', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.SetActiveItem(' + VarToJSON([NewCard, false]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : String) : TExtFunction; begin
  JSCode(JSName + '.SetActiveItem(' + VarToJSON([NewCard]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerCard.SetActiveItem(NewCard : Integer) : TExtFunction; begin
  JSCode(JSName + '.setActiveItem(' + VarToJSON([NewCard]) + ');', 'TExtLayoutContainerCard');
  Result := Self;
end;

function TExtLayoutContainerColumn.JSClassName : string; begin
  Result := 'Ext.layout.container.Column';
end;

{$IFDEF FPC}constructor TExtLayoutContainerColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentBoundList.JSClassName : string; begin
  Result := 'Ext.layout.component.BoundList';
end;

{$IFDEF FPC}constructor TExtLayoutComponentBoundList.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyLocalStorage.JSClassName : string; begin
  Result := 'Ext.data.proxy.LocalStorage';
end;

{$IFDEF FPC}constructor TExtDataProxyLocalStorage.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtChartSeriesColumn.SetFAxis(Value : String); begin
  FAxis := Value;
  JSCode('axis:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesColumn.SetFXPadding(Value : Integer); begin
  FXPadding := Value;
  JSCode('xPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesColumn.SetFXPaddingObject(Value : TExtObject); begin
  FXPaddingObject := Value;
  Value.DeleteFromGarbage;
  JSCode('xPadding:' + VarToJSON([Value, false]));
end;

procedure TExtChartSeriesColumn.SetFYPadding(Value : Integer); begin
  FYPadding := Value;
  JSCode('yPadding:' + VarToJSON([Value]));
end;

procedure TExtChartSeriesColumn.SetFYPaddingObject(Value : TExtObject); begin
  FYPaddingObject := Value;
  Value.DeleteFromGarbage;
  JSCode('yPadding:' + VarToJSON([Value, false]));
end;

function TExtChartSeriesColumn.JSClassName : string; begin
  Result := 'Ext.chart.series.Column';
end;

procedure TExtChartSeriesColumn.InitDefaults; begin
  inherited;
  FXPaddingObject := TExtObject.CreateInternal(Self, 'xPadding');
  FYPaddingObject := TExtObject.CreateInternal(Self, 'yPadding');
end;

{$IFDEF FPC}constructor TExtChartSeriesColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtChartSeriesColumn.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtChartSeriesColumn.Destroy; begin
  try
    FXPaddingObject.Free;
    FYPaddingObject.Free;
  except end;
  inherited;
end;

function TExtDdDropZone.JSClassName : string; begin
  Result := 'Ext.dd.DropZone';
end;

{$IFDEF FPC}constructor TExtDdDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDdDropZone.GetTargetFromEvent(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getTargetFromEvent(' + VarToJSON([E, false]) + ');', 'TExtDdDropZone');
  Result := Self;
end;

function TExtDdDropZone.OnNodeEnter(NodeData : TExtObject; Source : TExtDdDragSource; E : TEvent; Data : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.onNodeEnter(' + VarToJSON([NodeData, false, Source, false, E, false, Data, false]) + ');', 'TExtDdDropZone');
  Result := Self;
end;

procedure TExtDataProxyRest.SetFActionMethods(Value : TExtObject); begin
  FActionMethods := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.actionMethods=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDataProxyRest.SetFAppendId(Value : Boolean); begin
  FAppendId := Value;
  JSCode('appendId:' + VarToJSON([Value]));
end;

procedure TExtDataProxyRest.SetFBatchActions(Value : Boolean); begin
  FBatchActions := Value;
  JSCode('batchActions:' + VarToJSON([Value]));
end;

procedure TExtDataProxyRest.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtDataProxyRest.JSClassName : string; begin
  Result := 'Ext.data.proxy.Rest';
end;

procedure TExtDataProxyRest.InitDefaults; begin
  inherited;
  FActionMethods := TExtObject.CreateInternal(Self, 'actionMethods');
  FAppendId := true;
end;

{$IFDEF FPC}constructor TExtDataProxyRest.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtDataProxyRest.BuildUrl(Request : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.buildUrl(' + VarToJSON([Request, false]) + ');', 'TExtDataProxyRest');
  Result := Self;
end;

constructor TExtDataProxyRest.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtDataProxyRest.Destroy; begin
  try
    FActionMethods.Free;
  except end;
  inherited;
end;

function TExtChartLegendItem.JSClassName : string; begin
  Result := 'Ext.chart.LegendItem';
end;

{$IFDEF FPC}constructor TExtChartLegendItem.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtChartLegendItem.CreateLegend : TExtFunction; begin
  JSCode(JSName + '.createLegend();', 'TExtChartLegendItem');
  Result := Self;
end;

function TExtChartLegendItem.UpdatePosition(RelativeTo : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.updatePosition(' + VarToJSON([RelativeTo, false]) + ');', 'TExtChartLegendItem');
  Result := Self;
end;

procedure TExtFormFieldSet.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxCmp(Value : TExtFormFieldCheckbox); begin
  FCheckboxCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.checkboxCmp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSet.SetFCheckboxName(Value : String); begin
  FCheckboxName := Value;
  JSCode('checkboxName:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCheckboxToggle(Value : Boolean); begin
  FCheckboxToggle := Value;
  JSCode('checkboxToggle:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFFieldDefaults(Value : TExtObject); begin
  FFieldDefaults := Value;
  Value.DeleteFromGarbage;
  JSCode('fieldDefaults:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldSet.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtFormFieldSet.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldSet.SetFLegend(Value : TExtComponent); begin
  FLegend := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.legend=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSet.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFToggleCmp(Value : TExtPanelTool); begin
  FToggleCmp := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.toggleCmp=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSet.SetFToggleOnTitleClick(Value : Boolean); begin
  FToggleOnTitleClick := Value;
  JSCode('toggleOnTitleClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSet.SetFOnBeforecollapse(Value : TExtFormFieldSetOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', ['F', '%0.nm'], true));
  FOnBeforecollapse := Value;
end;

procedure TExtFormFieldSet.SetFOnBeforeexpand(Value : TExtFormFieldSetOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', ['F', '%0.nm'], true));
  FOnBeforeexpand := Value;
end;

procedure TExtFormFieldSet.SetFOnCollapse(Value : TExtFormFieldSetOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['F', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtFormFieldSet.SetFOnExpand(Value : TExtFormFieldSetOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['F', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtFormFieldSet.SetFOnFielderrorchange(Value : TExtFormFieldSetOnFielderrorchange); begin
  if Assigned(FOnFielderrorchange) then
    JSCode(JSName+'.events ["fielderrorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fielderrorchange', Ajax('fielderrorchange', ['This', '%0.nm','The', '%1.nm','Error', '%2'], true));
  FOnFielderrorchange := Value;
end;

procedure TExtFormFieldSet.SetFOnFieldvaliditychange(Value : TExtFormFieldSetOnFieldvaliditychange); begin
  if Assigned(FOnFieldvaliditychange) then
    JSCode(JSName+'.events ["fieldvaliditychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fieldvaliditychange', Ajax('fieldvaliditychange', ['This', '%0.nm','The', '%1.nm','IsValid', '%2'], true));
  FOnFieldvaliditychange := Value;
end;

function TExtFormFieldSet.JSClassName : string; begin
  Result := 'Ext.form.FieldSet';
end;

procedure TExtFormFieldSet.InitDefaults; begin
  inherited;
  FCheckboxCmp := TExtFormFieldCheckbox.CreateInternal(Self, 'checkboxCmp');
  FFieldDefaults := TExtObject.CreateInternal(Self, 'fieldDefaults');
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
  FLegend := TExtComponent.CreateInternal(Self, 'legend');
  FToggleCmp := TExtPanelTool.CreateInternal(Self, 'toggleCmp');
end;

{$IFDEF FPC}constructor TExtFormFieldSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldSet.Collapse : TExtFunction; begin
  JSCode(JSName + '.collapse();', 'TExtFormFieldSet');
  Result := Self;
end;

constructor TExtFormFieldSet.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldSet.Expand : TExtFunction; begin
  JSCode(JSName + '.expand();', 'TExtFormFieldSet');
  Result := Self;
end;

function TExtFormFieldSet.SetTitle(Title : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([Title]) + ');', 'TExtFormFieldSet');
  Result := Self;
end;

function TExtFormFieldSet.Toggle : TExtFunction; begin
  JSCode(JSName + '.toggle();', 'TExtFormFieldSet');
  Result := Self;
end;

destructor TExtFormFieldSet.Destroy; begin
  try
    FCheckboxCmp.Free;
    FFieldDefaults.Free;
    FLayoutObject.Free;
    FLegend.Free;
    FToggleCmp.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldSet.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse(TExtFormFieldSet(ParamAsObject('F')))
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand(TExtFormFieldSet(ParamAsObject('F')))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtFormFieldSet(ParamAsObject('F')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtFormFieldSet(ParamAsObject('F')))
  else if (AEvtName = 'fielderrorchange') and Assigned(FOnFielderrorchange) then
    FOnFielderrorchange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('Error'))
  else if (AEvtName = 'fieldvaliditychange') and Assigned(FOnFieldvaliditychange) then
    FOnFieldvaliditychange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('IsValid'));
end;

procedure TExtFormFieldRadio.SetFFocusCls(Value : String); begin
  FFocusCls := Value;
  JSCode('focusCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldRadio.SetFIsRadio(Value : Boolean); begin
  FIsRadio := Value;
  JSCode(JSName + '.isRadio=' + VarToJSON([Value]) + ';');
end;

function TExtFormFieldRadio.JSClassName : string; begin
  Result := 'Ext.form.field.Radio';
end;

{$IFDEF FPC}constructor TExtFormFieldRadio.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldRadio.GetGroupValue : TExtFunction; begin
  JSCode(JSName + '.getGroupValue();', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.GetSubmitValue : TExtFunction; begin
  JSCode(JSName + '.getSubmitValue();', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtFormFieldRadio.SetValue(Value : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldRadio');
  Result := Self;
end;

function TExtGridRowEditorButtons.JSClassName : string; begin
  Result := 'Ext.grid.RowEditorButtons';
end;

{$IFDEF FPC}constructor TExtGridRowEditorButtons.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtDdDragSource.SetFAnimRepair(Value : Boolean); begin
  FAnimRepair := Value;
  JSCode('animRepair:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFDdGroup(Value : String); begin
  FDdGroup := Value;
  JSCode('ddGroup:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFDropAllowed(Value : String); begin
  FDropAllowed := Value;
  JSCode('dropAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFDropNotAllowed(Value : String); begin
  FDropNotAllowed := Value;
  JSCode('dropNotAllowed:' + VarToJSON([Value]));
end;

procedure TExtDdDragSource.SetFRepairHighlightColor(Value : String); begin
  FRepairHighlightColor := Value;
  JSCode('repairHighlightColor:' + VarToJSON([Value]));
end;

function TExtDdDragSource.JSClassName : string; begin
  Result := 'Ext.dd.DragSource';
end;

{$IFDEF FPC}constructor TExtDdDragSource.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragSource.Create(El : THTMLElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragSource.Create(El : TExtElement; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragSource.Create(El : String; Config : TExtObject = nil); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, Config, false]) + ');');
  InitDefaults;
end;

function TExtDdDragSource.GetDragData : TExtFunction; begin
  JSCode(JSName + '.getDragData();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtDdDragSource.GetProxy : TExtFunction; begin
  JSCode(JSName + '.getProxy();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtDdDragSource.HideProxy : TExtFunction; begin
  JSCode(JSName + '.hideProxy();', 'TExtDdDragSource');
  Result := Self;
end;

function TExtLayoutComponentBody.JSClassName : string; begin
  Result := 'Ext.layout.component.Body';
end;

{$IFDEF FPC}constructor TExtLayoutComponentBody.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormCheckboxGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumns(Value : Integer); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsString(Value : String); begin
  FColumnsString := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFColumnsTArrayOfInteger(Value : TArrayOfInteger); begin
  FColumnsTArrayOfInteger := Value;
  JSCode('columns:' + ArrayToJSON(Value));
end;

procedure TExtFormCheckboxGroup.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFIsFormField(Value : Boolean); begin
  FIsFormField := Value;
  JSCode(JSName + '.isFormField=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormCheckboxGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFItemsList(Value : TExtObjectList); begin
  FItemsList := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormCheckboxGroup.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFValidateOnChange(Value : Boolean); begin
  FValidateOnChange := Value;
  JSCode('validateOnChange:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtFormCheckboxGroup.SetFVertical(Value : Boolean); begin
  FVertical := Value;
  JSCode('vertical:' + VarToJSON([Value]));
end;

procedure TExtFormCheckboxGroup.SetFOnChange(Value : TExtFormCheckboxGroupOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','NewValue', '%1.nm','OldValue', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtFormCheckboxGroup.SetFOnDirtychange(Value : TExtFormCheckboxGroupOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', ['This', '%0.nm','IsDirty', '%1'], true));
  FOnDirtychange := Value;
end;

procedure TExtFormCheckboxGroup.SetFOnValiditychange(Value : TExtFormCheckboxGroupOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', ['This', '%0.nm','IsValid', '%1'], true));
  FOnValiditychange := Value;
end;

function TExtFormCheckboxGroup.JSClassName : string; begin
  Result := 'Ext.form.CheckboxGroup';
end;

procedure TExtFormCheckboxGroup.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
  FItemsList := TExtObjectList.Create(Self, 'items');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
  FValue := TExtObject.CreateInternal(Self, 'value');
end;

{$IFDEF FPC}constructor TExtFormCheckboxGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormCheckboxGroup.BatchChanges(Fn : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.batchChanges(' + VarToJSON([Fn, false]) + ');', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

constructor TExtFormCheckboxGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormCheckboxGroup.ExtractFileInput : TExtFunction; begin
  JSCode(JSName + '.extractFileInput();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetChecked : TExtFunction; begin
  JSCode(JSName + '.getChecked();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetErrors : TExtFunction; begin
  JSCode(JSName + '.getErrors();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetModelData : TExtFunction; begin
  JSCode(JSName + '.getModelData();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetSubmitData : TExtFunction; begin
  JSCode(JSName + '.getSubmitData();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.InitField : TExtFunction; begin
  JSCode(JSName + '.initField();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.InitValue : TExtFunction; begin
  JSCode(JSName + '.initValue();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isEqual(' + VarToJSON([Value1, false, Value2, false]) + ');', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.IsFileUpload : TExtFunction; begin
  JSCode(JSName + '.isFileUpload();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.ResetOriginalValue : TExtFunction; begin
  JSCode(JSName + '.resetOriginalValue();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormCheckboxGroup');
  Result := Self;
end;

function TExtFormCheckboxGroup.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormCheckboxGroup');
  Result := Self;
end;

destructor TExtFormCheckboxGroup.Destroy; begin
  try
    FItems.Free;
    FItemsList.Free;
    FOriginalValue.Free;
    FValue.Free;
  except end;
  inherited;
end;

procedure TExtFormCheckboxGroup.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormField(ParamAsObject('This')), TExtObject(ParamAsObject('NewValue')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsDirty'))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsValid'));
end;

procedure TExtFormFieldSpinner.SetFKeyNavEnabled(Value : Boolean); begin
  FKeyNavEnabled := Value;
  JSCode('keyNavEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFMouseWheelEnabled(Value : Boolean); begin
  FMouseWheelEnabled := Value;
  JSCode('mouseWheelEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFRepeatTriggerClick(Value : Boolean); begin
  FRepeatTriggerClick := Value;
  JSCode('repeatTriggerClick:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFSpinDownEl(Value : TExtElement); begin
  FSpinDownEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.spinDownEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSpinner.SetFSpinDownEnabled(Value : Boolean); begin
  FSpinDownEnabled := Value;
  if not ConfigAvailable(JSName) then
    SetSpinDownEnabled(Value)
  else
    JSCode('spinDownEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFSpinUpEl(Value : TExtElement); begin
  FSpinUpEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.spinUpEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldSpinner.SetFSpinUpEnabled(Value : Boolean); begin
  FSpinUpEnabled := Value;
  if not ConfigAvailable(JSName) then
    SetSpinUpEnabled(Value)
  else
    JSCode('spinUpEnabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldSpinner.SetFOnSpin(Value : TExtFormFieldSpinnerOnSpin); begin
  if Assigned(FOnSpin) then
    JSCode(JSName+'.events ["spin"].listeners=[];');
  if Assigned(Value) then
    AddListener('spin', Ajax('spin', ['This', '%0.nm','Direction', '%1'], true));
  FOnSpin := Value;
end;

procedure TExtFormFieldSpinner.SetFOnSpindown(Value : TExtFormFieldSpinnerOnSpindown); begin
  if Assigned(FOnSpindown) then
    JSCode(JSName+'.events ["spindown"].listeners=[];');
  if Assigned(Value) then
    AddListener('spindown', Ajax('spindown', ['This', '%0.nm'], true));
  FOnSpindown := Value;
end;

procedure TExtFormFieldSpinner.SetFOnSpinup(Value : TExtFormFieldSpinnerOnSpinup); begin
  if Assigned(FOnSpinup) then
    JSCode(JSName+'.events ["spinup"].listeners=[];');
  if Assigned(Value) then
    AddListener('spinup', Ajax('spinup', ['This', '%0.nm'], true));
  FOnSpinup := Value;
end;

function TExtFormFieldSpinner.JSClassName : string; begin
  Result := 'Ext.form.field.Spinner';
end;

procedure TExtFormFieldSpinner.InitDefaults; begin
  inherited;
  FKeyNavEnabled := true;
  FMouseWheelEnabled := true;
  FRepeatTriggerClick := true;
  FSpinDownEl := TExtElement.CreateInternal(Self, 'spinDownEl');
  FSpinDownEnabled := true;
  FSpinUpEl := TExtElement.CreateInternal(Self, 'spinUpEl');
  FSpinUpEnabled := true;
end;

{$IFDEF FPC}constructor TExtFormFieldSpinner.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldSpinner.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldSpinner.GetTriggerWidth : TExtFunction; begin
  JSCode(JSName + '.getTriggerWidth();', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SetSpinDownEnabled(Enabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setSpinDownEnabled(' + VarToJSON([Enabled]) + ');', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SetSpinUpEnabled(Enabled : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setSpinUpEnabled(' + VarToJSON([Enabled]) + ');', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SpinDown : TExtFunction; begin
  JSCode(JSName + '.spinDown();', 'TExtFormFieldSpinner');
  Result := Self;
end;

function TExtFormFieldSpinner.SpinUp : TExtFunction; begin
  JSCode(JSName + '.spinUp();', 'TExtFormFieldSpinner');
  Result := Self;
end;

destructor TExtFormFieldSpinner.Destroy; begin
  try
    FSpinDownEl.Free;
    FSpinUpEl.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldSpinner.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'spin') and Assigned(FOnSpin) then
    FOnSpin(TExtFormFieldSpinner(ParamAsObject('This')), ParamAsString('Direction'))
  else if (AEvtName = 'spindown') and Assigned(FOnSpindown) then
    FOnSpindown(TExtFormFieldSpinner(ParamAsObject('This')))
  else if (AEvtName = 'spinup') and Assigned(FOnSpinup) then
    FOnSpinup(TExtFormFieldSpinner(ParamAsObject('This')));
end;

procedure TExtFormFieldFile.SetFButton(Value : TExtButton); begin
  FButton := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.button=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldFile.SetFButtonConfig(Value : TExtObject); begin
  FButtonConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('buttonConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldFile.SetFButtonMargin(Value : Integer); begin
  FButtonMargin := Value;
  JSCode('buttonMargin:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFButtonOnly(Value : Boolean); begin
  FButtonOnly := Value;
  JSCode('buttonOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFButtonText(Value : String); begin
  FButtonText := Value;
  JSCode('buttonText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFClearOnSubmit(Value : Boolean); begin
  FClearOnSubmit := Value;
  JSCode('clearOnSubmit:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFFieldBodyCls(Value : String); begin
  FFieldBodyCls := Value;
  JSCode('fieldBodyCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFFileInputEl(Value : TExtElement); begin
  FFileInputEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.fileInputEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldFile.SetFReadOnly(Value : Boolean); begin
  FReadOnly := Value;
  JSCode('readOnly:' + VarToJSON([Value]));
end;

procedure TExtFormFieldFile.SetFOnChange(Value : TExtFormFieldFileOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','Value', '%1'], true));
  FOnChange := Value;
end;

function TExtFormFieldFile.JSClassName : string; begin
  Result := 'Ext.form.field.File';
end;

procedure TExtFormFieldFile.InitDefaults; begin
  inherited;
  FButton := TExtButton.CreateInternal(Self, 'button');
  FButtonConfig := TExtObject.CreateInternal(Self, 'buttonConfig');
  FFileInputEl := TExtElement.CreateInternal(Self, 'fileInputEl');
end;

{$IFDEF FPC}constructor TExtFormFieldFile.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldFile.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldFile.GetTriggerMarkup : TExtFunction; begin
  JSCode(JSName + '.getTriggerMarkup();', 'TExtFormFieldFile');
  Result := Self;
end;

function TExtFormFieldFile.SetValueExtEmptyFnReset : TExtFunction; begin
  JSCode(JSName + '.setValue: Ext.emptyFn, reset();', 'TExtFormFieldFile');
  Result := Self;
end;

destructor TExtFormFieldFile.Destroy; begin
  try
    FButton.Free;
    FButtonConfig.Free;
    FFileInputEl.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldFile.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormFieldFile(ParamAsObject('This')), ParamAsString('Value'));
end;

procedure TExtToolbarPaging.SetFAfterPageText(Value : String); begin
  FAfterPageText := Value;
  JSCode('afterPageText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFBeforePageText(Value : String); begin
  FBeforePageText := Value;
  JSCode('beforePageText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFDisplayInfo(Value : Boolean); begin
  FDisplayInfo := Value;
  JSCode('displayInfo:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFDisplayMsg(Value : String); begin
  FDisplayMsg := Value;
  JSCode('displayMsg:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFEmptyMsg(Value : String); begin
  FEmptyMsg := Value;
  JSCode('emptyMsg:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFFirstText(Value : String); begin
  FFirstText := Value;
  JSCode('firstText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFInputItemWidth(Value : Integer); begin
  FInputItemWidth := Value;
  JSCode('inputItemWidth:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFLastText(Value : String); begin
  FLastText := Value;
  JSCode('lastText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFNextText(Value : String); begin
  FNextText := Value;
  JSCode('nextText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFPrependButtons(Value : Boolean); begin
  FPrependButtons := Value;
  JSCode('prependButtons:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFPrevText(Value : String); begin
  FPrevText := Value;
  JSCode('prevText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFRefreshText(Value : String); begin
  FRefreshText := Value;
  JSCode('refreshText:' + VarToJSON([Value]));
end;

procedure TExtToolbarPaging.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtToolbarPaging.SetFOnBeforechange(Value : TExtToolbarPagingOnBeforechange); begin
  if Assigned(FOnBeforechange) then
    JSCode(JSName+'.events ["beforechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforechange', Ajax('beforechange', ['This', '%0.nm','Page', '%1'], true));
  FOnBeforechange := Value;
end;

procedure TExtToolbarPaging.SetFOnChange(Value : TExtToolbarPagingOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','PageData', '%1.nm'], true));
  FOnChange := Value;
end;

function TExtToolbarPaging.JSClassName : string; begin
  Result := 'Ext.toolbar.Paging';
end;

procedure TExtToolbarPaging.InitDefaults; begin
  inherited;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtToolbarPaging.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtToolbarPaging.Bind(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.bind(' + VarToJSON([Store, false]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

constructor TExtToolbarPaging.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtToolbarPaging.DoRefresh : TExtFunction; begin
  JSCode(JSName + '.doRefresh();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MoveFirst : TExtFunction; begin
  JSCode(JSName + '.moveFirst();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MoveLast : TExtFunction; begin
  JSCode(JSName + '.moveLast();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MoveNext : TExtFunction; begin
  JSCode(JSName + '.moveNext();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.MovePrevious : TExtFunction; begin
  JSCode(JSName + '.movePrevious();', 'TExtToolbarPaging');
  Result := Self;
end;

function TExtToolbarPaging.Unbind(Store : TExtDataStore) : TExtFunction; begin
  JSCode(JSName + '.unbind(' + VarToJSON([Store, false]) + ');', 'TExtToolbarPaging');
  Result := Self;
end;

destructor TExtToolbarPaging.Destroy; begin
  try
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtToolbarPaging.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforechange') and Assigned(FOnBeforechange) then
    FOnBeforechange(TExtToolbarPaging(ParamAsObject('This')), ParamAsInteger('Page'))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtToolbarPaging(ParamAsObject('This')), TExtObject(ParamAsObject('PageData')));
end;

procedure TExtFormFieldPicker.SetFEditable(Value : Boolean); begin
  FEditable := Value;
  JSCode('editable:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFIsExpanded(Value : Boolean); begin
  FIsExpanded := Value;
  JSCode(JSName + '.isExpanded=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldPicker.SetFMatchFieldWidth(Value : Boolean); begin
  FMatchFieldWidth := Value;
  JSCode('matchFieldWidth:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFOpenCls(Value : String); begin
  FOpenCls := Value;
  JSCode('openCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFPickerAlign(Value : String); begin
  FPickerAlign := Value;
  JSCode('pickerAlign:' + VarToJSON([Value]));
end;

procedure TExtFormFieldPicker.SetFOnCollapse(Value : TExtFormFieldPickerOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['Field', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtFormFieldPicker.SetFOnExpand(Value : TExtFormFieldPickerOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['Field', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtFormFieldPicker.SetFOnSelect(Value : TExtFormFieldPickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['Field', '%0.nm','Value', '%1.nm'], true));
  FOnSelect := Value;
end;

function TExtFormFieldPicker.JSClassName : string; begin
  Result := 'Ext.form.field.Picker';
end;

procedure TExtFormFieldPicker.InitDefaults; begin
  inherited;
  FMatchFieldWidth := true;
  FPickerAlign := 'tl-bl?';
end;

{$IFDEF FPC}constructor TExtFormFieldPicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldPicker.Collapse : TExtFunction; begin
  JSCode(JSName + '.collapse();', 'TExtFormFieldPicker');
  Result := Self;
end;

constructor TExtFormFieldPicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldPicker.Expand : TExtFunction; begin
  JSCode(JSName + '.expand();', 'TExtFormFieldPicker');
  Result := Self;
end;

function TExtFormFieldPicker.GetPicker : TExtFunction; begin
  JSCode(JSName + '.getPicker();', 'TExtFormFieldPicker');
  Result := Self;
end;

procedure TExtFormFieldPicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtFormFieldPicker(ParamAsObject('Field')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtFormFieldPicker(ParamAsObject('Field')))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormFieldPicker(ParamAsObject('Field')), TExtObject(ParamAsObject('Value')));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTpl(Value : String); begin
  FAfterIFrameTpl := Value;
  JSCode('afterIFrameTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTplList(Value : TExtObjectList); begin
  FAfterIFrameTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterIFrameTplTemplate(Value : TExtXTemplate); begin
  FAfterIFrameTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTpl(Value : String); begin
  FAfterTextAreaTpl := Value;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTplList(Value : TExtObjectList); begin
  FAfterTextAreaTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFAfterTextAreaTplTemplate(Value : TExtXTemplate); begin
  FAfterTextAreaTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('afterTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTpl(Value : String); begin
  FBeforeIFrameTpl := Value;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTplList(Value : TExtObjectList); begin
  FBeforeIFrameTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeIFrameTplTemplate(Value : TExtXTemplate); begin
  FBeforeIFrameTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeIFrameTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTpl(Value : String); begin
  FBeforeTextAreaTpl := Value;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTplList(Value : TExtObjectList); begin
  FBeforeTextAreaTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFBeforeTextAreaTplTemplate(Value : TExtXTemplate); begin
  FBeforeTextAreaTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('beforeTextAreaTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFButtonTips(Value : TExtObject); begin
  FButtonTips := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.buttonTips=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldHtmlEditor.SetFCreateLinkText(Value : String); begin
  FCreateLinkText := Value;
  JSCode('createLinkText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFDefaultButtonUI(Value : String); begin
  FDefaultButtonUI := Value;
  JSCode('defaultButtonUI:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFDefaultLinkValue(Value : String); begin
  FDefaultLinkValue := Value;
  JSCode('defaultLinkValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFDefaultValue(Value : String); begin
  FDefaultValue := Value;
  JSCode('defaultValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableAlignments(Value : Boolean); begin
  FEnableAlignments := Value;
  JSCode('enableAlignments:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableColors(Value : Boolean); begin
  FEnableColors := Value;
  JSCode('enableColors:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFont(Value : Boolean); begin
  FEnableFont := Value;
  JSCode('enableFont:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFontSize(Value : Boolean); begin
  FEnableFontSize := Value;
  JSCode('enableFontSize:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableFormat(Value : Boolean); begin
  FEnableFormat := Value;
  JSCode('enableFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableLinks(Value : Boolean); begin
  FEnableLinks := Value;
  JSCode('enableLinks:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableLists(Value : Boolean); begin
  FEnableLists := Value;
  JSCode('enableLists:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFEnableSourceEdit(Value : Boolean); begin
  FEnableSourceEdit := Value;
  JSCode('enableSourceEdit:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFFontFamilies(Value : TArrayOfString); begin
  FFontFamilies := Value;
  JSCode('fontFamilies:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTpl(Value : String); begin
  FIframeAttrTpl := Value;
  JSCode('iframeAttrTpl:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTplList(Value : TExtObjectList); begin
  FIframeAttrTplList := Value;
  Value.DeleteFromGarbage;
  JSCode('iframeAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFIframeAttrTplTemplate(Value : TExtXTemplate); begin
  FIframeAttrTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('iframeAttrTpl:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFIsFormField(Value : Boolean); begin
  FIsFormField := Value;
  JSCode(JSName + '.isFormField=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldHtmlEditor.SetFName(Value : String); begin
  FName := Value;
  JSCode('name:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFOriginalValue(Value : TExtObject); begin
  FOriginalValue := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.originalValue=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtFormFieldHtmlEditor.SetFSubmitValue(Value : Boolean); begin
  FSubmitValue := Value;
  JSCode('submitValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFValidateOnChange(Value : Boolean); begin
  FValidateOnChange := Value;
  JSCode('validateOnChange:' + VarToJSON([Value]));
end;

procedure TExtFormFieldHtmlEditor.SetFValue(Value : TExtObject); begin
  FValue := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetValue(Value)
  else
    JSCode('value:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldHtmlEditor.SetFOnActivate(Value : TExtFormFieldHtmlEditorOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnBeforepush(Value : TExtFormFieldHtmlEditorOnBeforepush); begin
  if Assigned(FOnBeforepush) then
    JSCode(JSName+'.events ["beforepush"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforepush', Ajax('beforepush', ['This', '%0.nm','Html', '%1'], true));
  FOnBeforepush := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnBeforesync(Value : TExtFormFieldHtmlEditorOnBeforesync); begin
  if Assigned(FOnBeforesync) then
    JSCode(JSName+'.events ["beforesync"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforesync', Ajax('beforesync', ['This', '%0.nm','Html', '%1'], true));
  FOnBeforesync := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnChange(Value : TExtFormFieldHtmlEditorOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['This', '%0.nm','NewValue', '%1.nm','OldValue', '%2.nm'], true));
  FOnChange := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnDirtychange(Value : TExtFormFieldHtmlEditorOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', ['This', '%0.nm','IsDirty', '%1'], true));
  FOnDirtychange := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnEditmodechange(Value : TExtFormFieldHtmlEditorOnEditmodechange); begin
  if Assigned(FOnEditmodechange) then
    JSCode(JSName+'.events ["editmodechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('editmodechange', Ajax('editmodechange', ['This', '%0.nm','SourceEdit', '%1'], true));
  FOnEditmodechange := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnInitialize(Value : TExtFormFieldHtmlEditorOnInitialize); begin
  if Assigned(FOnInitialize) then
    JSCode(JSName+'.events ["initialize"].listeners=[];');
  if Assigned(Value) then
    AddListener('initialize', Ajax('initialize', ['This', '%0.nm'], true));
  FOnInitialize := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnPush(Value : TExtFormFieldHtmlEditorOnPush); begin
  if Assigned(FOnPush) then
    JSCode(JSName+'.events ["push"].listeners=[];');
  if Assigned(Value) then
    AddListener('push', Ajax('push', ['This', '%0.nm','Html', '%1'], true));
  FOnPush := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnSync(Value : TExtFormFieldHtmlEditorOnSync); begin
  if Assigned(FOnSync) then
    JSCode(JSName+'.events ["sync"].listeners=[];');
  if Assigned(Value) then
    AddListener('sync', Ajax('sync', ['This', '%0.nm','Html', '%1'], true));
  FOnSync := Value;
end;

procedure TExtFormFieldHtmlEditor.SetFOnValiditychange(Value : TExtFormFieldHtmlEditorOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', ['This', '%0.nm','IsValid', '%1'], true));
  FOnValiditychange := Value;
end;

function TExtFormFieldHtmlEditor.JSClassName : string; begin
  Result := 'Ext.form.field.HtmlEditor';
end;

procedure TExtFormFieldHtmlEditor.InitDefaults; begin
  inherited;
  FAfterIFrameTplList := TExtObjectList.Create(Self, 'afterIFrameTpl');
  FAfterIFrameTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterIFrameTpl');
  FAfterTextAreaTplList := TExtObjectList.Create(Self, 'afterTextAreaTpl');
  FAfterTextAreaTplTemplate := TExtXTemplate.CreateInternal(Self, 'afterTextAreaTpl');
  FBeforeIFrameTplList := TExtObjectList.Create(Self, 'beforeIFrameTpl');
  FBeforeIFrameTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeIFrameTpl');
  FBeforeTextAreaTplList := TExtObjectList.Create(Self, 'beforeTextAreaTpl');
  FBeforeTextAreaTplTemplate := TExtXTemplate.CreateInternal(Self, 'beforeTextAreaTpl');
  FButtonTips := TExtObject.CreateInternal(Self, 'buttonTips');
  FIframeAttrTplList := TExtObjectList.Create(Self, 'iframeAttrTpl');
  FIframeAttrTplTemplate := TExtXTemplate.CreateInternal(Self, 'iframeAttrTpl');
  FOriginalValue := TExtObject.CreateInternal(Self, 'originalValue');
  FValue := TExtObject.CreateInternal(Self, 'value');
end;

{$IFDEF FPC}constructor TExtFormFieldHtmlEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldHtmlEditor.BatchChanges(Fn : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.batchChanges(' + VarToJSON([Fn, false]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.CheckDirty : TExtFunction; begin
  JSCode(JSName + '.checkDirty();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

constructor TExtFormFieldHtmlEditor.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldHtmlEditor.ExecCmd(Cmd : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.ExecCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.ExecCmd(Cmd : String; Value : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.execCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.ExtractFileInput : TExtFunction; begin
  JSCode(JSName + '.extractFileInput();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetErrors(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetModelData : TExtFunction; begin
  JSCode(JSName + '.getModelData();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetName : TExtFunction; begin
  JSCode(JSName + '.getName();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetSubmitData : TExtFunction; begin
  JSCode(JSName + '.getSubmitData();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetToolbar : TExtFunction; begin
  JSCode(JSName + '.getToolbar();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.GetValue : TExtFunction; begin
  JSCode(JSName + '.getValue();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.InitField : TExtFunction; begin
  JSCode(JSName + '.initField();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.InitValue : TExtFunction; begin
  JSCode(JSName + '.initValue();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.InsertAtCursor(Text : String) : TExtFunction; begin
  JSCode(JSName + '.insertAtCursor(' + VarToJSON([Text]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.IsEqual(Value1 : TExtObject; Value2 : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.isEqual(' + VarToJSON([Value1, false, Value2, false]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.IsFileUpload : TExtFunction; begin
  JSCode(JSName + '.isFileUpload();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.RelayCmd(Cmd : String; Value : String) : TExtFunction; begin
  JSCode(JSName + '.RelayCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.RelayCmd(Cmd : String; Value : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.relayCmd(' + VarToJSON([Cmd, Value]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.Reset : TExtFunction; begin
  JSCode(JSName + '.reset();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.ResetOriginalValue : TExtFunction; begin
  JSCode(JSName + '.resetOriginalValue();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.SetReadOnly(ReadOnly : Boolean) : TExtFunction; begin
  JSCode(JSName + '.setReadOnly(' + VarToJSON([ReadOnly]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.ToggleSourceEdit(SourceEditMode : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.toggleSourceEdit(' + VarToJSON([SourceEditMode]) + ');', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

function TExtFormFieldHtmlEditor.Validate : TExtFunction; begin
  JSCode(JSName + '.validate();', 'TExtFormFieldHtmlEditor');
  Result := Self;
end;

destructor TExtFormFieldHtmlEditor.Destroy; begin
  try
    FAfterIFrameTplList.Free;
    FAfterIFrameTplTemplate.Free;
    FAfterTextAreaTplList.Free;
    FAfterTextAreaTplTemplate.Free;
    FBeforeIFrameTplList.Free;
    FBeforeIFrameTplTemplate.Free;
    FBeforeTextAreaTplList.Free;
    FBeforeTextAreaTplTemplate.Free;
    FButtonTips.Free;
    FIframeAttrTplList.Free;
    FIframeAttrTplTemplate.Free;
    FOriginalValue.Free;
    FValue.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldHtmlEditor.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtFormFieldHtmlEditor(ParamAsObject('This')))
  else if (AEvtName = 'beforepush') and Assigned(FOnBeforepush) then
    FOnBeforepush(TExtFormFieldHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'beforesync') and Assigned(FOnBeforesync) then
    FOnBeforesync(TExtFormFieldHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtFormField(ParamAsObject('This')), TExtObject(ParamAsObject('NewValue')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsDirty'))
  else if (AEvtName = 'editmodechange') and Assigned(FOnEditmodechange) then
    FOnEditmodechange(TExtFormFieldHtmlEditor(ParamAsObject('This')), ParamAsBoolean('SourceEdit'))
  else if (AEvtName = 'initialize') and Assigned(FOnInitialize) then
    FOnInitialize(TExtFormFieldHtmlEditor(ParamAsObject('This')))
  else if (AEvtName = 'push') and Assigned(FOnPush) then
    FOnPush(TExtFormFieldHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'sync') and Assigned(FOnSync) then
    FOnSync(TExtFormFieldHtmlEditor(ParamAsObject('This')), ParamAsString('Html'))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange(TExtFormField(ParamAsObject('This')), ParamAsBoolean('IsValid'));
end;

procedure TExtTreeView.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFDeferInitialRefresh(Value : Boolean); begin
  FDeferInitialRefresh := Value;
  JSCode('deferInitialRefresh:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFIsTreeView(Value : Boolean); begin
  FIsTreeView := Value;
  JSCode(JSName + '.isTreeView=' + VarToJSON([Value]) + ';');
end;

procedure TExtTreeView.SetFRootVisible(Value : Boolean); begin
  FRootVisible := Value;
  JSCode('rootVisible:' + VarToJSON([Value]));
end;

procedure TExtTreeView.SetFOnAfteritemcollapse(Value : TExtTreeViewOnAfteritemcollapse); begin
  if Assigned(FOnAfteritemcollapse) then
    JSCode(JSName+'.events ["afteritemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemcollapse', Ajax('afteritemcollapse', ['Node', '%0.nm','Index', '%1','Item', '%2.nm'], true));
  FOnAfteritemcollapse := Value;
end;

procedure TExtTreeView.SetFOnAfteritemexpand(Value : TExtTreeViewOnAfteritemexpand); begin
  if Assigned(FOnAfteritemexpand) then
    JSCode(JSName+'.events ["afteritemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemexpand', Ajax('afteritemexpand', ['Node', '%0.nm','Index', '%1','Item', '%2.nm'], true));
  FOnAfteritemexpand := Value;
end;

procedure TExtTreeView.SetFOnNodedragover(Value : TExtTreeViewOnNodedragover); begin
  if Assigned(FOnNodedragover) then
    JSCode(JSName+'.events ["nodedragover"].listeners=[];');
  if Assigned(Value) then
    AddListener('nodedragover', Ajax('nodedragover', ['TargetNode', '%0.nm','Position', '%1','DragData', '%2.nm','E', '%3.nm'], true));
  FOnNodedragover := Value;
end;

function TExtTreeView.JSClassName : string; begin
  Result := 'Ext.tree.View';
end;

{$IFDEF FPC}constructor TExtTreeView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTreeView.Collapse(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.Expand(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.GetTreeStore : TExtFunction; begin
  JSCode(JSName + '.getTreeStore();', 'TExtTreeView');
  Result := Self;
end;

function TExtTreeView.Toggle(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.toggle(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreeView');
  Result := Self;
end;

procedure TExtTreeView.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'afteritemcollapse') and Assigned(FOnAfteritemcollapse) then
    FOnAfteritemcollapse(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'), THTMLElement(ParamAsObject('Item')))
  else if (AEvtName = 'afteritemexpand') and Assigned(FOnAfteritemexpand) then
    FOnAfteritemexpand(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsInteger('Index'), THTMLElement(ParamAsObject('Item')))
  else if (AEvtName = 'nodedragover') and Assigned(FOnNodedragover) then
    FOnNodedragover(TExtDataNodeInterface(ParamAsObject('TargetNode')), ParamAsString('Position'), TExtObject(ParamAsObject('DragData')), TExtEventObject(ParamAsObject('E')));
end;

function TExtLayoutComponentFieldText.JSClassName : string; begin
  Result := 'Ext.layout.component.field.Text';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldText.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldTrigger.JSClassName : string; begin
  Result := 'Ext.layout.component.field.Trigger';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldTrigger.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldSlider.JSClassName : string; begin
  Result := 'Ext.layout.component.field.Slider';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldSlider.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldFieldContainer.JSClassName : string; begin
  Result := 'Ext.layout.component.field.FieldContainer';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldFieldContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldSet.JSClassName : string; begin
  Result := 'Ext.layout.component.FieldSet';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldSet.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerAbsolute.SetFIgnoreOnContentChange(Value : Boolean); begin
  FIgnoreOnContentChange := Value;
  JSCode('ignoreOnContentChange:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAbsolute.JSClassName : string; begin
  Result := 'Ext.layout.container.Absolute';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAbsolute.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtPanel.SetFAnimCollapse(Value : Boolean); begin
  FAnimCollapse := Value;
  JSCode('animCollapse:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFBbar(Value : TExtObjectList); begin
  FBbar := Value;
  Value.DeleteFromGarbage;
  JSCode('bbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFButtonAlign(Value : TButtonAlignEnum); begin
  FButtonAlign := Value;
  JSCode('buttonAlign:"' + EnumToJSString(TypeInfo(TButtonAlignEnum), ord(Value)) + '"');
end;

procedure TExtPanel.SetFButtons(Value : TExtObjectList); begin
  FButtons := Value;
  Value.DeleteFromGarbage;
  JSCode('buttons:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCloseAction(Value : String); begin
  FCloseAction := Value;
  JSCode('closeAction:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapsedCls(Value : String); begin
  FCollapsedCls := Value;
  JSCode('collapsedCls:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseDirection(Value : String); begin
  FCollapseDirection := Value;
  JSCode('collapseDirection:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseFirst(Value : Boolean); begin
  FCollapseFirst := Value;
  JSCode('collapseFirst:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapseMode(Value : String); begin
  FCollapseMode := Value;
  JSCode('collapseMode:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFCollapsible(Value : Boolean); begin
  FCollapsible := Value;
  JSCode('collapsible:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFConstrainHeader(Value : Boolean); begin
  FConstrainHeader := Value;
  JSCode('constrainHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFDd(Value : TExtDdDragSource); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtPanel.SetFDdDragger(Value : TExtUtilComponentDragger); begin
  FDdDragger := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtPanel.SetFDockedItems(Value : TExtObjectList); begin
  FDockedItems := Value;
  Value.DeleteFromGarbage;
  JSCode('dockedItems:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFFbar(Value : TExtObjectList); begin
  FFbar := Value;
  Value.DeleteFromGarbage;
  JSCode('fbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFFloatable(Value : Boolean); begin
  FFloatable := Value;
  JSCode('floatable:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFFrame(Value : Boolean); begin
  FFrame := Value;
  JSCode('frame:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFFrameHeader(Value : Boolean); begin
  FFrameHeader := Value;
  JSCode('frameHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFGlyph(Value : Integer); begin
  FGlyph := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFGlyphString(Value : String); begin
  FGlyphString := Value;
  JSCode('glyph:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHeader(Value : Boolean); begin
  FHeader := Value;
  JSCode('header:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHeaderObject(Value : TExtObject); begin
  FHeaderObject := Value;
  Value.DeleteFromGarbage;
  JSCode('header:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFHeaderOverCls(Value : String); begin
  FHeaderOverCls := Value;
  JSCode('headerOverCls:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHeaderPosition(Value : String); begin
  FHeaderPosition := Value;
  JSCode('headerPosition:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFHideCollapseTool(Value : Boolean); begin
  FHideCollapseTool := Value;
  JSCode('hideCollapseTool:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFIcon(Value : String); begin
  FIcon := Value;
  if not ConfigAvailable(JSName) then
    SetIcon(Value)
  else
    JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFIconCls(Value : String); begin
  FIconCls := Value;
  if not ConfigAvailable(JSName) then
    SetIconCls(Value)
  else
    JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFLbar(Value : TExtObjectList); begin
  FLbar := Value;
  Value.DeleteFromGarbage;
  JSCode('lbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFManageHeight(Value : Boolean); begin
  FManageHeight := Value;
  JSCode('manageHeight:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFMinButtonWidth(Value : Integer); begin
  FMinButtonWidth := Value;
  JSCode('minButtonWidth:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFOverlapHeader(Value : Boolean); begin
  FOverlapHeader := Value;
  JSCode('overlapHeader:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFPlaceholder(Value : TExtComponent); begin
  FPlaceholder := Value;
  Value.DeleteFromGarbage;
  JSCode('placeholder:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFPlaceholderCollapseHideMode(Value : Integer); begin
  FPlaceholderCollapseHideMode := Value;
  JSCode('placeholderCollapseHideMode:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFPlaceholderObject(Value : TExtObject); begin
  FPlaceholderObject := Value;
  Value.DeleteFromGarbage;
  JSCode('placeholder:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFRbar(Value : TExtObjectList); begin
  FRbar := Value;
  Value.DeleteFromGarbage;
  JSCode('rbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFSimpleDrag(Value : Boolean); begin
  FSimpleDrag := Value;
  JSCode('simpleDrag:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTbar(Value : TExtObjectList); begin
  FTbar := Value;
  Value.DeleteFromGarbage;
  JSCode('tbar:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFTitle(Value : String); begin
  FTitle := Value;
  if not ConfigAvailable(JSName) then
    SetTitle(Value)
  else
    JSCode('title:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTitleAlign(Value : String); begin
  FTitleAlign := Value;
  JSCode('titleAlign:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTitleCollapse(Value : Boolean); begin
  FTitleCollapse := Value;
  JSCode('titleCollapse:' + VarToJSON([Value]));
end;

procedure TExtPanel.SetFTools(Value : TExtObjectList); begin
  FTools := Value;
  Value.DeleteFromGarbage;
  JSCode('tools:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFToolsList(Value : TExtObjectList); begin
  FToolsList := Value;
  Value.DeleteFromGarbage;
  JSCode('tools:' + VarToJSON([Value, false]));
end;

procedure TExtPanel.SetFOnBeforeclose(Value : TExtPanelOnBeforeclose); begin
  if Assigned(FOnBeforeclose) then
    JSCode(JSName+'.events ["beforeclose"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeclose', Ajax('beforeclose', ['Panel', '%0.nm'], true));
  FOnBeforeclose := Value;
end;

procedure TExtPanel.SetFOnBeforecollapse(Value : TExtPanelOnBeforecollapse); begin
  if Assigned(FOnBeforecollapse) then
    JSCode(JSName+'.events ["beforecollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecollapse', Ajax('beforecollapse', ['P', '%0.nm','Direction', '%1','Animate', '%2'], true));
  FOnBeforecollapse := Value;
end;

procedure TExtPanel.SetFOnBeforeexpand(Value : TExtPanelOnBeforeexpand); begin
  if Assigned(FOnBeforeexpand) then
    JSCode(JSName+'.events ["beforeexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeexpand', Ajax('beforeexpand', ['P', '%0.nm','Animate', '%1'], true));
  FOnBeforeexpand := Value;
end;

procedure TExtPanel.SetFOnClose(Value : TExtPanelOnClose); begin
  if Assigned(FOnClose) then
    JSCode(JSName+'.events ["close"].listeners=[];');
  if Assigned(Value) then
    AddListener('close', Ajax('close', ['Panel', '%0.nm'], true));
  FOnClose := Value;
end;

procedure TExtPanel.SetFOnCollapse(Value : TExtPanelOnCollapse); begin
  if Assigned(FOnCollapse) then
    JSCode(JSName+'.events ["collapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('collapse', Ajax('collapse', ['P', '%0.nm'], true));
  FOnCollapse := Value;
end;

procedure TExtPanel.SetFOnExpand(Value : TExtPanelOnExpand); begin
  if Assigned(FOnExpand) then
    JSCode(JSName+'.events ["expand"].listeners=[];');
  if Assigned(Value) then
    AddListener('expand', Ajax('expand', ['P', '%0.nm'], true));
  FOnExpand := Value;
end;

procedure TExtPanel.SetFOnFloat(Value : TExtPanelOnFloat); begin
  if Assigned(FOnFloat) then
    JSCode(JSName+'.events ["float"].listeners=[];');
  if Assigned(Value) then
    AddListener('float', Ajax('float', [], true));
  FOnFloat := Value;
end;

procedure TExtPanel.SetFOnGlyphchange(Value : TExtPanelOnGlyphchange); begin
  if Assigned(FOnGlyphchange) then
    JSCode(JSName+'.events ["glyphchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('glyphchange', Ajax('glyphchange', ['This', '%0.nm','NewGlyph', '%1','OldGlyph', '%2'], true));
  FOnGlyphchange := Value;
end;

procedure TExtPanel.SetFOnIconchange(Value : TExtPanelOnIconchange); begin
  if Assigned(FOnIconchange) then
    JSCode(JSName+'.events ["iconchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('iconchange', Ajax('iconchange', ['P', '%0.nm','NewIcon', '%1','OldIcon', '%2'], true));
  FOnIconchange := Value;
end;

procedure TExtPanel.SetFOnIconclschange(Value : TExtPanelOnIconclschange); begin
  if Assigned(FOnIconclschange) then
    JSCode(JSName+'.events ["iconclschange"].listeners=[];');
  if Assigned(Value) then
    AddListener('iconclschange', Ajax('iconclschange', ['P', '%0.nm','NewIconCls', '%1','OldIconCls', '%2'], true));
  FOnIconclschange := Value;
end;

procedure TExtPanel.SetFOnTitlechange(Value : TExtPanelOnTitlechange); begin
  if Assigned(FOnTitlechange) then
    JSCode(JSName+'.events ["titlechange"].listeners=[];');
  if Assigned(Value) then
    AddListener('titlechange', Ajax('titlechange', ['P', '%0.nm','NewTitle', '%1','OldTitle', '%2'], true));
  FOnTitlechange := Value;
end;

procedure TExtPanel.SetFOnUnfloat(Value : TExtPanelOnUnfloat); begin
  if Assigned(FOnUnfloat) then
    JSCode(JSName+'.events ["unfloat"].listeners=[];');
  if Assigned(Value) then
    AddListener('unfloat', Ajax('unfloat', [], true));
  FOnUnfloat := Value;
end;

function TExtPanel.JSClassName : string; begin
  Result := 'Ext.panel.Panel';
end;

procedure TExtPanel.InitDefaults; begin
  inherited;
  FBbar := TExtObjectList.Create(Self, 'bbar');
  FButtons := TExtObjectList.Create(Self, 'buttons');
  FDd := TExtDdDragSource.CreateInternal(Self, 'dd');
  FDdDragger := TExtUtilComponentDragger.CreateInternal(Self, 'dd');
  FDockedItems := TExtObjectList.Create(Self, 'dockedItems');
  FFbar := TExtObjectList.Create(Self, 'fbar');
  FHeaderObject := TExtObject.CreateInternal(Self, 'header');
  FLbar := TExtObjectList.Create(Self, 'lbar');
  FPlaceholder := TExtComponent.CreateInternal(Self, 'placeholder');
  FPlaceholderObject := TExtObject.CreateInternal(Self, 'placeholder');
  FRbar := TExtObjectList.Create(Self, 'rbar');
  FTbar := TExtObjectList.Create(Self, 'tbar');
  FTitleAlign := 's natural * behavior depending on the css direction property - `';
  FTools := TExtObjectList.Create(Self, 'tools');
  FToolsList := TExtObjectList.Create(Self, 'tools');
end;

{$IFDEF FPC}constructor TExtPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPanel.AddTool(Tools : TExtObjectList) : TExtFunction; begin
  JSCode(JSName + '.addTool(' + VarToJSON(Tools) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.Close : TExtFunction; begin
  JSCode(JSName + '.close();', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.Collapse(Direction : String = ''; Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.collapse(' + VarToJSON([Direction, Animate]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.ConvertCollapseDir : TExtFunction; begin
  JSCode(JSName + '.convertCollapseDir();', 'TExtPanel');
  Result := Self;
end;

constructor TExtPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanel.Expand(Animate : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.expand(' + VarToJSON([Animate]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.GetCollapsed : TExtFunction; begin
  JSCode(JSName + '.getCollapsed();', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.GetHeader : TExtFunction; begin
  JSCode(JSName + '.getHeader();', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.SetGlyph(NewGlyph : String) : TExtFunction; begin
  JSCode(JSName + '.SetGlyph(' + VarToJSON([NewGlyph]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.SetGlyph(NewGlyph : Integer) : TExtFunction; begin
  JSCode(JSName + '.setGlyph(' + VarToJSON([NewGlyph]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.SetIcon(NewIcon : String) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([NewIcon]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.SetIconCls(NewIconCls : String) : TExtFunction; begin
  JSCode(JSName + '.setIconCls(' + VarToJSON([NewIconCls]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.SetTitle(NewTitle : String) : TExtFunction; begin
  JSCode(JSName + '.setTitle(' + VarToJSON([NewTitle]) + ');', 'TExtPanel');
  Result := Self;
end;

function TExtPanel.ToggleCollapse : TExtFunction; begin
  JSCode(JSName + '.toggleCollapse();', 'TExtPanel');
  Result := Self;
end;

destructor TExtPanel.Destroy; begin
  try
    FBbar.Free;
    FButtons.Free;
    FDd.Free;
    FDdDragger.Free;
    FDockedItems.Free;
    FFbar.Free;
    FHeaderObject.Free;
    FLbar.Free;
    FPlaceholder.Free;
    FPlaceholderObject.Free;
    FRbar.Free;
    FTbar.Free;
    FTools.Free;
    FToolsList.Free;
  except end;
  inherited;
end;

procedure TExtPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforeclose') and Assigned(FOnBeforeclose) then
    FOnBeforeclose(TExtPanel(ParamAsObject('Panel')))
  else if (AEvtName = 'beforecollapse') and Assigned(FOnBeforecollapse) then
    FOnBeforecollapse(TExtPanel(ParamAsObject('P')), ParamAsString('Direction'), ParamAsBoolean('Animate'))
  else if (AEvtName = 'beforeexpand') and Assigned(FOnBeforeexpand) then
    FOnBeforeexpand(TExtPanel(ParamAsObject('P')), ParamAsBoolean('Animate'))
  else if (AEvtName = 'close') and Assigned(FOnClose) then
    FOnClose(TExtPanel(ParamAsObject('Panel')))
  else if (AEvtName = 'collapse') and Assigned(FOnCollapse) then
    FOnCollapse(TExtPanel(ParamAsObject('P')))
  else if (AEvtName = 'expand') and Assigned(FOnExpand) then
    FOnExpand(TExtPanel(ParamAsObject('P')))
  else if (AEvtName = 'float') and Assigned(FOnFloat) then
    FOnFloat()
  else if (AEvtName = 'glyphchange') and Assigned(FOnGlyphchange) then
    FOnGlyphchange(TExtPanel(ParamAsObject('This')), ParamAsInteger('NewGlyph'), ParamAsInteger('OldGlyph'))
  else if (AEvtName = 'iconchange') and Assigned(FOnIconchange) then
    FOnIconchange(TExtPanel(ParamAsObject('P')), ParamAsString('NewIcon'), ParamAsString('OldIcon'))
  else if (AEvtName = 'iconclschange') and Assigned(FOnIconclschange) then
    FOnIconclschange(TExtPanel(ParamAsObject('P')), ParamAsString('NewIconCls'), ParamAsString('OldIconCls'))
  else if (AEvtName = 'titlechange') and Assigned(FOnTitlechange) then
    FOnTitlechange(TExtPanel(ParamAsObject('P')), ParamAsString('NewTitle'), ParamAsString('OldTitle'))
  else if (AEvtName = 'unfloat') and Assigned(FOnUnfloat) then
    FOnUnfloat();
end;

function TExtDrawSpriteDD.JSClassName : string; begin
  Result := 'Ext.draw.SpriteDD';
end;

{$IFDEF FPC}constructor TExtDrawSpriteDD.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtPanelDD.JSClassName : string; begin
  Result := 'Ext.panel.DD';
end;

{$IFDEF FPC}constructor TExtPanelDD.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtLayoutContainerAccordion.SetFActiveOnTop(Value : Boolean); begin
  FActiveOnTop := Value;
  JSCode('activeOnTop:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFAutoWidth(Value : Boolean); begin
  FAutoWidth := Value;
  JSCode('autoWidth:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFCollapseFirst(Value : Boolean); begin
  FCollapseFirst := Value;
  JSCode('collapseFirst:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFFill(Value : Boolean); begin
  FFill := Value;
  JSCode('fill:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFHideCollapseTool(Value : Boolean); begin
  FHideCollapseTool := Value;
  JSCode('hideCollapseTool:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFMulti(Value : Boolean); begin
  FMulti := Value;
  JSCode('multi:' + VarToJSON([Value]));
end;

procedure TExtLayoutContainerAccordion.SetFTitleCollapse(Value : Boolean); begin
  FTitleCollapse := Value;
  JSCode('titleCollapse:' + VarToJSON([Value]));
end;

function TExtLayoutContainerAccordion.JSClassName : string; begin
  Result := 'Ext.layout.container.Accordion';
end;

{$IFDEF FPC}constructor TExtLayoutContainerAccordion.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtPickerTime.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtPickerTime.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

function TExtPickerTime.JSClassName : string; begin
  Result := 'Ext.picker.Time';
end;

procedure TExtPickerTime.InitDefaults; begin
  inherited;
  FFormat := 'g:i A';
end;

{$IFDEF FPC}constructor TExtPickerTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPickerTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPickerTime.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtPickerTime');
  Result := Self;
end;

function TExtPickerTime.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtPickerTime');
  Result := Self;
end;

function TExtPickerTime.UpdateList : TExtFunction; begin
  JSCode(JSName + '.updateList();', 'TExtPickerTime');
  Result := Self;
end;

function TExtGridView.JSClassName : string; begin
  Result := 'Ext.grid.View';
end;

{$IFDEF FPC}constructor TExtGridView.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewDropZone.JSClassName : string; begin
  Result := 'Ext.view.DropZone';
end;

{$IFDEF FPC}constructor TExtViewDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTabBar.SetFIsTabBar(Value : Boolean); begin
  FIsTabBar := Value;
  JSCode(JSName + '.isTabBar=' + VarToJSON([Value]) + ';');
end;

procedure TExtTabBar.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtTabBar.SetFOnChange(Value : TExtTabBarOnChange); begin
  if Assigned(FOnChange) then
    JSCode(JSName+'.events ["change"].listeners=[];');
  if Assigned(Value) then
    AddListener('change', Ajax('change', ['TabBar', '%0.nm','Tab', '%1.nm','Card', '%2.nm'], true));
  FOnChange := Value;
end;

function TExtTabBar.JSClassName : string; begin
  Result := 'Ext.tab.Bar';
end;

{$IFDEF FPC}constructor TExtTabBar.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTabBar.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'change') and Assigned(FOnChange) then
    FOnChange(TExtTabBar(ParamAsObject('TabBar')), TExtTab(ParamAsObject('Tab')), TExtComponent(ParamAsObject('Card')));
end;

procedure TExtGridColumn.SetFAlign(Value : TAlignEnum); begin
  FAlign := Value;
  JSCode('align:"' + EnumToJSString(TypeInfo(TAlignEnum), ord(Value)) + '"');
end;

procedure TExtGridColumn.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFDataIndex(Value : String); begin
  FDataIndex := Value;
  JSCode('dataIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFEditor(Value : TExtObject); begin
  FEditor := Value;
  Value.DeleteFromGarbage;
  JSCode('editor:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFEditorString(Value : String); begin
  FEditorString := Value;
  JSCode('editor:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFEditRenderer(Value : TExtFunction); begin
  FEditRenderer := Value;
  JSCode('editRenderer:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumn.SetFEmptyCellText(Value : String); begin
  FEmptyCellText := Value;
  JSCode('emptyCellText:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFGroupable(Value : Boolean); begin
  FGroupable := Value;
  JSCode('groupable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFHideable(Value : Boolean); begin
  FHideable := Value;
  JSCode('hideable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFIsHeader(Value : Boolean); begin
  FIsHeader := Value;
  JSCode(JSName + '.isHeader=' + VarToJSON([Value]) + ';');
end;

procedure TExtGridColumn.SetFLockable(Value : Boolean); begin
  FLockable := Value;
  JSCode('lockable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFLocked(Value : Boolean); begin
  FLocked := Value;
  JSCode('locked:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFMenuDisabled(Value : Boolean); begin
  FMenuDisabled := Value;
  JSCode('menuDisabled:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFMenuText(Value : String); begin
  FMenuText := Value;
  JSCode('menuText:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRenderer(Value : TExtFunction); begin
  FRenderer := Value;
  JSCode('renderer:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumn.SetFRendererColIndex(Value : Integer); begin
  FRendererColIndex := Value;
  JSCode('rendererColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRendererMetaData(Value : TExtObject); begin
  FRendererMetaData := Value;
  Value.DeleteFromGarbage;
  JSCode('rendererMetaData:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFRendererRecord(Value : TExtDataModel); begin
  FRendererRecord := Value;
  Value.DeleteFromGarbage;
  JSCode('rendererRecord:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFRendererReturn(Value : String); begin
  FRendererReturn := Value;
  JSCode('rendererReturn:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRendererRowIndex(Value : Integer); begin
  FRendererRowIndex := Value;
  JSCode('rendererRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRendererStore(Value : TExtDataStore); begin
  FRendererStore := Value;
  Value.DeleteFromGarbage;
  JSCode('rendererStore:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFRendererString(Value : String); begin
  FRendererString := Value;
  JSCode('renderer:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFRendererValue(Value : TExtObject); begin
  FRendererValue := Value;
  Value.DeleteFromGarbage;
  JSCode('rendererValue:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFRendererView(Value : TExtView); begin
  FRendererView := Value;
  Value.DeleteFromGarbage;
  JSCode('rendererView:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumn.SetFSortable(Value : Boolean); begin
  FSortable := Value;
  JSCode('sortable:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFStateId(Value : String); begin
  FStateId := Value;
  JSCode('stateId:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTdCls(Value : String); begin
  FTdCls := Value;
  JSCode('tdCls:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFText(Value : String); begin
  FText := Value;
  if not ConfigAvailable(JSName) then
    SetText(Value)
  else
    JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTextEl(Value : TExtElement); begin
  FTextEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.textEl=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtGridColumn.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTooltipType(Value : String); begin
  FTooltipType := Value;
  JSCode('tooltipType:' + VarToJSON([Value]));
end;

procedure TExtGridColumn.SetFTriggerEl(Value : TExtElement); begin
  FTriggerEl := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.triggerEl=' + VarToJSON([Value, false]) + ';');
end;

function TExtGridColumn.JSClassName : string; begin
  Result := 'Ext.grid.column.Column';
end;

procedure TExtGridColumn.InitDefaults; begin
  inherited;
  FColumns := TExtObjectList.Create(Self, 'columns');
  FEditor := TExtObject.CreateInternal(Self, 'editor');
  FRendererMetaData := TExtObject.CreateInternal(Self, 'rendererMetaData');
  FRendererRecord := TExtDataModel.CreateInternal(Self, 'rendererRecord');
  FRendererStore := TExtDataStore.CreateInternal(Self, 'rendererStore');
  FRendererValue := TExtObject.CreateInternal(Self, 'rendererValue');
  FRendererView := TExtView.CreateInternal(Self, 'rendererView');
  FScope := TExtObject.CreateInternal(Self, 'scope');
  FTextEl := TExtElement.CreateInternal(Self, 'textEl');
  FTriggerEl := TExtElement.CreateInternal(Self, 'triggerEl');
end;

{$IFDEF FPC}constructor TExtGridColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridColumn.AutoSize(The : TExtGridColumn) : TExtFunction; begin
  JSCode(JSName + '.AutoSize(' + VarToJSON([The, false]) + ');', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.AutoSize(The : Integer) : TExtFunction; begin
  JSCode(JSName + '.autoSize(' + VarToJSON([The]) + ');', 'TExtGridColumn');
  Result := Self;
end;

constructor TExtGridColumn.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridColumn.GetIndex : TExtFunction; begin
  JSCode(JSName + '.getIndex();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.GetSortParam : TExtFunction; begin
  JSCode(JSName + '.getSortParam();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.GetVisibleIndex : TExtFunction; begin
  JSCode(JSName + '.getVisibleIndex();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.IsHideable : TExtFunction; begin
  JSCode(JSName + '.isHideable();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.IsLockable : TExtFunction; begin
  JSCode(JSName + '.isLockable();', 'TExtGridColumn');
  Result := Self;
end;

function TExtGridColumn.SetText(Text : String) : TExtFunction; begin
  JSCode(JSName + '.setText(' + VarToJSON([Text]) + ');', 'TExtGridColumn');
  Result := Self;
end;

destructor TExtGridColumn.Destroy; begin
  try
    FColumns.Free;
    FEditor.Free;
    FRendererMetaData.Free;
    FRendererRecord.Free;
    FRendererStore.Free;
    FRendererValue.Free;
    FRendererView.Free;
    FScope.Free;
    FTextEl.Free;
    FTriggerEl.Free;
  except end;
  inherited;
end;

function TExtGridCellEditor.JSClassName : string; begin
  Result := 'Ext.grid.CellEditor';
end;

{$IFDEF FPC}constructor TExtGridCellEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridColumnLayout.JSClassName : string; begin
  Result := 'Ext.grid.ColumnLayout';
end;

{$IFDEF FPC}constructor TExtGridColumnLayout.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridPropertyHeaderContainer.JSClassName : string; begin
  Result := 'Ext.grid.property.HeaderContainer';
end;

{$IFDEF FPC}constructor TExtGridPropertyHeaderContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyHeaderContainer.Create(Grid : TExtGridPropertyGrid; Source : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([Grid, false, Source, false]) + ');');
  InitDefaults;
end;

procedure TExtDdDragZone.SetFContainerScroll(Value : TExtObject); begin
  FContainerScroll := Value;
  Value.DeleteFromGarbage;
  JSCode('containerScroll:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragZone.SetFContainerScrollBoolean(Value : Boolean); begin
  FContainerScrollBoolean := Value;
  JSCode('containerScroll:' + VarToJSON([Value]));
end;

procedure TExtDdDragZone.SetFDragData(Value : TExtObject); begin
  FDragData := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dragData=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtDdDragZone.SetFScrollEl(Value : String); begin
  FScrollEl := Value;
  JSCode('scrollEl:' + VarToJSON([Value]));
end;

procedure TExtDdDragZone.SetFScrollElElement(Value : TExtDomElement); begin
  FScrollElElement := Value;
  Value.DeleteFromGarbage;
  JSCode('scrollEl:' + VarToJSON([Value, false]));
end;

procedure TExtDdDragZone.SetFScrollElTHTMLElement(Value : THTMLElement); begin
  FScrollElTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('scrollEl:' + VarToJSON([Value, false]));
end;

function TExtDdDragZone.JSClassName : string; begin
  Result := 'Ext.dd.DragZone';
end;

procedure TExtDdDragZone.InitDefaults; begin
  inherited;
  FContainerScroll := TExtObject.CreateInternal(Self, 'containerScroll');
  FDragData := TExtObject.CreateInternal(Self, 'dragData');
  FScrollElElement := TExtDomElement.CreateInternal(Self, 'scrollEl');
end;

{$IFDEF FPC}constructor TExtDdDragZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtDdDragZone.Create(El : THTMLElement; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragZone.Create(El : TExtElement; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, false, Config, false]) + ');');
  InitDefaults;
end;

constructor TExtDdDragZone.Create(El : String; Config : TExtObject); begin
  CreateVar(JSClassName + '(' + VarToJSON([El, Config, false]) + ');');
  InitDefaults;
end;

function TExtDdDragZone.GetDragData(E : TEvent) : TExtFunction; begin
  JSCode(JSName + '.getDragData(' + VarToJSON([E, false]) + ');', 'TExtDdDragZone');
  Result := Self;
end;

destructor TExtDdDragZone.Destroy; begin
  try
    FContainerScroll.Free;
    FDragData.Free;
    FScrollElElement.Free;
  except end;
  inherited;
end;

function TExtGridHeaderDropZone.JSClassName : string; begin
  Result := 'Ext.grid.header.DropZone';
end;

{$IFDEF FPC}constructor TExtGridHeaderDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridLockingHeaderContainer.JSClassName : string; begin
  Result := 'Ext.grid.locking.HeaderContainer';
end;

{$IFDEF FPC}constructor TExtGridLockingHeaderContainer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtViewDragZone.JSClassName : string; begin
  Result := 'Ext.view.DragZone';
end;

{$IFDEF FPC}constructor TExtViewDragZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtWindow.SetFAnimateTarget(Value : String); begin
  FAnimateTarget := Value;
  JSCode('animateTarget:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFAnimateTargetElement(Value : TExtElement); begin
  FAnimateTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('animateTarget:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFCollapsed(Value : Boolean); begin
  FCollapsed := Value;
  JSCode('collapsed:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFConstrain(Value : Boolean); begin
  FConstrain := Value;
  JSCode('constrain:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFConstrainHeader(Value : Boolean); begin
  FConstrainHeader := Value;
  JSCode('constrainHeader:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFDd(Value : TExtUtilComponentDragger); begin
  FDd := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.dd=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtWindow.SetFDefaultFocus(Value : Integer); begin
  FDefaultFocus := Value;
  JSCode('defaultFocus:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFDefaultFocusComponent(Value : TExtComponent); begin
  FDefaultFocusComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultFocus:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFDefaultFocusString(Value : String); begin
  FDefaultFocusString := Value;
  JSCode('defaultFocus:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFExpandOnShow(Value : Boolean); begin
  FExpandOnShow := Value;
  JSCode('expandOnShow:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFGhost(Value : Boolean); begin
  FGhost := Value;
  JSCode('ghost:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFGhostFunction(Value : TExtFunction); begin
  FGhostFunction := Value;
  JSCode('ghost:' + VarToJSON([Value, true]));
end;

procedure TExtWindow.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFHideShadowOnDeactivate(Value : Boolean); begin
  FHideShadowOnDeactivate := Value;
  JSCode('hideShadowOnDeactivate:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFIsWindow(Value : Boolean); begin
  FIsWindow := Value;
  JSCode(JSName + '.isWindow=' + VarToJSON([Value]) + ';');
end;

procedure TExtWindow.SetFMaximizable(Value : Boolean); begin
  FMaximizable := Value;
  JSCode('maximizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFMaximized(Value : Boolean); begin
  FMaximized := Value;
  JSCode('maximized:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFMinimizable(Value : Boolean); begin
  FMinimizable := Value;
  JSCode('minimizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFModal(Value : Boolean); begin
  FModal := Value;
  JSCode('modal:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFOnEsc(Value : TExtFunction); begin
  FOnEsc := Value;
  JSCode('onEsc:' + VarToJSON([Value, true]));
end;

procedure TExtWindow.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFResizable(Value : Boolean); begin
  FResizable := Value;
  JSCode('resizable:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFResizableObject(Value : TExtObject); begin
  FResizableObject := Value;
  Value.DeleteFromGarbage;
  JSCode('resizable:' + VarToJSON([Value, false]));
end;

procedure TExtWindow.SetFX(Value : Integer); begin
  FX := Value;
  JSCode('x:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFY(Value : Integer); begin
  FY := Value;
  JSCode('y:' + VarToJSON([Value]));
end;

procedure TExtWindow.SetFOnActivate(Value : TExtWindowOnActivate); begin
  if Assigned(FOnActivate) then
    JSCode(JSName+'.events ["activate"].listeners=[];');
  if Assigned(Value) then
    AddListener('activate', Ajax('activate', ['This', '%0.nm'], true));
  FOnActivate := Value;
end;

procedure TExtWindow.SetFOnDeactivate(Value : TExtWindowOnDeactivate); begin
  if Assigned(FOnDeactivate) then
    JSCode(JSName+'.events ["deactivate"].listeners=[];');
  if Assigned(Value) then
    AddListener('deactivate', Ajax('deactivate', ['This', '%0.nm'], true));
  FOnDeactivate := Value;
end;

procedure TExtWindow.SetFOnMaximize(Value : TExtWindowOnMaximize); begin
  if Assigned(FOnMaximize) then
    JSCode(JSName+'.events ["maximize"].listeners=[];');
  if Assigned(Value) then
    AddListener('maximize', Ajax('maximize', ['This', '%0.nm'], true));
  FOnMaximize := Value;
end;

procedure TExtWindow.SetFOnMinimize(Value : TExtWindowOnMinimize); begin
  if Assigned(FOnMinimize) then
    JSCode(JSName+'.events ["minimize"].listeners=[];');
  if Assigned(Value) then
    AddListener('minimize', Ajax('minimize', ['This', '%0.nm'], true));
  FOnMinimize := Value;
end;

procedure TExtWindow.SetFOnResize(Value : TExtWindowOnResize); begin
  if Assigned(FOnResize) then
    JSCode(JSName+'.events ["resize"].listeners=[];');
  if Assigned(Value) then
    AddListener('resize', Ajax('resize', ['This', '%0.nm','Width', '%1','Height', '%2'], true));
  FOnResize := Value;
end;

procedure TExtWindow.SetFOnRestore(Value : TExtWindowOnRestore); begin
  if Assigned(FOnRestore) then
    JSCode(JSName+'.events ["restore"].listeners=[];');
  if Assigned(Value) then
    AddListener('restore', Ajax('restore', ['This', '%0.nm'], true));
  FOnRestore := Value;
end;

function TExtWindow.JSClassName : string; begin
  Result := 'Ext.window.Window';
end;

procedure TExtWindow.InitDefaults; begin
  inherited;
  FAnimateTargetElement := TExtElement.CreateInternal(Self, 'animateTarget');
  FDd := TExtUtilComponentDragger.CreateInternal(Self, 'dd');
  FDefaultFocusComponent := TExtComponent.CreateInternal(Self, 'defaultFocus');
  FResizableObject := TExtObject.CreateInternal(Self, 'resizable');
end;

{$IFDEF FPC}constructor TExtWindow.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtWindow.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtWindow.GetDefaultFocus : TExtFunction; begin
  JSCode(JSName + '.getDefaultFocus();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Maximize(Animate : Boolean) : TExtFunction; begin
  JSCode(JSName + '.maximize(' + VarToJSON([Animate]) + ');', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Minimize : TExtFunction; begin
  JSCode(JSName + '.minimize();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.Restore : TExtFunction; begin
  JSCode(JSName + '.restore();', 'TExtWindow');
  Result := Self;
end;

function TExtWindow.ToggleMaximize : TExtFunction; begin
  JSCode(JSName + '.toggleMaximize();', 'TExtWindow');
  Result := Self;
end;

destructor TExtWindow.Destroy; begin
  try
    FAnimateTargetElement.Free;
    FDd.Free;
    FDefaultFocusComponent.Free;
    FResizableObject.Free;
  except end;
  inherited;
end;

procedure TExtWindow.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'activate') and Assigned(FOnActivate) then
    FOnActivate(TExtWindow(ParamAsObject('This')))
  else if (AEvtName = 'deactivate') and Assigned(FOnDeactivate) then
    FOnDeactivate(TExtWindow(ParamAsObject('This')))
  else if (AEvtName = 'maximize') and Assigned(FOnMaximize) then
    FOnMaximize(TExtWindow(ParamAsObject('This')))
  else if (AEvtName = 'minimize') and Assigned(FOnMinimize) then
    FOnMinimize(TExtWindow(ParamAsObject('This')))
  else if (AEvtName = 'resize') and Assigned(FOnResize) then
    FOnResize(TExtWindow(ParamAsObject('This')), ParamAsInteger('Width'), ParamAsInteger('Height'))
  else if (AEvtName = 'restore') and Assigned(FOnRestore) then
    FOnRestore(TExtWindow(ParamAsObject('This')));
end;

procedure TExtGridColumnNumber.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtGridColumnNumber.JSClassName : string; begin
  Result := 'Ext.grid.column.Number';
end;

{$IFDEF FPC}constructor TExtGridColumnNumber.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridColumnTemplate.SetFTpl(Value : String); begin
  FTpl := Value;
  JSCode('tpl:' + VarToJSON([Value]));
end;

procedure TExtGridColumnTemplate.SetFTplTemplate(Value : TExtXTemplate); begin
  FTplTemplate := Value;
  Value.DeleteFromGarbage;
  JSCode('tpl:' + VarToJSON([Value, false]));
end;

function TExtGridColumnTemplate.JSClassName : string; begin
  Result := 'Ext.grid.column.Template';
end;

procedure TExtGridColumnTemplate.InitDefaults; begin
  inherited;
  FTplTemplate := TExtXTemplate.CreateInternal(Self, 'tpl');
end;

{$IFDEF FPC}constructor TExtGridColumnTemplate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridColumnTemplate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtGridColumnTemplate.Destroy; begin
  try
    FTplTemplate.Free;
  except end;
  inherited;
end;

procedure TExtGridColumnCheckColumn.SetFStopSelection(Value : Boolean); begin
  FStopSelection := Value;
  JSCode('stopSelection:' + VarToJSON([Value]));
end;

procedure TExtGridColumnCheckColumn.SetFOnBeforecheckchange(Value : TExtGridColumnCheckColumnOnBeforecheckchange); begin
  if Assigned(FOnBeforecheckchange) then
    JSCode(JSName+'.events ["beforecheckchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecheckchange', Ajax('beforecheckchange', ['This', '%0.nm','RowIndex', '%1','Checked', '%2'], true));
  FOnBeforecheckchange := Value;
end;

procedure TExtGridColumnCheckColumn.SetFOnCheckchange(Value : TExtGridColumnCheckColumnOnCheckchange); begin
  if Assigned(FOnCheckchange) then
    JSCode(JSName+'.events ["checkchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('checkchange', Ajax('checkchange', ['This', '%0.nm','RowIndex', '%1','Checked', '%2'], true));
  FOnCheckchange := Value;
end;

function TExtGridColumnCheckColumn.JSClassName : string; begin
  Result := 'Ext.grid.column.CheckColumn';
end;

{$IFDEF FPC}constructor TExtGridColumnCheckColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridColumnCheckColumn.OnDisable(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.onDisable(' + VarToJSON([Silent]) + ');', 'TExtGridColumnCheckColumn');
  Result := Self;
end;

function TExtGridColumnCheckColumn.OnEnable(Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.onEnable(' + VarToJSON([Silent]) + ');', 'TExtGridColumnCheckColumn');
  Result := Self;
end;

procedure TExtGridColumnCheckColumn.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecheckchange') and Assigned(FOnBeforecheckchange) then
    FOnBeforecheckchange(TExtGridColumnCheckColumn(ParamAsObject('This')), ParamAsInteger('RowIndex'), ParamAsBoolean('Checked'))
  else if (AEvtName = 'checkchange') and Assigned(FOnCheckchange) then
    FOnCheckchange(TExtGridColumnCheckColumn(ParamAsObject('This')), ParamAsInteger('RowIndex'), ParamAsBoolean('Checked'));
end;

procedure TExtGridColumnDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

function TExtGridColumnDate.JSClassName : string; begin
  Result := 'Ext.grid.column.Date';
end;

{$IFDEF FPC}constructor TExtGridColumnDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridViewDropZone.JSClassName : string; begin
  Result := 'Ext.grid.ViewDropZone';
end;

{$IFDEF FPC}constructor TExtGridViewDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldComboBox.JSClassName : string; begin
  Result := 'Ext.layout.component.field.ComboBox';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldComboBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridHeaderDragZone.JSClassName : string; begin
  Result := 'Ext.grid.header.DragZone';
end;

{$IFDEF FPC}constructor TExtGridHeaderDragZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtGridRowNumberer.SetFDraggable(Value : Boolean); begin
  FDraggable := Value;
  JSCode('draggable:' + VarToJSON([Value]));
end;

procedure TExtGridRowNumberer.SetFText(Value : String); begin
  FText := Value;
  JSCode('text:' + VarToJSON([Value]));
end;

procedure TExtGridRowNumberer.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

function TExtGridRowNumberer.JSClassName : string; begin
  Result := 'Ext.grid.RowNumberer';
end;

{$IFDEF FPC}constructor TExtGridRowNumberer.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldDate.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFDisabledDates(Value : TArrayOfString); begin
  FDisabledDates := Value;
  if not ConfigAvailable(JSName) then
    SetDisabledDates(Value)
  else
    JSCode('disabledDates:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldDate.SetFDisabledDatesText(Value : String); begin
  FDisabledDatesText := Value;
  JSCode('disabledDatesText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFDisabledDays(Value : TArrayOfInteger); begin
  FDisabledDays := Value;
  if not ConfigAvailable(JSName) then
    SetDisabledDays(Value)
  else
    JSCode('disabledDays:' + ArrayToJSON(Value));
end;

procedure TExtFormFieldDate.SetFDisabledDaysText(Value : String); begin
  FDisabledDaysText := Value;
  JSCode('disabledDaysText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFShowToday(Value : Boolean); begin
  FShowToday := Value;
  JSCode('showToday:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFStartDay(Value : Integer); begin
  FStartDay := Value;
  JSCode('startDay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFSubmitFormat(Value : String); begin
  FSubmitFormat := Value;
  JSCode('submitFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldDate.SetFUseStrict(Value : Boolean); begin
  FUseStrict := Value;
  JSCode('useStrict:' + VarToJSON([Value]));
end;

function TExtFormFieldDate.JSClassName : string; begin
  Result := 'Ext.form.field.Date';
end;

procedure TExtFormFieldDate.InitDefaults; begin
  inherited;
  FStartDay := 0;
end;

{$IFDEF FPC}constructor TExtFormFieldDate.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldDate.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldDate.GetErrors(Value : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldDate');
  Result := Self;
end;

function TExtFormFieldDate.SetDisabledDates(DisabledDates : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDates(' + VarToJSON([DisabledDates]) + ');', 'TExtFormFieldDate');
  Result := Self;
end;

function TExtFormFieldDate.SetDisabledDays(DisabledDays : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.setDisabledDays(' + VarToJSON([DisabledDays]) + ');', 'TExtFormFieldDate');
  Result := Self;
end;

function TExtFormFieldDate.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldDate');
  Result := Self;
end;

function TExtFormFieldDate.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldDate');
  Result := Self;
end;

procedure TExtFormFieldNumber.SetFAllowDecimals(Value : Boolean); begin
  FAllowDecimals := Value;
  JSCode('allowDecimals:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFAutoStripChars(Value : Boolean); begin
  FAutoStripChars := Value;
  JSCode('autoStripChars:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFBaseChars(Value : String); begin
  FBaseChars := Value;
  JSCode('baseChars:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFDecimalPrecision(Value : Integer); begin
  FDecimalPrecision := Value;
  JSCode('decimalPrecision:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFDecimalSeparator(Value : String); begin
  FDecimalSeparator := Value;
  JSCode('decimalSeparator:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMaxValue(Value : Integer); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFMinValue(Value : Integer); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFNanText(Value : String); begin
  FNanText := Value;
  JSCode('nanText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFNegativeText(Value : String); begin
  FNegativeText := Value;
  JSCode('negativeText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFStep(Value : Integer); begin
  FStep := Value;
  JSCode('step:' + VarToJSON([Value]));
end;

procedure TExtFormFieldNumber.SetFSubmitLocaleSeparator(Value : Boolean); begin
  FSubmitLocaleSeparator := Value;
  JSCode('submitLocaleSeparator:' + VarToJSON([Value]));
end;

function TExtFormFieldNumber.JSClassName : string; begin
  Result := 'Ext.form.field.Number';
end;

{$IFDEF FPC}constructor TExtFormFieldNumber.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldNumber.GetErrors(Value : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

function TExtFormFieldNumber.SetMaxValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

function TExtFormFieldNumber.SetMinValue(Value : Integer) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldNumber');
  Result := Self;
end;

procedure TExtContainerButtonGroup.SetFBaseCls(Value : String); begin
  FBaseCls := Value;
  JSCode('baseCls:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFColumns(Value : Integer); begin
  FColumns := Value;
  JSCode('columns:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFDefaultButtonUI(Value : String); begin
  FDefaultButtonUI := Value;
  JSCode('defaultButtonUI:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFFrame(Value : Boolean); begin
  FFrame := Value;
  JSCode('frame:' + VarToJSON([Value]));
end;

procedure TExtContainerButtonGroup.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtContainerButtonGroup.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

function TExtContainerButtonGroup.JSClassName : string; begin
  Result := 'Ext.container.ButtonGroup';
end;

procedure TExtContainerButtonGroup.InitDefaults; begin
  inherited;
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
end;

{$IFDEF FPC}constructor TExtContainerButtonGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtContainerButtonGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtContainerButtonGroup.Destroy; begin
  try
    FLayoutObject.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldComboBox.SetFAllQuery(Value : String); begin
  FAllQuery := Value;
  JSCode('allQuery:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFAutoSelect(Value : Boolean); begin
  FAutoSelect := Value;
  JSCode('autoSelect:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFDefaultListConfig(Value : TExtObject); begin
  FDefaultListConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('defaultListConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFDelimiter(Value : String); begin
  FDelimiter := Value;
  JSCode('delimiter:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFEnableRegEx(Value : Boolean); begin
  FEnableRegEx := Value;
  JSCode('enableRegEx:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFForceSelection(Value : Boolean); begin
  FForceSelection := Value;
  JSCode('forceSelection:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFGrowToLongestValue(Value : Boolean); begin
  FGrowToLongestValue := Value;
  JSCode('growToLongestValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFHiddenName(Value : String); begin
  FHiddenName := Value;
  JSCode('hiddenName:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFLastQuery(Value : String); begin
  FLastQuery := Value;
  JSCode(JSName + '.lastQuery=' + VarToJSON([Value]) + ';');
end;

procedure TExtFormFieldComboBox.SetFListConfig(Value : TExtObject); begin
  FListConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('listConfig:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFMultiSelect(Value : Boolean); begin
  FMultiSelect := Value;
  JSCode('multiSelect:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFPageSize(Value : Integer); begin
  FPageSize := Value;
  JSCode('pageSize:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryCaching(Value : Boolean); begin
  FQueryCaching := Value;
  JSCode('queryCaching:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryDelay(Value : Integer); begin
  FQueryDelay := Value;
  JSCode('queryDelay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryMode(Value : String); begin
  FQueryMode := Value;
  JSCode('queryMode:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFQueryParam(Value : String); begin
  FQueryParam := Value;
  JSCode('queryParam:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFSelectOnTab(Value : Boolean); begin
  FSelectOnTab := Value;
  JSCode('selectOnTab:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFStoreList(Value : TExtObjectList); begin
  FStoreList := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFStoreString(Value : String); begin
  FStoreString := Value;
  JSCode('store:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTransform(Value : String); begin
  FTransform := Value;
  JSCode('transform:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTransformElement(Value : TExtElement); begin
  FTransformElement := Value;
  Value.DeleteFromGarbage;
  JSCode('transform:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFTransformTHTMLElement(Value : THTMLElement); begin
  FTransformTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('transform:' + VarToJSON([Value, false]));
end;

procedure TExtFormFieldComboBox.SetFTriggerAction(Value : String); begin
  FTriggerAction := Value;
  JSCode('triggerAction:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTypeAhead(Value : Boolean); begin
  FTypeAhead := Value;
  JSCode('typeAhead:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFTypeAheadDelay(Value : Integer); begin
  FTypeAheadDelay := Value;
  JSCode('typeAheadDelay:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFValueField(Value : String); begin
  FValueField := Value;
  JSCode('valueField:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFValueNotFoundText(Value : String); begin
  FValueNotFoundText := Value;
  JSCode('valueNotFoundText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldComboBox.SetFOnBeforedeselect(Value : TExtFormFieldComboBoxOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforedeselect := Value;
end;

procedure TExtFormFieldComboBox.SetFOnBeforequery(Value : TExtFormFieldComboBoxOnBeforequery); begin
  if Assigned(FOnBeforequery) then
    JSCode(JSName+'.events ["beforequery"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforequery', Ajax('beforequery', ['QueryEvent', '%0.nm'], true));
  FOnBeforequery := Value;
end;

procedure TExtFormFieldComboBox.SetFOnBeforeselect(Value : TExtFormFieldComboBoxOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', ['Combo', '%0.nm','RecordJS', '%1.nm','Index', '%2'], true));
  FOnBeforeselect := Value;
end;

procedure TExtFormFieldComboBox.SetFOnSelect(Value : TExtFormFieldComboBoxOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', ['Combo', '%0.nm','Records', '%1.nm'], true));
  FOnSelect := Value;
end;

function TExtFormFieldComboBox.JSClassName : string; begin
  Result := 'Ext.form.field.ComboBox';
end;

procedure TExtFormFieldComboBox.InitDefaults; begin
  inherited;
  FDefaultListConfig := TExtObject.CreateInternal(Self, 'defaultListConfig');
  FListConfig := TExtObject.CreateInternal(Self, 'listConfig');
  FQueryDelay := 500;
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FStoreList := TExtObjectList.Create(Self, 'store');
  FTransformElement := TExtElement.CreateInternal(Self, 'transform');
end;

{$IFDEF FPC}constructor TExtFormFieldComboBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormFieldComboBox.BindStore(Store : String = '') : TExtFunction; begin
  JSCode(JSName + '.bindStore(' + VarToJSON([Store]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.BindStore(Store : TExtDataAbstractStore) : TExtFunction; begin
  JSCode(JSName + '.BindStore(' + VarToJSON([Store, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.ClearValue : TExtFunction; begin
  JSCode(JSName + '.clearValue();', 'TExtFormFieldComboBox');
  Result := Self;
end;

constructor TExtFormFieldComboBox.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldComboBox.DoQuery(QueryString : String; ForceAll : Boolean = false; RawQuery : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.doQuery(' + VarToJSON([QueryString, ForceAll, RawQuery]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecord(Field : String; Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecord(' + VarToJSON([Field, Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecordByDisplay(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecordByDisplay(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.FindRecordByValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.findRecordByValue(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.Select(R : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.select(' + VarToJSON([R, false]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.SetValue(Value : TArrayOfString) : TExtFunction; begin
  JSCode(JSName + '.SetValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

function TExtFormFieldComboBox.SetValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldComboBox');
  Result := Self;
end;

destructor TExtFormFieldComboBox.Destroy; begin
  try
    FDefaultListConfig.Free;
    FListConfig.Free;
    FStore.Free;
    FStoreList.Free;
    FTransformElement.Free;
  except end;
  inherited;
end;

procedure TExtFormFieldComboBox.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'beforequery') and Assigned(FOnBeforequery) then
    FOnBeforequery(TExtObject(ParamAsObject('QueryEvent')))
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtDataRecord(ParamAsObject('RecordJS')), ParamAsInteger('Index'))
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect(TExtFormFieldComboBox(ParamAsObject('Combo')), TExtObjectList(ParamAsObject('Records')));
end;

procedure TExtGridColumnAction.SetFAltText(Value : String); begin
  FAltText := Value;
  JSCode('altText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFDisabled(Value : Boolean); begin
  FDisabled := Value;
  JSCode('disabled:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClass(Value : TExtFunction); begin
  FGetClass := Value;
  JSCode('getClass:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFGetClassColIndex(Value : Integer); begin
  FGetClassColIndex := Value;
  JSCode('getClassColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClassMetadata(Value : TExtObject); begin
  FGetClassMetadata := Value;
  Value.DeleteFromGarbage;
  JSCode('getClassMetadata:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetClassMetadataAttr(Value : String); begin
  FGetClassMetadataAttr := Value;
  JSCode('getClassMetadataAttr:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClassMetadataCss(Value : String); begin
  FGetClassMetadataCss := Value;
  JSCode('getClassMetadataCss:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClassR(Value : TExtDataModel); begin
  FGetClassR := Value;
  Value.DeleteFromGarbage;
  JSCode('getClassR:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetClassRowIndex(Value : Integer); begin
  FGetClassRowIndex := Value;
  JSCode('getClassRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetClassStore(Value : TExtDataStore); begin
  FGetClassStore := Value;
  Value.DeleteFromGarbage;
  JSCode('getClassStore:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetClassV(Value : TExtObject); begin
  FGetClassV := Value;
  Value.DeleteFromGarbage;
  JSCode('getClassV:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetTip(Value : TExtFunction); begin
  FGetTip := Value;
  JSCode('getTip:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFGetTipColIndex(Value : Integer); begin
  FGetTipColIndex := Value;
  JSCode('getTipColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetTipMetadata(Value : TExtObject); begin
  FGetTipMetadata := Value;
  Value.DeleteFromGarbage;
  JSCode('getTipMetadata:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetTipMetadataAttr(Value : String); begin
  FGetTipMetadataAttr := Value;
  JSCode('getTipMetadataAttr:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetTipMetadataCss(Value : String); begin
  FGetTipMetadataCss := Value;
  JSCode('getTipMetadataCss:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetTipR(Value : TExtDataModel); begin
  FGetTipR := Value;
  Value.DeleteFromGarbage;
  JSCode('getTipR:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetTipRowIndex(Value : Integer); begin
  FGetTipRowIndex := Value;
  JSCode('getTipRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFGetTipStore(Value : TExtDataStore); begin
  FGetTipStore := Value;
  Value.DeleteFromGarbage;
  JSCode('getTipStore:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFGetTipV(Value : TExtObject); begin
  FGetTipV := Value;
  Value.DeleteFromGarbage;
  JSCode('getTipV:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFHandler(Value : TExtFunction); begin
  FHandler := Value;
  JSCode('handler:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFHandlerColIndex(Value : Integer); begin
  FHandlerColIndex := Value;
  JSCode('handlerColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFHandlerE(Value : TEvent); begin
  FHandlerE := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerE:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFHandlerItem(Value : TExtObject); begin
  FHandlerItem := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerItem:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFHandlerRecord(Value : TExtDataModel); begin
  FHandlerRecord := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerRecord:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFHandlerRow(Value : THTMLElement); begin
  FHandlerRow := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerRow:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFHandlerRowIndex(Value : Integer); begin
  FHandlerRowIndex := Value;
  JSCode('handlerRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFHandlerView(Value : TExtViewTable); begin
  FHandlerView := Value;
  Value.DeleteFromGarbage;
  JSCode('handlerView:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFIcon(Value : String); begin
  FIcon := Value;
  JSCode('icon:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFIconCls(Value : String); begin
  FIconCls := Value;
  JSCode('iconCls:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFIsDisabled(Value : TExtFunction); begin
  FIsDisabled := Value;
  JSCode('isDisabled:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFIsDisabledColIndex(Value : Integer); begin
  FIsDisabledColIndex := Value;
  JSCode('isDisabledColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFIsDisabledItem(Value : TExtObject); begin
  FIsDisabledItem := Value;
  Value.DeleteFromGarbage;
  JSCode('isDisabledItem:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFIsDisabledRecord(Value : TExtDataModel); begin
  FIsDisabledRecord := Value;
  Value.DeleteFromGarbage;
  JSCode('isDisabledRecord:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFIsDisabledRowIndex(Value : Integer); begin
  FIsDisabledRowIndex := Value;
  JSCode('isDisabledRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFIsDisabledView(Value : TExtViewTable); begin
  FIsDisabledView := Value;
  Value.DeleteFromGarbage;
  JSCode('isDisabledView:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsDisabled(Value : Boolean); begin
  FItemsDisabled := Value;
  JSCode('itemsDisabled:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetClass(Value : TExtFunction); begin
  FItemsGetClass := Value;
  JSCode('itemsGetClass:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassColIndex(Value : Integer); begin
  FItemsGetClassColIndex := Value;
  JSCode('itemsGetClassColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassMetadata(Value : TExtObject); begin
  FItemsGetClassMetadata := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetClassMetadata:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassMetadataAttr(Value : String); begin
  FItemsGetClassMetadataAttr := Value;
  JSCode('itemsGetClassMetadataAttr:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassMetadataCss(Value : String); begin
  FItemsGetClassMetadataCss := Value;
  JSCode('itemsGetClassMetadataCss:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassR(Value : TExtDataModel); begin
  FItemsGetClassR := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetClassR:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassRowIndex(Value : Integer); begin
  FItemsGetClassRowIndex := Value;
  JSCode('itemsGetClassRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassStore(Value : TExtDataStore); begin
  FItemsGetClassStore := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetClassStore:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetClassV(Value : TExtObject); begin
  FItemsGetClassV := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetClassV:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetTip(Value : TExtFunction); begin
  FItemsGetTip := Value;
  JSCode('itemsGetTip:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipColIndex(Value : Integer); begin
  FItemsGetTipColIndex := Value;
  JSCode('itemsGetTipColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipMetadata(Value : TExtObject); begin
  FItemsGetTipMetadata := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetTipMetadata:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipMetadataAttr(Value : String); begin
  FItemsGetTipMetadataAttr := Value;
  JSCode('itemsGetTipMetadataAttr:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipMetadataCss(Value : String); begin
  FItemsGetTipMetadataCss := Value;
  JSCode('itemsGetTipMetadataCss:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipR(Value : TExtDataModel); begin
  FItemsGetTipR := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetTipR:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipRowIndex(Value : Integer); begin
  FItemsGetTipRowIndex := Value;
  JSCode('itemsGetTipRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipStore(Value : TExtDataStore); begin
  FItemsGetTipStore := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetTipStore:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsGetTipV(Value : TExtObject); begin
  FItemsGetTipV := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsGetTipV:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsHandler(Value : TExtFunction); begin
  FItemsHandler := Value;
  JSCode('itemsHandler:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerColIndex(Value : Integer); begin
  FItemsHandlerColIndex := Value;
  JSCode('itemsHandlerColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerE(Value : TEvent); begin
  FItemsHandlerE := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsHandlerE:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerItem(Value : TExtObject); begin
  FItemsHandlerItem := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsHandlerItem:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerRecord(Value : TExtDataModel); begin
  FItemsHandlerRecord := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsHandlerRecord:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerRowIndex(Value : Integer); begin
  FItemsHandlerRowIndex := Value;
  JSCode('itemsHandlerRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsHandlerView(Value : TExtViewTable); begin
  FItemsHandlerView := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsHandlerView:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsIcon(Value : String); begin
  FItemsIcon := Value;
  JSCode('itemsIcon:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsIconCls(Value : String); begin
  FItemsIconCls := Value;
  JSCode('itemsIconCls:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabled(Value : TExtFunction); begin
  FItemsIsDisabled := Value;
  JSCode('itemsIsDisabled:' + VarToJSON([Value, true]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabledColIndex(Value : Integer); begin
  FItemsIsDisabledColIndex := Value;
  JSCode('itemsIsDisabledColIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabledItem(Value : TExtObject); begin
  FItemsIsDisabledItem := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsIsDisabledItem:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabledRecord(Value : TExtDataModel); begin
  FItemsIsDisabledRecord := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsIsDisabledRecord:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabledRowIndex(Value : Integer); begin
  FItemsIsDisabledRowIndex := Value;
  JSCode('itemsIsDisabledRowIndex:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFItemsIsDisabledView(Value : TExtViewTable); begin
  FItemsIsDisabledView := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsIsDisabledView:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsRow(Value : THTMLElement); begin
  FItemsRow := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsRow:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsScope(Value : TExtObject); begin
  FItemsScope := Value;
  Value.DeleteFromGarbage;
  JSCode('itemsScope:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFItemsTooltip(Value : String); begin
  FItemsTooltip := Value;
  JSCode('itemsTooltip:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFMenuText(Value : String); begin
  FMenuText := Value;
  JSCode('menuText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFScope(Value : TExtObject); begin
  FScope := Value;
  Value.DeleteFromGarbage;
  JSCode('scope:' + VarToJSON([Value, false]));
end;

procedure TExtGridColumnAction.SetFStopSelection(Value : Boolean); begin
  FStopSelection := Value;
  JSCode('stopSelection:' + VarToJSON([Value]));
end;

procedure TExtGridColumnAction.SetFTooltip(Value : String); begin
  FTooltip := Value;
  JSCode('tooltip:' + VarToJSON([Value]));
end;

function TExtGridColumnAction.JSClassName : string; begin
  Result := 'Ext.grid.column.Action';
end;

procedure TExtGridColumnAction.InitDefaults; begin
  inherited;
  FGetClassMetadata := TExtObject.CreateInternal(Self, 'getClassMetadata');
  FGetClassR := TExtDataModel.CreateInternal(Self, 'getClassR');
  FGetClassStore := TExtDataStore.CreateInternal(Self, 'getClassStore');
  FGetClassV := TExtObject.CreateInternal(Self, 'getClassV');
  FGetTipMetadata := TExtObject.CreateInternal(Self, 'getTipMetadata');
  FGetTipR := TExtDataModel.CreateInternal(Self, 'getTipR');
  FGetTipStore := TExtDataStore.CreateInternal(Self, 'getTipStore');
  FGetTipV := TExtObject.CreateInternal(Self, 'getTipV');
  FHandlerItem := TExtObject.CreateInternal(Self, 'handlerItem');
  FHandlerRecord := TExtDataModel.CreateInternal(Self, 'handlerRecord');
  FHandlerView := TExtViewTable.CreateInternal(Self, 'handlerView');
  FIsDisabledItem := TExtObject.CreateInternal(Self, 'isDisabledItem');
  FIsDisabledRecord := TExtDataModel.CreateInternal(Self, 'isDisabledRecord');
  FIsDisabledView := TExtViewTable.CreateInternal(Self, 'isDisabledView');
  FItems := TExtObjectList.Create(Self, 'items');
  FItemsGetClassMetadata := TExtObject.CreateInternal(Self, 'itemsGetClassMetadata');
  FItemsGetClassR := TExtDataModel.CreateInternal(Self, 'itemsGetClassR');
  FItemsGetClassStore := TExtDataStore.CreateInternal(Self, 'itemsGetClassStore');
  FItemsGetClassV := TExtObject.CreateInternal(Self, 'itemsGetClassV');
  FItemsGetTipMetadata := TExtObject.CreateInternal(Self, 'itemsGetTipMetadata');
  FItemsGetTipR := TExtDataModel.CreateInternal(Self, 'itemsGetTipR');
  FItemsGetTipStore := TExtDataStore.CreateInternal(Self, 'itemsGetTipStore');
  FItemsGetTipV := TExtObject.CreateInternal(Self, 'itemsGetTipV');
  FItemsHandlerItem := TExtObject.CreateInternal(Self, 'itemsHandlerItem');
  FItemsHandlerRecord := TExtDataModel.CreateInternal(Self, 'itemsHandlerRecord');
  FItemsHandlerView := TExtViewTable.CreateInternal(Self, 'itemsHandlerView');
  FItemsIsDisabledItem := TExtObject.CreateInternal(Self, 'itemsIsDisabledItem');
  FItemsIsDisabledRecord := TExtDataModel.CreateInternal(Self, 'itemsIsDisabledRecord');
  FItemsIsDisabledView := TExtViewTable.CreateInternal(Self, 'itemsIsDisabledView');
  FItemsScope := TExtObject.CreateInternal(Self, 'itemsScope');
  FScope := TExtObject.CreateInternal(Self, 'scope');
end;

{$IFDEF FPC}constructor TExtGridColumnAction.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridColumnAction.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridColumnAction.DisableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.DisableAction(' + VarToJSON([Index, false, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.DisableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.disableAction(' + VarToJSON([Index, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.EnableAction(Index : TExtGridColumnAction; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.EnableAction(' + VarToJSON([Index, false, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

function TExtGridColumnAction.EnableAction(Index : Integer; Silent : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.enableAction(' + VarToJSON([Index, Silent]) + ');', 'TExtGridColumnAction');
  Result := Self;
end;

destructor TExtGridColumnAction.Destroy; begin
  try
    FGetClassMetadata.Free;
    FGetClassR.Free;
    FGetClassStore.Free;
    FGetClassV.Free;
    FGetTipMetadata.Free;
    FGetTipR.Free;
    FGetTipStore.Free;
    FGetTipV.Free;
    FHandlerItem.Free;
    FHandlerRecord.Free;
    FHandlerView.Free;
    FIsDisabledItem.Free;
    FIsDisabledRecord.Free;
    FIsDisabledView.Free;
    FItems.Free;
    FItemsGetClassMetadata.Free;
    FItemsGetClassR.Free;
    FItemsGetClassStore.Free;
    FItemsGetClassV.Free;
    FItemsGetTipMetadata.Free;
    FItemsGetTipR.Free;
    FItemsGetTipStore.Free;
    FItemsGetTipV.Free;
    FItemsHandlerItem.Free;
    FItemsHandlerRecord.Free;
    FItemsHandlerView.Free;
    FItemsIsDisabledItem.Free;
    FItemsIsDisabledRecord.Free;
    FItemsIsDisabledView.Free;
    FItemsScope.Free;
    FScope.Free;
  except end;
  inherited;
end;

procedure TExtGridColumnBoolean.SetFFalseText(Value : String); begin
  FFalseText := Value;
  JSCode('falseText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnBoolean.SetFTrueText(Value : String); begin
  FTrueText := Value;
  JSCode('trueText:' + VarToJSON([Value]));
end;

procedure TExtGridColumnBoolean.SetFUndefinedText(Value : String); begin
  FUndefinedText := Value;
  JSCode('undefinedText:' + VarToJSON([Value]));
end;

function TExtGridColumnBoolean.JSClassName : string; begin
  Result := 'Ext.grid.column.Boolean';
end;

{$IFDEF FPC}constructor TExtGridColumnBoolean.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormPanel.SetFFieldDefaults(Value : TExtObject); begin
  FFieldDefaults := Value;
  Value.DeleteFromGarbage;
  JSCode('fieldDefaults:' + VarToJSON([Value, false]));
end;

procedure TExtFormPanel.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtFormPanel.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtFormPanel.SetFPollForChanges(Value : Boolean); begin
  FPollForChanges := Value;
  JSCode('pollForChanges:' + VarToJSON([Value]));
end;

procedure TExtFormPanel.SetFPollInterval(Value : Integer); begin
  FPollInterval := Value;
  JSCode('pollInterval:' + VarToJSON([Value]));
end;

procedure TExtFormPanel.SetFOnActioncomplete(Value : TExtFormPanelOnActioncomplete); begin
  if Assigned(FOnActioncomplete) then
    JSCode(JSName+'.events ["actioncomplete"].listeners=[];');
  if Assigned(Value) then
    AddListener('actioncomplete', Ajax('actioncomplete', [], true));
  FOnActioncomplete := Value;
end;

procedure TExtFormPanel.SetFOnActionfailed(Value : TExtFormPanelOnActionfailed); begin
  if Assigned(FOnActionfailed) then
    JSCode(JSName+'.events ["actionfailed"].listeners=[];');
  if Assigned(Value) then
    AddListener('actionfailed', Ajax('actionfailed', [], true));
  FOnActionfailed := Value;
end;

procedure TExtFormPanel.SetFOnBeforeaction(Value : TExtFormPanelOnBeforeaction); begin
  if Assigned(FOnBeforeaction) then
    JSCode(JSName+'.events ["beforeaction"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeaction', Ajax('beforeaction', [], true));
  FOnBeforeaction := Value;
end;

procedure TExtFormPanel.SetFOnDirtychange(Value : TExtFormPanelOnDirtychange); begin
  if Assigned(FOnDirtychange) then
    JSCode(JSName+'.events ["dirtychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('dirtychange', Ajax('dirtychange', [], true));
  FOnDirtychange := Value;
end;

procedure TExtFormPanel.SetFOnFielderrorchange(Value : TExtFormPanelOnFielderrorchange); begin
  if Assigned(FOnFielderrorchange) then
    JSCode(JSName+'.events ["fielderrorchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fielderrorchange', Ajax('fielderrorchange', ['This', '%0.nm','The', '%1.nm','Error', '%2'], true));
  FOnFielderrorchange := Value;
end;

procedure TExtFormPanel.SetFOnFieldvaliditychange(Value : TExtFormPanelOnFieldvaliditychange); begin
  if Assigned(FOnFieldvaliditychange) then
    JSCode(JSName+'.events ["fieldvaliditychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('fieldvaliditychange', Ajax('fieldvaliditychange', ['This', '%0.nm','The', '%1.nm','IsValid', '%2'], true));
  FOnFieldvaliditychange := Value;
end;

procedure TExtFormPanel.SetFOnValiditychange(Value : TExtFormPanelOnValiditychange); begin
  if Assigned(FOnValiditychange) then
    JSCode(JSName+'.events ["validitychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('validitychange', Ajax('validitychange', [], true));
  FOnValiditychange := Value;
end;

function TExtFormPanel.JSClassName : string; begin
  Result := 'Ext.form.Panel';
end;

procedure TExtFormPanel.InitDefaults; begin
  inherited;
  FFieldDefaults := TExtObject.CreateInternal(Self, 'fieldDefaults');
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
  FPollInterval := 500;
end;

{$IFDEF FPC}constructor TExtFormPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtFormPanel.CheckChange : TExtFunction; begin
  JSCode(JSName + '.checkChange();', 'TExtFormPanel');
  Result := Self;
end;

constructor TExtFormPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormPanel.GetForm : TExtFunction; begin
  JSCode(JSName + '.getForm();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.GetRecord : TExtFunction; begin
  JSCode(JSName + '.getRecord();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.GetValues : TExtFunction; begin
  JSCode(JSName + '.getValues();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.HasInvalidField : TExtFunction; begin
  JSCode(JSName + '.hasInvalidField();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.IsDirty : TExtFunction; begin
  JSCode(JSName + '.isDirty();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.IsValid : TExtFunction; begin
  JSCode(JSName + '.isValid();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.Load(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.load(' + VarToJSON([Options, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.LoadRecord(RecordJS : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.loadRecord(' + VarToJSON([RecordJS, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.StartPolling(Interval : Integer) : TExtFunction; begin
  JSCode(JSName + '.startPolling(' + VarToJSON([Interval]) + ');', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.StopPolling : TExtFunction; begin
  JSCode(JSName + '.stopPolling();', 'TExtFormPanel');
  Result := Self;
end;

function TExtFormPanel.Submit(Options : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.submit(' + VarToJSON([Options, false]) + ');', 'TExtFormPanel');
  Result := Self;
end;

destructor TExtFormPanel.Destroy; begin
  try
    FFieldDefaults.Free;
    FLayoutObject.Free;
  except end;
  inherited;
end;

procedure TExtFormPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'actioncomplete') and Assigned(FOnActioncomplete) then
    FOnActioncomplete()
  else if (AEvtName = 'actionfailed') and Assigned(FOnActionfailed) then
    FOnActionfailed()
  else if (AEvtName = 'beforeaction') and Assigned(FOnBeforeaction) then
    FOnBeforeaction()
  else if (AEvtName = 'dirtychange') and Assigned(FOnDirtychange) then
    FOnDirtychange()
  else if (AEvtName = 'fielderrorchange') and Assigned(FOnFielderrorchange) then
    FOnFielderrorchange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('Error'))
  else if (AEvtName = 'fieldvaliditychange') and Assigned(FOnFieldvaliditychange) then
    FOnFieldvaliditychange(TExtFormFieldAncestor(ParamAsObject('This')), TExtFormLabelable(ParamAsObject('The')), ParamAsString('IsValid'))
  else if (AEvtName = 'validitychange') and Assigned(FOnValiditychange) then
    FOnValiditychange();
end;

procedure TExtFormRadioGroup.SetFAllowBlank(Value : Boolean); begin
  FAllowBlank := Value;
  JSCode('allowBlank:' + VarToJSON([Value]));
end;

procedure TExtFormRadioGroup.SetFBlankText(Value : String); begin
  FBlankText := Value;
  JSCode('blankText:' + VarToJSON([Value]));
end;

procedure TExtFormRadioGroup.SetFItems(Value : TExtObjectList); begin
  FItems := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

procedure TExtFormRadioGroup.SetFItemsList(Value : TExtObjectList); begin
  FItemsList := Value;
  Value.DeleteFromGarbage;
  JSCode('items:' + VarToJSON([Value, false]));
end;

function TExtFormRadioGroup.JSClassName : string; begin
  Result := 'Ext.form.RadioGroup';
end;

procedure TExtFormRadioGroup.InitDefaults; begin
  inherited;
  FItems := TExtObjectList.Create(Self, 'items');
  FItemsList := TExtObjectList.Create(Self, 'items');
end;

{$IFDEF FPC}constructor TExtFormRadioGroup.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormRadioGroup.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormRadioGroup.SetValue(Value : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.setValue(' + VarToJSON([Value, false]) + ');', 'TExtFormRadioGroup');
  Result := Self;
end;

destructor TExtFormRadioGroup.Destroy; begin
  try
    FItems.Free;
    FItemsList.Free;
  except end;
  inherited;
end;

procedure TExtPanelTable.SetFAllowDeselect(Value : Boolean); begin
  FAllowDeselect := Value;
  JSCode('allowDeselect:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFColumnLines(Value : Boolean); begin
  FColumnLines := Value;
  JSCode('columnLines:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFColumnsObject(Value : TExtObject); begin
  FColumnsObject := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFDeferRowRender(Value : Boolean); begin
  FDeferRowRender := Value;
  JSCode('deferRowRender:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFDisableSelection(Value : Boolean); begin
  FDisableSelection := Value;
  JSCode('disableSelection:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEmptyText(Value : String); begin
  FEmptyText := Value;
  JSCode('emptyText:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnHide(Value : Boolean); begin
  FEnableColumnHide := Value;
  JSCode('enableColumnHide:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnMove(Value : Boolean); begin
  FEnableColumnMove := Value;
  JSCode('enableColumnMove:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableColumnResize(Value : Boolean); begin
  FEnableColumnResize := Value;
  JSCode('enableColumnResize:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFEnableLocking(Value : Boolean); begin
  FEnableLocking := Value;
  JSCode('enableLocking:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFFeatures(Value : TExtObjectList); begin
  FFeatures := Value;
  Value.DeleteFromGarbage;
  JSCode('features:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFFeaturesList(Value : TExtObjectList); begin
  FFeaturesList := Value;
  Value.DeleteFromGarbage;
  JSCode('features:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFForceFit(Value : Boolean); begin
  FForceFit := Value;
  JSCode('forceFit:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFHasView(Value : Boolean); begin
  FHasView := Value;
  JSCode(JSName + '.hasView=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelTable.SetFHideHeaders(Value : Boolean); begin
  FHideHeaders := Value;
  JSCode('hideHeaders:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFOptimizedColumnMove(Value : Boolean); begin
  FOptimizedColumnMove := Value;
  JSCode(JSName + '.optimizedColumnMove=' + VarToJSON([Value]) + ';');
end;

procedure TExtPanelTable.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFScroll(Value : String); begin
  FScroll := Value;
  JSCode('scroll:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFScrollBoolean(Value : Boolean); begin
  FScrollBoolean := Value;
  JSCode('scroll:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSealedColumns(Value : Boolean); begin
  FSealedColumns := Value;
  JSCode('sealedColumns:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSelModel(Value : TExtSelectionModel); begin
  FSelModel := Value;
  Value.DeleteFromGarbage;
  JSCode('selModel:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFSelModelObject(Value : TExtObject); begin
  FSelModelObject := Value;
  Value.DeleteFromGarbage;
  JSCode('selModel:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFSelType(Value : String); begin
  FSelType := Value;
  JSCode('selType:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFSortableColumns(Value : Boolean); begin
  FSortableColumns := Value;
  JSCode('sortableColumns:' + VarToJSON([Value]));
end;

procedure TExtPanelTable.SetFStore(Value : TExtDataStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFVerticalScroller(Value : TExtObject); begin
  FVerticalScroller := Value;
  Value.DeleteFromGarbage;
  JSCode('verticalScroller:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFView(Value : TExtViewTable); begin
  FView := Value;
  Value.DeleteFromGarbage;
  JSCode('view:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFViewConfig(Value : TExtObject); begin
  FViewConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('viewConfig:' + VarToJSON([Value, false]));
end;

procedure TExtPanelTable.SetFOnBeforecellclick(Value : TExtPanelTableOnBeforecellclick); begin
  if Assigned(FOnBeforecellclick) then
    JSCode(JSName+'.events ["beforecellclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellclick', Ajax('beforecellclick', [], true));
  FOnBeforecellclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecellcontextmenu(Value : TExtPanelTableOnBeforecellcontextmenu); begin
  if Assigned(FOnBeforecellcontextmenu) then
    JSCode(JSName+'.events ["beforecellcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellcontextmenu', Ajax('beforecellcontextmenu', [], true));
  FOnBeforecellcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnBeforecelldblclick(Value : TExtPanelTableOnBeforecelldblclick); begin
  if Assigned(FOnBeforecelldblclick) then
    JSCode(JSName+'.events ["beforecelldblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecelldblclick', Ajax('beforecelldblclick', [], true));
  FOnBeforecelldblclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecellkeydown(Value : TExtPanelTableOnBeforecellkeydown); begin
  if Assigned(FOnBeforecellkeydown) then
    JSCode(JSName+'.events ["beforecellkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellkeydown', Ajax('beforecellkeydown', [], true));
  FOnBeforecellkeydown := Value;
end;

procedure TExtPanelTable.SetFOnBeforecellmousedown(Value : TExtPanelTableOnBeforecellmousedown); begin
  if Assigned(FOnBeforecellmousedown) then
    JSCode(JSName+'.events ["beforecellmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellmousedown', Ajax('beforecellmousedown', [], true));
  FOnBeforecellmousedown := Value;
end;

procedure TExtPanelTable.SetFOnBeforecellmouseup(Value : TExtPanelTableOnBeforecellmouseup); begin
  if Assigned(FOnBeforecellmouseup) then
    JSCode(JSName+'.events ["beforecellmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecellmouseup', Ajax('beforecellmouseup', [], true));
  FOnBeforecellmouseup := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainerclick(Value : TExtPanelTableOnBeforecontainerclick); begin
  if Assigned(FOnBeforecontainerclick) then
    JSCode(JSName+'.events ["beforecontainerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerclick', Ajax('beforecontainerclick', [], true));
  FOnBeforecontainerclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainercontextmenu(Value : TExtPanelTableOnBeforecontainercontextmenu); begin
  if Assigned(FOnBeforecontainercontextmenu) then
    JSCode(JSName+'.events ["beforecontainercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainercontextmenu', Ajax('beforecontainercontextmenu', [], true));
  FOnBeforecontainercontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainerdblclick(Value : TExtPanelTableOnBeforecontainerdblclick); begin
  if Assigned(FOnBeforecontainerdblclick) then
    JSCode(JSName+'.events ["beforecontainerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainerdblclick', Ajax('beforecontainerdblclick', [], true));
  FOnBeforecontainerdblclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermousedown(Value : TExtPanelTableOnBeforecontainermousedown); begin
  if Assigned(FOnBeforecontainermousedown) then
    JSCode(JSName+'.events ["beforecontainermousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermousedown', Ajax('beforecontainermousedown', [], true));
  FOnBeforecontainermousedown := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseout(Value : TExtPanelTableOnBeforecontainermouseout); begin
  if Assigned(FOnBeforecontainermouseout) then
    JSCode(JSName+'.events ["beforecontainermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseout', Ajax('beforecontainermouseout', [], true));
  FOnBeforecontainermouseout := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseover(Value : TExtPanelTableOnBeforecontainermouseover); begin
  if Assigned(FOnBeforecontainermouseover) then
    JSCode(JSName+'.events ["beforecontainermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseover', Ajax('beforecontainermouseover', [], true));
  FOnBeforecontainermouseover := Value;
end;

procedure TExtPanelTable.SetFOnBeforecontainermouseup(Value : TExtPanelTableOnBeforecontainermouseup); begin
  if Assigned(FOnBeforecontainermouseup) then
    JSCode(JSName+'.events ["beforecontainermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforecontainermouseup', Ajax('beforecontainermouseup', [], true));
  FOnBeforecontainermouseup := Value;
end;

procedure TExtPanelTable.SetFOnBeforedeselect(Value : TExtPanelTableOnBeforedeselect); begin
  if Assigned(FOnBeforedeselect) then
    JSCode(JSName+'.events ["beforedeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforedeselect', Ajax('beforedeselect', [], true));
  FOnBeforedeselect := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemclick(Value : TExtPanelTableOnBeforeitemclick); begin
  if Assigned(FOnBeforeitemclick) then
    JSCode(JSName+'.events ["beforeitemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemclick', Ajax('beforeitemclick', [], true));
  FOnBeforeitemclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemcontextmenu(Value : TExtPanelTableOnBeforeitemcontextmenu); begin
  if Assigned(FOnBeforeitemcontextmenu) then
    JSCode(JSName+'.events ["beforeitemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcontextmenu', Ajax('beforeitemcontextmenu', [], true));
  FOnBeforeitemcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemdblclick(Value : TExtPanelTableOnBeforeitemdblclick); begin
  if Assigned(FOnBeforeitemdblclick) then
    JSCode(JSName+'.events ["beforeitemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemdblclick', Ajax('beforeitemdblclick', [], true));
  FOnBeforeitemdblclick := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmousedown(Value : TExtPanelTableOnBeforeitemmousedown); begin
  if Assigned(FOnBeforeitemmousedown) then
    JSCode(JSName+'.events ["beforeitemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmousedown', Ajax('beforeitemmousedown', [], true));
  FOnBeforeitemmousedown := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseenter(Value : TExtPanelTableOnBeforeitemmouseenter); begin
  if Assigned(FOnBeforeitemmouseenter) then
    JSCode(JSName+'.events ["beforeitemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseenter', Ajax('beforeitemmouseenter', [], true));
  FOnBeforeitemmouseenter := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseleave(Value : TExtPanelTableOnBeforeitemmouseleave); begin
  if Assigned(FOnBeforeitemmouseleave) then
    JSCode(JSName+'.events ["beforeitemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseleave', Ajax('beforeitemmouseleave', [], true));
  FOnBeforeitemmouseleave := Value;
end;

procedure TExtPanelTable.SetFOnBeforeitemmouseup(Value : TExtPanelTableOnBeforeitemmouseup); begin
  if Assigned(FOnBeforeitemmouseup) then
    JSCode(JSName+'.events ["beforeitemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmouseup', Ajax('beforeitemmouseup', [], true));
  FOnBeforeitemmouseup := Value;
end;

procedure TExtPanelTable.SetFOnBeforeselect(Value : TExtPanelTableOnBeforeselect); begin
  if Assigned(FOnBeforeselect) then
    JSCode(JSName+'.events ["beforeselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeselect', Ajax('beforeselect', [], true));
  FOnBeforeselect := Value;
end;

procedure TExtPanelTable.SetFOnCellclick(Value : TExtPanelTableOnCellclick); begin
  if Assigned(FOnCellclick) then
    JSCode(JSName+'.events ["cellclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellclick', Ajax('cellclick', [], true));
  FOnCellclick := Value;
end;

procedure TExtPanelTable.SetFOnCellcontextmenu(Value : TExtPanelTableOnCellcontextmenu); begin
  if Assigned(FOnCellcontextmenu) then
    JSCode(JSName+'.events ["cellcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellcontextmenu', Ajax('cellcontextmenu', [], true));
  FOnCellcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnCelldblclick(Value : TExtPanelTableOnCelldblclick); begin
  if Assigned(FOnCelldblclick) then
    JSCode(JSName+'.events ["celldblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('celldblclick', Ajax('celldblclick', [], true));
  FOnCelldblclick := Value;
end;

procedure TExtPanelTable.SetFOnCellkeydown(Value : TExtPanelTableOnCellkeydown); begin
  if Assigned(FOnCellkeydown) then
    JSCode(JSName+'.events ["cellkeydown"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellkeydown', Ajax('cellkeydown', [], true));
  FOnCellkeydown := Value;
end;

procedure TExtPanelTable.SetFOnCellmousedown(Value : TExtPanelTableOnCellmousedown); begin
  if Assigned(FOnCellmousedown) then
    JSCode(JSName+'.events ["cellmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellmousedown', Ajax('cellmousedown', [], true));
  FOnCellmousedown := Value;
end;

procedure TExtPanelTable.SetFOnCellmouseup(Value : TExtPanelTableOnCellmouseup); begin
  if Assigned(FOnCellmouseup) then
    JSCode(JSName+'.events ["cellmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('cellmouseup', Ajax('cellmouseup', [], true));
  FOnCellmouseup := Value;
end;

procedure TExtPanelTable.SetFOnColumnhide(Value : TExtPanelTableOnColumnhide); begin
  if Assigned(FOnColumnhide) then
    JSCode(JSName+'.events ["columnhide"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnhide', Ajax('columnhide', [], true));
  FOnColumnhide := Value;
end;

procedure TExtPanelTable.SetFOnColumnmove(Value : TExtPanelTableOnColumnmove); begin
  if Assigned(FOnColumnmove) then
    JSCode(JSName+'.events ["columnmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnmove', Ajax('columnmove', [], true));
  FOnColumnmove := Value;
end;

procedure TExtPanelTable.SetFOnColumnresize(Value : TExtPanelTableOnColumnresize); begin
  if Assigned(FOnColumnresize) then
    JSCode(JSName+'.events ["columnresize"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnresize', Ajax('columnresize', [], true));
  FOnColumnresize := Value;
end;

procedure TExtPanelTable.SetFOnColumnschanged(Value : TExtPanelTableOnColumnschanged); begin
  if Assigned(FOnColumnschanged) then
    JSCode(JSName+'.events ["columnschanged"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnschanged', Ajax('columnschanged', [], true));
  FOnColumnschanged := Value;
end;

procedure TExtPanelTable.SetFOnColumnshow(Value : TExtPanelTableOnColumnshow); begin
  if Assigned(FOnColumnshow) then
    JSCode(JSName+'.events ["columnshow"].listeners=[];');
  if Assigned(Value) then
    AddListener('columnshow', Ajax('columnshow', [], true));
  FOnColumnshow := Value;
end;

procedure TExtPanelTable.SetFOnContainerclick(Value : TExtPanelTableOnContainerclick); begin
  if Assigned(FOnContainerclick) then
    JSCode(JSName+'.events ["containerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerclick', Ajax('containerclick', [], true));
  FOnContainerclick := Value;
end;

procedure TExtPanelTable.SetFOnContainercontextmenu(Value : TExtPanelTableOnContainercontextmenu); begin
  if Assigned(FOnContainercontextmenu) then
    JSCode(JSName+'.events ["containercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('containercontextmenu', Ajax('containercontextmenu', [], true));
  FOnContainercontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnContainerdblclick(Value : TExtPanelTableOnContainerdblclick); begin
  if Assigned(FOnContainerdblclick) then
    JSCode(JSName+'.events ["containerdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('containerdblclick', Ajax('containerdblclick', [], true));
  FOnContainerdblclick := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseout(Value : TExtPanelTableOnContainermouseout); begin
  if Assigned(FOnContainermouseout) then
    JSCode(JSName+'.events ["containermouseout"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseout', Ajax('containermouseout', [], true));
  FOnContainermouseout := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseover(Value : TExtPanelTableOnContainermouseover); begin
  if Assigned(FOnContainermouseover) then
    JSCode(JSName+'.events ["containermouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseover', Ajax('containermouseover', [], true));
  FOnContainermouseover := Value;
end;

procedure TExtPanelTable.SetFOnContainermouseup(Value : TExtPanelTableOnContainermouseup); begin
  if Assigned(FOnContainermouseup) then
    JSCode(JSName+'.events ["containermouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('containermouseup', Ajax('containermouseup', [], true));
  FOnContainermouseup := Value;
end;

procedure TExtPanelTable.SetFOnDeselect(Value : TExtPanelTableOnDeselect); begin
  if Assigned(FOnDeselect) then
    JSCode(JSName+'.events ["deselect"].listeners=[];');
  if Assigned(Value) then
    AddListener('deselect', Ajax('deselect', [], true));
  FOnDeselect := Value;
end;

procedure TExtPanelTable.SetFOnFilterchange(Value : TExtPanelTableOnFilterchange); begin
  if Assigned(FOnFilterchange) then
    JSCode(JSName+'.events ["filterchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('filterchange', Ajax('filterchange', [], true));
  FOnFilterchange := Value;
end;

procedure TExtPanelTable.SetFOnHeaderclick(Value : TExtPanelTableOnHeaderclick); begin
  if Assigned(FOnHeaderclick) then
    JSCode(JSName+'.events ["headerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headerclick', Ajax('headerclick', [], true));
  FOnHeaderclick := Value;
end;

procedure TExtPanelTable.SetFOnHeadercontextmenu(Value : TExtPanelTableOnHeadercontextmenu); begin
  if Assigned(FOnHeadercontextmenu) then
    JSCode(JSName+'.events ["headercontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('headercontextmenu', Ajax('headercontextmenu', [], true));
  FOnHeadercontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnHeadertriggerclick(Value : TExtPanelTableOnHeadertriggerclick); begin
  if Assigned(FOnHeadertriggerclick) then
    JSCode(JSName+'.events ["headertriggerclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('headertriggerclick', Ajax('headertriggerclick', [], true));
  FOnHeadertriggerclick := Value;
end;

procedure TExtPanelTable.SetFOnItemclick(Value : TExtPanelTableOnItemclick); begin
  if Assigned(FOnItemclick) then
    JSCode(JSName+'.events ["itemclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemclick', Ajax('itemclick', [], true));
  FOnItemclick := Value;
end;

procedure TExtPanelTable.SetFOnItemcontextmenu(Value : TExtPanelTableOnItemcontextmenu); begin
  if Assigned(FOnItemcontextmenu) then
    JSCode(JSName+'.events ["itemcontextmenu"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcontextmenu', Ajax('itemcontextmenu', [], true));
  FOnItemcontextmenu := Value;
end;

procedure TExtPanelTable.SetFOnItemdblclick(Value : TExtPanelTableOnItemdblclick); begin
  if Assigned(FOnItemdblclick) then
    JSCode(JSName+'.events ["itemdblclick"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemdblclick', Ajax('itemdblclick', [], true));
  FOnItemdblclick := Value;
end;

procedure TExtPanelTable.SetFOnItemmousedown(Value : TExtPanelTableOnItemmousedown); begin
  if Assigned(FOnItemmousedown) then
    JSCode(JSName+'.events ["itemmousedown"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmousedown', Ajax('itemmousedown', [], true));
  FOnItemmousedown := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseenter(Value : TExtPanelTableOnItemmouseenter); begin
  if Assigned(FOnItemmouseenter) then
    JSCode(JSName+'.events ["itemmouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseenter', Ajax('itemmouseenter', [], true));
  FOnItemmouseenter := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseleave(Value : TExtPanelTableOnItemmouseleave); begin
  if Assigned(FOnItemmouseleave) then
    JSCode(JSName+'.events ["itemmouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseleave', Ajax('itemmouseleave', [], true));
  FOnItemmouseleave := Value;
end;

procedure TExtPanelTable.SetFOnItemmouseup(Value : TExtPanelTableOnItemmouseup); begin
  if Assigned(FOnItemmouseup) then
    JSCode(JSName+'.events ["itemmouseup"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmouseup', Ajax('itemmouseup', [], true));
  FOnItemmouseup := Value;
end;

procedure TExtPanelTable.SetFOnSelect(Value : TExtPanelTableOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

procedure TExtPanelTable.SetFOnSelectionchange(Value : TExtPanelTableOnSelectionchange); begin
  if Assigned(FOnSelectionchange) then
    JSCode(JSName+'.events ["selectionchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('selectionchange', Ajax('selectionchange', [], true));
  FOnSelectionchange := Value;
end;

procedure TExtPanelTable.SetFOnSortchange(Value : TExtPanelTableOnSortchange); begin
  if Assigned(FOnSortchange) then
    JSCode(JSName+'.events ["sortchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('sortchange', Ajax('sortchange', [], true));
  FOnSortchange := Value;
end;

procedure TExtPanelTable.SetFOnViewready(Value : TExtPanelTableOnViewready); begin
  if Assigned(FOnViewready) then
    JSCode(JSName+'.events ["viewready"].listeners=[];');
  if Assigned(Value) then
    AddListener('viewready', Ajax('viewready', ['This', '%0.nm'], true));
  FOnViewready := Value;
end;

function TExtPanelTable.JSClassName : string; begin
  Result := 'Ext.panel.Table';
end;

procedure TExtPanelTable.InitDefaults; begin
  inherited;
  FColumns := TExtObjectList.Create(Self, 'columns');
  FColumnsObject := TExtObject.CreateInternal(Self, 'columns');
  FDeferRowRender := true;
  FFeatures := TExtObjectList.Create(Self, 'features');
  FFeaturesList := TExtObjectList.Create(Self, 'features');
  FSelModel := TExtSelectionModel.CreateInternal(Self, 'selModel');
  FSelModelObject := TExtObject.CreateInternal(Self, 'selModel');
  FSelType := 'rowmodel';
  FStore := TExtDataStore.CreateInternal(Self, 'store');
  FVerticalScroller := TExtObject.CreateInternal(Self, 'verticalScroller');
  FView := TExtViewTable.CreateInternal(Self, 'view');
  FViewConfig := TExtObject.CreateInternal(Self, 'viewConfig');
end;

{$IFDEF FPC}constructor TExtPanelTable.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtPanelTable.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtPanelTable.GetSelectionModel : TExtFunction; begin
  JSCode(JSName + '.getSelectionModel();', 'TExtPanelTable');
  Result := Self;
end;

function TExtPanelTable.GetStore : TExtFunction; begin
  JSCode(JSName + '.getStore();', 'TExtPanelTable');
  Result := Self;
end;

function TExtPanelTable.GetView : TExtFunction; begin
  JSCode(JSName + '.getView();', 'TExtPanelTable');
  Result := Self;
end;

destructor TExtPanelTable.Destroy; begin
  try
    FColumns.Free;
    FColumnsObject.Free;
    FFeatures.Free;
    FFeaturesList.Free;
    FSelModel.Free;
    FSelModelObject.Free;
    FStore.Free;
    FVerticalScroller.Free;
    FView.Free;
    FViewConfig.Free;
  except end;
  inherited;
end;

procedure TExtPanelTable.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforecellclick') and Assigned(FOnBeforecellclick) then
    FOnBeforecellclick()
  else if (AEvtName = 'beforecellcontextmenu') and Assigned(FOnBeforecellcontextmenu) then
    FOnBeforecellcontextmenu()
  else if (AEvtName = 'beforecelldblclick') and Assigned(FOnBeforecelldblclick) then
    FOnBeforecelldblclick()
  else if (AEvtName = 'beforecellkeydown') and Assigned(FOnBeforecellkeydown) then
    FOnBeforecellkeydown()
  else if (AEvtName = 'beforecellmousedown') and Assigned(FOnBeforecellmousedown) then
    FOnBeforecellmousedown()
  else if (AEvtName = 'beforecellmouseup') and Assigned(FOnBeforecellmouseup) then
    FOnBeforecellmouseup()
  else if (AEvtName = 'beforecontainerclick') and Assigned(FOnBeforecontainerclick) then
    FOnBeforecontainerclick()
  else if (AEvtName = 'beforecontainercontextmenu') and Assigned(FOnBeforecontainercontextmenu) then
    FOnBeforecontainercontextmenu()
  else if (AEvtName = 'beforecontainerdblclick') and Assigned(FOnBeforecontainerdblclick) then
    FOnBeforecontainerdblclick()
  else if (AEvtName = 'beforecontainermousedown') and Assigned(FOnBeforecontainermousedown) then
    FOnBeforecontainermousedown()
  else if (AEvtName = 'beforecontainermouseout') and Assigned(FOnBeforecontainermouseout) then
    FOnBeforecontainermouseout()
  else if (AEvtName = 'beforecontainermouseover') and Assigned(FOnBeforecontainermouseover) then
    FOnBeforecontainermouseover()
  else if (AEvtName = 'beforecontainermouseup') and Assigned(FOnBeforecontainermouseup) then
    FOnBeforecontainermouseup()
  else if (AEvtName = 'beforedeselect') and Assigned(FOnBeforedeselect) then
    FOnBeforedeselect()
  else if (AEvtName = 'beforeitemclick') and Assigned(FOnBeforeitemclick) then
    FOnBeforeitemclick()
  else if (AEvtName = 'beforeitemcontextmenu') and Assigned(FOnBeforeitemcontextmenu) then
    FOnBeforeitemcontextmenu()
  else if (AEvtName = 'beforeitemdblclick') and Assigned(FOnBeforeitemdblclick) then
    FOnBeforeitemdblclick()
  else if (AEvtName = 'beforeitemmousedown') and Assigned(FOnBeforeitemmousedown) then
    FOnBeforeitemmousedown()
  else if (AEvtName = 'beforeitemmouseenter') and Assigned(FOnBeforeitemmouseenter) then
    FOnBeforeitemmouseenter()
  else if (AEvtName = 'beforeitemmouseleave') and Assigned(FOnBeforeitemmouseleave) then
    FOnBeforeitemmouseleave()
  else if (AEvtName = 'beforeitemmouseup') and Assigned(FOnBeforeitemmouseup) then
    FOnBeforeitemmouseup()
  else if (AEvtName = 'beforeselect') and Assigned(FOnBeforeselect) then
    FOnBeforeselect()
  else if (AEvtName = 'cellclick') and Assigned(FOnCellclick) then
    FOnCellclick()
  else if (AEvtName = 'cellcontextmenu') and Assigned(FOnCellcontextmenu) then
    FOnCellcontextmenu()
  else if (AEvtName = 'celldblclick') and Assigned(FOnCelldblclick) then
    FOnCelldblclick()
  else if (AEvtName = 'cellkeydown') and Assigned(FOnCellkeydown) then
    FOnCellkeydown()
  else if (AEvtName = 'cellmousedown') and Assigned(FOnCellmousedown) then
    FOnCellmousedown()
  else if (AEvtName = 'cellmouseup') and Assigned(FOnCellmouseup) then
    FOnCellmouseup()
  else if (AEvtName = 'columnhide') and Assigned(FOnColumnhide) then
    FOnColumnhide()
  else if (AEvtName = 'columnmove') and Assigned(FOnColumnmove) then
    FOnColumnmove()
  else if (AEvtName = 'columnresize') and Assigned(FOnColumnresize) then
    FOnColumnresize()
  else if (AEvtName = 'columnschanged') and Assigned(FOnColumnschanged) then
    FOnColumnschanged()
  else if (AEvtName = 'columnshow') and Assigned(FOnColumnshow) then
    FOnColumnshow()
  else if (AEvtName = 'containerclick') and Assigned(FOnContainerclick) then
    FOnContainerclick()
  else if (AEvtName = 'containercontextmenu') and Assigned(FOnContainercontextmenu) then
    FOnContainercontextmenu()
  else if (AEvtName = 'containerdblclick') and Assigned(FOnContainerdblclick) then
    FOnContainerdblclick()
  else if (AEvtName = 'containermouseout') and Assigned(FOnContainermouseout) then
    FOnContainermouseout()
  else if (AEvtName = 'containermouseover') and Assigned(FOnContainermouseover) then
    FOnContainermouseover()
  else if (AEvtName = 'containermouseup') and Assigned(FOnContainermouseup) then
    FOnContainermouseup()
  else if (AEvtName = 'deselect') and Assigned(FOnDeselect) then
    FOnDeselect()
  else if (AEvtName = 'filterchange') and Assigned(FOnFilterchange) then
    FOnFilterchange()
  else if (AEvtName = 'headerclick') and Assigned(FOnHeaderclick) then
    FOnHeaderclick()
  else if (AEvtName = 'headercontextmenu') and Assigned(FOnHeadercontextmenu) then
    FOnHeadercontextmenu()
  else if (AEvtName = 'headertriggerclick') and Assigned(FOnHeadertriggerclick) then
    FOnHeadertriggerclick()
  else if (AEvtName = 'itemclick') and Assigned(FOnItemclick) then
    FOnItemclick()
  else if (AEvtName = 'itemcontextmenu') and Assigned(FOnItemcontextmenu) then
    FOnItemcontextmenu()
  else if (AEvtName = 'itemdblclick') and Assigned(FOnItemdblclick) then
    FOnItemdblclick()
  else if (AEvtName = 'itemmousedown') and Assigned(FOnItemmousedown) then
    FOnItemmousedown()
  else if (AEvtName = 'itemmouseenter') and Assigned(FOnItemmouseenter) then
    FOnItemmouseenter()
  else if (AEvtName = 'itemmouseleave') and Assigned(FOnItemmouseleave) then
    FOnItemmouseleave()
  else if (AEvtName = 'itemmouseup') and Assigned(FOnItemmouseup) then
    FOnItemmouseup()
  else if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect()
  else if (AEvtName = 'selectionchange') and Assigned(FOnSelectionchange) then
    FOnSelectionchange()
  else if (AEvtName = 'sortchange') and Assigned(FOnSortchange) then
    FOnSortchange()
  else if (AEvtName = 'viewready') and Assigned(FOnViewready) then
    FOnViewready(TExtPanelTable(ParamAsObject('This')));
end;

function TExtTreeColumn.JSClassName : string; begin
  Result := 'Ext.tree.Column';
end;

{$IFDEF FPC}constructor TExtTreeColumn.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTip.SetFClosable(Value : Boolean); begin
  FClosable := Value;
  JSCode('closable:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFCloseAction(Value : String); begin
  FCloseAction := Value;
  JSCode('closeAction:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFConstrainPosition(Value : Boolean); begin
  FConstrainPosition := Value;
  JSCode('constrainPosition:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFDefaultAlign(Value : String); begin
  FDefaultAlign := Value;
  JSCode('defaultAlign:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFMaxWidth(Value : Integer); begin
  FMaxWidth := Value;
  JSCode('maxWidth:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFShadow(Value : Boolean); begin
  FShadow := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFShadowString(Value : String); begin
  FShadowString := Value;
  JSCode('shadow:' + VarToJSON([Value]));
end;

procedure TExtTip.SetFWidth(Value : Integer); begin
  FWidth := Value;
  JSCode('width:' + VarToJSON([Value]));
end;

function TExtTip.JSClassName : string; begin
  Result := 'Ext.tip.Tip';
end;

{$IFDEF FPC}constructor TExtTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTip.ShowAt(Xy : TArrayOfInteger) : TExtFunction; begin
  JSCode(JSName + '.showAt(' + VarToJSON([Xy]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : THTMLElement; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([El, false, Position]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : TExtElement; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.ShowBy(' + VarToJSON([El, false, Position]) + ');', 'TExtTip');
  Result := Self;
end;

function TExtTip.ShowBy(El : String; Position : String = '') : TExtFunction; begin
  JSCode(JSName + '.showBy(' + VarToJSON([El, Position]) + ');', 'TExtTip');
  Result := Self;
end;

procedure TExtTabPanel.SetFActiveItem(Value : Integer); begin
  FActiveItem := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveItemString(Value : String); begin
  FActiveItemString := Value;
  JSCode('activeItem:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveTab(Value : Integer); begin
  FActiveTab := Value;
  JSCode('activeTab:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFActiveTabComponent(Value : TExtComponent); begin
  FActiveTabComponent := Value;
  Value.DeleteFromGarbage;
  JSCode('activeTab:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFActiveTabString(Value : String); begin
  FActiveTabString := Value;
  JSCode('activeTab:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFDeferredRender(Value : Boolean); begin
  FDeferredRender := Value;
  JSCode('deferredRender:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFItemCls(Value : String); begin
  FItemCls := Value;
  JSCode('itemCls:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFLayout(Value : TExtEnumsLayout); begin
  FLayout := Value;
  JSCode('layout:"' + EnumToJSString(TypeInfo(TExtEnumsLayout), ord(Value)) + '"');
end;

procedure TExtTabPanel.SetFLayoutObject(Value : TExtObject); begin
  FLayoutObject := Value;
  Value.DeleteFromGarbage;
  JSCode('layout:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFMaxTabWidth(Value : Integer); begin
  FMaxTabWidth := Value;
  JSCode('maxTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFMinTabWidth(Value : Integer); begin
  FMinTabWidth := Value;
  JSCode('minTabWidth:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFRemovePanelHeader(Value : Boolean); begin
  FRemovePanelHeader := Value;
  JSCode('removePanelHeader:' + VarToJSON([Value]));
end;

procedure TExtTabPanel.SetFTabBar(Value : TExtObject); begin
  FTabBar := Value;
  Value.DeleteFromGarbage;
  JSCode('tabBar:' + VarToJSON([Value, false]));
end;

procedure TExtTabPanel.SetFTabPosition(Value : TTabPositionEnum); begin
  FTabPosition := Value;
  JSCode('tabPosition:"' + EnumToJSString(TypeInfo(TTabPositionEnum), ord(Value)) + '"');
end;

procedure TExtTabPanel.SetFOnBeforetabchange(Value : TExtTabPanelOnBeforetabchange); begin
  if Assigned(FOnBeforetabchange) then
    JSCode(JSName+'.events ["beforetabchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforetabchange', Ajax('beforetabchange', ['TabPanel', '%0.nm','NewCard', '%1.nm','OldCard', '%2.nm'], true));
  FOnBeforetabchange := Value;
end;

procedure TExtTabPanel.SetFOnTabchange(Value : TExtTabPanelOnTabchange); begin
  if Assigned(FOnTabchange) then
    JSCode(JSName+'.events ["tabchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('tabchange', Ajax('tabchange', ['TabPanel', '%0.nm','NewCard', '%1.nm','OldCard', '%2.nm'], true));
  FOnTabchange := Value;
end;

function TExtTabPanel.JSClassName : string; begin
  Result := 'Ext.tab.Panel';
end;

procedure TExtTabPanel.InitDefaults; begin
  inherited;
  FActiveTabComponent := TExtComponent.CreateInternal(Self, 'activeTab');
  FLayoutObject := TExtObject.CreateInternal(Self, 'layout');
  FTabBar := TExtObject.CreateInternal(Self, 'tabBar');
end;

{$IFDEF FPC}constructor TExtTabPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTabPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTabPanel.GetActiveTab : TExtFunction; begin
  JSCode(JSName + '.getActiveTab();', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.GetTabBar : TExtFunction; begin
  JSCode(JSName + '.getTabBar();', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.SetActiveTab(Card : TExtComponent) : TExtFunction; begin
  JSCode(JSName + '.SetActiveTab(' + VarToJSON([Card, false]) + ');', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.SetActiveTab(Card : String) : TExtFunction; begin
  JSCode(JSName + '.SetActiveTab(' + VarToJSON([Card]) + ');', 'TExtTabPanel');
  Result := Self;
end;

function TExtTabPanel.SetActiveTab(Card : Integer) : TExtFunction; begin
  JSCode(JSName + '.setActiveTab(' + VarToJSON([Card]) + ');', 'TExtTabPanel');
  Result := Self;
end;

destructor TExtTabPanel.Destroy; begin
  try
    FActiveTabComponent.Free;
    FLayoutObject.Free;
    FTabBar.Free;
  except end;
  inherited;
end;

procedure TExtTabPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforetabchange') and Assigned(FOnBeforetabchange) then
    FOnBeforetabchange(TExtTabPanel(ParamAsObject('TabPanel')), TExtComponent(ParamAsObject('NewCard')), TExtComponent(ParamAsObject('OldCard')))
  else if (AEvtName = 'tabchange') and Assigned(FOnTabchange) then
    FOnTabchange(TExtTabPanel(ParamAsObject('TabPanel')), TExtComponent(ParamAsObject('NewCard')), TExtComponent(ParamAsObject('OldCard')));
end;

procedure TExtTreeViewDropZone.SetFAllowContainerDrop(Value : String); begin
  FAllowContainerDrop := Value;
  JSCode('allowContainerDrop:' + VarToJSON([Value]));
end;

procedure TExtTreeViewDropZone.SetFAllowParentInserts(Value : Boolean); begin
  FAllowParentInserts := Value;
  JSCode('allowParentInserts:' + VarToJSON([Value]));
end;

procedure TExtTreeViewDropZone.SetFAppendOnly(Value : String); begin
  FAppendOnly := Value;
  JSCode('appendOnly:' + VarToJSON([Value]));
end;

procedure TExtTreeViewDropZone.SetFExpandDelay(Value : String); begin
  FExpandDelay := Value;
  JSCode('expandDelay:' + VarToJSON([Value]));
end;

function TExtTreeViewDropZone.JSClassName : string; begin
  Result := 'Ext.tree.ViewDropZone';
end;

{$IFDEF FPC}constructor TExtTreeViewDropZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtMenu.SetFAllowOtherMenus(Value : Boolean); begin
  FAllowOtherMenus := Value;
  JSCode('allowOtherMenus:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFEnableKeyNav(Value : Boolean); begin
  FEnableKeyNav := Value;
  JSCode('enableKeyNav:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFFloating(Value : Boolean); begin
  FFloating := Value;
  JSCode('floating:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFHidden(Value : Boolean); begin
  FHidden := Value;
  JSCode('hidden:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFIgnoreParentClicks(Value : Boolean); begin
  FIgnoreParentClicks := Value;
  JSCode('ignoreParentClicks:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFIsMenu(Value : Boolean); begin
  FIsMenu := Value;
  JSCode(JSName + '.isMenu=' + VarToJSON([Value]) + ';');
end;

procedure TExtMenu.SetFMinWidth(Value : Integer); begin
  FMinWidth := Value;
  JSCode('minWidth:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFParentMenu(Value : TExtMenu); begin
  FParentMenu := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.parentMenu=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenu.SetFPlain(Value : Boolean); begin
  FPlain := Value;
  JSCode('plain:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFShowSeparator(Value : Boolean); begin
  FShowSeparator := Value;
  JSCode('showSeparator:' + VarToJSON([Value]));
end;

procedure TExtMenu.SetFOnClick(Value : TExtMenuOnClick); begin
  if Assigned(FOnClick) then
    JSCode(JSName+'.events ["click"].listeners=[];');
  if Assigned(Value) then
    AddListener('click', Ajax('click', ['Menu', '%0.nm','Item', '%1.nm','E', '%2.nm'], true));
  FOnClick := Value;
end;

procedure TExtMenu.SetFOnMouseenter(Value : TExtMenuOnMouseenter); begin
  if Assigned(FOnMouseenter) then
    JSCode(JSName+'.events ["mouseenter"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseenter', Ajax('mouseenter', ['Menu', '%0.nm','E', '%1.nm'], true));
  FOnMouseenter := Value;
end;

procedure TExtMenu.SetFOnMouseleave(Value : TExtMenuOnMouseleave); begin
  if Assigned(FOnMouseleave) then
    JSCode(JSName+'.events ["mouseleave"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseleave', Ajax('mouseleave', ['Menu', '%0.nm','E', '%1.nm'], true));
  FOnMouseleave := Value;
end;

procedure TExtMenu.SetFOnMouseover(Value : TExtMenuOnMouseover); begin
  if Assigned(FOnMouseover) then
    JSCode(JSName+'.events ["mouseover"].listeners=[];');
  if Assigned(Value) then
    AddListener('mouseover', Ajax('mouseover', ['Menu', '%0.nm','Item', '%1.nm','E', '%2.nm'], true));
  FOnMouseover := Value;
end;

function TExtMenu.JSClassName : string; begin
  Result := 'Ext.menu.Menu';
end;

procedure TExtMenu.InitDefaults; begin
  inherited;
  FHidden := true;
  FParentMenu := TExtMenu.CreateInternal(Self, 'parentMenu');
end;

{$IFDEF FPC}constructor TExtMenu.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtMenu.CanActivateItem : TExtFunction; begin
  JSCode(JSName + '.canActivateItem();', 'TExtMenu');
  Result := Self;
end;

constructor TExtMenu.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtMenu.DeactivateActiveItem : TExtFunction; begin
  JSCode(JSName + '.deactivateActiveItem();', 'TExtMenu');
  Result := Self;
end;

destructor TExtMenu.Destroy; begin
  try
    FParentMenu.Free;
  except end;
  inherited;
end;

procedure TExtMenu.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'click') and Assigned(FOnClick) then
    FOnClick(TExtMenu(ParamAsObject('Menu')), TExtComponent(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseenter') and Assigned(FOnMouseenter) then
    FOnMouseenter(TExtMenu(ParamAsObject('Menu')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseleave') and Assigned(FOnMouseleave) then
    FOnMouseleave(TExtMenu(ParamAsObject('Menu')), TExtEventObject(ParamAsObject('E')))
  else if (AEvtName = 'mouseover') and Assigned(FOnMouseover) then
    FOnMouseover(TExtMenu(ParamAsObject('Menu')), TExtComponent(ParamAsObject('Item')), TExtEventObject(ParamAsObject('E')));
end;

function TExtLayoutComponentFieldHtmlEditor.JSClassName : string; begin
  Result := 'Ext.layout.component.field.HtmlEditor';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldHtmlEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtLayoutComponentFieldTextArea.JSClassName : string; begin
  Result := 'Ext.layout.component.field.TextArea';
end;

{$IFDEF FPC}constructor TExtLayoutComponentFieldTextArea.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtTipToolTip.SetFAnchor(Value : String); begin
  FAnchor := Value;
  JSCode('anchor:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAnchorOffset(Value : Integer); begin
  FAnchorOffset := Value;
  JSCode('anchorOffset:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAnchorToTarget(Value : Boolean); begin
  FAnchorToTarget := Value;
  JSCode('anchorToTarget:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFAutoHide(Value : Boolean); begin
  FAutoHide := Value;
  JSCode('autoHide:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFDelegate(Value : String); begin
  FDelegate := Value;
  JSCode('delegate:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFDismissDelay(Value : Integer); begin
  FDismissDelay := Value;
  JSCode('dismissDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFHideDelay(Value : Integer); begin
  FHideDelay := Value;
  JSCode('hideDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFMouseOffset(Value : TArrayOfInteger); begin
  FMouseOffset := Value;
  JSCode('mouseOffset:' + ArrayToJSON(Value));
end;

procedure TExtTipToolTip.SetFShowDelay(Value : Integer); begin
  FShowDelay := Value;
  JSCode('showDelay:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFTarget(Value : THTMLElement); begin
  FTarget := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetTarget(Value)
  else
    JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipToolTip.SetFTargetElement(Value : TExtElement); begin
  FTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipToolTip.SetFTargetString(Value : String); begin
  FTargetString := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFTrackMouse(Value : Boolean); begin
  FTrackMouse := Value;
  JSCode('trackMouse:' + VarToJSON([Value]));
end;

procedure TExtTipToolTip.SetFTriggerElement(Value : THTMLElement); begin
  FTriggerElement := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.triggerElement=' + VarToJSON([Value, false]) + ';');
end;

function TExtTipToolTip.JSClassName : string; begin
  Result := 'Ext.tip.ToolTip';
end;

procedure TExtTipToolTip.InitDefaults; begin
  inherited;
  FTargetElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtTipToolTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtTipToolTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTipToolTip.Hide : TExtFunction; begin
  JSCode(JSName + '.hide();', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.SetTarget(T : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([T, false]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.SetTarget(T : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.SetTarget(' + VarToJSON([T, false]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.SetTarget(T : String) : TExtFunction; begin
  JSCode(JSName + '.setTarget(' + VarToJSON([T]) + ');', 'TExtTipToolTip');
  Result := Self;
end;

function TExtTipToolTip.Show : TExtFunction; begin
  JSCode(JSName + '.show();', 'TExtTipToolTip');
  Result := Self;
end;

destructor TExtTipToolTip.Destroy; begin
  try
    FTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtTreePanel.SetFAnimate(Value : Boolean); begin
  FAnimate := Value;
  JSCode('animate:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFDisplayField(Value : String); begin
  FDisplayField := Value;
  JSCode('displayField:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFFolderSort(Value : Boolean); begin
  FFolderSort := Value;
  JSCode('folderSort:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFHideHeaders(Value : Boolean); begin
  FHideHeaders := Value;
  JSCode('hideHeaders:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFLines(Value : Boolean); begin
  FLines := Value;
  JSCode('lines:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFRoot(Value : TExtDataModel); begin
  FRoot := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFRootInterface(Value : TExtDataNodeInterface); begin
  FRootInterface := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFRootObject(Value : TExtObject); begin
  FRootObject := Value;
  Value.DeleteFromGarbage;
  JSCode('root:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFRootVisible(Value : Boolean); begin
  FRootVisible := Value;
  JSCode('rootVisible:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFSingleExpand(Value : Boolean); begin
  FSingleExpand := Value;
  JSCode('singleExpand:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFStore(Value : TExtDataTreeStore); begin
  FStore := Value;
  Value.DeleteFromGarbage;
  JSCode('store:' + VarToJSON([Value, false]));
end;

procedure TExtTreePanel.SetFUseArrows(Value : Boolean); begin
  FUseArrows := Value;
  JSCode('useArrows:' + VarToJSON([Value]));
end;

procedure TExtTreePanel.SetFOnAfteritemcollapse(Value : TExtTreePanelOnAfteritemcollapse); begin
  if Assigned(FOnAfteritemcollapse) then
    JSCode(JSName+'.events ["afteritemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemcollapse', Ajax('afteritemcollapse', [], true));
  FOnAfteritemcollapse := Value;
end;

procedure TExtTreePanel.SetFOnAfteritemexpand(Value : TExtTreePanelOnAfteritemexpand); begin
  if Assigned(FOnAfteritemexpand) then
    JSCode(JSName+'.events ["afteritemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('afteritemexpand', Ajax('afteritemexpand', [], true));
  FOnAfteritemexpand := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemappend(Value : TExtTreePanelOnBeforeitemappend); begin
  if Assigned(FOnBeforeitemappend) then
    JSCode(JSName+'.events ["beforeitemappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemappend', Ajax('beforeitemappend', [], true));
  FOnBeforeitemappend := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemcollapse(Value : TExtTreePanelOnBeforeitemcollapse); begin
  if Assigned(FOnBeforeitemcollapse) then
    JSCode(JSName+'.events ["beforeitemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemcollapse', Ajax('beforeitemcollapse', [], true));
  FOnBeforeitemcollapse := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemexpand(Value : TExtTreePanelOnBeforeitemexpand); begin
  if Assigned(FOnBeforeitemexpand) then
    JSCode(JSName+'.events ["beforeitemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemexpand', Ajax('beforeitemexpand', [], true));
  FOnBeforeitemexpand := Value;
end;

procedure TExtTreePanel.SetFOnBeforeiteminsert(Value : TExtTreePanelOnBeforeiteminsert); begin
  if Assigned(FOnBeforeiteminsert) then
    JSCode(JSName+'.events ["beforeiteminsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeiteminsert', Ajax('beforeiteminsert', [], true));
  FOnBeforeiteminsert := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemmove(Value : TExtTreePanelOnBeforeitemmove); begin
  if Assigned(FOnBeforeitemmove) then
    JSCode(JSName+'.events ["beforeitemmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemmove', Ajax('beforeitemmove', [], true));
  FOnBeforeitemmove := Value;
end;

procedure TExtTreePanel.SetFOnBeforeitemremove(Value : TExtTreePanelOnBeforeitemremove); begin
  if Assigned(FOnBeforeitemremove) then
    JSCode(JSName+'.events ["beforeitemremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeitemremove', Ajax('beforeitemremove', [], true));
  FOnBeforeitemremove := Value;
end;

procedure TExtTreePanel.SetFOnBeforeload(Value : TExtTreePanelOnBeforeload); begin
  if Assigned(FOnBeforeload) then
    JSCode(JSName+'.events ["beforeload"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforeload', Ajax('beforeload', [], true));
  FOnBeforeload := Value;
end;

procedure TExtTreePanel.SetFOnCheckchange(Value : TExtTreePanelOnCheckchange); begin
  if Assigned(FOnCheckchange) then
    JSCode(JSName+'.events ["checkchange"].listeners=[];');
  if Assigned(Value) then
    AddListener('checkchange', Ajax('checkchange', ['Node', '%0.nm','Checked', '%1'], true));
  FOnCheckchange := Value;
end;

procedure TExtTreePanel.SetFOnItemappend(Value : TExtTreePanelOnItemappend); begin
  if Assigned(FOnItemappend) then
    JSCode(JSName+'.events ["itemappend"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemappend', Ajax('itemappend', [], true));
  FOnItemappend := Value;
end;

procedure TExtTreePanel.SetFOnItemcollapse(Value : TExtTreePanelOnItemcollapse); begin
  if Assigned(FOnItemcollapse) then
    JSCode(JSName+'.events ["itemcollapse"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemcollapse', Ajax('itemcollapse', [], true));
  FOnItemcollapse := Value;
end;

procedure TExtTreePanel.SetFOnItemexpand(Value : TExtTreePanelOnItemexpand); begin
  if Assigned(FOnItemexpand) then
    JSCode(JSName+'.events ["itemexpand"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemexpand', Ajax('itemexpand', [], true));
  FOnItemexpand := Value;
end;

procedure TExtTreePanel.SetFOnIteminsert(Value : TExtTreePanelOnIteminsert); begin
  if Assigned(FOnIteminsert) then
    JSCode(JSName+'.events ["iteminsert"].listeners=[];');
  if Assigned(Value) then
    AddListener('iteminsert', Ajax('iteminsert', [], true));
  FOnIteminsert := Value;
end;

procedure TExtTreePanel.SetFOnItemmove(Value : TExtTreePanelOnItemmove); begin
  if Assigned(FOnItemmove) then
    JSCode(JSName+'.events ["itemmove"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemmove', Ajax('itemmove', [], true));
  FOnItemmove := Value;
end;

procedure TExtTreePanel.SetFOnItemremove(Value : TExtTreePanelOnItemremove); begin
  if Assigned(FOnItemremove) then
    JSCode(JSName+'.events ["itemremove"].listeners=[];');
  if Assigned(Value) then
    AddListener('itemremove', Ajax('itemremove', [], true));
  FOnItemremove := Value;
end;

procedure TExtTreePanel.SetFOnLoad(Value : TExtTreePanelOnLoad); begin
  if Assigned(FOnLoad) then
    JSCode(JSName+'.events ["load"].listeners=[];');
  if Assigned(Value) then
    AddListener('load', Ajax('load', [], true));
  FOnLoad := Value;
end;

function TExtTreePanel.JSClassName : string; begin
  Result := 'Ext.tree.Panel';
end;

procedure TExtTreePanel.InitDefaults; begin
  inherited;
  FRoot := TExtDataModel.CreateInternal(Self, 'root');
  FRootInterface := TExtDataNodeInterface.CreateInternal(Self, 'root');
  FRootObject := TExtObject.CreateInternal(Self, 'root');
  FStore := TExtDataTreeStore.CreateInternal(Self, 'store');
end;

{$IFDEF FPC}constructor TExtTreePanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTreePanel.CollapseAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseAll(' + VarToJSON([Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.CollapseNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.collapseNode(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

constructor TExtTreePanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTreePanel.ExpandAll(Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandAll(' + VarToJSON([Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.ExpandNode(RecordJS : TExtDataModel; Deep : Boolean = false; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandNode(' + VarToJSON([RecordJS, false, Deep, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.ExpandPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.expandPath(' + VarToJSON([Path, Field, Separator, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.GetChecked : TExtFunction; begin
  JSCode(JSName + '.getChecked();', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.GetRootNode : TExtFunction; begin
  JSCode(JSName + '.getRootNode();', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SelectPath(Path : String; Field : String = ''; Separator : String = ''; Callback : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.selectPath(' + VarToJSON([Path, Field, Separator, Callback, true, Scope, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SetRootNode(Root : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SetRootNode(Root : TExtDataNodeInterface) : TExtFunction; begin
  JSCode(JSName + '.SetRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

function TExtTreePanel.SetRootNode(Root : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.setRootNode(' + VarToJSON([Root, false]) + ');', 'TExtTreePanel');
  Result := Self;
end;

destructor TExtTreePanel.Destroy; begin
  try
    FRoot.Free;
    FRootInterface.Free;
    FRootObject.Free;
    FStore.Free;
  except end;
  inherited;
end;

procedure TExtTreePanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'afteritemcollapse') and Assigned(FOnAfteritemcollapse) then
    FOnAfteritemcollapse()
  else if (AEvtName = 'afteritemexpand') and Assigned(FOnAfteritemexpand) then
    FOnAfteritemexpand()
  else if (AEvtName = 'beforeitemappend') and Assigned(FOnBeforeitemappend) then
    FOnBeforeitemappend()
  else if (AEvtName = 'beforeitemcollapse') and Assigned(FOnBeforeitemcollapse) then
    FOnBeforeitemcollapse()
  else if (AEvtName = 'beforeitemexpand') and Assigned(FOnBeforeitemexpand) then
    FOnBeforeitemexpand()
  else if (AEvtName = 'beforeiteminsert') and Assigned(FOnBeforeiteminsert) then
    FOnBeforeiteminsert()
  else if (AEvtName = 'beforeitemmove') and Assigned(FOnBeforeitemmove) then
    FOnBeforeitemmove()
  else if (AEvtName = 'beforeitemremove') and Assigned(FOnBeforeitemremove) then
    FOnBeforeitemremove()
  else if (AEvtName = 'beforeload') and Assigned(FOnBeforeload) then
    FOnBeforeload()
  else if (AEvtName = 'checkchange') and Assigned(FOnCheckchange) then
    FOnCheckchange(TExtDataNodeInterface(ParamAsObject('Node')), ParamAsBoolean('Checked'))
  else if (AEvtName = 'itemappend') and Assigned(FOnItemappend) then
    FOnItemappend()
  else if (AEvtName = 'itemcollapse') and Assigned(FOnItemcollapse) then
    FOnItemcollapse()
  else if (AEvtName = 'itemexpand') and Assigned(FOnItemexpand) then
    FOnItemexpand()
  else if (AEvtName = 'iteminsert') and Assigned(FOnIteminsert) then
    FOnIteminsert()
  else if (AEvtName = 'itemmove') and Assigned(FOnItemmove) then
    FOnItemmove()
  else if (AEvtName = 'itemremove') and Assigned(FOnItemremove) then
    FOnItemremove()
  else if (AEvtName = 'load') and Assigned(FOnLoad) then
    FOnLoad();
end;

function TExtTreeViewDragZone.JSClassName : string; begin
  Result := 'Ext.tree.ViewDragZone';
end;

{$IFDEF FPC}constructor TExtTreeViewDragZone.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

procedure TExtFormFieldTime.SetFAltFormats(Value : String); begin
  FAltFormats := Value;
  JSCode('altFormats:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFFormat(Value : String); begin
  FFormat := Value;
  JSCode('format:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFIncrement(Value : Integer); begin
  FIncrement := Value;
  JSCode('increment:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFInvalidText(Value : String); begin
  FInvalidText := Value;
  JSCode('invalidText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxText(Value : String); begin
  FMaxText := Value;
  JSCode('maxText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxValue(Value : TDateTime); begin
  FMaxValue := Value;
  if not ConfigAvailable(JSName) then
    SetMaxValue(Value)
  else
    JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMaxValueString(Value : String); begin
  FMaxValueString := Value;
  JSCode('maxValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinText(Value : String); begin
  FMinText := Value;
  JSCode('minText:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinValue(Value : TDateTime); begin
  FMinValue := Value;
  if not ConfigAvailable(JSName) then
    SetMinValue(Value)
  else
    JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFMinValueString(Value : String); begin
  FMinValueString := Value;
  JSCode('minValue:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFPickerMaxHeight(Value : Integer); begin
  FPickerMaxHeight := Value;
  JSCode('pickerMaxHeight:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSelectOnTab(Value : Boolean); begin
  FSelectOnTab := Value;
  JSCode('selectOnTab:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSnapToIncrement(Value : Boolean); begin
  FSnapToIncrement := Value;
  JSCode('snapToIncrement:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFSubmitFormat(Value : String); begin
  FSubmitFormat := Value;
  JSCode('submitFormat:' + VarToJSON([Value]));
end;

procedure TExtFormFieldTime.SetFTriggerCls(Value : String); begin
  FTriggerCls := Value;
  JSCode('triggerCls:' + VarToJSON([Value]));
end;

function TExtFormFieldTime.JSClassName : string; begin
  Result := 'Ext.form.field.Time';
end;

procedure TExtFormFieldTime.InitDefaults; begin
  inherited;
  FFormat := 'g:i A';
end;

{$IFDEF FPC}constructor TExtFormFieldTime.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtFormFieldTime.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtFormFieldTime.GetErrors(Value : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.getErrors(' + VarToJSON([Value, false]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMaxValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.SetMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMaxValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setMaxValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMinValue(Value : TDateTime) : TExtFunction; begin
  JSCode(JSName + '.SetMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtFormFieldTime.SetMinValue(Value : String) : TExtFunction; begin
  JSCode(JSName + '.setMinValue(' + VarToJSON([Value]) + ');', 'TExtFormFieldTime');
  Result := Self;
end;

function TExtWindowMessageBox.JSClassName : string; begin
  Result := 'Ext.window.MessageBox';
end;

{$IFDEF FPC}constructor TExtWindowMessageBox.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtWindowMessageBox.Alert(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.alert(' + VarToJSON([Title, Msg, Fn, true, Scope, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Confirm(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.confirm(' + VarToJSON([Title, Msg, Fn, true, Scope, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Progress(Title : String; Msg : String; ProgressText : String = '') : TExtFunction; begin
  JSCode(JSName + '.progress(' + VarToJSON([Title, Msg, ProgressText]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Prompt(Title : String; Msg : String; Fn : TExtFunction; Scope : TExtObject; Multiline : Integer; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.Prompt(' + VarToJSON([Title, Msg, Fn, true, Scope, false, Multiline, Value]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Prompt(Title : String; Msg : String; Fn : TExtFunction = nil; Scope : TExtObject = nil; Multiline : Boolean = false; Value : String = '') : TExtFunction; begin
  JSCode(JSName + '.prompt(' + VarToJSON([Title, Msg, Fn, true, Scope, false, Multiline, Value]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.SetIcon(Icon : String; Width : Integer = 0; Height : Integer = 0) : TExtFunction; begin
  JSCode(JSName + '.setIcon(' + VarToJSON([Icon, Width, Height]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Show(Config : TExtShowConfig) : TExtFunction; begin
  JSCode(JSName + '.show(' + VarToJSON([Config, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.UpdateProgress(Value : Integer = 0; ProgressText : String = ''; Msg : String = '') : TExtFunction; begin
  JSCode(JSName + '.updateProgress(' + VarToJSON([Value, ProgressText, Msg]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

function TExtWindowMessageBox.Wait(Msg : String; Title : String = ''; Config : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.wait(' + VarToJSON([Msg, Title, Config, false]) + ');', 'TExtWindowMessageBox');
  Result := Self;
end;

procedure TExtMenuColorPicker.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuColorPicker.SetFPicker(Value : TExtPickerColor); begin
  FPicker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.picker=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenuColorPicker.SetFPickerId(Value : String); begin
  FPickerId := Value;
  JSCode('pickerId:' + VarToJSON([Value]));
end;

procedure TExtMenuColorPicker.SetFOnSelect(Value : TExtMenuColorPickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

function TExtMenuColorPicker.JSClassName : string; begin
  Result := 'Ext.menu.ColorPicker';
end;

procedure TExtMenuColorPicker.InitDefaults; begin
  inherited;
  FPicker := TExtPickerColor.CreateInternal(Self, 'picker');
end;

{$IFDEF FPC}constructor TExtMenuColorPicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuColorPicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtMenuColorPicker.Destroy; begin
  try
    FPicker.Free;
  except end;
  inherited;
end;

procedure TExtMenuColorPicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect();
end;

procedure TExtGridPanel.SetFColumns(Value : TExtObjectList); begin
  FColumns := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridPanel.SetFColumnsObject(Value : TExtObject); begin
  FColumnsObject := Value;
  Value.DeleteFromGarbage;
  JSCode('columns:' + VarToJSON([Value, false]));
end;

procedure TExtGridPanel.SetFRowLines(Value : Boolean); begin
  FRowLines := Value;
  JSCode('rowLines:' + VarToJSON([Value]));
end;

procedure TExtGridPanel.SetFOnBeforereconfigure(Value : TExtGridPanelOnBeforereconfigure); begin
  if Assigned(FOnBeforereconfigure) then
    JSCode(JSName+'.events ["beforereconfigure"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforereconfigure', Ajax('beforereconfigure', ['This', '%0.nm','Store', '%1.nm','Columns', '%2.nm','OldStore', '%3.nm','The', '%4.nm'], true));
  FOnBeforereconfigure := Value;
end;

procedure TExtGridPanel.SetFOnReconfigure(Value : TExtGridPanelOnReconfigure); begin
  if Assigned(FOnReconfigure) then
    JSCode(JSName+'.events ["reconfigure"].listeners=[];');
  if Assigned(Value) then
    AddListener('reconfigure', Ajax('reconfigure', ['This', '%0.nm','Store', '%1.nm','Columns', '%2.nm','OldStore', '%3.nm','The', '%4.nm'], true));
  FOnReconfigure := Value;
end;

function TExtGridPanel.JSClassName : string; begin
  Result := 'Ext.grid.Panel';
end;

procedure TExtGridPanel.InitDefaults; begin
  inherited;
  FColumns := TExtObjectList.Create(Self, 'columns');
  FColumnsObject := TExtObject.CreateInternal(Self, 'columns');
end;

{$IFDEF FPC}constructor TExtGridPanel.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPanel.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtGridPanel.Destroy; begin
  try
    FColumns.Free;
    FColumnsObject.Free;
  except end;
  inherited;
end;

procedure TExtGridPanel.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforereconfigure') and Assigned(FOnBeforereconfigure) then
    FOnBeforereconfigure(TExtGridPanel(ParamAsObject('This')), TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Columns')), TExtDataStore(ParamAsObject('OldStore')), TExtObjectList(ParamAsObject('The')))
  else if (AEvtName = 'reconfigure') and Assigned(FOnReconfigure) then
    FOnReconfigure(TExtGridPanel(ParamAsObject('This')), TExtDataStore(ParamAsObject('Store')), TExtObjectList(ParamAsObject('Columns')), TExtDataStore(ParamAsObject('OldStore')), TExtObjectList(ParamAsObject('The')));
end;

function TExtGridRowEditor.JSClassName : string; begin
  Result := 'Ext.grid.RowEditor';
end;

{$IFDEF FPC}constructor TExtGridRowEditor.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtGridRowEditor.StartEdit(RecordJS : TExtDataModel; ColumnHeader : TExtDataModel) : TExtFunction; begin
  JSCode(JSName + '.startEdit(' + VarToJSON([RecordJS, false, ColumnHeader, false]) + ');', 'TExtGridRowEditor');
  Result := Self;
end;

procedure TExtMenuDatePicker.SetFHideOnClick(Value : Boolean); begin
  FHideOnClick := Value;
  JSCode('hideOnClick:' + VarToJSON([Value]));
end;

procedure TExtMenuDatePicker.SetFPicker(Value : TExtPickerDate); begin
  FPicker := Value;
  Value.DeleteFromGarbage;
  JSCode(JSName + '.picker=' + VarToJSON([Value, false]) + ';');
end;

procedure TExtMenuDatePicker.SetFPickerId(Value : String); begin
  FPickerId := Value;
  JSCode('pickerId:' + VarToJSON([Value]));
end;

procedure TExtMenuDatePicker.SetFOnSelect(Value : TExtMenuDatePickerOnSelect); begin
  if Assigned(FOnSelect) then
    JSCode(JSName+'.events ["select"].listeners=[];');
  if Assigned(Value) then
    AddListener('select', Ajax('select', [], true));
  FOnSelect := Value;
end;

function TExtMenuDatePicker.JSClassName : string; begin
  Result := 'Ext.menu.DatePicker';
end;

procedure TExtMenuDatePicker.InitDefaults; begin
  inherited;
  FPicker := TExtPickerDate.CreateInternal(Self, 'picker');
end;

{$IFDEF FPC}constructor TExtMenuDatePicker.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtMenuDatePicker.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtMenuDatePicker.Destroy; begin
  try
    FPicker.Free;
  except end;
  inherited;
end;

procedure TExtMenuDatePicker.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'select') and Assigned(FOnSelect) then
    FOnSelect();
end;

procedure TExtSliderTip.SetFAlign(Value : String); begin
  FAlign := Value;
  JSCode('align:' + VarToJSON([Value]));
end;

procedure TExtSliderTip.SetFOffsets(Value : TExtObjectList); begin
  FOffsets := Value;
  Value.DeleteFromGarbage;
  JSCode('offsets:' + VarToJSON([Value, false]));
end;

procedure TExtSliderTip.SetFPosition(Value : String); begin
  FPosition := Value;
  JSCode('position:' + VarToJSON([Value]));
end;

function TExtSliderTip.JSClassName : string; begin
  Result := 'Ext.slider.Tip';
end;

procedure TExtSliderTip.InitDefaults; begin
  inherited;
  FOffsets := TExtObjectList.Create(Self, 'offsets');
end;

{$IFDEF FPC}constructor TExtSliderTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtSliderTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

destructor TExtSliderTip.Destroy; begin
  try
    FOffsets.Free;
  except end;
  inherited;
end;

procedure TExtTipQuickTip.SetFInterceptTitles(Value : Boolean); begin
  FInterceptTitles := Value;
  JSCode('interceptTitles:' + VarToJSON([Value]));
end;

procedure TExtTipQuickTip.SetFTarget(Value : String); begin
  FTarget := Value;
  JSCode('target:' + VarToJSON([Value]));
end;

procedure TExtTipQuickTip.SetFTargetElement(Value : TExtElement); begin
  FTargetElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

procedure TExtTipQuickTip.SetFTargetTHTMLElement(Value : THTMLElement); begin
  FTargetTHTMLElement := Value;
  Value.DeleteFromGarbage;
  JSCode('target:' + VarToJSON([Value, false]));
end;

function TExtTipQuickTip.JSClassName : string; begin
  Result := 'Ext.tip.QuickTip';
end;

procedure TExtTipQuickTip.InitDefaults; begin
  inherited;
  FTargetElement := TExtElement.CreateInternal(Self, 'target');
end;

{$IFDEF FPC}constructor TExtTipQuickTip.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

function TExtTipQuickTip.CancelShow(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.CancelShow(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.CancelShow(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.CancelShow(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.CancelShow(El : String) : TExtFunction; begin
  JSCode(JSName + '.cancelShow(' + VarToJSON([El]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

constructor TExtTipQuickTip.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtTipQuickTip.Register(Config : TExtObject) : TExtFunction; begin
  JSCode(JSName + '.register(' + VarToJSON([Config, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : THTMLElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : TExtElement) : TExtFunction; begin
  JSCode(JSName + '.Unregister(' + VarToJSON([El, false]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

function TExtTipQuickTip.Unregister(El : String) : TExtFunction; begin
  JSCode(JSName + '.unregister(' + VarToJSON([El]) + ');', 'TExtTipQuickTip');
  Result := Self;
end;

destructor TExtTipQuickTip.Destroy; begin
  try
    FTargetElement.Free;
  except end;
  inherited;
end;

procedure TExtGridPropertyGrid.SetFInferTypes(Value : Boolean); begin
  FInferTypes := Value;
  JSCode('inferTypes:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFNameColumnWidth(Value : Integer); begin
  FNameColumnWidth := Value;
  JSCode('nameColumnWidth:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFNameColumnWidthString(Value : String); begin
  FNameColumnWidthString := Value;
  JSCode('nameColumnWidth:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFNameField(Value : String); begin
  FNameField := Value;
  JSCode('nameField:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFSource(Value : TExtObject); begin
  FSource := Value;
  Value.DeleteFromGarbage;
  if not ConfigAvailable(JSName) then
    SetSource(Value)
  else
    JSCode('source:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFSourceConfig(Value : TExtObject); begin
  FSourceConfig := Value;
  Value.DeleteFromGarbage;
  JSCode('sourceConfig:' + VarToJSON([Value, false]));
end;

procedure TExtGridPropertyGrid.SetFValueField(Value : String); begin
  FValueField := Value;
  JSCode('valueField:' + VarToJSON([Value]));
end;

procedure TExtGridPropertyGrid.SetFOnBeforepropertychange(Value : TExtGridPropertyGridOnBeforepropertychange); begin
  if Assigned(FOnBeforepropertychange) then
    JSCode(JSName+'.events ["beforepropertychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('beforepropertychange', Ajax('beforepropertychange', ['Source', '%0.nm','RecordId', '%1','Value', '%2.nm','OldValue', '%3.nm'], true));
  FOnBeforepropertychange := Value;
end;

procedure TExtGridPropertyGrid.SetFOnPropertychange(Value : TExtGridPropertyGridOnPropertychange); begin
  if Assigned(FOnPropertychange) then
    JSCode(JSName+'.events ["propertychange"].listeners=[];');
  if Assigned(Value) then
    AddListener('propertychange', Ajax('propertychange', ['Source', '%0.nm','RecordId', '%1','Value', '%2.nm','OldValue', '%3.nm'], true));
  FOnPropertychange := Value;
end;

function TExtGridPropertyGrid.JSClassName : string; begin
  Result := 'Ext.grid.property.Grid';
end;

procedure TExtGridPropertyGrid.InitDefaults; begin
  inherited;
  FSource := TExtObject.CreateInternal(Self, 'source');
  FSourceConfig := TExtObject.CreateInternal(Self, 'sourceConfig');
end;

{$IFDEF FPC}constructor TExtGridPropertyGrid.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

constructor TExtGridPropertyGrid.Create; begin
  CreateVar(JSClassName + '({});');
  InitDefaults;
end;

function TExtGridPropertyGrid.GetSource : TExtFunction; begin
  JSCode(JSName + '.getSource();', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.RemoveProperty(Prop : String) : TExtFunction; begin
  JSCode(JSName + '.removeProperty(' + VarToJSON([Prop]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.SetProperty(Prop : String; Value : TExtObject; Create : Boolean = false) : TExtFunction; begin
  JSCode(JSName + '.setProperty(' + VarToJSON([Prop, Value, false, Create]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

function TExtGridPropertyGrid.SetSource(Source : TExtObject; SourceConfig : TExtObject = nil) : TExtFunction; begin
  JSCode(JSName + '.setSource(' + VarToJSON([Source, false, SourceConfig, false]) + ');', 'TExtGridPropertyGrid');
  Result := Self;
end;

destructor TExtGridPropertyGrid.Destroy; begin
  try
    FSource.Free;
    FSourceConfig.Free;
  except end;
  inherited;
end;

procedure TExtGridPropertyGrid.HandleEvent(const AEvtName : string); begin
  inherited;
  if (AEvtName = 'beforepropertychange') and Assigned(FOnBeforepropertychange) then
    FOnBeforepropertychange(TExtObject(ParamAsObject('Source')), ParamAsString('RecordId'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('OldValue')))
  else if (AEvtName = 'propertychange') and Assigned(FOnPropertychange) then
    FOnPropertychange(TExtObject(ParamAsObject('Source')), ParamAsString('RecordId'), TExtObject(ParamAsObject('Value')), TExtObject(ParamAsObject('OldValue')));
end;

function TExtMessageBoxSingleton.JSClassName : string; begin
  Result := 'Ext.MessageBox';
end;

class function TExtMessageBoxSingleton.CANCEL : Integer; begin
  Result := 8
end;

class function TExtMessageBoxSingleton.ERROR : String; begin
  Result := 'ext-mb-error'
end;

class function TExtMessageBoxSingleton.INFO : String; begin
  Result := 'ext-mb-info'
end;

class function TExtMessageBoxSingleton.NO : Integer; begin
  Result := 4
end;

class function TExtMessageBoxSingleton.OK : Integer; begin
  Result := 1
end;

class function TExtMessageBoxSingleton.OKCANCEL : Integer; begin
  Result := 9
end;

class function TExtMessageBoxSingleton.QUESTION : String; begin
  Result := 'ext-mb-question'
end;

class function TExtMessageBoxSingleton.WARNING : String; begin
  Result := 'ext-mb-warning'
end;

class function TExtMessageBoxSingleton.YES : Integer; begin
  Result := 2
end;

class function TExtMessageBoxSingleton.YESNO : Integer; begin
  Result := 6
end;

class function TExtMessageBoxSingleton.YESNOCANCEL : Integer; begin
  Result := 14
end;

{$IFDEF FPC}constructor TExtMessageBoxSingleton.AddTo(List : TExtObjectList);begin inherited end;{$ENDIF}

initialization
  ExtFormFieldVTypes := TExtFormFieldVTypesSingleton.CreateSingleton;
  ExtFxManager := TExtFxManagerSingleton.CreateSingleton;
  ExtFxCubicBezier := TExtFxCubicBezierSingleton.CreateSingleton;
  ExtFxEasing := TExtFxEasingSingleton.CreateSingleton;
  ExtMenuManager := TExtMenuManagerSingleton.CreateSingleton;
  ExtDomHelper := TExtDomHelperSingleton.CreateSingleton;
  ExtFocusManager := TExtFocusManagerSingleton.CreateSingleton;
  ExtEventObjectImpl := TExtEventObjectImplSingleton.CreateSingleton;
  ExtDrawEngineImageExporter := TExtDrawEngineImageExporterSingleton.CreateSingleton;
  ExtDrawEngineSvgExporter := TExtDrawEngineSvgExporterSingleton.CreateSingleton;
  ExtDraw := TExtDrawSingleton.CreateSingleton;
  ExtShadowPool := TExtShadowPoolSingleton.CreateSingleton;
  ExtStateManager := TExtStateManagerSingleton.CreateSingleton;
  ExtUtilCookies := TExtUtilCookiesSingleton.CreateSingleton;
  ExtUtilCSS := TExtUtilCSSSingleton.CreateSingleton;
  ExtTipQuickTipManager := TExtTipQuickTipManagerSingleton.CreateSingleton;
  ExtUtilInflector := TExtUtilInflectorSingleton.CreateSingleton;
  ExtUtilHistory := TExtUtilHistorySingleton.CreateSingleton;
  ExtPerfMonitor := TExtPerfMonitorSingleton.CreateSingleton;
  ExtDataSortTypes := TExtDataSortTypesSingleton.CreateSingleton;
  ExtDataJsonP := TExtDataJsonPSingleton.CreateSingleton;
  ExtButtonManager := TExtButtonManagerSingleton.CreateSingleton;
  ExtAppEventBus := TExtAppEventBusSingleton.CreateSingleton;
  ExtComponentQuery := TExtComponentQuerySingleton.CreateSingleton;
  ExtChartShape := TExtChartShapeSingleton.CreateSingleton;
  ExtDataValidations := TExtDataValidationsSingleton.CreateSingleton;
  ExtDataTypes := TExtDataTypesSingleton.CreateSingleton;
  ExtDdDragDropManager := TExtDdDragDropManagerSingleton.CreateSingleton;
  ExtDirectManager := TExtDirectManagerSingleton.CreateSingleton;
  ExtDdScrollManager := TExtDdScrollManagerSingleton.CreateSingleton;
  ExtDdRegistry := TExtDdRegistrySingleton.CreateSingleton;
  ExtUtilTaskManager := TExtUtilTaskManagerSingleton.CreateSingleton;
  ExtPluginManager := TExtPluginManagerSingleton.CreateSingleton;
  ExtComponentManager := TExtComponentManagerSingleton.CreateSingleton;
  ExtModelManager := TExtModelManagerSingleton.CreateSingleton;
  ExtAppDomainStore := TExtAppDomainStoreSingleton.CreateSingleton;
  ExtAppDomainGlobal := TExtAppDomainGlobalSingleton.CreateSingleton;
  ExtAjax := TExtAjaxSingleton.CreateSingleton;
  ExtAppDomainController := TExtAppDomainControllerSingleton.CreateSingleton;
  ExtAppDomainDirect := TExtAppDomainDirectSingleton.CreateSingleton;
  ExtAppDomainComponent := TExtAppDomainComponentSingleton.CreateSingleton;
  ExtFormCheckboxManager := TExtFormCheckboxManagerSingleton.CreateSingleton;
  ExtFormRadioManager := TExtFormRadioManagerSingleton.CreateSingleton;
  ExtDataStoreManager := TExtDataStoreManagerSingleton.CreateSingleton;
  ExtMessageBox := TExtMessageBoxSingleton.CreateSingleton;

finalization
  ExtMessageBox.Destroy;
  ExtDataStoreManager.Destroy;
  ExtFormRadioManager.Destroy;
  ExtFormCheckboxManager.Destroy;
  ExtAppDomainComponent.Destroy;
  ExtAppDomainDirect.Destroy;
  ExtAppDomainController.Destroy;
  ExtAjax.Destroy;
  ExtAppDomainGlobal.Destroy;
  ExtAppDomainStore.Destroy;
  ExtModelManager.Destroy;
  ExtComponentManager.Destroy;
  ExtPluginManager.Destroy;
  ExtUtilTaskManager.Destroy;
  ExtDdRegistry.Destroy;
  ExtDdScrollManager.Destroy;
  ExtDirectManager.Destroy;
  ExtDdDragDropManager.Destroy;
  ExtDataTypes.Destroy;
  ExtDataValidations.Destroy;
  ExtChartShape.Destroy;
  ExtComponentQuery.Destroy;
  ExtAppEventBus.Destroy;
  ExtButtonManager.Destroy;
  ExtDataJsonP.Destroy;
  ExtDataSortTypes.Destroy;
  ExtPerfMonitor.Destroy;
  ExtUtilHistory.Destroy;
  ExtUtilInflector.Destroy;
  ExtTipQuickTipManager.Destroy;
  ExtUtilCSS.Destroy;
  ExtUtilCookies.Destroy;
  ExtStateManager.Destroy;
  ExtShadowPool.Destroy;
  ExtDraw.Destroy;
  ExtDrawEngineSvgExporter.Destroy;
  ExtDrawEngineImageExporter.Destroy;
  ExtEventObjectImpl.Destroy;
  ExtFocusManager.Destroy;
  ExtDomHelper.Destroy;
  ExtMenuManager.Destroy;
  ExtFxEasing.Destroy;
  ExtFxCubicBezier.Destroy;
  ExtFxManager.Destroy;
  ExtFormFieldVTypes.Destroy;
end.